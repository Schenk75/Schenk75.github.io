{"meta":{"title":"Schenk - Blog","subtitle":"","description":"","author":"schenk","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2020-11-04T03:12:18.440Z","updated":"2020-11-04T03:12:18.440Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2020-11-04T08:13:00.108Z","updated":"2020-11-04T08:13:00.108Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"SJTUer Major in Cyber Security Cubing Since 2017 Biiiiiig Fan of Christopher Nolan &amp; One Piece &amp; Hua Chenyu"},{"title":"","date":"2020-11-04T03:04:03.774Z","updated":"2020-11-04T03:04:03.774Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-11-04T03:12:28.561Z","updated":"2020-11-04T03:12:28.561Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"友链 - Links","date":"2020-11-04T03:11:19.565Z","updated":"2020-11-04T03:11:19.565Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-04T03:12:36.216Z","updated":"2020-11-04T03:12:36.216Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSDN博客保存为PDF","slug":"csdn-pdf","date":"2020-11-26T14:30:42.000Z","updated":"2020-11-26T14:38:48.154Z","comments":true,"path":"2020/11/26/csdn-pdf/","link":"","permalink":"http://example.com/2020/11/26/csdn-pdf/","excerpt":"将CSDN博客去除无用信息并保存为PDF","text":"F12打开开发者工具，在Console输入以下js代码： 123456789101112131415161718(function()&#123; &#x27;use strict&#x27;; var articleBox = $(&quot;div.article_content&quot;); articleBox.removeAttr(&quot;style&quot;); $(&quot;#btn-readmore&quot;).parent().remove(); $(&quot;#side&quot;).remove(); $(&quot;#comment_title, #comment_list, #comment_bar, #comment_form, .announce, #ad_cen, #ad_bot&quot;).remove(); $(&quot;.nav_top_2011, #header, #navigator&quot;).remove(); $(&quot;.csdn-side-toolbar,.template-box,.reward-user-box,.blog-footer-bottom&quot;).remove(); $(&quot;.p4course_target, .comment-box, .recommend-box, #csdn-toolbar, #tool-box,#dmp_ad_58, .more-toolbox, .article-info-box, .btn-readmore, .pub-footer-new&quot;).remove(); $(&quot;aside&quot;).remove(); $(&quot;.tool-box&quot;).remove(); $(&quot;main&quot;).css(&#x27;display&#x27;,&#x27;content&#x27;); $(&quot;main&quot;).css(&#x27;float&#x27;,&#x27;left&#x27;); $(&quot;#mainBox&quot;).width(&quot;100%&quot;); document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8; window.print();&#125;)(); 或者： 12345678910111213141516(function doPrint()&#123; &#x27;use strict&#x27;; var articleBox = $(&quot;div.article_content&quot;); articleBox.removeAttr(&quot;style&quot;); var head_str = &quot;&quot;; var foot_str = &quot;&quot;; var older = document.body.innerHTML; var title= document.getElementsByClassName(&#x27;article-title-box&#x27;)[0].innerHTML; var main_body = document.getElementsByClassName(&#x27;article_content&#x27;)[0].innerHTML; document.body.innerHTML = head_str + title + main_body + foot_str; $(&quot;#mainBox&quot;).width(&quot;100%&quot;); document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8; window.print(); document.body.innerHTML = older; return false;&#125;)();","categories":[{"name":"Useful skills","slug":"Useful-skills","permalink":"http://example.com/categories/Useful-skills/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"现代密码学 Notes","slug":"现代密码学-notes","date":"2020-11-25T11:09:27.000Z","updated":"2020-11-26T09:19:24.883Z","comments":true,"path":"2020/11/25/现代密码学-notes/","link":"","permalink":"http://example.com/2020/11/25/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/","excerpt":"现代密码学课程笔记","text":"古典替换密码 恺撒密码 每个字母用其后的第三个字母替换，即 Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC 恺撒密码的一般形式，可以将字母移动的位数由3变为1-25中的任何一个 混合单表替换密码 每个字母可以用其它任何一个字母替换（不能重复） 密钥长度为26个字母，因为每个字母需要一个映射 简单的单表替换密码 设置一个没有重复字母的“密钥字”，其它字母按顺序写在密钥字最后字母后面 给定密钥字 JULISCAER Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: JULISCAERTVWXYZBDFGHKMNOPQ 多字母替换密码 使用多个单字母替换表，因此一个字母可以被多个字母替换：用一个密钥选择每个字母使用哪个字母表，密钥的第i个字母表示使用第i个字母表，依次使用每个字母表，当密钥的字母使用完后，再从头开始 古典置换密码 方法：通过重新编排消息字母隐藏信息 特点：没有改变原来消息的字母集 关键思想：按一定规则写出明文，按另一规则读出密文 密钥：用于读密文的方法和写明文的方法 分组密码 在分组密码中，消息被分成许多块，每块都要被加密 替换运算 S-boxes 一个二进制字用其它二进制字替换，这种替换函数就构成密钥，可以看作是一个大的查表运算 混淆：使作用于明文的密钥和密文之间的关系复杂化 置换运算 P-boxes 二进制字次序被打乱，重新排序的方法构成密钥 扩散：将明文及密钥的影响尽可能迅速地散布到较多个输出的密文中 雪崩效应 输入改变1bit, 导致近一半的比特发生变化 保证小的输入变化导致大的输出变化 完备性效应 每个输出比特是所有输入比特的复杂函数的输出 保证每个输出比特依赖于所有的输入比特 Feistel密码 把输入块分成左右两部分 轮函数g是一个S-P网络 由第i个密钥控制（子密钥） L(i) = R(i-1) R(i) = L(i-1) xor g(K(i), R(i-1)) 求逆很容易 实际中，一些这样的连续变换形成完整密码变换 Feistel密码设计 分组大小：增加分组长度会提高安全性, 但降低了密码运算速度 密钥大小：增加密钥长度可以提高安全性(使得穷搜索困难)，但降低了密码速度 轮数：增加轮数可以提高安全性，但降低速度 子密钥生成：子密钥生成越复杂就越安全，但降低速度 Lucifer 分组长度是128-bit，密钥长度是128-bit 每轮使用的子密钥是密钥的左半部分 密钥每次要向左旋转56-bits，所以密钥的每部分都参加运算 轮函数的具体结构： 现代分组加密算法 简化的DES (S-DES) 加密算法涉及五个函数： 初始置换 IP 复合函数 fk1 ，由密钥K确定，具有转换和替换的运算 转换函数 SW 复合函数 fk2 初始置换IP的逆置换 IP-1 加解密流程 密文 = IP-1(fk2(SW(fk1(IP(明文))))) 明文 = IP-1(fk1(SW(fk2(IP(密文))))) 密钥生成： P10(k1, k2, k3, k4, k5, k6, k7, k8, k9, k10) = (k3, k5, k2, k7, k4, k10, k1, k9, k8, k6) P8(k1, k2, k3, k4, k5, k6, k7, k8, k9, k10) = (k6, k3, k7, k4, k8, k5, k10, k9) LS-1为循环左移1位，LS-2为循环左移2位 IP函数： IP= 1 2 3 4 5 6 7 8 ​ 2 6 3 1 4 8 5 7 IP-1= 1 2 3 4 5 6 7 8 ​ 4 1 3 5 7 2 8 6 函数fk：fk(L, R) = (L xor F(R, SK), R) , 其中SK为子密钥 F是一个4-bit到4-bit的映射： 首先对R做扩张/置换(E/P)运算 E/P运算：(1, 2, 3, 4) =&gt; (4, 1, 2, 3, 2, 3, 4, 1) 将子密钥SK（对应具体算法中的K1和K2）与E/P运算的结果异或得到8-bit数 P0,0 P0,1 P0,2 P0,3 P1,0 P1,1 P1,2 P1,3 第一行进入S盒S0，第二行进入S盒S1，分别产生2-bit输出 第1和第4输入比特决定行，第2和第3输入比特决定列，以确定选取S-盒元素的位置 如 (P0,0 P0,3)=(0 0),并且(P0,1 P0,2)=(1 0)，则选取S盒矩阵的第0行第2列的元素作为2-bit输出 加密具体过程 数据加密标准DES DES加密流程 对明文X，通过一个固定的初始置换IP得到X0： X0 = IP(X) = L0R0 , 分为左右两部分。 函数F的16次迭代：LiRi (1&lt;=i&lt;=16） Li = Ri-1 , Ri = Li-1 xor F(Ri-1, Ki) 其中Ki是长为48位的子密钥。 对比特串R16L16使用逆置换IP-1得到密文Y： Y = IP-1(R16L16) 加密相关的表见附录 DES一轮加密 轮函数F F(Ri-1, Ki) ，输入为32-bit的Ri-1和48-bit的子密钥Ki 对Ri-1使用扩展函数E，扩展为48-bit 计算 E(Ri-1) xor Ki ，结果写成8个6-bit串 B=b1b2b3b4b5b6 使用8个4*16的S盒，其中的元素取0~15的整数，每个S盒输出为4-bit串： b1b6确定S盒的行数，b2b3b4b5确定S盒的列数 最后，P为固定置换，输出为32-bit串 密钥K计算子密钥 密钥K是长度为64的位串：56位参加子密钥编排，8位是奇偶校验位，在密钥编排的计算中，不参加运算。 给定64位的密钥K，放弃奇偶校验位(8, 16, …, 64)，先进行PC-1固定置换，结果为前28-bit的C0和后28-bit的D0 对1 &lt;= i &lt;= 16，计算 Ci = LSi(Ci-1) Di = LSi(Di-1) 其中LSi表示循环左移1或2位，当i=1,2,9,16时移1位，其他情况移2位 计算 Ki = PC-2(CiDi) DES的S盒 DES的核心是S盒 S盒不是它输入变量的线性函数 改变S盒的一个输入位至少要引起两位的输出改变 对任何一个S盒，如果固定一个输入比特，其它输入变化时，输出数字中0和1的总数近于相等 双重DES 加密：C = EK2[EK1[P]] 解密：P = DK1[DK2[P]] 三重DES 两个密钥加密：C = EK1[DK2[EK1[P]]] IDEA 分组长度为64位，子分组长度为16位 密钥长度为128位 进行8轮循环 同一算法既可以加密也可以解密 IDEA加密总体方案 IDEA加密具体过程 是整数模216+1乘 (IDEA的S盒) 是整数模216加 IDEA的密钥生成 52个16-bit的加密子密钥从128-bit的密钥中生成： 前8个子密钥直接从密钥中取出； 对密钥进行25-bit循环左移，接下来的密钥从中取出； 重复进行直到52个子密钥全部生成。 解密密钥从加密子密钥中导出： 解密循环 i 的前4个子密钥从加密循环 10-i 的前4个子密钥中导出： 解密密钥的第1、4个子密钥对应于1、4加密子密钥的乘法逆元； 解密密钥的第2、3个子密钥对应于2、3加密子密钥的加法逆元 对前8个循环来说，循环 i 的最后两个子密钥等于加密循环 9-i 的最后两个子密钥 AES-Rijndael 可变块长、可变密钥长度 分组长度指定为128位 密钥长度为128，192或256位，相应的迭代轮数为10、12和14 AES框架 AES轮函数 每一轮迭代的结构都一样，只是最后一轮省略了列混合变换： 字节替换(Byte Sub) 对数据的每一字节应用一个非线性变换； 替换表是一个16×16的矩阵。表中纵向的x取自状态矩阵中的高4比特，横向的y取自低4比特。 行移位(Shift Row) 对每一行的字节循环重新排序，可以表示为: Bi,j = Ai,(i+j)mod4 列混合(Mix Column) 对矩阵的列应用一个线性变换: 将状态的每一列视为GF(28)上的多项式S(x)，然后乘以固定多项式a(x)，并模除x4+1。其中a(x) = {03}x3+{01}x2+{01}x+{02} a(x)存在关于x4+1的逆元，变换的矩阵为： 列混合变换的结果为： 轮密钥加(Add Round Key) 把轮密钥混合到中间数据，对状态和每轮的子密钥进行简单的异或操作 每轮子密钥是通过密钥调度算法从主密钥中产生，子密钥长度等于分组长度 轮密钥加运算需要用到4个导出的32比特子密钥 AES子密钥生成 Rijindael算法每一轮需要用到Nb比特的子密钥，共有Nr轮，另外，第一次轮密钥加的时候也需要用一轮子密钥，于是总共需要Nb*(Nr+1)比特的子密钥，对于AES-128来说就是用1408比特的子密钥 AES解密过程 逆字节替换、逆行移位、逆列混合、轮密钥加(其逆变换就是本身) 分组密码工作模式 ECB 电码本模式 消息分成相互独立的加密模块 每块独立使用DES算法 适合少量的数据加密 如果最后一个分组长度不够，需要填充 对于同一个明文分组，如果出现多次，其密文是相同的，因为每次的加密密钥都相同 (缺陷) CBC 密码分组链接模式 使重复的明文分组产生不同的密文分组：每次加密使用相同加密密钥，但是输入是当前明文分组盒前一个密文分组的异或 适合加密长度大于64比特的消息 如果最后一个分组长度不够，需要填充 可以用来进行用户鉴别 解密时，每一个密文分组被解密后，再与前一个密文分组异或，便能得到明文分组 产生第一个密文分组时，需要一个初始向量IV与第一个明文分组异或，IV对于收发方都是已知的，且应该像密钥一样被保护 CFB 密码反馈模式 消息作为比特流，不需要对消息填充 适合数据以比特或字节为单位出现 错误传播 可以用于认证 加密过程： 解密过程： 将收到的密文单元和加密函数的输出进行异或 仍然使用加密算法而不是解密算法 OFB 输出反馈模式 结构类似CFB，不同之处在于OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器 消息作为比特流，不需要对消息填充 比特错误不会被传播 加密过程： 解密过程： CTR 计算器模式 可并行加密 预处理 吞吐量仅受可使用并行数量的限制 加密数据块随机访问 对称密码算法分析 序列密码 附录 DES算法相关表 初始置换IP (对明文输入进行次序打乱) 初始置换的逆置换IP-1 扩展置换E (32-bit到48-bit) 置换函数P PC1 PC2 S-box 例子 AES算法相关表 字节替换表","categories":[{"name":"Course Notes","slug":"Course-Notes","permalink":"http://example.com/categories/Course-Notes/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"论文阅读-SGX Support for Dynamic Memory Management Inside an Enclave","slug":"sgx-support-for-dynamic-memory-management-inside-an-enclave-notes","date":"2020-11-25T00:20:42.000Z","updated":"2020-11-26T09:31:41.670Z","comments":true,"path":"2020/11/25/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/","link":"","permalink":"http://example.com/2020/11/25/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/","excerpt":"论文SGX Support for Dynamic Memory Management Inside an Enclave阅读笔记","text":"1. Introduction SGX1 shortcomings enclave建立时必须分配其所需的所有内存，并且难以根据工作量自适应分配enclave，需要根据最坏情况的工作量来分配内存 enclave页的访问控制由EPCM来管理，当页被加入enclave时其权限就得写入EPCM中，并且不能再改变，这就意味着必须允许页上将来可能执行的任何操作，不能做到权限最小化 library OS，异常处理和代码延迟加载 2. SGX2 Considerations &amp; Requirements 动态内存管理需要满足的条件 enclave需要自己掌控其内存和权限 enclave代码在enclave不知情的情况下被改变时，将不会被执行 系统的资源管理器能够正常管理和分配资源 需要同时有EPCM权限和系统权限才能更改内存权限 安全考量 enclave软件需要改变页的权限来进行访问控制 权限更改时要保证旧的权限从TLB中移除 如果enclave要将页还回系统，并且想要在以后使用相同的内存地址，则enclave需要知道页是什么时候被还回的 软件考量 enclave内部的内存管理机构需要能够重新分配内存资源 3. SGX2 Overview and Usage SGX2新增的指令 Enclave内存分配 To implement dynamic memory allocation and commitment, the enclave runtime system and the operating system have to agree on a protocol that coordinates the operating system usage of EAUG and the enclave runtime system usage of EACCEPT. Committed： Virtual Size减去为程序保留的内存（未分配）。怎么理解为程序保留的但未分配的内存？就是告诉系统我要一块内存，但暂时还用不上，不过分配的地址得给我，系统就给程序一个不用的地址，但不分配内存，等程序真的要使用时（读写），就从页面或物理内存中分配出来映射到那个地址上。 提交的内存： 系统从物理内存或者换页内存分配给进程的那一部分。这部分内存在虚拟内存的线性地址中是连续的，不过在物理内存或者换页内存中，不一定是连续的。提交但未使用的内存一般都在换页内存里面，只有去使用的时候，才会换到物理内存里面，这点要注意。 Enclave内存释放 SGX2 provides a more robust reclamation of committed memory. OS and enclave runtime system need to coordinate the execution of EMODT, ETRACK, and EREMOVE by the OS and execution of EACCEPT by the enclave runtime. 改变页的权限 分为扩大权限和缩减权限。 扩大权限： The internal manager executes EMODPE to extend the page permissions in the EPCM. The internal manager requests the system manager to extend page permissions in the page tables. 缩减权限： The internal manager requests that the system manager to restrict permissions on a page. The system manager executes EMODPR and updates page table permissions. After permissions have been updated, the system manager executes ETRACK on the SECS of the calling enclave and sends IPIs (处理器间中断：允许一个CPU向系统其他的CPU发送中断信号) to all processors that may be executing inside the enclave to flush TLB mappings. After all IPIs have been acknowledged, control is returned to the internal manager. The internal manager verifies that page permissions have been restricted and TLB mappings flushed by executing EACCEPT. 权限的更改(同时包含扩大和缩减权限)：先缩减后扩大 —— 避免产生不安全的中间临时情况 线程控制机构TCS分配 The software protocol is very similar to page restriction except that instead of executing EMODPR the OS executes EMODT. 动态加载模块 To support dynamic loading of modules, SGX2 provides EACCEPTCOPY which allows the internal manager to atomically initialize the contents and permission of a page. Library OS支持 提供异常处理 由enclave产生的异常 异常的类型 错误情况的具体信息 SGX2还另外提供enclave运行时产生的enclave内部的异常","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"SGX程序基础","slug":"sgx-programming","date":"2020-11-23T23:27:01.780Z","updated":"2020-11-24T07:29:19.728Z","comments":true,"path":"2020/11/24/sgx-programming/","link":"","permalink":"http://example.com/2020/11/24/sgx-programming/","excerpt":"Intel SGX程序SampleCode Notes","text":"项目目录结构 以SampleEnclave为例，目录结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940.├── App│ ├── App.cpp│ ├── App.h│ ├── Edger8rSyntax│ │ ├── Arrays.cpp│ │ ├── Functions.cpp│ │ ├── Pointers.cpp│ │ └── Types.cpp│ └── TrustedLibrary│ ├── Libc.cpp│ ├── Libcxx.cpp│ └── Thread.cpp├── Enclave│ ├── Edger8rSyntax│ │ ├── Arrays.cpp│ │ ├── Arrays.edl│ │ ├── Functions.cpp│ │ ├── Functions.edl│ │ ├── Pointers.cpp│ │ ├── Pointers.edl│ │ ├── Types.cpp│ │ └── Types.edl│ ├── Enclave.config.xml│ ├── Enclave.cpp│ ├── Enclave.edl│ ├── Enclave.h│ ├── Enclave.lds│ ├── Enclave_private_test.pem│ └── TrustedLibrary│ ├── Libc.cpp│ ├── Libc.edl│ ├── Libcxx.cpp│ ├── Libcxx.edl│ ├── Thread.cpp│ └── Thread.edl├── Include│ └── user_types.h├── Makefile└── README.txt App目录：存放应用程序中的不可信代码部分 App.cpp文件：应用程序中的不可信部分代码，其中包括了创建Enclave及销毁Enclave的代码，也定义了一些相关的返回码供使用者查看Enclave程序的执行状态。其中的main函数是整个项目的入口函数。 App.h文件：应用程序中的不可信部分代码的头文件，定义了一些宏常量和函数声明。 Edger8rSyntax文件夹：提供了一些工具。 TrustedLibrary文件夹：提供了一些函数库。 Enclave目录：存放应用程序中的可信代码部分和可信与不可信代码接口文件 Enclave.config.xml文件：Enclave的配置文件，定义了Enclave的元数据信息。 Enclave.cpp文件：应用程序中的可信部分代码，包括了可信函数的实现。 Enclave.h文件：应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明。 Enclave.edl文件：Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口，trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。 Enclave.lds文件：定义了一些Enclave可执行文件信息。 Enclave_private_test.pem文件：SGX生成的私钥。 Edger8rSyntax文件夹：提供了一些工具。 TrustedLibrary文件夹：提供了一些函数库。 Include目录：存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义 user_types.h文件：定义了用户自定义的类型 Makefile文件：项目的编译文件，定义了项目的编译信息","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Ubuntu将安装的应用固定到桌面","slug":"ubuntu-show-application","date":"2020-11-23T10:23:08.000Z","updated":"2020-11-26T14:34:54.918Z","comments":true,"path":"2020/11/23/ubuntu-show-application/","link":"","permalink":"http://example.com/2020/11/23/ubuntu-show-application/","excerpt":"Ubuntu20.04将国内版本的firefox固定到桌面","text":"升级了一下ubuntu，从18.04升到了20.04，发现自动安装了国际版的firefox，之前安装的国内版firefox目录还在/opt下，但是桌面显示的firefox是国际版的，且启动栏也没有国内版的firefox应用。 Step1 卸载国际版firefox 12dpkg --get-selections | grep firefoxsudo apt-get purge firefox ... # 所有上一步列出的应用 Step2 在/usr/share/applications/目录新建firefox.desktop，并添加内容： 123456[Desktop Entry]Name&#x3D;FirefoxExec&#x3D;&#x2F;opt&#x2F;firefox&#x2F;firefoxIcon&#x3D;&#x2F;opt&#x2F;firefox&#x2F;browser&#x2F;chrome&#x2F;icons&#x2F;default&#x2F;default128.pngTerminal&#x3D;FalseType&#x3D;Application Step3 更改firefox.desktop文件权限： 1sudo chmod 755 firefox.desktop Step4 在启动栏可以看见新建的应用图标，并且可以添加到侧边栏","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"SGX Developer Guide - Reading Notes","slug":"SGX-Developer-Guide-Notes","date":"2020-11-16T13:14:04.602Z","updated":"2020-11-23T03:06:52.375Z","comments":true,"path":"2020/11/16/SGX-Developer-Guide-Notes/","link":"","permalink":"http://example.com/2020/11/16/SGX-Developer-Guide-Notes/","excerpt":"Intel SGX Developer Guide 学习笔记","text":"专业名词 ECall：“Enclave Call”一个调用enclave内部接口函数的操作 OCall：“Out call”从enclave内部向外部的应用发起调用的操作 Trusted：任何在enclave内部 trusted 环境下执行的代码或者数据结构 Trusted Thread Context：线程的上下文存放在enclave中，主要包括以下几个部分组成： Thread Control Structure（TCS）线程控制结构 Thread Data/Thread Local Storage 在enclave中的线程相关的数据 State Save Area(SSA) 线程异常处理机制 Stack 线程栈 Untrusted：指代任何运行在应用的 untrusted 环境下（等价于enclave外部）的代码或者数据结构。 Enclave 编程模型 Enclave开发原则 enclave是一个庞大而单一的软件实体，目标在于将对于一个应用而言的可信计算基降低至可信运行时系统，ISV代码和第三方可信库。在上述组件中的任一个bug将会导致enclave的安全问题。 非可信域控制了enclave 接口函数什么时候被调用的顺序。 当调用进入enclave中，是由不可信域来在enclave中选择可信线程上下文去执行。 并不保证传递进去enclave（ecall）中的参数和从enclave向外部发送的参数（ocall）是正确的，因为这是由不可信域提供的。 enclave向外部发送的调用 OCall，不能保证不可信函数一定正确地被执行。 任何人都可以加载一个enclave。更为严重的是，攻击者可能使用攻击性应用程序去加载一个enclave，利用该enclave存在的安全漏洞，窃取相关数据。 Enclave文件格式 一个 enclave library 文件包括可信代码和数据部分，当enclave被创建时，这些将会被导入到受保护的 enclave 内存（即EPC）中 在一个enclave文件中，还存在着Intel SGX特定的数据结构，enclave元数据： 元数据没有导入EPC中，而是被不可信的加载器加载，并决定enclave如何导入到EPC中 元数据中定义了可信线程上下文的数量，包括可信堆和可信栈的大小，在enclave初始化的时候，可信堆和可信栈被可信运行时系统初始化 元数据同时包括enclave的签名，这对于enclave的认证和初始化时非常重要的 **注：**不管enclave中定义了多少个可信线程，在设计的过程中不能假设不可信应用将会以特定的顺序去调用 Enclave 中的接口函数。一旦enclave被初始化，一个攻击者可以调用 Enclave 接口函数，以任何可能的顺序去发起调用并且提供相应的输入参数。 Enclave可信计算基 Enclave Interface 函数 (ECalls) enclave无法控制哪个ECall被执行，或者ECall将会以怎样的顺序被调用 ISV接口函数仅仅只能在enclave初始化后被调用，这意味着： 任何必要的地址基地址重置被正确地执行。 可信全局数据，例如栈等被正确地初始化。 可信线程的上下文，可信线程被正确地初始化。 不直接说明的可信初始化函数执行完成。（例如ISV全局构造函数） Enclave的输入 Enclave输入和输出可以被不可信的代码观察和修改 为了防止针对输入函数的攻击，软件开发者应该采用加密的方式和完整性检测来保证enclave执行的可信性 当一个encalve函数被调用时： 函数的参数和其他任何通过引用传递的序列化数据参数进入到可信环境中，并且对于攻击者无法访问的。 在参数上进行读写操作，返回值和其他序列化的引用，根据enclave开发者的参数与特殊定义，将不会影响ISV代码和数据的保密和完整性。 参数和返回值，序列化数据被可信运行时分配和管理，不对任何ISV代码和数据进行覆盖。 参数，返回值和序列化引用的大小被ISV所指定。 通过引用传递的输入参数 当ISV接口函数被调用时，输入参数将被停留在enclave中。然而，当一个输入参数通过引用的形式传递，只有引用（或指针）将会放置到enclave中。引用所指向的值停留在外部，并且会不断地变化。例如，一个攻击者可能在enclave检查函数参数后改变所引用的值。 外部Enclave调用 (OCalls) Enclave无法直接访问OS提供的服务。作为替代的是，encalve必须发起一个OCall将其传递到不可信应用中。 当一个enclave内的ISV函数发起OCall时： OCall仅仅暴露其参数和返回值到不可信域中。 当一个OCall发生时，返回值和任何序列化数据的引用将传递进入可信执行环境中，对攻击者不可以访问。另外enclave需要检查指针。 当一个OCall发生时，可信线程上下文与OCall之前的相同，除了在栈上的数据和易变寄存器上的值。 Enclave签名 在软件中通过enclave建立信任的过程中主要有着以下三种行为： Measurement（度量）：作为enclave在可信环境中初始化时用来验证文件准确性的身份。 Attestation（认证）：向其它实体证明当前的环境被正确的初始化。 Sealing（数据的密封）：通过某种方式保证可信环境上的数据可以正确地持久化和重新加载。 Enclave签名包含允许Intel SGX硬件检测enclave的完整性是否被篡改的信息，同时可以识别enclave持有人的身份。encalve 签名包含这几个如下的重要字段，对于外部实体的认证非常重要。 Enclave Measurement - 一个简单的256位哈希值用来标注代码和放入到enclave中的初始化数据，包括他们放入到EPC中期待的顺序和位置，以及这些页面的安全属性。当enclave代码/数据加载到EPC中，CPU开始计算enclave measurement并且将这个值存储在MRENCLAVE 寄存器中。接着CPU比较MRENCLAVE寄存器中的内容和存放在SIGSTRUCT中的enclave measurement值。当且仅当它们相等的时候，CPU允许enclave被初始化。 Enclave所有者的公钥 - 当一个enclave被正确地初始化，CPU将enclave所有者的公钥的hash存放在MRSIGNER寄存器中。MRSIGNER中的内容将会用作enclave所有者的身份证明。被同一个key认证的enclave在MRSIGNER寄存器中的值相同。 Enclave的安全版本号（ISVSVN）- enclave所有者对于enclave的每个版本号分配一个安全版本号。安全版本号反映了enclave的安全属性级别，并且需要单调递增，随着安全属性的不断上升。在一个enclave被正确初始化后，CPU记录SVN，并且在远程认证的过程中被使用。一个有着相同安全属性的enclave的不同版本应该分配相同的安全版本号。例如，一个没有解决安全相关bug的新版本enclave需要与旧版本的enclave持有相同的安全版本号。 Enclave的产品ID（ISVPRODID）- enclave所有者针对每一个enclave分配一个产品ID。产品ID允许enclave所有者使用相同的enclave所有者身份去分割enclave。当一个enclave被正确的初始化后，CPU记录Product ID，在远程认证的过程中可以被使用。 Enclave认证 本地认证 一个enclave可以请求硬件生成一个证书，即report，其中通过密码学证据证明着enclave存在这个平台上。这个report可以给其他的enclave，让其进行验证report是同一平台上生成。内部enclave之间认证机制使用的是对称密钥，只有验证report结构的enclave和创建enclave report的硬件可以访问到，并且嵌入到硬件平台中。 一个enclave report包含着以下的信息： enclave中的code和初始化数据的measurement。 enclave初始化的时候记录ISV证书公钥的哈希值。 用户后来添加的数据。 其他安全相关的状态信息。 上述所有数据的一个签名，可以被生成report的同一平台去进行验证。 本地认证过程 在上图中，应用A持有enclave A，应用B持有enclave B。在不可信应用A和B为两个enclave建立通信后，enclave B向enclave A发送了MRENCLAVE的值。（应用A和B可以是同一应用） 有两种方法对于应用而言可以提取enclave的MRENCLAVE measurement: 应用B从enclave B的enclave证书中提取MRENCLAVE的值。 enclave B提供了一个接口来导出该值，通过创建一个report。 Encalve A请求硬件生成一份report送至enclave B，并且其中包含着从enclave B获取到的数据。enclave A通过不可信应用将数据发送给enclave B。 当enclave B收到了来自enclave A的报告，enclave B要求硬件去验证report来确认enclave A和B在同一平台上运行。enclave B从enclave A中提取相应的MRENCLAVE，然后请求硬件生成自己的report，接着发送给enclave A。 enclave A验证enclave B的report，并且验证enclave B和自己运行在同一平台上。 远程 (跨平台) 认证 一个持有enclave的应用可以要求enclave去生成一份report，接着将这份report传到平台服务去生成一种类型的证书，反映着enclave和平台的状态。这种类型的证书被称为quote。这个quote可以传递到平台外的实体，并且使用Intel Enhanced Privacy ID（Intel EPID）签名技术去进行验证。作为结果，CPU的密钥并没有直接从平台内部暴露出去。 一个quote包含这以下的数据： enclave中代码和初始化数据的measurement。 enclave初始化的时候记录ISV证书公钥的哈希值。 enclave的产品ID和安全版本号。 enclave的属性，例如，encalve是否运行在debug mode。 enclave中添加的用户数据。提供了一种方式由enclave向外部实体提供数据。 上述所有数据的一个签名，借助于Intel EPID组签名技术。 包含在quote中的enclave 数据（MRENCLAVE, MRSIGNER, ISVPRODID, ISVSVN, ATTRIBUTES等等）在远程认证过程的末尾提供给远程服务使用上。服务提供者将根据这些数据去进行判断是否可信。 EPID Intel EPID是一种组签名技术，允许平台去匿名签名对象并且可以保护签名者的隐私（如果使用机器的CPUID签名，会导致隐私的泄露）。通过Intel EPID签名技术，组里面的每一个签名者都有他们各自的私钥，但是验证者使用相同的公钥去验证个人的签名。因此，用户无法识别出两个交易是否来自于同一个机构，因为用户无法检测中是组里面哪个成员做了签名。在Intel SGX中，这个组是所有支持Intel SGX平台的集合。 QE Intel中内嵌了一种特殊的enclave，成为Quoting Enclave（QE），QE验证report正确地按照其MRENCLAVE mesurement值进行创建，然后将它用一个硬件特定的非对称密钥（Intel EPID key）进行签名，输出的内容就是quote。当enclave 系统正在运行的过程中，只有QE有权限访问Intel EPID key。因此quote可以看作直接来自于硬件本身，但是CPU key永远不会暴露到平台外部。 远程认证过程 当应用需要在平台外部的服务，它首先和外部服务提供系统建立连接。服务提供者发起挑战(包含一个nonce)来证明应用确实运行在enclave中 应用从应用的enclave请求一份report，并将来自外部服务提供商的nonce传递进enclave中 enclave生成一份report结构，并将其连同一个清单返回给应用，清单包含report中用户数据部分的值以及nonce和用于挑战应答交互的密钥 report发送给QE去做签名 QE验证report QE转换report的body转换为quote，并对其使用EPID进行签名 QE返回quote structure 应用返回quote结构体和其他相关的信息到外部服务者 外部服务者使用EPID验证公钥去验证quote的签名信息。 外部服务者对比来自enclave的信息，并与其它可信配置的信息进行比较。判断enclave是否满足条件。其中包括检测enclave是否运行在debug模式，及其的measurement，产品ID和enclave所有人等等。 区分不同的Enclave运行实例 Intel SGX不直接提供一种机制（例如，通过自动生成的REPORT字段）来区分同一个enclave的两个不同的实例。 如果想要尝试的话，可以使用RDRAND函数生成随机数，并作为作为用户数据，嵌入到REPORT中。 Enclave密封 为了保护和持久化数据，提供了一种由enclave软件从特定的enclave中提取key的机制。这个Key只能在特定的平台上被某个enclave生成。enclave 软件使用那个key去在平台上加密数据或者从平台上解密已经存在的数据。我们把这种加密和解密的操作成为密封和解封。 软件密封技术 密封到当前的enclave（依照于enclave度量） 密封到当前enclave 使用enclave measurement的当前版本（MRENCLAVE），当enclave创建的时候，将这个值绑定到密封操作所需要使用的key上。这个绑定操作由硬件执行通过EGETKEY指令。 只有有着相同的MRENCLAVE度量的enclave才能够将密封的数据进行解密。如果enclave的DLL，Dynamic Library，或者Shared Object文件被篡改，那么enclave的measurement将会发生改变。作为影响，密封的key同样会发生变化，数据将不会被还原。 密封到enclave当前的所有者 将数据密封到enclave的当前的所有者需要使用enclave所有者的身份，这个值由CPU在enclave初始化的过程中存储在MRSIGNER寄存器中，并且这个值被绑定到密封数据函数所需要使用到的key中。这个绑定是由硬件通过EGETKEY指令完成。被密封数据函数使用的key同时也被绑定到enclave的产品ID上。产品ID在enclave初始化时存储在CPU中。 当MRSIGNER度量寄存器的值和产品ID相同时，enclave才能解密。 这种机制的好处是： 它允许enclave的所有者对enclave进行升级，但是不需要进行复杂的升级过程来解密之前密封在之前版本的enclave（MRENCLAVE 度量值不同）中的数据，并且重新使用密封到新的版本 它允许来自相同的所有者的enclave实现共享数据 Enclave所有者生产出enclave后，可以为之指定安全版本号。这个安全版本号同样在enclave初始化的时候存储在CPU中。一个enclave在从CPU中获取密封key的请求中必须提供一个相应的安全版本号。一个enclave不能指定一个比它当前安全版本号靠后的enclave，但是encalve可以指定一个在当前安全版本号之前的安全版本号。这个选项使enclave获得了解封之前版本的enclave中的数据，对于enclave软件更新，是有着巨大的好处的。 密封和解封过程 在enclave中密封数据的主要过程如下： 为加密数据和密封数据结构在enclave中分配内存。其中密封数据结构主要包括要加密的数据和额外认证数据(AAD, 额外的参与MAC计算但不进行加密的数据或文本)。额外认证数据中的信息可能包括应用enclave，版本号，数据等 调用加密数据的API来执行加密操作，一个加密操作算法如下： 验证输入参数是有效的。例如，如果作为参数进行传递的是一个指向加密数据结构的指针，它指向的缓存必须存在于enclave中。 初始化并向其中填充一个将要被EGETKEY指令来执行密钥请求的数据结构。过程如下： 获取EREPORT去获得安全ISV和TCB安全版本号，将在key获取中使用 Key 名称：识别获取key的名字，在这种情况下即为Seal key Key Policy：识别即将使用的软件密封策略。使用MRSIGNER来表示密封到enclave的所有者上，使用MRENCLAVE来表示密封到当前的enclave（enclave measurement）中。保留位必须被清除 Key ID：调用RDRAND来获取一个随机数 属性字段：表明密封密钥应该与什么属性进行绑定 使用上一步构造出的密钥请求结构调用EGETKEY获取Seal key 使用加密算法来使用密封密钥来执行密封操作。推荐使用AES-GCM加解密函数，例如Rijndael128GCM 从内存删除seal key以防泄露 将密封数据结构（包括密钥请求结构）从enclave中保存到外部内存中。密钥请求结构将用来在今后的enclave初始化后去获取密封密钥。 在enclave中对加密数据进行解密主要包括以下过程： 为待解密的数据分配内存。 调用解密api去执行解密操作。一个解密操作算法如下： 验证输入参数的合法性。 从密封数据结构中提取密钥请求结构 借助密钥请求结构去通过EGETKEY指令获取密封密钥 调用解密算法使用密封密钥解密 从内存中删除密封密钥以防止泄露 验证解密算法生成的hash与加密过程中生成的hash一致 区分不同的Enclave实例 即使同一个enclave的两个不同的实例可以在它们认证时区分，但是当两个enclave都使用EGETKEY指令时，目前Intel SGX不提供一种机制来阻止一个enclave实例去访问另一个enclave的密封数据，两个实例将会返回相同的密钥值。 如果要区分enclave实例的SEAL key，推荐： Intel recommends that enclave writers use the KEYID field of the KEYREQUEST structure passed into the EGETKEY instruction to pass an enclave instance specific nonce. This will provide a different key even when the same enclave is in a different virtual machine. 处理器特征 在enclave中可以执行大部分Ring3软件能执行的指令 程序性能 Enclave创建 enclave的大小很大程度上影响了创建enclave的时间，主要是由于在enclave的度量（measurement）过程中，需要进行一系列操作以保证所有的代码加载到enclave中是可信的。 在enclave的创建过程中，一系列的EADD和EEXTEND指令将被运行，主要用于加载和度量enclave的页面。 EADD每次加载4k字节的数据。 EEXTEND每次度量256字节的数据。这意味着对于EADD添加的4KB的数据，需要发起16次的EEXTEND调用。 相关的性能优化建议： 减小enclave的大小。仔细检查在enclave中每段代码和数据元素，如有必要，将其移除。（使用工具：Intel VTune Amplifier）。例如，将即将静态链接的.o 文件先转换为诶.a文件。 Intel SGX 允许enclave通过 Enclave Dynamic Memory Management（EDMM）的方式去进行扩展。当你的OS支持EDMM，那么可以先创建一个比较小的enclave，然后扩展它。 通过在application中添加加载条的方式来获取用户的注意力，借此隐藏应用的加载时间。 避免频繁的enclave创建和重新加载，进而最小化重复的加载性能损耗。 Enclave切换 在enclave之间的频繁转变需要在上下文之间切换非常多次。当一个EENTER指令触发进入enclave时，为了保证enclave可以正常运行，属于不可信运行时的注册状态（register state）和其它信息被存储，enclave中的线程状态和其它属于可信状态的信息被加载，这部分工作主要是由SDK生成的代码执行。一个相反的过程发生在从enclave中退出（被EEXIT指令触发）：可信线程状态信息被保存，不可信的注册状态和其它信息被还原，在这个过程中同样执行着安全检查，这部分工作也主要由SDK生成的代码自动执行。这些行为构成了在应用和enclave之间控制权切换所带来的固定负载。 然而，这个转变中有一些可变变量影响着损耗，即传递参数的大小。参数在从不可信应用部分到可信enclave传递的过程中被序列化，并且返回值被反序列化。在可信enclave中，来自不可信应用的参数被反序列化，并且将返回值序列化。如果应用传递大量的参数，将会有显著的性能损耗。 如果在enclave和应用之间的控制权的转变很大程度地冲击着性能，考虑通过通过以下的方式降低影响： 减小传递参数的总大小。（使用工具：Intel VTunte Amplifier） 当确实有大量数据需要进行传递的时候，考虑使用指针的方式。需要说明的是，使用指针会带来一部分安全风险，为此你必须自己去实现指针检查器，如果使用这种方式的话。 过多缓存未命中 encalve所存储的内存内容在处理器cache之外的部分都是加密受保护的。这种类型的保护在从内存中获取cache lines带来了相应的负载。这种负载和Intel SGX实现方式有直接关系。 Intel SGX架构中在缓存未命中的情况下，相对于其他传统的负载，新增了两种类型的负载： 对于不在处理器cache中的每一条cache line所执行的完成check/anti-replay 检查，以及在系统内存中更新相应的数据结构（如果必要的话）。这种类型的负载依赖于内存访问模式。 在cache和内存中加载和移除数据所带来的加解密。 如果你的系统受到大量的缓存未命中而相关的性能损耗的冲击，可以考虑下面的步骤： 减小enclave中的数据的大小。观察数据，以保证只有必要的数据才能装载进入enclave中。更少的数据意味着更少的加减密和更少的数据结构检查，在Intel SGX内存控制/保护机制下。可以使用Intel VTune Amplifier来观察应用中的cache行为。 可以查看下面的文档去创建一个更加“缓存友好”的应用：PDF地址 过多的页写入 需要考虑Intel SGX应用频繁大量的页面切换对性能的影响，并且如何最小化这方面的后果： Intel SGX使用安全存储 EPC 来存储enclave中的内容。Enclave页面大小为4KB。当enclave比EPC总可用的内存要大的话，enclave分页机制可能会被某些特权软件来使用。当OS尝试交换enclave页面时，CPU使用EWB指令执行以下的步骤： 读取要替换出去的Intel SGX页面（移出） 加密页面中的内容 将加密的页面写到未收到保护的系统内存中 由于这个过程有着固定的负载，因此越多的页面被替换出去，越多的性能损耗发生。为了阻止应用频繁经历这种页面的交换，尽可能确保enclave的大小小于EPC。尽可能只将秘密数据和在这之上的操作放入enclave中，从而最小化页面交换的可能性。可以使用Intel VTune Amplifier工具来观察应用中页面替换的行为，来保证做出正确的决定 多线程下的性能 如果应用是多线程的，从数据同步，锁，线程模型和内存分配算法上去寻找改善性能的方法。 Intel SGX SDK 的一些关于同步和锁的原语已经被优化。 对于较重的多线程应用，推荐选择更好的内存分配算法。Intel SGX SDK针对linux提供了TCMalloc内存分配算法，相对于默认的dlmalloc内存分配算法，有着更好的性能表现。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Rust - Learn","slug":"Rust-notes","date":"2020-11-13T04:36:04.487Z","updated":"2020-11-16T07:49:22.339Z","comments":true,"path":"2020/11/13/Rust-notes/","link":"","permalink":"http://example.com/2020/11/13/Rust-notes/","excerpt":"Rust基础学习笔记","text":"Ch0 安装Rust 使用rustup安装 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装时出现的问题（未完全解决）：默认.cargo环境变量设置为了/home/&lt;username&gt;/~/.cargo，导致在用户家目录下又新建了~目录，在安装完rust后，将.cargo目录移动到~/家目录下，并修改所有可能会更改环境变量的文件，包括~/.profile、/etc/profile、/etc/bash.bashrc、~/.cargo/env，将其中的/home/&lt;username&gt;/~/.cargo改为~/.cargo。但是每当打开终端时，环境变量PATH还是会自动添加/home/&lt;username&gt;/~/.cargo/bin 暂时的解决方案：在~/.bashrc文件中添加语句，覆盖错误的环境变量(重启后就成功了) 1export PATH=~/.cargo/bin:$PATH Ch1 Cargo 1.1 使用Cargo创建项目 创建hello_world目录，并在其中新建二进制项目hello_world 1$ cargo new hello_world 创建库项目 1$ cargo new hello_world --lib 1.1.1 Cargo.toml Cargo.toml是项目的配置文件，通过cargo new自动生成 1234567[package]name = &quot;hello_world&quot;version = &quot;0.1.0&quot;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]edition = &quot;2018&quot;[dependencies] [package]片段：配置一个包，包含项目名称、版本、作者和Rust版本 [dependencies]片段：罗列项目依赖 1.1.2 源代码目录src 包含main.rs以及其他源文件 1.2 构建并运行Cargo项目 编译项目 1$ cargo build 编译并运行项目 1$ cargo run 快速检查代码确保其可以编译，但不生成可执行文件 1$ cargo check 以上命令会生成以下文件： 1.2.1 可执行文件 存放目录为./target/debug/hello_world 1.2.2 Cargo.lock Cargo.lock记录项目依赖的实际版本，确保项目构建是可重现的，这个文件不需要人为修改 1.3 发布(release)构建 当项目最终准备好发布时，可以优化编译项目是的Rust代码运行更快 1$ cargo build --release 此时生成的可执行文件在./target/release/目录下 Ch2 引入 - guess_number 2.1 创建变量 1let mut guess = String::new(); let 创建变量，变量默认不可变 mut 使得变量可变 :: 表明new是String类型的一个关联函数 2.2 从标准输入读取 123use std::io;io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;); io::stdin函数返回一个终端标准输入句柄 read_line将标准输入存入字符串 &amp;表示这个参数是一个引用 read_line函数返回一个Result类型（枚举），成员有Ok和Err Result实例有expect方法： 若Result值为Ok，expect获取Ok中的值并原样返回 若Result值为Err，expect导致程序崩溃，并显式当做参数传给expect的信息 2.3 crate crate是一个Rust代码包 我们构建的项目是一个二进制crate rand crate是一个库crate 2.3.1 导入外部crate 以rand crate为例 在使用rand编写代码之前需要修改Cargo.toml文件 123[dependencies]rand = &quot;0.5.5&quot; 再进行cargo build，此时会从Crates.io拷贝数据并下载对应的库文件，需要更换国内镜像源进行加速，编辑.cargo/config文件，加入以下内容 12345[source.crates-io]registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;replace-with &#x3D; &#39;ustc&#39;[source.ustc]registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot; 2.3.2 更新crate 1$ cargo update 2.3.3 获取所有本地依赖提供的文档 查看应该 use哪个trait以及该从crate中调用哪个方法 1$ cargo doc --open Ch3 常见编程概念 3.1 变量和可变性 使用let声明的变量默认是不可改变的 12let x = 3;x = 5; // 非法 在变量名之前加mut来使其可变 12let mut x = 3;x = 5; // 合法 3.1.1 变量和常量的区别 常量使用关键字const声明，并且必须注明值的类型 不能对常量使用mut 常量只能被设置为常量表达式，而不能是函数调用的结果 3.1.2 隐藏 定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量 12let x = 5;let x = x + 1; 当再次使用let时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字 3.2 数据类型 Rust 是 静态类型语言，在编译时就必须知道所有变量的类型 3.2.1 标量类型 标量类型代表一个单独的值 整型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 数字字面值 例子 Decimal 98_222 Hex 0xff Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b'A' 浮点型 Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位 默认类型是 f64 布尔型 bool，两个可能的值true和false 字符类型 char 类型的大小为四个字节，并代表了一个 Unicode 标量值 3.2.2 复合类型 元组类型 元组长度固定：一旦声明，其长度不会增大或缩小 元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的 12345let tup: (i32, f64, u8) = (500, 6.4, 1);let (x, y, z) = tup; // 解构let five_hundred = tup.0; // 使用索引访问 数组类型 数组中的每个元素的类型必须相同 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小 1234567let a = [1, 2, 3, 4, 5];let a: [i32; 5] = [1, 2, 3, 4, 5];let b = [0; 10]; // 初始化一个长度为10的全零数组let first = a[0]; // 使用索引访问 3.3 函数 fn 关键字声明新函数 在函数签名中，必须声明每个参数的类型 1234fn another_function(x: i32, y: i32) &#123; println!(&quot;The value of x is: &#123;&#125;&quot;, x); println!(&quot;The value of y is: &#123;&#125;&quot;, y);&#125; 3.3.1 具有返回值的函数 以表达式结尾 123fn plus_one(x: i32) -&gt; i32 &#123; x + 1&#125; 3.4 注释 // 单行注释 3.5 控制流 3.5.1 if表达式 123456789if number % 4 == 0 &#123; println!(&quot;number is divisible by 4&quot;);&#125; else if number % 3 == 0 &#123; println!(&quot;number is divisible by 3&quot;);&#125; else if number % 2 == 0 &#123; println!(&quot;number is divisible by 2&quot;);&#125; else &#123; println!(&quot;number is not divisible by 4, 3, or 2&quot;);&#125; Rust 不会尝试自动地将非布尔值转换为布尔值，所以if后跟的表达式必须是bool 在let语句中使用if 12345let number = if condition &#123; 5&#125; else &#123; 6&#125;; 代码块的值是其最后一个表达式的值 if和else中返回的类型要相同 3.5.2 循环 loop 无限循环，直到按下ctrl+c，或有break 内循环可以 continue 或者 break 外循环，此时需要在外循环添加生命周期： 1234567891011121314#![allow(unreachable_code)]fn main() &#123; &#x27;outer: loop &#123; println!(&quot;Entered the outer loop&quot;); &#x27;inner: loop &#123; println!(&quot;Entered the inner loop&quot;); // This would break only the inner loop //break; // This breaks the outer loop break &#x27;outer; &#125; &#125;&#125; loop 可以返回值，返回 break 后的表达式 12345678910fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; &#125; &#125;; assert_eq!(result, 20);&#125; while 12345let mut number = 3;while number != 0 &#123; println!(&quot;&#123;&#125;!&quot;, number); number = number - 1;&#125; for遍历集合 123456789101112131415161718let a = [10, 20, 30, 40, 50];// iter引用集合a，在循环结束后仍然可以使用afor element in a.iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element);&#125;// into_iter移动集合a的所有权，在循环结束后不能使用afor element in a.into_iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element);&#125;let mut b = [1, 2, 3];// iter_mut引用可变集合b，可以在循环中改变b中的元素for element in b.iter_mut() &#123; *element += 1;&#125; Ch4 所有权 4.1 什么是所有权 Rust管理内存的方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查 4.1.1 所有权规则： Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 值有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 4.1.2 变量作用域 12345&#123; // s 在这里无效, 它尚未声明 let s = &quot;hello&quot;; // 从此处起，s 是有效的 // 使用 s&#125; // 此作用域已结束，s 不再有效 4.1.3 String类型 字符串的字面值是不可变的，而String类型的字符串是可变的 String类型的字符串被分配到堆上，所以能够存储在编译时未知大小的文本 12// 基于字符串字面值来创建Stringlet s = String::from(&quot;hello&quot;); 4.1.4 内存与分配 对于String类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着： 必须在运行时向操作系统请求内存 需要一个当我们处理完String时将内存返回给操作系统的方法 Rust处理第二点的策略：内存在拥有它的变量离开作用域后就被自动释放 4.1.5 存储在堆上的变量 1. 移动 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; String 由三部分组成，如上图所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。 当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做二次释放的错误，两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。 在Rust中，经过以上语句，会认为s1不再有效，即s1 被移动到了 s2 中，因此当s1离开作用域时不会释放内存。 克隆 12let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone(); s2深度复制了s1堆上的内容，而不仅仅是栈上的指针。 以上只针对存储在堆上的类型，而对于类似整型等存储在栈上的类型，可以直接拷贝，变量值不会被移动 4.1.6 所有权与函数 123456789101112131415161718192021222324fn main() &#123; let s1 = gives_ownership(); // gives_ownership 将返回值移给 s1 let s2 = String::from(&quot;hello&quot;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃fn gives_ownership() -&gt; String &#123; // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数&#125;// takes_and_gives_back 将传入字符串并返回该值fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数&#125; 4.2 引用与借用 当String类型的变量传入函数中时，如何以引用的方式传入而不是将所有权交给函数？ 12345678910fn main() &#123; let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);&#125;fn calculate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权， // 所以什么也不会发生 &amp;s1语法让我们创建一个指向值s1的引用，但是并不拥有它 我们将获取引用作为函数参数称为借用 引用默认不允许被修改 4.2.1 可变引用 12345678fn main() &#123; let mut s = String::from(&quot;hello&quot;); change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(&quot;, world&quot;);&#125; 可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用，如以下代码是非法的： 12345let mut s = String::from(&quot;hello&quot;);// s被引用了两次，非法let r1 = &amp;mut s;let r2 = &amp;mut s; 这样的限制可以避免数据竞争，即 两个或更多指针同时访问同一数据 至少有一个指针被用来写入数据。 没有同步数据访问的机制 可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能同时拥有 12345let mut s = String::from(&quot;hello&quot;);&#123; let r1 = &amp;mut s;&#125; // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用let r2 = &amp;mut s; 可变引用和不可变引用不能同时存在，如以下代码非法： 1234567let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题let r3 = &amp;mut s; // 大问题println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3); 由于一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，所以以下代码合法： 123456789let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);// 此位置之后 r1 和 r2 不再使用let r3 = &amp;mut s; // 没问题println!(&quot;&#123;&#125;&quot;, r3); 4.2.2 悬垂引用 所谓悬垂指针是其指向的内存可能已经被分配给其它持有者 在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域，如以下函数非法： 1234fn dangle() -&gt; &amp;String &#123; // dangle 返回一个字符串的引用 let s = String::from(&quot;hello&quot;); // s 是一个新字符串 &amp;s // 返回字符串 s 的引用&#125; // 这里 s 离开作用域并被丢弃。其内存被释放。危险！ 而应该直接返回String，将所有权移动出去 4.3 Slice类型 slice是一个没有所有权的数据类型 slice允许你引用集合中一段连续的元素序列，而不用引用整个集合 4.3.1 字符串slice 字符串 slice是String中一部分值的引用 12345let s = String::from(&quot;hello world&quot;);let hello = &amp;s[0..5];let world = &amp;s[6..11];let all_s = &amp;s[..]; 字符串字面值就是slice，如let s = &quot;Hello world&quot;中，s的类型是&amp;str，是一个指向二进制程序特定位置的slice 4.3.2 其他类型的slice 如数组slice: 123let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3]; Ch5 结构体 5.1 结构体的定义和实例化 123456789101112131415161718// 定义struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125;// 实例化let mut user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1,&#125;;// 获取并修改字段user1.email = String::from(&quot;anotheremail@example.com&quot;); 想要修改实例中的字段，必须将整个结构体声明为可变 12345let user2 = User &#123; email: String::from(&quot;another@example.com&quot;), username: String::from(&quot;anotherusername567&quot;), ..user1&#125;; ..语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值 5.1.1 元组结构体 元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型 12345struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0);let origin = Point(0, 0, 0); 5.1.2 结构体数据的所有权 结构体可以直接存放自身拥有所有权的类型，如String等 结构体在存储引用、slice等没有自身所有权的类型时，需要用上生命周期 5.2 结构体引用和打印 5.2.1 函数调用结构体 函数引用结构体时，不需要获得其所有权，所以采用引用的方式调用: 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, area(&amp;rect1) );&#125;fn area(rectangle: &amp;Rectangle) -&gt; u32 &#123; rectangle.width * rectangle.height&#125; 5.2.2 结构体打印 需要使用派生trait 1234567891011#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1); // 或 println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);&#125; 5.3 方法语法 使用关键字impl给结构体定义方法，可以避免另外定义函数 1234567891011121314151617181920#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 将self以不可变引用的方式调用 fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, rect1.area() );&#125; 5.3.1 关联函数 在impl块中定义不以self作为参数的函数，通常用作返回一个结构体实例的构造函数： 123456789101112#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 返回一个正方形的实例 fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, height: size &#125; &#125;&#125; 使用let sq = Rectangle::square(3);调用关联函数 Ch6 枚举和模式匹配 6.1 定义枚举 以IP地址类型为例，通过enum定义一个枚举类型： 1234enum IpAddrKind &#123; V4(u8, u8, u8, u8), V6(String),&#125; 创建IpAddrKind实例： 12let four = IpAddrKind::V4(127.0.0.1);let six = IpAddrKind::V6(String::from(&quot;::1&quot;)); 枚举类型也可以像结构体一样使用impl为其定义方法 6.1.1 Option枚举 Option是标准库定义的另一个枚举，且被包含在preclude中 Rust没有空值，但拥有Option枚举来编码存在或不存在 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; Some可以包含任意类型的数据 使用None需要指定类型 1234let some_number = Some(5);let some_string = Some(&quot;a string&quot;);let absent_number: Option&lt;i32&gt; = None; Option&lt;T&gt;类型的值不能和T类型的值直接运算，必须提前进行转换，因此空值在使用前必须被检查 6.2 match控制流运算符 123456789101112131415161718enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(&quot;Lucky penny!&quot;); 1 &#125;, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个match表达式的返回值 6.2.1 匹配Option&lt;T&gt; 12345678910fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125;let five = Some(5);let six = plus_one(five);let none = plus_one(None); 用于空值处理 匹配是有穷的，必须覆盖变量的所有情况 6.2.2 _通配符 可以在match的所有分支的最后使用_来匹配剩余的所有情况 12345678let some_u8_value = 0u8;match some_u8_value &#123; 1 =&gt; println!(&quot;one&quot;), 3 =&gt; println!(&quot;three&quot;), 5 =&gt; println!(&quot;five&quot;), 7 =&gt; println!(&quot;seven&quot;), _ =&gt; (),&#125; 6.3 if let 简单控制流 123456let some_u8_value = Some(0u8);if let Some(3) = some_u8_value &#123; println!(&quot;three&quot;);&#125; else &#123; println!(&quot;other&quot;);&#125; 可以用于替代只有两分支的match语句 Ch7 使用包、Crate和模块管理项目 7.1 包和crate crate是一个二进制项或者库 包 (package) 是提供一系列功能的一个或者多个 crate，一个包会包含有一个Cargo.toml文件，阐述如何去构建这些 crate 一个包中至多只能包含一个库 crate 一个包中可以包含任意多个二进制 crate 一个包中至少包含一个 crate，无论是库的还是二进制的 使用cargo new创建项目时，src/main.rs就是一个与包同名的二进制 crate 的 crate根 通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate 7.2 模块 模块定义： 123456789101112mod front_of_house &#123; mod hosting &#123; fn add_to_waitlist() &#123;&#125; fn seat_at_table() &#123;&#125; &#125; mod serving &#123; fn take_order() &#123;&#125; fn server_order() &#123;&#125; fn take_payment() &#123;&#125; &#125;&#125; 对应的模块树： 123456789crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 7.3 引用模块树中项的路径 路径的两种形式，都是通过::连接： **绝对路径 ** 从 crate 根开始，以 crate 名或者字面值 crate 开头。 相对路径 从当前模块开始，以 self、super 或当前模块的标识符开头。 7.3.1 使用pub关键字暴露路径 Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，父模块不能使用子模块的私有项，但子模块可以使用父模块中的项，同级的两个模块可以互相引用 当父模块需要使用子模块的项的，需要在子模块中将其声明为pub 7.3.2 使用super起始的相对路径 super相当于文件系统中的..，即当前模块的父模块 7.3.3 创建公有的结构体和枚举 如果在一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的 1234567891011121314151617181920212223mod back_of_house &#123; pub struct Breakfast &#123; pub toast: String, seasonal_fruit: String, &#125; impl Breakfast &#123; pub fn summer(toast: &amp;str) -&gt; Breakfast &#123; Breakfast &#123; toast: String::from(toast), seasonal_fruit: String::from(&quot;peaches&quot;), &#125; &#125; &#125;&#125;pub fn eat_at_restaurant() &#123; // Order a breakfast in the summer with Rye toast let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;); // Change our mind about what bread we&#x27;d like meal.toast = String::from(&quot;Wheat&quot;); println!(&quot;I&#x27;d like &#123;&#125; toast please&quot;, meal.toast);&#125; 因为 back_of_house::Breakfast 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造实例 Breakfast，否则无法在 eat_at_restaurant 中创建实例 7.4 use关键字 使用use关键字可以简化模块中项的调用： 123456789101112131415mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;use crate::front_of_house::hosting; // 绝对路径// 或 use front_of_house::hosting; 相对路径pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;fn main() &#123;&#125; 可以使用 as 关键字提供新名称 123456789101112use std::fmt::Result;use std::io::Result as IoResult;fn function1() -&gt; Result &#123; // --snip--# Ok(())&#125;fn function2() -&gt; IoResult&lt;()&gt; &#123; // --snip--# Ok(())&#125; 当使用 use 关键字将名称导入作用域时，在新作用域中可用的名称是私有的，可以使用 pub use 重导出，使得名称可以引入任何代码的作用域中 7.4.1 使用嵌套路径精简代码 123456789use std::cmp::Ordering;use std::io;// 可以精简为：use std::&#123;cmp::Ordering, io&#125;;use std::io;use std::io::Write;// 可以精简为：use std::io::&#123;self, Write&#125;; 7.4.2 glob运算符 如果希望将一个路径下所有公有项引入作用域，可以指定路径后跟 * 1use std::collections::*; 7.5 将模块分割进不同文件 先使用如下语句引入模块： 1mod front_of_house; Ch8 常见集合 8.1 vector 在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值 vector 只能储存相同类型的值 8.1.1 新建vector 新建空vector时需要指明类型 1let v: Vec&lt;i32&gt; = Vec::new(); 使用 vec! 宏来定义含有初值的vector 1let v = vec![1, 2, 3]; 8.1.2 vector添加元素 1234let mut v = Vec::new();v.push(5);v.push(6); 当vector离开作用域时，会连同其元素全部销毁 8.1.3 读取vector元素 1let v = vec![1, 2, 3, 4, 5]; 使用索引访问，若越界，则会报错崩溃(适用于访问边界严格的vector) 12let third: &amp;i32 = &amp;v[2];println!(&quot;The third element is &#123;&#125;&quot;, third); 使用 get 方法返回一个 Option&lt;&amp;T&gt;，若越界，则会返回None(适用于vector索引可能由用户输入而越界) 1234match v.get(2) &#123; Some(third) =&gt; println!(&quot;The third element is &#123;&#125;&quot;, third), None =&gt; println!(&quot;There is no third element.&quot;),&#125; 当获取了vector的一个元素的不可变引用后，不能在其末尾添加元素，如下代码非法： 1234let mut v = vec![1, 2, 3, 4, 5];let first = &amp;v[0];v.push(6); 8.1.4 遍历vector中的元素 遍历不可变引用 1234let v = vec![100, 32, 57];for i in &amp;v &#123; println!(&quot;&#123;&#125;&quot;, i);&#125; 遍历可变引用 1234let mut v = vec![100, 32, 57];for i in &amp;mut v &#123; *i += 50;&#125; 8.1.5 结合枚举来存储多种类型 1234567891011enum SpreadsheetCell &#123; Int(i32), Float(f64), Text(String),&#125;let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(&quot;blue&quot;)), SpreadsheetCell::Float(10.12),]; 8.2 字符串 8.2.1 新建字符串 新建空字符串 1let mut s = String::new(); 往空字符串中装载数据 1let s = &quot;initial contents&quot;.to_string(); 新建有初始值的字符串 1let s = String::from(&quot;initial contents&quot;); 8.2.2 更新字符串 使用 push_str 方法来附加字符串 slice 12let mut s = String::from(&quot;foo&quot;);s.push_str(&quot;bar&quot;); 使用 push 附加一个字符 12let mut s = String::from(&quot;lo&quot;);s.push(&#x27;l&#x27;); 使用 + 运算符 123let s1 = String::from(&quot;Hello, &quot;);let s2 = String::from(&quot;world!&quot;);let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用 使用 format! 宏 12345let s1 = String::from(&quot;tic&quot;);let s2 = String::from(&quot;tac&quot;);let s3 = String::from(&quot;toe&quot;);let s = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, s1, s2, s3); 8.2.3 索引字符串 Rust的 String 字符串不支持索引单个值，但能够创建字符串slice 12let hello = &quot;Здравствуйте&quot;;let s = &amp;hello[0..4]; 8.2.4 遍历字符串 遍历每个元素（每个元素可能不止一个字节） 123for c in &quot;नमस्ते&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; 遍历每个原始字节 123for b in &quot;नमस्ते&quot;.bytes() &#123; println!(&quot;&#123;&#125;&quot;, b);&#125; 8.3 哈希map HashMap&lt;K, V&gt; 类型储存了一个键类型 K 对应一个值类型 V 的映射 8.3.1 新建一个哈希map 12345678use std::collections::HashMap;// 新建一个空的Hashmaplet mut scores = HashMap::new();// 插入键值对scores.insert(String::from(&quot;Blue&quot;), 10);scores.insert(String::from(&quot;Yellow&quot;), 50); 哈希 map 将它们的数据储存在堆上 所有的键必须是相同类型，值也必须都是相同类型 也可以通过vector的 collect 方法创建 123456use std::collections::HashMap;let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];let initial_scores = vec![10, 50];let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect(); 8.3.2 哈希map和所有权 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map 对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者 8.3.3 访问哈希map中的值 12let team_name = String::from(&quot;Blue&quot;);let score = scores.get(&amp;team_name); get 方法返回的 score 是 Option&lt;T&gt; 类型 8.3.4 遍历哈希map 123for (key, value) in &amp;scores &#123; println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);&#125; 8.3.5 更新哈希map 使用相同的键插入不同的值，会覆盖旧值 使用 entry 方法，只有在键没有对应的值存在的时候插入 12scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);scores.entry(String::from(&quot;Blue&quot;)).or_insert(50); 根据旧值更新一个值 123456789101112use std::collections::HashMap;// 统计单词出现的次数let text = &quot;hello world wonderful world&quot;;let mut map = HashMap::new();for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); *count += 1;&#125;println!(&quot;&#123;:?&#125;&quot;, map); or_insert 方法事实上会返回这个键的值的一个可变引用（&amp;mut V） Ch9 错误处理 9.1 panic!与不可恢复的错误 遇到错误时，Rust 有 panic!宏，当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出 9.1.1 backtrace backtrace 是一个执行到目前位置所有被调用的函数的列表 使用backtrace来找到自己写的代码中错误出在哪一行 1$ RUST_BACKTRACE=1 cargo run 9.2 Result与可恢复的错误 Result 枚举： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; T 代表成功时返回的 Ok 成员中的数据的类型 E 代表失败时返回的 Err 成员中的错误的类型 9.2.1 匹配不同的错误 使用 match 代码比较冗长，且较难理解 123456789101112131415161718use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(&quot;hello.txt&quot;); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; match error.kind() &#123; ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) &#123; Ok(fc) =&gt; fc, Err(e) =&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e), &#125;, other_error =&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error), &#125;, &#125;;&#125; 9.2.2 unwrap 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值 如果 Result 是成员 Err，unwrap 会为我们调用 panic! 12345use std::fs::File;fn main() &#123; let f = File::open(&quot;hello.txt&quot;).unwrap();&#125; 9.2.3 expect 12345use std::fs::File;fn main() &#123; let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);&#125; 使用方法类似 unwrap ，但是可以自己指定显示的错误信息 9.2.4 传播错误 12345678910111213use std::io;use std::io::Read;use std::fs::File;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; // 若文件打开失败，函数会返回相应的错误 let mut f = File::open(&quot;hello.txt&quot;)?; let mut s = String::new(); // 若文件内容写入字符串失败，函数会返回相应的错误 f.read_to_string(&amp;mut s)?; // 若函数执行完成没有出错，则返回Ok Ok(s)&#125; Rust提供了fs::read_to_string 的函数来简化从文件读取到一个字符串中的操作： 123456use std::io;use std::fs;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; fs::read_to_string(&quot;hello.txt&quot;)&#125; 9.3 panic!的使用场景 在当有可能会导致有害状态的情况下建议使用 panic! —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况： 有害状态并不包含 预期 会偶尔发生的错误 之后的代码的运行依赖于处于这种有害状态 当没有可行的手段来将有害状态信息编码进所使用的类型中的情况 Ch10 泛型、trait和生命周期 10.1 泛型 使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型 10.1.1 在函数定义中使用泛型 12345678910fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list.iter() &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，所以需要在函数名称之后写上 &lt;T&gt; 10.1.2 结构体定义中的泛型 字段 x 和 y 必须是相同的类型 123456789struct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; 字段 x 和 y 可以是不同的类型 12345678910struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;fn main() &#123; let both_integer = Point &#123; x: 5, y: 10 &#125;; let both_float = Point &#123; x: 1.0, y: 4.0 &#125;; let integer_and_float = Point &#123; x: 5, y: 4.0 &#125;;&#125; 10.1.3 枚举定义中的泛型 Option&lt;T&gt; 枚举： 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; Result&lt;T, E&gt; 枚举： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; 10.1.4 方法定义中的泛型 123456789101112131415struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Point&lt;T&gt; &#123; fn x(&amp;self) -&gt; &amp;T &#123; &amp;self.x &#125;&#125;fn main() &#123; let p = Point &#123; x: 5, y: 10 &#125;; println!(&quot;p.x = &#123;&#125;&quot;, p.x());&#125; 在 Point&lt;T&gt; 结构体上实现方法 x，它返回 T 类型的字段 x 的引用 必须在 impl 后面声明 T，这样 Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型 10.1.5 泛型代码的性能 Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失 Rust 通过在编译时进行泛型代码的单态化来保证效率，即在编译时填充泛型所使用的具体类型，从而将通用代码转换为特定代码 10.2 trait：定义共享的行为 trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能 10.2.1 定义并使用trait 12345678910111213141516171819202122232425262728293031pub trait Summary &#123; // 实现这个 trait 的类型所需要的行为的方法签名 fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;// 在impl关键字之后，提供需要实现trait的名称，接着是for和需要实现trait的类型的名称impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content) &#125;&#125; 只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait 不能为外部类型实现外部 trait：例如，不能在 aggregator crate 中为 Vec&lt;T&gt; 实现 Display trait。这是因为 Display 和 Vec&lt;T&gt; 都定义于标准库中，它们并不位于 aggregator crate 本地作用域中 10.2.2 默认实现 有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为 123456// trait提供默认实现pub trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; String::from(&quot;(Read more...)&quot;) &#125;&#125; 10.2.3 trait作为参数 123pub fn notify(item: impl Summary) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 对于 item 参数，指定了 impl 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 notify 函数体中，可以调用任何来自 Summary trait 的方法，比如 summarize 使用trait bound重写上面的函数 123pub fn notify&lt;T: Summary&gt;(item: T) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; trait bound适合函数传入多个相同类型的参数 12345// item1和item2的类型可以不同，只要它们都实现了Summarypub fn notify(item1: impl Summary, item2: impl Summary) // item1和item2的类型必须相同pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) 指定多个trait bound 123pub fn notify(item: impl Summary + Display)// 或pub fn notify&lt;T: Summary + Display&gt;(item: T) 通过 where 简化trait bound 1234fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32 where T: Display + Clone, U: Clone + Debug&#123; 10.2.4 返回trait类型 12345678fn returns_summarizable() -&gt; impl Summary &#123; Tweet &#123; username: String::from(&quot;horse_ebooks&quot;), content: String::from(&quot;of course, as you probably already know, people&quot;), reply: false, retweet: false, &#125;&#125; 通过使用 impl Summary 作为返回值类型，我们指定了 returns_summarizable 函数返回某个实现了 Summary trait 的类型，但是不确定其具体的类型 只适用于返回单一类型的情况，如果有分支结构，每个分支返回不同类型，则编译不能通过 10.3 生命周期与引用有效性 10.3.1 生命周期防止悬垂引用 Rust 编译器有一个借用检查器，它比较作用域来确保所有的借用都是有效的 避免了引用比数据的生命周期短的情况 10.3.2 函数的泛型生命周期 1234567891011121314fn main() &#123; let string1 = String::from(&quot;abcd&quot;); let string2 = &quot;xyz&quot;; let result = longest(string1.as_str(), string2); println!(&quot;The longest string is &#123;&#125;&quot;, result);&#125;fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 x 或 y 生命周期注解语法 123&amp;i32 // 引用&amp;&#x27;a i32 // 带有显式生命周期的引用&amp;&#x27;a mut i32 // 带有显式生命周期的可变引用 当有两个或以上的引用参数的生命周期注解都定义为 &amp;'a i32 ，则这些参数的生命周期必须与这泛型生命周期一样长 函数签名中的生命周期注解 12345678// 重写上面的longest函数，指定了签名中所有的引用必须有相同的生命周期&#x27;afn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 10.3.3 结构体定义生命周期注解 有生命周期注解的结构体可以存放引用 123struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125; 10.3.4 生命周期省略 编译器采用三条规则来判断引用何时不需要明确的注解，这些规则适用于 fn 定义，以及 impl 块 每一个是引用的参数都有它自己的生命周期参数 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数 如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 &amp;self 或 &amp;mut self，那么 self 的生命周期被赋给所有输出生命周期参数 10.3.5 方法定义中的生命周期注解 （实现方法时）结构体字段的生命周期必须总是在 impl 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。 12345678910struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125; 10.3.6 静态生命周期 'static 其生命周期能够存活于整个程序期间 所有的字符串字面值都拥有 'static 生命周期 Ch11 编写自动化测试 11.1 如何编写测试 Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作： 设置任何所需的数据或状态 运行需要测试的代码 断言其结果是我们所期望的 11.1.1 测试函数剖析 为了将一个函数变成测试函数，需要在 fn 行之前加上 #[test] 使用 cargo test 命令运行测试 使用 Cargo 新建一个库项目时，它会自动为我们生成一个测试模块和一个测试函数 1234567#[cfg(test)]mod tests &#123; #[test] fn exploration() &#123; assert_eq!(2 + 2, 4); &#125;&#125; 11.1.2 使用assert!宏来检查结果 如果值是 true，assert! 什么也不做，同时测试会通过 如果值为 false，assert! 调用 panic! 宏，这会导致测试失败 11.1.3 使用assert_eq!和assert_ne!宏来测试相等 assert_eq! 判断是否相等，assert_ne! 判断是否不等 断言失败时他们会打印出这两个值具体是什么，以便于观察测试为什么失败 11.1.4 自定义失败信息 为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值 12345678#[test]fn greeting_contains_name() &#123; let result = greeting(&quot;Carol&quot;); assert!( result.contains(&quot;Carol&quot;), &quot;Greeting did not contain name, value was `&#123;&#125;`&quot;, result );&#125; 11.1.5 使用 should_panic 检查 panic #[should_panic] 属性位于 #[test] 之后，对应的测试函数之前 这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败 11.1.6 将 Result&lt;T, E&gt; 用于测试 1234567891011#[cfg(test)]mod tests &#123; #[test] fn it_works() -&gt; Result&lt;(), String&gt; &#123; if 2 + 2 == 4 &#123; Ok(()) &#125; else &#123; Err(String::from(&quot;two plus two does not equal four&quot;)) &#125; &#125;&#125; 11.2 运行测试 11.2.1 并行或连续的运行测试 当运行多个测试时， Rust 默认使用线程来并行运行 应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境 如果有依赖，可以限制线程： 1$ cargo test -- --test-threads=1 11.2.2 显示函数输出 默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容 如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 --nocapture 参数来禁用： 1$ cargo test --nocapture 11.2.3 通过指定名字来运行部分测试 运行单个测试，向 cargo test 传递任意测试的名称来只运行这个测试 1$ cargo test one_hundred 过滤运行多个测试，指定部分测试的名称，任何名称匹配这个名称的测试会被运行，以下命令运行了所有名字中带有 add 的测试 1$ cargo test add 11.2.4 忽略某些测试 使用 ignore 属性来标记耗时的测试并排除他们 12345678910#[test]fn it_works() &#123; assert_eq!(2 + 2, 4);&#125;#[test]#[ignore]fn expensive_test() &#123; // 需要运行一个小时的代码&#125; 如果只希望运行被忽略的测试，可以使用 cargo test -- --ignored 11.3 测试的组织结构 11.3.1 单元测试 单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。 单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。 规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块。 测试模块 测试模块的 #[cfg(test)] 注解告诉 Rust 只在执行 cargo test 时才编译和运行测试代码 11.3.2 集成测试 集成测试的目的是测试库的多个部分能否一起正常工作 二进制项目，即只有 src/main.rs 而没有 src/lib.rs 不能进行集成测试 为了编写集成测试，需要在项目根目录创建一个 tests 目录，与 src 同级，可以随意在这个目录中创建任意多的测试文件 需要在文件顶部添加 use 123456use adder;#[test]fn it_adds_two() &#123; assert_eq!(4, adder::add_two(2));&#125; Ch12 I/O项目：命令行程序 12.1 接受命令行参数 使用标准库提供的函数：std::env::args ，返回一个传递给程序的命令行参数的迭代器 1234567891011use std::env;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let query = &amp;args[1]; let filename = &amp;args[2]; println!(&quot;Searching for &#123;&#125;&quot;, query); println!(&quot;In file &#123;&#125;&quot;, filename);&#125; 12.2 读取文件 使用标准库 std::fs 来处理文件 123let contents = fs::read_to_string(filename) .expect(&quot;Something went wrong reading the file&quot;);println!(&quot;With text:\\n&#123;&#125;&quot;, contents); 12.3 重构改进模块性和错误处理 在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程: 将程序拆分成 main.rs 和 lib.rs 并将程序的逻辑放入 lib.rs 中。 当命令行解析逻辑比较小时，可以保留在 main.rs 中。 当命令行解析开始变得复杂时，也同样将其从 main.rs 提取到 lib.rs 中。 经过这些过程之后保留在 main 函数中的责任应该被限制为： 使用参数值调用命令行解析逻辑 设置任何其他的配置 调用 lib.rs 中的 run 函数 如果 run 返回错误，则处理这个错误 12.4 采用测试驱动开发完善库的功能 测试驱动开发（Test Driven Development, TDD）模式，是一个软件开发技术，它遵循如下步骤： 编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。 编写或修改刚好足够的代码来使得新的测试通过。 重构刚刚增加或修改的代码，并确保测试仍然能通过。 从步骤 1 开始重复！ 12.6 将错误信息输出到标准错误 使用 eprintln! 将错误信息写入标准错误而不是标准输出 使用输出重定向： 1$ cargo run to poem.txt &gt; output.txt 若出错，会输出到标准错误，即显示在命令行，而不写入 output.txt 若正常执行，会输出到标准输出，即重定向到 output.txt Ch13 迭代器和闭包 13.1 闭包 可以保存进变量或作为参数传递给其他函数的匿名函数 使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它 13.1.1 定义闭包 12345678910use std::thread;use std::time::Duration;let expensive_closure = |num| &#123; println!(&quot;calculating slowly...&quot;); thread::sleep(Duration::from_secs(2)); num&#125;;expensive_closure(5); 闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数 如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2| 13.1.2 闭包类型推断和注解 闭包不用于暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用 闭包定义会为每个参数和返回值推断一个具体类型 如果尝试调用闭包两次，第一次使用 String 类型作为参数而第二次使用 u32，则会得到一个错误 13.1.3 使用带有泛型和Fn trait的闭包 可以创建一个存放闭包和调用闭包结果的结构体，该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值 1234567891011121314151617181920212223242526272829303132333435struct Cacher&lt;T&gt; // 闭包有一个 u32 的参数并返回一个 u32 where T: Fn(u32) -&gt; u32&#123; calculation: T, value: Option&lt;u32&gt;,&#125;impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32&#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; /*检查self.value是否已经有了一个 Some 的结果值； 如果有，它返回 Some 中的值并不会再次执行闭包*/ Some(v) =&gt; v, /* 如果 self.value 是 None， 则会调用 self.calculation 中储存的闭包， 将结果保存到 self.value 以便将来使用， 并同时返回结果值*/ None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125;&#125; 在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果。 Cacher 实现的限制： 第一次初始化 value 的值之后，就无法再改动；可以通过使 Cacher 存储一个哈希map而不是一个单独的值解决 它的应用被限制为只接受获取一个 u32 值并返回一个 u32 值的闭包 13.1.4 闭包会捕获其环境 闭包周围的作用域被称为其环境 闭包可以捕获其环境并访问其被定义的作用域的变量 123456789fn main() &#123; let x = 4; /* x 并不是 equal_to_x 的一个参数， 但equal_to_x 闭包也被允许使用变量 x， 因为它与 equal_to_x 定义于相同的作用域*/ let equal_to_x = |z| z == x; let y = 4; assert!(equal_to_x(y));&#125; 闭包有三种方式捕获其环境 FnOnce 消费从周围作用域捕获的变量。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次 FnMut 获取可变的借用值，所以可以改变其环境 Fn 从其环境获取不可变的借用值 13.2 迭代器 迭代器（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑 迭代器是惰性的，即在调用方法使用迭代器之前它都不会有效果 123456789let v1 = vec![1, 2, 3];// 创建一个迭代器，但是没有任何效果let v1_iter = v1.iter();/* 使用迭代器遍历，迭代器中的元素才开始迭代用 for 循环时无需使 v1_iter 可变，因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变*/for val in v1_iter &#123; println!(&quot;Got: &#123;&#125;&quot;, val);&#125; 13.2.1 Iterator trait 和 next方法 123456789// Iterator 是定义于标准库的 traitpub trait Iterator &#123; // Item类型将是迭代器next方法返回元素的类型 type Item; // next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; // 此处省略了方法的默认实现&#125; 在迭代器上直接调用 next 方法 1234567891011#[test]fn iterator_demonstration() &#123; let v1 = vec![1, 2, 3]; // 需要将迭代器定义为可变，因为next方法会改变迭代器 let mut v1_iter = v1.iter(); assert_eq!(v1_iter.next(), Some(&amp;1)); assert_eq!(v1_iter.next(), Some(&amp;2)); assert_eq!(v1_iter.next(), Some(&amp;3)); assert_eq!(v1_iter.next(), None);&#125; 13.2.2 消费适配器 调用 next 方法的方法，如 sum 123456789#[test]fn iterator_sum() &#123; let v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); // 调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权 let total: i32 = v1_iter.sum(); assert_eq!(total, 6);&#125; 13.2.3 迭代器适配器 将当前迭代器变为不同类型的迭代器，如 map 1234let v1: Vec&lt;i32&gt; = vec![1, 2, 3];// 调用 map 方法创建一个新迭代器，接着调用collect方法消费新迭代器并创建一个vectorlet v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();assert_eq!(v2, vec![2, 3, 4]); 13.2.4 创建自定义迭代器 可以实现 Iterator trait 来创建任何我们希望的迭代器 123456789101112131415161718192021222324252627282930313233struct Counter &#123; count: u32,&#125;impl Counter &#123; fn new() -&gt; Counter &#123; Counter &#123; count: 0 &#125; &#125;&#125;impl Iterator for Counter &#123; type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; self.count += 1; if self.count &lt; 6 &#123; Some(self.count) &#125; else &#123; None &#125; &#125;&#125;// 使用自定义的Counter迭代器的多种方法// 获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加#[test]fn using_other_iterator_trait_methods() &#123; let sum: u32 = Counter::new().zip(Counter::new().skip(1)) .map(|(a, b)| a * b) .filter(|x| x % 3 == 0) .sum(); assert_eq!(18, sum);&#125; Ch14 进一步认识Cargo和Crates.io 14.1 采用发布配置自定义构建 Cargo 有两个主要的配置： 运行 cargo build 时采用的 dev 配置 运行 cargo build --release 的 release 配置 dev 配置被定义为开发时的好的默认配置，release 配置则有着良好的发布构建的默认配置 可以在 Cargo.toml 文件中定义 [profile.*] 部分来覆盖默认配置 12345[profile.dev]opt-level = 0[profile.release]opt-level = 3 opt-level 设置控制 Rust 会对代码进行何种程度的优化，值从0到3，越高的优化级别需要更多的时间编译 14.2 将 crate 发布到 Crates.io 14.3 Cargo工作空间 14.4 从 Crates.io 安装二进制文件 使用命令 cargo install 可以从crates.io下载二进制crate，安装到 ~/.cargo/bin Ch15 智能指针 15.1 Box&lt;T&gt; box 允许将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针 使用场景： 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候 15.1.1 Box创建递归类型 Rust 需要在编译时知道类型占用多少空间，而递归类型无法在编译的时候知道大小 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了 以cons list为例 cons list 的每一项都包含两个元素：当前项的值和下一项。 其最后一项值包含一个叫做 Nil 的值且没有下一项。 cons list 通过递归调用 cons 函数产生。 代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。 12345678910enum List &#123; Cons(i32, List), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Cons(2, Cons(3, Nil)));&#125; Rust编译器无法计算一个 List 需要的大小，因为编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons成员储存了一个 i32 值和一个List值，这样的计算将无限进行下去。 使用Box&lt;T&gt;给递归类型一个已知的大小 12345678910111213enum List &#123; Cons(i32, Box&lt;List&gt;), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));&#125; 任何 List 值最多需要一个 i32 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了。 15.2 Deref trait 实现 Deref trait 允许我们重载解引用运算符 * 15.2.1 像引用一样使用 Box&lt;T&gt; 1234567fn main() &#123; let x = 5; let y = Box::new(x); assert_eq!(5, x); assert_eq!(5, *y);&#125; 15.2.2 自定义智能指针 定义 MyBox&lt;T&gt; 类型: 1234567struct MyBox&lt;T&gt;(T);impl&lt;T&gt; MyBox&lt;T&gt; &#123; fn new(x: T) -&gt; MyBox&lt;T&gt; &#123; MyBox(x) &#125;&#125; 15.2.3 在自定义智能指针实现 Deref trait 12345678910use std::ops::Deref;impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123; // 定义trait的关联类型 type Target = T; fn deref(&amp;self) -&gt; &amp;T &#123; // deref返回了我希望通过*运算符访问的值的引用 &amp;self.0 &#125;&#125; 当运行如下代码： 1234let x = 5;let y = MyBox::new(x);assert_eq!(5, *y); *y 在Rust底层运行了 *(y.deref()) 15.2.4 函数和方法的隐式解引用强制多态 解引用强制多态是 Rust 在函数或方法传参上的一种便利。将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。 123456789fn hello(name: &amp;str) &#123; println!(&quot;Hello, &#123;&#125;!&quot;, name);&#125;fn main() &#123; let m = MyBox::new(String::from(&quot;Rust&quot;)); // 解引用强制多态将 &amp;MyBox&lt;String&gt; 自动转换为 &amp;str hello(&amp;m);&#125; 15.3 Drop trait 允许我们在值要离开作用域时执行一些代码，可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源 通过 Drop trait 中的 drop 方法，可以在变量离开作用域时自动丢弃该值 15.3.1 通过 std::mem::drop 提早丢弃值 Rust不允许我们主动调用 Drop trait 的 drop 方法 当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop，其位于preclude，可以直接通过 drop(variable); 调用 15.4 Rc&lt;T&gt; 引用计数智能指针 有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。 Rust 使用引用计数 Rc&lt;T&gt; 的类型来启用多所有权，记录了一个值引用的数量来知晓这个值是否仍在被使用。 Rc&lt;T&gt; 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。 Rc&lt;T&gt; 只能用于单线程场景 15.4.1 使用 Rc&lt;T&gt; 共享数据 使用 Box&lt;T&gt; 定义的 cons list 的两个列表 b 和 c, 共享第三个列表 a 的所有权 12345678910111213enum List &#123; Cons(i32, Rc&lt;List&gt;), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;use std::rc::Rc;fn main() &#123; let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(&amp;a)); let c = Cons(4, Rc::clone(&amp;a));&#125; Rc::clone 只会增加引用计数，而不会深拷贝 在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 Rc::strong_count 函数获得 15.5 RefCell&lt;T&gt; 和内部可变性模式 内部可变性是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的 15.6 引用循环与内存泄漏 Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存，但是创建引用循环从而造成内存泄漏的可能性是存在的 Ch16 并发 16.1 使用线程同时运行代码 线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题： 竞争状态，多个线程以不一致的顺序访问数据或资源 死锁，两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行 只会发生在特定情况且难以稳定重现和修复的 bug 16.1.1 使用 spawn 创建新线程 为了创建一个新线程，需要调用 thread::spawn 函数并传递一个闭包，并在其中包含希望在新线程运行的代码 123456789101112131415161718192021222324252627282930use std::thread;use std::time::Duration;fn main() &#123; thread::spawn(|| &#123; for i in 1..10 &#123; println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i); // thread::sleep调用强制线程停止执行一小段时间，允许其他不同的线程运行 thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125;&#125;/*输出：hi number 1 from the main thread!hi number 1 from the spawned thread!hi number 2 from the main thread!hi number 2 from the spawned thread!hi number 3 from the main thread!hi number 3 from the spawned thread!hi number 4 from the main thread!hi number 4 from the spawned thread!hi number 5 from the spawned thread!*/ 当主线程结束时，新线程也会结束，而不管其是否执行完毕 16.1.2 使用 join 等待所有线程结束 thread::spawn 的返回值类型是 JoinHandle JoinHandle 是一个拥有所有权的值，当对其调用 join 方法时，它会等待其线程结束 通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束 12345678910111213141516171819use std::thread;use std::time::Duration;fn main() &#123; // 从thread::spawn保存一个JoinHandle来确保该线程能够运行结束 let handle = thread::spawn(|| &#123; for i in 1..10 &#123; println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125; handle.join().unwrap();&#125; 16.1.3 线程与 move 闭包 在参数列表前使用 move 关键字强制闭包获取其使用的环境值的所有权，可用于创建新线程时将值的所有权从一个线程移动到另一个线程 1234567891011use std::thread;fn main() &#123; let v = vec![1, 2, 3]; let handle = thread::spawn(move || &#123; println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v); &#125;); handle.join().unwrap();&#125; 16.2 线程间消息传递 Rust 中一个实现消息传递并发的主要工具是通道 1234567891011121314use std::thread;use std::sync::mpsc;fn main() &#123; let (tx, rx) = mpsc::channel(); thread::spawn(move || &#123; let val = String::from(&quot;hi&quot;); tx.send(val).unwrap(); &#125;); let received = rx.recv().unwrap(); println!(&quot;Got: &#123;&#125;&quot;, received);&#125; 使用 mpsc::channel 函数创建一个新的通道，可以有多个发送端，但只能有一个接收端， mpsc::channel 函数返回一个元组：(发送端，接收端)，或 (tx, rx) 通道的发送端有一个 send 方法用来获取需要放入通道的值，返回一个 Result&lt;T, E&gt; 类型 send 函数获取其参数的所有权并移动这个值归接收者所有，所以线程在发送 val 之后就不能再使用它了 通道的接收端有两个有用的方法：recv 和 try_recv recv 会阻塞主线程执行直到从通道中接收一个值，一旦发送了一个值，recv 会在一个 Result&lt;T, E&gt; 中返回它；当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了 try_recv 不会阻塞，立刻返回一个 Result&lt;T, E&gt;：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息 可以将 rx 作为迭代器来接收发送端发送的多个数据，并通过 for 循环打印 可以通过 clone 方法来创建多个发送端: 12let (tx, rx) = mpsc::channel();let tx1 = mpsc::Sender::clone(&amp;tx); 16.3 共享状态并发 16.3.1 互斥器 通过锁来保证任意时刻只有一个线程能访问某些数据 使用方式： 在使用数据之前尝试获取锁。 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。 使用 Mutex&lt;T&gt; 实现 通过关联函数 new 来创建 Mutex&lt;T&gt; 使用 lock 方法获取锁，该方法会阻塞当前线程，直到拥有锁为止 lock 调用返回一个叫做 MutexGuard 的智能指针，当其离开作用域时，会自动释放锁 16.3.2 在线程间共享 Mutex&lt;T&gt; 12345678910111213141516171819202122use std::sync::&#123;Mutex, Arc&#125;;use std::thread;fn main() &#123; let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 &#123; let counter = Arc::clone(&amp;counter); let handle = thread::spawn(move || &#123; let mut num = counter.lock().unwrap(); *num += 1; &#125;); handles.push(handle); &#125; for handle in handles &#123; handle.join().unwrap(); &#125; println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());&#125; 使用原子引用计数 Arc&lt;T&gt; 来实现 Mutex&lt;T&gt; 在多线程之间共享所有权 Ch17 Rust面向对象 17.1 面向对象语言的特征 对象包含数据和行为：结构体和枚举包含数据，impl 块提供对应方法 封装隐藏了实现细节：不添加 pub 就是私有的 通过继承重用代码：使用 trait 对象 17.2 为使用不同类型的值而设计的 trait 对象 17.3 面向对象设计模式的实现 Ch18 模式 18.1 用到模式的位置 18.1.1 match分支 在形式上 match 表达式由 match 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式 12345match VALUE &#123; PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION,&#125; 18.1.2 if let 表达式 等同于只关心一个情况的 match 语句简写 if let 表达式的缺点在于其穷尽性没有为编译器所检查，而 match 表达式则检查了 18.1.3 while let 条件循环 允许只要模式匹配就一直进行 while 循环 18.1.4 for循环 1for (index, value) in v.iter().enumerate() &#123;&#125; 使用 (index, value) 来匹配 enumerate 18.1.5 let语句 1let PATTERN = EXPRESSION; 18.1.6 函数参数 123fn foo(x: i32) &#123; // 代码&#125; x 部分就是一个模式 18.2 可反驳和不可反驳 能匹配任何传递的可能值的模式被称为是不可反驳的，如 let x = 5; 中的 x 对某些可能的值进行匹配会失败的模式被称为是可反驳的，如 if let Some(x) = a_value 中的 Some(x) 函数参数、 let 语句和 for 循环只能接受不可反驳的模式 匹配分支必须使用可反驳模式，如 if let 18.3 模式语法 18.3.1 匹配字面值 12345678let x = 1;match x &#123; 1 =&gt; println!(&quot;one&quot;), 2 =&gt; println!(&quot;two&quot;), 3 =&gt; println!(&quot;three&quot;), _ =&gt; println!(&quot;anything&quot;),&#125; 18.3.2 匹配命名变量 命名变量是匹配任何值的不可反驳模式，当其用于 match 表达式时，情况会不一样 123456789101112131415161718fn main() &#123; let x = Some(5); let y = 10; match x &#123; Some(50) =&gt; println!(&quot;Got 50&quot;), Some(y) =&gt; println!(&quot;Matched, y = &#123;:?&#125;&quot;, y), _ =&gt; println!(&quot;Default case, x = &#123;:?&#125;&quot;, x), &#125; println!(&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;, x, y);&#125;/*会打印：Matched, y = 5at the end: x = Some(5), y = 10*/ 在 match 表达式的新作用域中， y 是一个新变量，而不是开头声明为值 10 的那个 y ，新的 y 绑定会匹配任何 Some 中的值，在这里是 x 中的值 18.3.3 多个模式 使用 | 语法匹配多个模式 1234567let x = 1;match x &#123; 1 | 2 =&gt; println!(&quot;one or two&quot;), 3 =&gt; println!(&quot;three&quot;), _ =&gt; println!(&quot;anything&quot;),&#125; 18.3.4 通过 …= 匹配值的范围 使用 1..=5 替代 1 | 2 | 3 | 4 | 5 对 char 类型也适用：'a'..='j' 18.3.5 忽略模式中的值 使用 _ 忽略整个值 通过 _x 来忽略未使用的变量 使用 .. 忽略剩余的值 123456789fn main() &#123; let numbers = (2, 4, 8, 16, 32); match numbers &#123; (first, .., last) =&gt; &#123; println!(&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;, first, last); &#125;, &#125;&#125; 18.3.6 匹配守卫 匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支 1234567let num = Some(4);match num &#123; Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: &#123;&#125;&quot;, x), Some(x) =&gt; println!(&quot;&#123;&#125;&quot;, x), None =&gt; (),&#125; 18.3.7 @绑定 @ 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式 使用 @ 可以在一个模式中同时测试和保存变量值 12345678910111213141516171819enum Message &#123; Hello &#123; id: i32 &#125;,&#125;let msg = Message::Hello &#123; id: 5 &#125;;match msg &#123; // 将id值保存在id_variable中 Message::Hello &#123; id: id_variable @ 3..=7 &#125; =&gt; &#123; println!(&quot;Found an id in range: &#123;&#125;&quot;, id_variable) &#125;, // 无法保存id值 Message::Hello &#123; id: 10..=12 &#125; =&gt; &#123; println!(&quot;Found an id in another range&quot;) &#125;, Message::Hello &#123; id &#125; =&gt; &#123; println!(&quot;Found some other id: &#123;&#125;&quot;, id) &#125;,&#125; Ch19 高级特征 19.1 不安全的Rust 19.2 高级trait 19.3 高级类型 19.4 高级函数与闭包 19.5 宏","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Pointers on C - Learn","slug":"C和指针notes","date":"2020-11-11T02:30:39.921Z","updated":"2020-11-11T02:37:04.647Z","comments":true,"path":"2020/11/11/C和指针notes/","link":"","permalink":"http://example.com/2020/11/11/C%E5%92%8C%E6%8C%87%E9%92%88notes/","excerpt":"C学习记录","text":"Ch2 基本概念 2.1 环境 2.1.1 翻译环境 翻译过程：各源文件通过编译过程分别转为目标代码 -&gt; 各目标代码文件由链接器捆绑为单一完整的可执行程序 编译过程：预处理器处理 -&gt; 源代码经过解析判断语句的意思，从而生成目标代码 -&gt; 优化器对目标代码进一步处理 2.1.4 执行环境 程序执行过程：程序载入内存 -&gt; 启动程序调用main函数 -&gt; 程序的终止 程序运行过程中使用一个运行时的堆栈，用于存储函数的局部变量和返回地址；同时，程序也可以使用静态内存，其中的值在程序整个执行过程都会保留 2.2 词法规则 2.2.1 字符 \\ddd：三个八进制数字表示的字符 \\xddd：三个十六进制数字表示的字符 2.2.2 注释 //：单行注释 /* */：多行注释 TIPS: 有的程序从标准输入读取数据，读到EOF停止，在终端输入时Ctrl+D即为输入EOF Ch3 数据 3.1 基本数据类型 3.1.1 整型 变量的最小范围 类型 最小范围 char 0 ~ 27-1 signed char -(27-1) ~ 27-1 unsigned char 0 ~ 28-1 short int -(215-1) ~ 215-1 unsigned short int 0 ~ 216-1 int -(215-1) ~ 215-1 unsigned int 0 ~ 216-1 long int -(231-1) ~ 231-1 unsigned long int 0 ~ 232-1 short int至少16位，long int至少32位 头文件limits.h说明各种不同的整型的特点 一、整型常量 声明为const，初始化之后不能被改变 十进制整型常量可能是int、long、unsigned long。缺省情况下为最短类型但能完整容纳这个值 八进制整数以0开头 十六进制整数以0x开头 字符常量：类型为int，是单引号包围的单个字符 1&#x27;M&#x27; &#x27;\\n&#x27; 宽字符常量：多字节字符常量的前面有个L 1L&#x27;X&#x27; L&#x27;e^&#x27; 二、枚举类型 12345// 声明类型enum Jar_Type &#123;CUP, PINT, QUART, HALF_GALLON, GALLON&#125;;// 定义变量enum Jar_Type milk_jug, gas_can, medicine_bottle; 以整型方式存储，符号名实际值都是整型值。如CUP=0，PINT=1，以此类推 可以显式定值，若未指定值，则比前一个符号名大1 3.1.2 浮点类型 包括float、double、long double类型 所有浮点类型至少能容纳从10-37到1037之间的任何值 头文件float.h说明各种不同的浮点型的特点 浮点数默认为double类型；后面跟L/l表示long double；后面跟F/f表示float 3.1.3 指针 一、指针常量 一般都通过操作符来获得一个变量的地址，而不是通过表示为字面值的指针常量，如0xff2044ec 二、字符串常量 字符串：以NUL字节结尾的零个或多个字符，存储在字符数组中 字符串常量：直接值是一个“指向字符的指针”，而不是这些字符本身 3.2 基本声明 3.2.2 声明简单数组 1int value[20]; 编译器不检查数组的下标是否在合法范围内，所以当下标是通过用户输入计算而来的，必须检测是否越界 如果越界，不会报错，只会返回null 3.2.3 声明指针 1234567int *a;char *message = &quot;Hello World&quot;;// 把message声明为一个指向字符的指针，并用字符串常量中的第1个字符的地址对其初始化// 等价于以下语句char *message;message = &quot;Hello World&quot;; 3.3 typedef 为各种数据类型定义新名字 12345// 将变量ptr_to_char声明为一个指向字符的指针类型的新名字typedef char *ptr_to_char;// 声明a是一个指向字符的指针ptr_to_char a; 3.4 常量 const 123456789// 声明整数常量const int a;int const a;// 声明一个指向整型常量的指针int const *pci;// 声明一个指向整型的常量指针int * const cpi; #define 1#define MAX_LEN 20 3.5 作用域 3.5.1 代码块作用域 代码块：位于一对花括号之间的所有语句 嵌套代码块中，内层可以访问外层变量，而外层无法访问内层变量，但是当内外层有名字相同的变量时，内层无法访问外层的那个同名变量 非嵌套的代码块中，作用域没有重叠，所以编译器可以把它们存储在同一个内存地址 3.5.2 文件作用域 任何在所有代码块之外声明的标识符都具有文件作用域，在声明处到源文件末尾都可以访问 3.5.3 原型作用域 只适用于在函数原型中声明的参数名 3.5.4 函数作用域 只适用于语句标签，语句标签用于goto语句 3.6 链接属性 一、none 没有链接属性 声明的同名标识符被当作独立不同的实体 二、internal属性 单个文件中声明的同名标识符表示同一个实体 三、external属性 多个文件中声明的同名标识符表示同一个实体 只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。 默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体。 四、关键字extern和static 如果某个标识符在正常情况下具有external链接属性(只能是具有文件作用域的标识符)，在其前面加上static关键字可以将其链接属性变为internal 链接属性只能修改一次，也就是说一旦将标识符的链接属性变为internal，就无法变回external了 3.7 存储类型 存储变量的内存类型，有普通内存、运行时堆栈、硬件寄存器 在任何代码块之外声明的变量存储在静态内存中，为静态变量，在程序运行之前创建 在代码块内部声明的变量的缺省存储类型是自动的，即存储于堆栈中，进入代码块创建，离开代码块销毁 在代码块内部声明的变量加上static关键字，变为静态变量，但作用域不变。如在函数中声明static变量a，则a在程序开始执行时就被初始化，并且每次函数被调用时，a不会重新初始化 关键字register声明自动变量，存储在硬件寄存器中，为寄存器变量 初始化 如果不显式指定初值，静态变量将初始化为0，而自动变量初始值不确定 3.8 static关键字 用于函数定义或在代码块外声明变量时，将标识符的链接属性从external改为internal，但变量的存储类型和作用域不受影响 在代码块内部声明变量时将标识符的存储类型从自动变量改为静态变量，但变量的链接属性和作用域不受影响 3.9 总结 Ch4 语句 4.1 空语句 1; 只包含一个分号，不执行任何任务 4.2 表达式语句 C不存在赋值语句，赋值通过表达式语句(在表达式之后加上一个分号)实现，如： 1x = y + 3; 以下语句也是合法的，但结果被立即丢弃： 1y + 3; 4.3 代码块 位于一对花括号之内的可选的声明和语句列表 4.4 if语句 123456if (expression) &#123; statement&#125;else &#123; statement&#125; C语言不存在布尔变量，而使用整型的0和1代替，所以expression的结果不是0就是1 4.5 while语句 123while (expression) &#123; statement&#125; break终止所在while代码块的所有循环；continue终止所在while代码块的当前循环 4.6 for语句 123for (初始化部分; 条件部分; 调整部分)&#123; statement&#125; 4.7 do语句 123do &#123; statement&#125; while (expression); 循环体至少执行一次 4.8 switch语句 123456789switch (expression) &#123; case constant-expression-1: statement-1 break; case constant-expression-2: statement-2 break; ......&#125; switch的条件expression必须为整型值 每个case标签必须具有唯一的值 每个switch语句都应该添加一条并且只能添加一条default语句，可以在case语句列表的任何位置 4.9 goto语句 1goto 语句标签; 语句标签是在标识符后添加一个冒号，并跟上一些表达式语句 要尽可能避免使用goto语句 Ch5 操作符和表达式 5.1 操作符 5.1.1 算术操作符 1+ - * / % 5.1.2 移位操作符 左移：&lt;&lt; 右移：&gt;&gt; 无符号数的所有移位操作都是逻辑移位，有符号数是逻辑移位还是算术移位取决于编译器 5.1.3 位操作符 12&amp; | ~// 与或非 将value指定位置1 1value = value | 1 &lt;&lt; bit_number; 将value指定位置0 1value = value &amp; ~ (1 &lt;&lt; bit_number); 5.1.5 单目操作符 !：逻辑取反，产生整型结果0或1 ~：操作数每一位取反 -：取负 &amp;：取操作数的地址 *：间接访问，访问指针所指向的值 sizeof：判断操作数的类型长度，以字节为单位，操作数可以是变量，也可以是加上括号的类型 sizeof (a = b + 1)并没有向a赋值 强制类型转换，如获得整型变量a对应的浮点数值 1(float) a c+：增值操作符，a在变量被使用之前增加它的值，a在变量被使用之后增加它的值 5.1.6 关系操作符 1&gt; &gt;= &lt; &lt;= == != 产生的结果是整型的0或1 5.1.7 逻辑操作符 &amp;&amp;：对于expression1 &amp;&amp; expression2，若expression1为假，则不再对expression2求值 ||：对于expression1 || expression2，若expression1为真，则不再对expression2求值 5.1.8 条件操作符 expression1 ? expression2 : expression3 5.2 布尔值 C没有显式的布尔类型，用整数代替，0是假，任何非零值都是真 5.4 表达式求值 函数进行表达式求值时应该尽量避免以下形式： 1f() + g() + h() 而使用以下形式，因为如果函数的返回值和执行顺序相关，则会产生不确定性 123temp = f();temp += g();temp += h(); Ch6 指针 6.1 内存和地址 内存中的每个位置由一个独一无二的地址标识 内存中的每个位置都包含一个值 编译器帮助实现通过变量访问内存位置，但是硬件仍然通过地址访问内存位置 6.2 值和类型 不能简单地通过检查一个值的位来判断它的类型，因为不同的数据类型和指令会将其解释为不同的类型 6.5 未初始化和非法的指针 在对指针进行间接访问之前，一定要进行初始化，下面是一个错误例子，因为指针a指向的位置不能确定： 12int *a;*a = 12; 6.6 NULL指针 NULL指针不指向任何东西 要使一个指针变量为NULL，可以给它赋一个零值；测试一个指针变量是否为NULL，可以将它与零值比较 6.7 指针、间接访问和左值 12345678int a;int *d = &amp;a;// 合法，对指针d指向的值(a)进行修改*d = 10 - *d;// 非法，整型数的计算结果赋给指针d = 10 - *d; 6.10 指针的指针 123int a = 12;int *b = &amp;a;int **c = &amp;b; 表达式 相当的表达式 a 12 b &amp;a *b a, 12 c &amp;b *c b, &amp;a **c *b, a, 12 6.11 指针表达式 6.13 指针运算 6.13.1 算术运算 当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据对应变量的类型的长度进行调整。例如若float类型指针变量p占4个字节，则p+1不会指向p的第二字节，而是会指向p所占的4个字节之后的那个字节 两个指针只有当都指向同一个数组中的元素时，才允许进行相减，并且减法的结果是两个元素在数组中的距离，而不是内存地址的差值，即在减法运算的同时会除掉变量类型的长度 6.13.2 关系运算 对于指向同一个数组中的元素的指针，可以用关系操作符(&gt; &lt; &gt;= &lt;=)来判断哪个指针指向数组中更前或更后的元素 Ch7 函数 7.2 函数声明 7.2.1 原型 原型总结了函数定义的起始部分的声明，向编译器提供有关函数应该如何调用的完整信息 函数原型的使用： 1234567// func_use.c#include &quot;func.h&quot;... // func.hint *func(int *value, int len);... 声明一个没有参数的函数原型： 1int *func(void); 7.2.2 函数的缺省认定 当程序调用一个无法见到原型的函数时，编译器会认为该函数返回一个整型 7.3 函数的参数 所有参数都是传值调用，函数不会修改实际传递的参数 当传递的参数是指针时，可以通过指针的间接访问修改指针所指的值，称为传址调用 7.4 ADT和黑盒 使用static关键字限制对非接口函数和数据的访问 7.5 递归 通过运行时堆栈支持递归函数的实现 通过一个简单的递归作为实例： 123456789101112// 接受一个整型值(无符号)，把它转换为字符并打印，前导零被删除#include &lt;stdio.h&gt;void binary_to_ascii(unsigned int value) &#123; unsigned int quotient; quotient = value / 10; if (quotient != 0) &#123; binary_to_ascii(quotient); &#125; putchar(value % 10 + &#x27;0&#x27;);&#125; 7.5.1 追踪递归函数 程序运行时堆栈的变化： ​ … 7.5.2 递归与迭代 如果一个递归函数内部所执行的最后一条语句就是调用自身时，被称为尾部递归，这样的递归很容易被改写为循环迭代的形式，而迭代的效率通常较高 7.6 可变参数列表 7.6.1 stdarg宏 定义于stdarg.h头文件 类型va_list：用于声明变量来访问参数列表的未确定部分 此时声明函数的方式为float average(int n, ...) 宏va_start：初始化va_list声明的变量，第1个参数是va_list变量名，第2个参数是省略号前的最后一个有名字的参数 宏va_arg：用于访问参数，第1个参数是va_list变量名，第2个参数是参数列表中下一个参数的类型，返回这个参数的值，并指向下一个可变参数 宏va_end：访问完最后一个可变参数后调用，参数为va_list变量名 7.6.2 可变参数的限制 这些宏无法判断实际存在的参数的数量 这些宏无法判断每个参数的类型 Ch8 数组 8.1 一维数组 8.1.1 数组名 1int b[10]; b[3]的类型是整型 b是一个指向b[0]的常量指针，因而不能修改数组名的值，即不能修改数组存储的内存地址 数组的赋值 12345678int a[10];int b[10];int *c;// 以下两个表达式作用相同，将c指向a[0]c = &amp;a[0];c = a; // 以下表达式非法，不能将数组复制给数组，数组间的复制只能通过循环逐个元素复制 b = a; // 以下表达式非法，a是常量，不能被修改 a = c; 123456789 #### 8.1.2 下标引用通过以下例子说明：​&#96;&#96;&#96;cint array[10];int *ap &#x3D; array + 2; 表达式 对等表达式 ap array+2, &amp;array[2] *ap array[2], *(array+2) ap[0] array[2] ap+6 array+8, &amp;array[8] *ap+6 array[2]+6 *(ap+6) array[8] ap[-1] array[1] ap[9] 非法 8.1.3 指针与下标 指针有时比下标更加高效 在数组中一次一步移动时，与固定数字相乘的运算在编译的时候完成，所以在运行时所需的指令就少 但这在实际中不常用，因为可能编译器对循环会有优化 8.1.5 数组和指针 12int a[5]; // 数组int *b; // 指针 a和b都具有指针值，都可以进行间接访问和下标引用操作 区别： 声明数组时，编译器会为数组保留内存空间，然后再创建数组名 声明指针变量时，编译器只为指针本身保留内存空间，而不为整型值分配内存空间 在上述声明后： *a是合法的，*b是非法的，因为*b将访问内存中某个不确定的位置 b是合法的，a是非法的，因为a是常量指针 8.1.7 声明数组参数 下面的函数原型是等价的： 12int strlen(char *string);int strlen(char string[]); 8.1.8 初始化 1int vector[5] = &#123;1, 2, 3, 4, 5&#125;; 静态初始化：静态变量存储在静态内存，只初始化一次 自动初始化：自动变量在缺省情况下是未初始化的，若给定初值，则每次进入代码块都会重新初始化 8.1.9 不完整的初始化 1int vector[5] = &#123;1, 2, 3, 4&#125;; vector[4]被初始化为0 8.1.10 自动计算数组长度 如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有初始值的长度 8.1.11 字符数组的初始化 12345// 初始化一个字符串数组char message1[] = &quot;Hello&quot;;// 初始化一个字符串常量char *message2 = &quot;Hello&quot;; 8.2 多维数组 8.2.1 存储顺序 定义一个数组： 1int array[3][6]; 其在内存中的存储形式为： 这18个元素的下标值依次是(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (1,0) … (2,4) (2,5) 8.2.2 数组名 如在int matrix[3][10]中，matrix是指向一个包含10个整型元素的数组的指针 那么matrix+1则指向： 而*(matrix + 1) + 5就等价于matrix[1] + 5，是一个指向整型的指针： 8.2.4 指向数组的指针 声明一个指向整型数组的指针，并令其指向matrix数组的第一行： 1int (*p)[10] = matrix; 8.2.5 作为函数参数的多维数组 可以使用以下两张形式的任何一种： 12void func(int (*mat)[10]);void func(int mat[][10]); 8.2.6 初始化 8.2.7 数组长度自动计算 在多维数组中，只有第1维才能根据初始化列表缺省地提供，剩余的几个维必须显式写出 8.3 指针数组 定义方式如下： 1234567char const *keyword[] = &#123; &quot;do&quot;, &quot;for&quot;, &quot;if&quot;, &quot;return&quot;, NULL&#125; 这样定义的好处在于如果要遍历这个表，只需要for (kwp=keyword; *kwp!=NULL; kwp++) Ch9 字符串、字符和字节 9.1 字符串基础 字符串的长度不包含最后的NUL字节 头文件string.h包含了使用字符串函数所需的原型和声明 9.2 字符串长度 1size_t strlen(char const *string); 返回类型为size_t，是一个无符号整数类型 不要在表达式中同时包含有符号数和无符号数，因此应该把strlen的返回值强制转换为int 9.3 不受限制的字符串函数 9.3.1 复制字符串 1char *strcpy(char *dst, char const *src); dst必须是一个字符数组或是一个指向动态分配内存的数组的指针 复制字符串前必须保证目标字符数组的空间足以容纳需要复制的字符串，不然会覆盖数组之后内存的内容 9.3.2 连接字符串 1char *strcat(char *dst, char const *src); 将src字符串的拷贝添加到dst字符串之后 9.3.4 字符串比较 1int strcmp(char const *s1, char const *s2); 若s1小于s2，返回一个小于0的值；若s1大于s2，返回一个大于0的值；若s1和s2相等，返回0 9.4 长度受限的字符串函数 字符串复制，将src的前len个字符(不够补NUL)复制给dst，但当src的长度大于len时，只能复制len个字符给dst，因此结果的dst最后是没有NUL的 1char *strncpy(char *dst, char const *src, size_t len); 字符串连接，将src的前len个字符(不够补NUL)连接到dst后面，会自动添加一个NUL在dst的最后 1char *strncat(char *dst, char const *src, size_t len); 字符串比较，比较两个字符串的前len位 1int strncmp(char const *s1, char const *s2, size_t len); 9.5 字符串查找基础 9.5.1 查找一个字符 12char *strchr(char const *str, int ch);char *strrchr(char const *str, int ch); 在字符串str中查找字符ch第一次出现的位置，返回一个指向该位置的指针，若没有找到返回NULL指针 strchr从左开始找，strrchr从右开始找 9.5.2 查找任何几个字符 1char *strpbrk(char const *str, char const *group); 返回一个指向str中第一个匹配group中任何一个字符的位置指针 9.5.3 查找一个子串 1char *strstr(char const *s1, char const *s2); 在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针 9.6 高级字符串查找 9.6.1 查找一个字符串前缀 12size_t strspn(char const *str, char const *group);size_t strcspn(char const *str, char const *group); strspn返回str起始部分匹配group中任意字符的字符数，而strcspn找的是非group中的字符 例如得到指向字符串中第一个非空白字符： 1prt = buffer + strspn(buffer, &quot;\\n\\t\\r\\f\\v&quot;); 9.6.2 查找标记 1char *strtok(char *str, char const *sep); 从字符串中隔离各个单独的称为标记的部分 sep定义了用作分隔符的字符集合 若strtok的第一个参数不是NULL，函数将找到字符串的第一个标记，同时保存它在字符串中的位置；若strtok的第一个参数是NULL，函数将在同一个字符串中从保存的位置开始查找下一个标记；若找不到下一个标记，则返回NULL 例子：查找被空白分隔的单词 123for (token=strtok(line, whitespace); token!=NULL; token=strtok(NULL, whitespace)) &#123; printf(&quot;%s\\n&quot;, token);&#125; 9.7 错误信息 1char *strerror(int error_number); 参数为错误代码，返回一个指向用于描述错误的字符串的指针 9.8 字符操作 头文件ctype.h 9.8.1 字符分类 9.8.2 字符大小写转换 12int tolower(int ch);int toupper(int ch); 9.9 内存操作 12345void *memcpy(void *dst, void const *src, size_t length);void *memmove(void *dst, void const *src, size_t length);void *memcmp(void const *a, void const *b, size_t length);void *memchr(void const *a, int ch, size_t length);void *memset(void *a, int ch, size_t length); 与strn带头的函数不同，这些函数遇到NUL字节时不会停止操作 Ch10 结构和联合 10.1 结构基础知识 当一个结构变量在表达式中使用时，并不被替换成一个指针，而是一个标量类型 10.1.1 结构声明 12345struct &#123; int a; char b; float c;&#125; x, y[20], *z; 声明了结构体x，包含20个结构体的数组y，指向结构体的指针z 1234567struct SIMPLE &#123; int a; char b; float c;&#125;;struct SIMPLE x, y[20], *z; 推荐使用以下声明方法： 1234567typedef struct &#123; int a; char b; float c;&#125; Simple;Simple x, y[20], *z; 10.1.2 结构成员 直接访问： 1234Simple simp;// 访问成员asimp.a 间接访问： 1234Simple *simp;// 访问成员asimp-&gt;a 10.1.5 结构的自引用 123456789101112131415161718192021222324252627// 错误struct SELF_REF &#123; int a; struct SELF_REF b; int c;&#125;;// 正确struct SELF_REF &#123; int a; struct SELF_REF *b; int c;&#125;;// 错误typedef struct &#123; int a; struct SELF_REF *b; int c;&#125; SELF_REF;// 正确typedef struct SELF_REF_TAG &#123; int a; struct SELF_REF_TAG *b; int c;&#125; SELF_REF; 10.1.6 不完整的声明 用于多个相互依赖的结构体之间的声明 123456789struct B;struct A &#123; struct B *partner;&#125;;struct B &#123; struct A *partner;&#125;; 10.2 结构、指针和成员 后面几节都以以下结构体为例： 1234567891011typedef struct &#123; int a; short b[2];&#125; Ex2;typedef struct Ex &#123; int a; char b[3]; Ex2 c; struct EX *d;&#125;; 若声明一个结构体： 12Ex x = &#123;10, &quot;Hi&quot;, &#123;5, &#123;-1, 25&#125;&#125;, 0&#125;;Ex *px = &amp;x; 10.2.1 访问指针 px的右值： px的左值： px+1是一个非法的左值 10.2.2 访问结构 *px的右值： *px的左值（接受一个新值）： *px+1是非法的，因为没办法将结构体和整型相加 *(px+1)也是非法的 10.2.3 访问结构成员 px-&gt;a的右值： 如果进行以下声明： 12int *pi;pi = &amp;px-&gt;a; 则pi为： ​ **注：**px的结果是整个结构，而pi的结果是一个整型数 px-&gt;b的右值为指针常量，所以没有合法左值： 对数组元素的访问采用px-&gt;b[1] 10.2.4 访问嵌套的结构 px-&gt;c的左值是整个结构，右值如下： px-&gt;c.a的右值： *px-&gt;c.b的右值： 10.2.5 访问指针成员 对px-&gt;d进行初始化，使其指向一个结构体： 12Ex y;px-&gt;d = &amp;y; px-&gt;d-&gt;c.b[1]的右值： 10.3 结构的存储分配 12345struct ALIGN &#123; char a; int b; char c;&#125;; 对于上述结构体，若整型长度为4字节，而且它的起始存储位置必须能被4整除，于是a存储为1字节，但是后面必须空出3字节才能存放b，其存储形式为： 一个结构体占了12个字节的存储空间，有效利用空间却只有6字节 如果声明改为如下形式，则只需要8个字节就能存储这个结构体： 12345struct ALIGN &#123; int b; char a; char c;&#125;; sizeof可以得出一个结构体的整体长度，包括跳过的字节 使用offset(type, member)能获得结构体中某成员的实际位置，如offset(struct ALIGN, b) 10.4 作为函数参数的结构 最好使用指针来传递参数，并声明为寄存器变量来提高效率 若结构体成员不能改变，则： 1void test(register ALIGN const *test); 若需要根据程序运行结果修改结构体中的值，则： 1void test(register ALIGN *test); 调用方式都为： 1test(&amp;align); 10.5 位段 注重可移植性的程序应该避免使用位段 10.6 联合 联合的所有成员引用的是内存中的相同位置 如果联合的各个成员具有不同的长度，联合的长度就是最长成员的长度 应用场景比如： 12345678struct VARIABLE &#123; enum &#123;INT, FLOAT, STRING&#125; type; union &#123; int i; float f; char *s; &#125; value;&#125;; 对于整型，type设为INT，存储于value.i中；对于浮点数，type设为FLOAT，存储于value.f中； 联合的初始化，初始值必须是联合第一个成员的类型，如 12345union &#123; int a; float b; char c[4];&#125; x = &#123;5&#125;; Ch11 动态内存分配 11.1 为什么使用动态分配内存 声明数组时，数组的长度往往在运行时才能知道，但是编译时需要指定数组的长度，因为需要提前开辟内存空间。 11.2 malloc和free 在头文件stdlib.h中声明 11.2.1 malloc 1void *malloc(size_t size); malloc从内存池中提取一块合适的内存，并返回一个指向这块内存起始位置的指针(如果内存池中的内存可以满足需求的话，否则返回NULL) 参数是需要分配的内存字节数 malloc分配的是一块连续的内存 分配的内存不会被初始化 11.2.2 free 1void free(void *pointer); 参数是NULL时不会产生任何效果 参数是先前从malloc、calloc或realloc返回的值时，将分配的内存归还给内存池 11.3 calloc和realloc 11.3.1 calloc 1void *calloc(size_t num_elements, size_t element_size); 参数包括所需元素的数量和每个元素的字节数 将分配的内存初始化为0 11.3.2 realloc 1void *realloc(void *ptr, size_t new_size); 用于修改一个原先已经分配的内存块的大小 扩大内存块时，在原先的内存块之后添加；缩小内存块时，从原先内存块的尾部删除 11.4 使用动态分配的内存 获得足够存储25个整型的内存 12int *pi;pi = malloc(25 * sizeof(int)); 11.5 常见的动态内存错误 对NULL指针进行解引用操作 对分配的内存进行操作时越界 释放并非动态分配的内存 试图释放一块动态分配的内存的一部分 一块动态内存被释放之后被继续使用 内存泄漏：在使用完毕动态内存后没有进行释放 Ch12 使用结构和指针 12.2 单链表 声明一个节点： 1234typedef struct NODE &#123; struct NODE *link; int value;&#125; Node; 链表结构如图所示： 12.2.1 插入一个有序单链表 1234567891011121314151617181920212223242526272829// 函数的参数是一个指向链表第一个节点的指针，以及一个需要插入的新值#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;sll_node.h&quot;#define FALSE 0#define TRUE 1int sll_insert(register Node **linkp, int new_value) &#123; register Node *current; register Node *new; // 寻找正确的插入位置 while ((current=*linkp) != NULL &amp;&amp; current-&gt;value &lt; new_value) &#123; linkp = &amp;current-&gt;link; &#125; // 为新节点分配内存 new = (Node *)malloc(sizeof(Node)); if (new == NULL) &#123; return FALSE; &#125; new-&gt;value = new_value; // 插入节点 new-&gt;link = current; *linkp = new; return TRUE;&#125; 12.3 双链表 声明一个双链表节点: 12345typedef struct NODE &#123; struct NODE *fwd; struct NODE *bwd; int value;&#125; Node; 双链表结构如图所示： Ch14 预处理器 14.1 预定义符号 符号 样例 含义 _FILE_ “name.c” 进行编译的文件名 _LINE_ 25 文件当前行的行号 _DATE_ “Jan 31 1997” 文件被编译的日期 _TIME_ “18:04:30” 文件被编译的时间 _STDC_ 1 如果编译器遵循ANSI C，值为1 14.2 #define 1#define name stuff 替换文本不仅限于数值字面值常量。 123#define reg register#define do_forever for(;;)#define CASE break;case 14.2.1 宏 #define允许把参数替换到文本中，如： 123#define SQUARE(x) (x)*(x)SQUARE(5) // 输出25 14.2.3 宏与函数 可以使用宏来实现简单的函数，如比较大小： 1#define MAX(a, b) ((a)&gt;(b) ? (a) : (b)) 14.2.6 #undef 移除一个宏定义 1#undef name 14.3 条件编译 1234567#if 常量表达式 statements#elif 常量表达式 statements#else statements#endif 如果常量表达式非零，则statements正常编译，否则不编译","categories":[{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"复习 - SQ1复形","slug":"复习-SQ1复形","date":"2020-11-04T10:51:12.000Z","updated":"2020-11-05T02:32:02.662Z","comments":true,"path":"2020/11/04/复习-SQ1复形/","link":"","permalink":"http://example.com/2020/11/04/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/","excerpt":"太久没练复形都忘光了。。。整理复习一下","text":"Overview CS Algs by Depth Depth 1 Shape Scramble Solve / / Depth 2 Shape Scramble Solve /-3-3/ /33/ /3/ /-3/ Depth 3 Shape Scramble Solve /3/1/ /-1/-3/ /-3/-2/ /2/3/ /3/3/ /-3/-3/ /3/12/ /-1-2/-3/ /33/-1-2/ /12/-3-3/ /33/-1/ /1/-3-3/ /-3-3/2/ /-2/33/ /3/1-4/ /-14/-3/ Depth 4 Shape Scramble Solve /33/-1-2/-2-4/ /24/12/-3-3/ /-3-3/01/-2-2/ -2/22/12/-3-3/ /3/1-4/42/ /24/1/-4/3/ /3/1-4/-2-4/ /-4-2/1/-4/3/ /33/-1-2/0-4/ /04/12/-3-3/ /33/12/02/ /0-2/21/33/ /33/-1-2/0-2/ /02/12/-3-3/ /-3-3/01/-2/ /2/0-1/33/ /3/1-4/4/ y2 /0-4/-41/3/ 1-1/0-3/5-2/04/ y2 /-4/1/-4/3/ /03/12/-32/ /-34/12/03/ 1-1/0-3/-1-2/3-2/ /-32/12/03/ /3/1-4/02/ /0-2/-14/-3/ /0-3/0-1/02/ /0-2/01/03/ /0-3/0-1/12/ /-1-2/01/03/ 1-1/3/21/-2/ /2/12/03/ /3/12/4/ /-4/-1-2/-3/ 1-1/0-3/-1-2/0-4/ /04/12/03/ 1-1/3/21/-2-3/ /23/-2-1/-3/ /3/12/23/ /-2-3/-1-2/-3/ /33/-1/4/ /-4/1/-3-3/ 1-1/3/21/0-3/ /03/-2-1/-3/ /0-3/0-1/1/ /-1/01/03/ /0-3/0-1/04/ /0-4/01/03/ Depth 5 Shape Scramble Solve Note /03/12/-3/02/ /0-2/3/-1-2/0-3/ /0-3/0-1/1/02/ /0-2/-1/01/03/ 1-1/03/01/-1/0-2/ /02/02/1/03/ /3/12/2-3/34/ /32/-34/12/03/ 1-1/0-3/-1-2/3-4/-3/ /3/-34/12/03/ 1-1/0-3/-1-2/3-2/3/ /-3/-32/12/03/ 1-1/0-3/-1-2/0-4/-3/ /3/04/12/03/ /03/12/04/3/ /-3/62/-12/03/ /33/1/-2/2/ /-2/2/-1/-3-3/ /33/-1-2/-2/1-2/ /-12/2/12/-3-3/ /33/-1-2/02/2-1/ /-21/0-2/12/-3-3/ 1-1/3/21/2-3/2-1/ /-21/-23/-2-1/-3/ 1-1/3/21/4-3/-21/ /2-1/-43/-2-1/-3/ /0-3/0-1/1/32/ /-3-2/-1/01/03/ 1-1/0-3/-1/0-2/-3-2/ /32/02/1/03/ /33/-1-2/-2-4/-3/ /3/24/12/-3-3/ 1-1/0-3/-1-2/0-4/-32/ /3-2/04/12/03/ 1-1/-3/-1-2/4/-2/ /2/-4/12/3/ /33/-1-2/0-4/02/ /0-2/04/12/-3-3/ 1-1/3/21/2/0-1/ /01/-2/-2-1/-3/ 1-1/0-3/-1-2/02/0-1/ /01/0-2/12/03/ /3/12/-2/01/ /0-1/2/-1-2/-3/ /03/12/02/3-2/ /-32/0-2/-1-2/0-3/ /3/1/-2/2/ /-2/2/-1/-3/ /3/1/-2-1/01/ /0-1/21/-1/-3/ 三小角换风筝尾 /3/1/-2/0-1/ /01/2/-1/-3/ 1-1/0-3/-1-2/3-4/32/ /-3-2/-34/12/03/ /3/12/-23/21/ /-2-1/2-3/-1-2/-3/ 1-1/0-3/-1-2/3-2/-3/ /3/-32/12/03/ /03/12/-32/3/ /-3/3-2/-1-2/0-3/ 1-1/0-3/-1-2/3-2/0-2/ /02/-32/12/03/ /3/1-4/02/-1/ /1/0-2/-14/-3/ 构造飞镖 /3/1-4/02/0-2/ /02/0-2/-14/-3/ 构造飞镖 1-1/3/21/2-3/0-1/ /01/-23/-2-1/-3/ /33/-1-2/2/0-1/ /01/-2/12/-3-3/ 三小角并一小角 /-3-3/01/-2-2/1-2/ \\ 合并六星 Depth 6 Shape Scramble Solve Note /0-3/-2-1/-32/-1-2/-4/ /4/12/3-2/21/03/ 1-1/-3/-1-2/2-3/-2-1/0-4/ /04/21/-23/12/3/ 待优化 1-1/0-3/-1-2/3-4/-1-2/-2/ /2/12/ -34/12/03/ 1-1/3/21/4-3/21/02/ /0-2/-2-1/-43/-2-1/-3/ /0-3/0-1/12/2/-1/ /1/-2/-1-2/01/03/ /3/1/-2-1/0-2/01/ /0-1/02/21/-1/-3/ /3/1/-2/2/03/ /0-3/-2/2/-1/-3/ /33/1/-2-2/21/-2-2/ \\ 两步变六星 /3/1/-2/0-1/2/ /-2/01/2/-1/-3/ 两步后23动1 /3/1/-2-1/01/-2/ /2/0-1/21/-1/-3/ /33/1/-2/2/-2-3/ /23/-2/2/-1/-3-3/ /3/12/-2/01/2/ /-2/0-1/2/-1-2/-3/ /3/12/-2/2-3/-2/ /21/2-1/21/-1/-3/ /3/1/-2/2/-23/ /2-3/-2/2/-1/-3/ /33/-1-2/-2/1/2/ /33/12/2/-1/-2/ 1-1/3/2-5/2/0-1/-4/ /4/01/-2/-25/-3/ 构造shield-paw /3/1/-2/2/-2/ /2/-2/2/-1/-3/ 构造shield-kite Depth 7 Shape Scramble Solve /3/1/-2/2/-2/1/ /-1/2/-2/2/-1/-3/ /0-3/0-1/02/0-2/02/0-1/ /01/0-2/02/0-2/01/03/","categories":[{"name":"Cube","slug":"Cube","permalink":"http://example.com/categories/Cube/"}],"tags":[{"name":"sq1","slug":"sq1","permalink":"http://example.com/tags/sq1/"},{"name":"cube","slug":"cube","permalink":"http://example.com/tags/cube/"}]},{"title":"Hexo+Volantis个人博客部署","slug":"Hexo-Volantis个人博客部署","date":"2020-11-03T09:46:42.000Z","updated":"2020-11-04T09:59:52.992Z","comments":true,"path":"2020/11/03/Hexo-Volantis个人博客部署/","link":"","permalink":"http://example.com/2020/11/03/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/","excerpt":"个人博客配置心得","text":"配置部署Hexo 配置流程 参考链接 安装npm 安装git 其中配置npm源 123456# 获取npm源npm get registry# 修改为淘宝源npm config set registry http://registry.npm.taobao.org/# 重置# npm config set registry https://registry.npmjs.org/ 常用命令 12345# 上传至githubhexo g &amp;&amp; hexo d# 本地运行hexo g &amp;&amp; hexo s Markdown公式显示问题 使用hexo-renderer-markdown-it插件 处理Markdown图片问题 在最开始的尝试中遇到以下问题： 直接将图片保存到github，在hexo编译生成的html网页中通过相对路径访问速度太慢 将博客部署到gitee上，由于服务器在国内，图片加载速度确实比github快很多，但是问题在于部署在gitee上的博客会有各种奇怪显示问题，所以也放弃 最终的解决办法： 先在github新建一个仓库Source，专门用来存放博客文章用到的图片 使用jsdelivr提供的cdn加速 在本地编写好markdown后，将图片文件夹复制到Source目录下并push到github仓库 在markdown文档中通过ctrl+f将所有图片的路径前缀改为https://cdn.jsdelivr.net/gh/&lt;github用户名&gt;/Source@latest/&lt;文件夹名&gt; Volantis主题配置 主题安装 修改./_config.yml 1theme: volantis 下载主题 1npm i hexo-theme-volantis volantis主题会安装在./node_modules/hexo-theme-volantis中 主题个性化 搜索工具安装 1npm i -S hexo-generator-search hexo-generator-json-content 字数统计工具安装 1npm i hexo-wordcount 主题配置文件 顶部导航栏 1234567891011121314151617181920212223navbar: logo: # choose [img] or [icon + title] img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/taiga.svg menu: - name: 主页 icon: fab fa-stack-overflow url: / - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: Search... # Search bar placeholder 封面 12345678910111213141516171819202122cover: layout_scheme: dock # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) background: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/interstellar.jpg logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;Schenk - Blog&#x27; subtitle: &#x27;SJTUer | Cuber&#x27; features: - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ 全局CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556custom_css: navbar: height: 44px width: auto # auto, max effect: [shadow, blur, floatable] # [shadow, floatable, blur] sidebar: effect: [shadow, floatable] # [shadow, floatable, blur] body: effect: [shadow, floatable] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true grayscale: false # Enable grayscale effect text_align: # left, right, justify, center h1: center h2: left h3: left h4: left p: justify gap: h2: 30px # Spacing above H2 (only px unit) h3: 18px # Spacing above H3 (only px unit) h4: 8px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... fontsize: root: 16px h1: 1.5rem # 不推荐用在文章中 h2: 1.5rem h3: 1.25rem h4: 1.125rem h5: 1rem h6: 1rem list: .9375rem meta: .875rem code: .875rem footnote: .78125rem fontfamily: logofont: fontfamily: &#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27; name: &#x27;Microsoft Yahei&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27; name: &#x27;Microsoft Yahei&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf weight: normal style: normal codefont: fontfamily: &#x27;UbuntuMono&#x27; name: &#x27;UbuntuMono&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/UbuntuMono-Regular.ttf weight: normal style: normal 页脚 1234567site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [copyright] # site copyright copyright: &#x27;[Copyright © 2020 Schenk](https://github.com/Schenk75/Schenk75.github.io)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; 文章布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: false # true, false # show readmore button readmore: always # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, wordcount, counter] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: data:image/png;base64,666 # ---------------- # 打赏组件 (for layout: post) donate: enable: false height: 128px images: - https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags] # meta library meta_library: # 默认文章作者（可在 front-matter 中覆盖） author: avatar: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg name: Schenk url: / # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag 侧边栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106sidebar: # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, webinfo] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg shape: circle # circle, rectangle url: /about/ title: Schenk subtitle: jinrishici: false # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/github-icon.svg size: 30px url: https://github.com/Schenk75 - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/struts.svg url: / - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/logos/WCAlogo.svg url: https://cubingchina.com/results/person/2018SHEN04 # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fas fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2020/11/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: service: busuanzi # busuanzi, leancloud siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; 统计工具 12analytics: busuanzi: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/tools/busuanzi.pure.mini.js 关闭评论 1234comments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: # valine, minivaline, disqus, gitalk, vssue, livere, isso, hashover 插件 1234567891011plugins: ######## Plugins to optimize the experience: # Codeblock Copy Button clipboard: enable: true js: https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js ######## Plugins for SEO: # npm i hexo-wordcount wordcount: enable: true 页面布局模板 参考链接 front-matter设置 参考链接","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"cdn","slug":"cdn","permalink":"http://example.com/tags/cdn/"}]},{"title":"Internet安全协议与分析Notes","slug":"Internet安全协议Notes","date":"2020-11-02T06:54:20.991Z","updated":"2020-11-25T11:22:52.456Z","comments":true,"path":"2020/11/02/Internet安全协议Notes/","link":"","permalink":"http://example.com/2020/11/02/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/","excerpt":"Internet安全协议与分析期末复习","text":"IPSec 通信保护协议 AH 通信提供数据源认证、抗抵赖性、数据完整性和反重播保证，但不提供机密性保护 AH传输模式 源IP地址、目的IP地址是不能修改的，否则会被检测出来，因此AH在传输模式下和NAT冲突 AH隧道模式 AH验证的范围也是整个IP包，因此AH和NAT的冲突在隧道模式下也存在 ESP 为IP提供机密性、数据源认证、抗重播以及数据完整性等安全服务，但不提供抗抵赖性 对IP头部不进行认证，因此不会和NAT冲突 ESP传输模式 ESP隧道模式 密钥交换管理协议IKE 安全机制 前向安全性：一个密钥被破解不影响其他密钥的安全性 数据验证 DH交换和密钥分发 阶段1 主模式协商 野蛮模式协商 两种模式对比 阶段2 SSL 安全机制 数据机密性：对称加密 身份验证机制：基于证书的数字签名 消息完整性：MAC算法 SSL连接和会话 连接是点对点的、暂时的 会话是客户端和服务器之间持久的关联 SSL分层结构 上层协议 SSL握手协议：协商加密套件，交换密钥，身份认证 SSL password变化协议：修改新的加密套件和密钥 SSL警告协议：当其他过程中出现错误或发送异常时，向对方报告告警信息 下层协议 SSL记录协议：对上层数据分块、压缩、加密、传输 SSL握手协议 阶段1：建立安全能力 协商加密套件 阶段2：服务器鉴别与密钥交换 阶段3：客户端鉴别与密钥交换 服务器和客户端分别发送自己的证书并交换密钥信息以便进行身份认证 阶段4：完成 检验双方是否获得同样的安全参数 SSL记录协议 为每个SSL连接提供： 机密性 完整性 SSL协议安全性分析 鉴别机制：公开密钥机制和数字证书 加密机制：混合密码体制 完整性机制：定义了共享的、可以用来形成报文鉴别码MAC的密钥 抗重放攻击：序列号，用随机数标记握手 SSL脆弱性分析 客户端假冒 无法提供基于UDP的应用的安全保护 不能对抗通信流量分析：SSL只对数据进行保护，数据包的IP头和TCP头暴露在外 SSL进程存储空间中的主密钥泄露 SET 双重数字签名 订单信息OI：客户给商家 支付信息PI：客户给银行 SET电子支付流程 支付初始化：持卡人选择商品，下订单，选择银行卡 初始请求：持卡人发送请求指定交易环境 初始应答：商家回复交易环境信息，以及证书等，并附上签名 购物请求： 持卡人检查商家初始应答发送的签名信息，确保数据完整性 持卡人发送PReq 商家验证持卡人的身份和授权 商家将相关信息发送给支付网关 支付网关认证 网关将信息发送给银行 收单银行处理 确保PI和AuthReq的一致性 校验持卡人和商家对于订购行为的一致性 发送AuthRes给商家 支付完成 通过捕获令牌(Capture Token)完成支付 下单回复 SET核心技术 公开密钥加密 数字签名 数字信封：公钥算法加密对称密钥 电子安全证书 PGP 提供可用于电子邮件和文件存储应用的保密与鉴别服务 PGP数字签名与认证 PGP保密性 邮件的存储转发特性不适合用DH算法交换密钥 使用公钥算法对每个消息生成一次性会话密钥 PGP保密和认证结合 PGP压缩 使用ZIP算法 先签名后压缩 只需要存储原始报文和签名 易于更换压缩算法 PGP密钥环 每个结点都有存储密钥的结构 私钥环：存储该结点拥有的公/私钥对 公钥环：存储该结点拥有的其他所有用户的公钥 PGP信任网 PGP中没有认证机构，而是由用户互相对对方的公钥进行数字签名 确认是否信任 通过自己的数字签名 通过自己完全信任的人的数字签名 通过自己有限信任的多个人的数字签名 Kerberos 采用传统加密算法(非公钥算法) 基本概念 Principle：安全个体，有名字和口令 KDC：网络服务，提供ticket和临时会话密钥 Ticket：客户用来向服务器证明身份的票据 其大多数信息被服务器的密钥加密 Authenticator：包含最近产生的信息的记录，需要用到会话密钥 Credentials：一个Ticket加上秘密的会话密钥 AS：Authentication Server 通过long-term key认证用户 授予用户ticket granting ticket和short-term key 认证服务 TGS：Ticket Granting Server 通过ticket granting ticket和short-term key认证用户 发放service granting ticket给用户以访问其他服务器 授权和访问控制服务 Kerberos工作流程 1. 认证服务交换：获得票据许可票据(ticket granting ticket) 2. 票据许可服务交换：获得服务许可票据(service granting ticket) 3. 客户/服务器认证交换：获得服务 Kerberos跨域认证 获得本地TGS访问权 请求一张远程TGS的票据许可票据 向远程TGS请求其域内的服务 Kerberos优缺点 优点 密码不在网上传输，不易被窃听，难以猜测 单点登录机制，只用输入一次口令 票据被盗之后难以使用，因为需要配合认证头来使用 缺点 缺乏撤销机制 密钥管理复杂 跨域认证复杂 需要始终同步 需要始终在线的AS和TGS BAN 所用符号 A, B, S：泛指参与协议的主体 P, Q, R：主体变量 X, Y: 公式变量 K: 密钥变量 Kab, Kbs, Kas: 主体之间的共享密钥 Ka, Kb, Ks: 主体的公钥 Ka-1, Kb-1, Ks-1: 主体的私钥 Na, Nb, Ns：主体各自生成的用于确认新鲜性的随机数Nonce {X}k：用密钥k加密X的结果 &lt;X&gt;Y：X和Y的组合 P-&gt;Q:(X)：P发送消息X给Q bel(P,Q)：主体P相信X sees(P,X)：P接收到X said(P,X)：P发送X cont(P,X)：P拥有对X正确与否的判决权 fresh(X)：X是新鲜的 skey(P,K,Q)：K是P,Q的共享密钥 goodkey(P,K,Q)：K是P,Q共享的良好密钥 pubkey(P,K)：K是P的公钥 secret(P,X,Q)：X是P和Q的共享秘密 推理规则 消息意义规则 从加密消息所使用密钥以及消息中包含的秘密来推断消息发送者的身份 例如对于共享密钥：bel(P,goodkey(P,K,Q)) and sees(P,{X}k) =&gt; bel(P,said(Q,X)) 随机数验证规则 如果P相信X是新鲜的，并且P相信Q曾经发送过X，那么P相信Q相信X bel(P,fresh(X)) and bel(P,said(Q,X)) =&gt; bel(P,bel(Q,X)) 仲裁规则 如果P相信Q对X是有仲裁权的，并且P相信Q相信X，那么P相信X bel(P,cont(Q,X)) and bel(P,bel(Q,X)) =&gt; bel(P,X) 信仰规则 bel(P,X) and bel(P,Y) =&gt; bel(P,(X,Y)) bel(P,(X,Y)) =&gt; bel(P,X) or bel(P,Y) bel(P,bel(Q,(X,Y))) =&gt; bel(P,bel(Q,X)) or bel(P,bel(Q,Y)) 接收规则 如果P接收到一个消息，那么P也接收到这个消息的一部分 sees(P,(X,Y)) =&gt; sees(P,X) sees(P,&lt;X&gt;Y) =&gt; sees(P,X) 如果P收到加密消息，那么以下三种情况P可以读出消息原文 bel(P,goodkey(P,K,Q)) and sees(P,{X}K) =&gt; sees(P,X) bel(P,pubkey(P,K)) and sees(P,{X}K) =&gt; sees(P,X) bel(P,pubkey(Q,K)) and sees(P,{X}K-1) =&gt; sees(P,X) 新鲜规则 如果消息的一部分是新鲜的，则整个消息是新鲜的 bel(P,fresh(X)) =&gt; bel(P,fresh(X,Y)) 传递规则 如果P相信Q曾经发送过整个消息，那么P相信Q曾经发送过消息的部分 bel(P,said(Q,(X,Y))) =&gt; bel(P,said(Q,X))","categories":[{"name":"Course Notes","slug":"Course-Notes","permalink":"http://example.com/categories/Course-Notes/"}],"tags":[{"name":"安全协议","slug":"安全协议","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-01T13:16:05.384Z","updated":"2020-11-03T14:11:41.657Z","comments":true,"path":"2020/11/01/hello-world/","link":"","permalink":"http://example.com/2020/11/01/hello-world/","excerpt":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Git - Learn","slug":"Git学习","date":"2020-10-13T09:00:19.289Z","updated":"2020-11-04T04:20:24.639Z","comments":true,"path":"2020/10/13/Git学习/","link":"","permalink":"http://example.com/2020/10/13/Git%E5%AD%A6%E4%B9%A0/","excerpt":"Git学习记录","text":"版本控制 1. 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS 2. 集中版本控制 所有的版本数据都存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3. 分布式版本控制 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN的主要区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git环境配置 Git配置 查看配置 1git config -l 查看不同级别的配置文件： 1234567# 查看系统configgit config --system --list# Git\\etc\\gitconfig：Git安装目录下的gitconfig # 查看当前用户（global）配置git config --global --list# C:\\Users\\Administrator\\.gitconfig 只适用于当前登录用户的配置 设置用户名与邮箱（用户标识，必要） 12git config --global user.name &quot;&lt;名称&gt;&quot; # 名称git config --global user.email &lt;邮箱&gt; # 邮箱 Git基本理论 三个区域 Git本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下: Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本： Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) Git项目搭建 创建工作目录与常用指令 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 创建权限仓库 创建全新的仓库，需要用GIT管理的项目的根目录执行： 12# 在当前目录新建一个Git代码库$ git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 12# 克隆一个项目和它的整个代码历史(版本信息)$ git clone &lt;url&gt; Git文件操作 文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态 12345678# 查看指定文件状态git status &lt;filename&gt;#查看所有文件状态git statusgit add . 添加所有文件到暂存区git commit -m &quot;消息内容&quot; 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 12345*.txt # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt # 但lib.txt除外/temp # 仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ # 忽略build/目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt Git分支 git分支中常用指令： 123456789101112131415161718192021# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Docker - Learn","slug":"Docker学习","date":"2020-10-12T11:59:23.847Z","updated":"2020-11-04T04:20:38.053Z","comments":true,"path":"2020/10/12/Docker学习/","link":"","permalink":"http://example.com/2020/10/12/Docker%E5%AD%A6%E4%B9%A0/","excerpt":"Docker学习记录","text":"底层原理 Docker是怎么工作的？ Docker是一个C-S结构的系统，Docker的守护进程运行在服务主机上，通过Socket从客户端访问。 DockerServer接收到DockerClient的指令就会执行这个命令。 Docker为什么比VM快？ Docker有着比虚拟机更少的抽象层 Docker利用的是宿主机的内核，VM需要有Guest OS。所以新建一个容器的时候，docker不需要像VM一样重新加载一个操作系统内核，避免引导 Docker常用命令 docker的默认工作路径 1/var/lib/docker 帮助命令 123docker version # 显示docker的版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker &lt;命令&gt; --help # 查看帮助命令 镜像命令 docker images 查看所有本地的主机上的镜像 1234567891011121314[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 9 months ago 13.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IDCREATED 镜像的创建时间SIZE 镜像的大小# 命令可选项-a, --all 列出所有镜像-q, --quiet 只显示镜像的id docker search 搜索镜像 1234567[root@localhost ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10046 [OK] mariadb MariaDB is a community-developed fork of MyS… 3680 [OK] # 可选项，通过收藏数过滤--filter=STAR=3000 搜索出来的镜像是STARS大于3000的 docker pull [:tag] 下载镜像 123456789101112131415161718192021222324252627282930313233343536[root@localhost ~]# docker pull mysqlUsing default tag: latest # 如果不写tag，默认是latestlatest: Pulling from library/mysqld121f8d1c412: Pull complete # 分层下载，docker镜像的核心 联合文件系统f3cebc0b4691: Pull complete 1862755a0b37: Pull complete 489b44f3dbb4: Pull complete 690874f836db: Pull complete baa8be383ffb: Pull complete 55356608b4ac: Pull complete dd35ceccb6eb: Pull complete 429b35712b19: Pull complete 162d8291095c: Pull complete 5e500ef7181b: Pull complete af7528e958b6: Pull complete Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 下载指定版本，共用的层会复用，不用重复下载[root@localhost ~]# docker pull mysql:5.75.7: Pulling from library/mysqld121f8d1c412: Already exists f3cebc0b4691: Already exists 1862755a0b37: Already exists 489b44f3dbb4: Already exists 690874f836db: Already exists baa8be383ffb: Already exists 55356608b4ac: Already exists 277d8f888368: Pull complete 21f2da6feb67: Pull complete 2c98f818bcb9: Pull complete 031b0a770162: Pull complete Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像 12docker rmi -f &lt;镜像id&gt; [&lt;镜像id&gt; &lt;镜像id&gt;] # 删除指定的镜像docker rmi -f $(docker images -aq) # 删除所有镜像 容器命令 **注：**有了镜像才可以创建容器，以centos镜像为例 1docker pull centos docker run [可选参数] 新建并启动容器 1234567891011121314151617# 参数说明--name=&quot;&lt;Name&gt;&quot; 容器名字，自定义，用来区分容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p 指定容器的端口，配置端口转发 -p ip:主机端口:容器端口 -p 主机端口:容器端口（常用） -p 容器端口-P 随机指定端口例：# 启动并进入容器[root@localhost ~]# docker run -it centos /bin/bash# 退出容器并关闭容器[root@bebbdced119e /]# exit# 退出容器但不关闭容器Ctrl + p + q docker ps [可选参数] 列出运行的容器 1234# 参数说明-a 列出所有运行过的容器-n=&lt;n&gt; 列出最近创建的n个容器-q 只显示容器编号 **docker rm 删除容器 123docker rm &lt;容器id&gt; 删除指定容器，不能删除正在运行的容器，若要强制删除加参数-fdocker rm -f $(docker ps -aq) 删除所有的容器docker ps -a -q|xargs docker rm 删除所有的容器 启动和停止容器 1234docker start &lt;容器id&gt; 启动容器docker restart &lt;容器id&gt; 重启容器docker stop &lt;容器id&gt; 停止容器docker kill &lt;容器id&gt; 强制停止容器 常用其他命令 后台启动容器 1234docker run -d centos# 问题：docker ps发现centos停止了# 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 查看日志 12docker logs -ft &lt;容器id&gt; # 查看所有日志docker logs -ft --tail &lt;n&gt; &lt;容器id&gt; # 查看最新的n条日志 **查看容器中的进程信息 ** 1docker top &lt;容器id&gt; 查看容器的元数据 1docker inspect &lt;容器id&gt; 进入正在后台运行的容器 1234567# 方法1docker exec -it &lt;容器id&gt; &lt;bashshell&gt;# 进入容器后开启一个新的终端，可以在里面操作（常用）# 方法2docker attach &lt;容器id&gt;# 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件 1docker cp &lt;容器id&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;","categories":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"Linux - Learn","slug":"Linux学习","date":"2020-09-11T11:47:26.625Z","updated":"2020-11-04T04:20:59.170Z","comments":true,"path":"2020/09/11/Linux学习/","link":"","permalink":"http://example.com/2020/09/11/Linux%E5%AD%A6%E4%B9%A0/","excerpt":"Linux学习记录","text":"了解系统信息 硬盘大小 123fdisk -l&#x2F;dev&#x2F;sda 操作系统中第一块硬盘的名称以及所在路径Linux操作系统一切皆文件 （文件名） sd (硬盘类型) a（第一块） 内存大小 1cat &#x2F;proc&#x2F;meminfo cpu大小 1cat &#x2F;proc&#x2F;cpuinfo 收集系统信息 1uname -a Linux文件系统 12345678910111213&#x2F;bin 普通用户和管理员都可以执行的命令&#x2F;sbin 只有管理员才能执行的命令 eg.关机重启&#x2F;boot 引导 主引导目录 独立的分区 启动菜单 内核&#x2F;dev device 设备文件存放目录&#x2F;etc 配置文件存放目录&#x2F;home 普通用户的家目录&#x2F;root 管理员的家&#x2F;media 光驱的挂载目录&#x2F;mnt 临时设备的挂载目录&#x2F;proc 里面的数据都在内存中，进程的所在目录&#x2F;tmp 临时文件存放目录&#x2F;usr 第三方软件的安装目录&#x2F;var 常变文件存放目录 eg.日志文件、邮件文件 挂载光驱 12弹出光驱：umount &#x2F;dev&#x2F;cdrom挂载光驱：mount &#x2F;dev&#x2F;cdrom &#x2F;media Linux文件类型的显示颜色 1234567蓝色 目录黑色 普通文件浅蓝色 符号链接（快捷方式）黑底黄字 设备文件 硬盘 sda红色 压缩包绿色 带有执行权限的文件紫色 图片 模块文件 压缩和解压缩 文件压缩和解压缩 12gzip bigfilegunzip bigfile.gz 12bzip2 bigfilebunzip2 bigfile.bz2 目录(文件夹)打包压缩 12tar -zcf &#x2F;tmp&#x2F;allfile.tar.gz &#x2F;tmp&#x2F;allfiletar -jcf &#x2F;tmp&#x2F;allfile.tar.bz2 &#x2F;tmp&#x2F;allfile 目录(文件夹)解压缩并解包 123tar -zxf &#x2F;tmp&#x2F;allfile.tar.gz -C &#x2F;tmptar -jxf &#x2F;tmp&#x2F;allfile.tar.bz2 -C &#x2F;tmp-C 指定解包位置 vim 模式切换 123命令模式 -&gt; 输入模式：i输入模式 -&gt; 命令模式：Esc命令模式 -&gt; 末行模式：: 末行模式命令 12345:wq 保存并退出:q! 不保存退出:set nu 显示行号:% s&#x2F;old&#x2F;new&#x2F;g 每一行中的old替换成new:50,56 d 删除50-56行的数据 命令模式命令 123456780 光标移动到当前行首$ 光标移动到当前行末yy 复制当前行2yy 复制当前行以及后一行，其他数字以此类推p 粘贴到当前行下一行dd 删除当前行gg 回到第一行G 回到最后一行 Linux软件安装——封装后的软件包 后缀名 123rpm red hat系统deb debian系统源码包 不考虑系统版本 有关软件包安装的命令 123456rpm -qa 列出所有已经安装的rpm包查询特定的rpm包使用管道符：rpm -qa | grep &quot;tree&quot;rpm -qpi 软件名 确认该软件的作用rpm -qpl 软件名 确认该软件的安装路径(无法修改)rpm -ivh 软件名 安装软件rpm -e 软件名 软件卸载 Linux软件安装——yum 12yum install 软件名yum remove 软件名 用户和组 三个重要文件 12345678910111213&#x2F;etc&#x2F;passwd 保存操作系统中所有的用户信息root : x : 0 : 0 : root : &#x2F;root : &#x2F;bin&#x2F;bash每一条目共7个字段，用冒号隔开字段1：用户名字段2：密码占位符字段3：用户的UID 0 表示超级用户 500-60000 普通用户 1-499 程序用户字段4：基本组的GID，先有组才有用户字段5：用户信息记录字段字段6：用户的家目录字段7：用户登录系统后使用的命令解释器 12345678910&#x2F;etc&#x2F;shadow 保存了用户密码信息root : $6$ME9wjPHAid5ds$PO&#x2F;GlBVEt1 : 18325 : 0 : 99999 : 7 :::字段1：用户名*字段2：用户的密码加盐并通过散列算法后的字符串（sha）字段3：距离1970&#x2F;1&#x2F;1密码最近一次修改的时间字段4：密码的最短有效期*字段5：密码的最长有效期（建议时间 90）字段6：密码过期前7天警告字段7：密码的不活跃期字段8：用户的失效时间 1&#x2F;etc&#x2F;group 记录了系统中所有组的信息 建立和调整用户属性 123456789101112131415161718192021222324252627282930313233343536371、建立一个名为class1的组ID为1000，class2的组ID为2000建立：groupadd class1groupadd -g 2000 class2修改gid：groupmod -g 1000 class1查看：vim &#x2F;etc&#x2F;group2、建立tom用户要求其基本组是class1,附加组为class2，tom用户的UID为600建立：useradd -g class1 -G class2 -u 600 tom修改：usermod查看：id tom3、建立一个程序用户UID为250,用户名为testuser，没有家目录（程序用户没有登录系统权限）useradd -u 250 -M -s &#x2F;sbin&#x2F;nologin testuser-M：没有家目录-s &#x2F;sbin&#x2F;nologin：不能登录4、为tom用户设定密码为123，并设定密码最长有效期为90天，将用户密码进行锁定使其无法登录passwd tom 设定密码chage -M 90 tom 设定密码最长有效期或者修改配置文件&#x2F;etc&#x2F;login.defspasswd -l tom 锁定passwd -u tom 解锁查看：passwd -S tomvim &#x2F;etc&#x2F;shadow5、删除tom用户和testuser用户，删除class1组和class2组userdel -r tom （-r 连同用户的家目录一起删除）userdel -r testusergroupdel class1groupdel class1 文件目录权限 列出文件信息 123456ls -a 列出所有文件，包括隐藏文件ls -l(ll) 列出文件详细信息文件：-rw-rw-r--.(权限) 1(链接数) centos(所属用户) centos(所属组) 12(文件大小，字节) Sep 12 10:07(最后修改时间) test.txt目录：drwxrwxr-x.(权限) 2(子目录数) centos(所属用户) centos(所属组) 6 Sep 12 10:06(最后修改时间) testdirls -ld 列出某一目录的详细信息ls -h 用人能看懂的方式显示文件大小 权限详细 1234567891011121314- rw- rw- r--.d rwx rwx r-x.共4个字段字段1：文件类型 -普通文件 d目录文件 l符号链接文件 b块设备字段2：文件所属者的权限 r w x 文件 读取 写入 可执行 目录 查看目录文件 增删文件 进入目录字段3：文件所属组的权限字段4：其他用户的权限 赋权限 12345方法1：chmod 对象 算术运算符 权限 文件 对象：u-所属者 g-所属组 o-其他用户 a-所有用户 算术运算符：- + &#x3D; 权限：r w x方法2：chmod 777 文件 改变文件的所属者和所属组 12chown 用户 文件chgrp 组 文件 粘滞位 sgid suid权限 12345678910粘滞位针对目录赋权，目录中创建的文件只有建立者可以删除 chmod o+t 文件 chmod o-t 文件sgid 针对目录建立的权限，在该目录中建立的文件所属组继承父目录的所属组 chmod g+s 文件 chmod g-s 文件suid 对可执行文件建立。谁运行该文件，就具有该文件所属者的权限 chmod u+s 文件 chmod u-s 文件 eg. chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim 查找有异常权限的文件 1234查找有suid权限的可执行文件find &#x2F;usr&#x2F;bin -perm 4755其中权限的第一个4表示suid权限，如果是2则表示sgid权限，如果是1则表示粘滞位权限的多一位也可以用于赋权限 不再允许添加新用户 123456789新建用户时会更改的文件 &#x2F;etc&#x2F;group &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow home&#x2F;xxxx锁定文件从而不能添加新用户 chattr +i &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow查看文件是否被锁定 lsattr &#x2F;etc&#x2F;passwd umask 1234567一般目录的最高权限是777一般文件的最高权限是666用户创建的文件通过umask来确定其权限root的umask是0022(第一位是特殊权限)普通用户并且uid&#x3D;sid的umask是0002umask的设置在&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc两个文件中 网络地址配置 12345678910111. 确认网卡信息：ip addr &#x2F; ifconfig2. 关闭NetworkManager服务：systemctl stop NetworkManager3. 网卡启用桥接模式，并配置网络地址： ip addr add IP&#x2F;掩码长度 dev ens334. 设置网关： ip route add default via IP dev ens335. 配置DNS： vim &#x2F;etc&#x2F;resolv.conf nameserver 202.120.2.1016. 关闭防火墙： systemctl stop firewalld.service 日志文件 123456789101112位置：&#x2F;var&#x2F;log日志记录的配置文件：&#x2F;etc&#x2F;rsyslog.conf 其中配置方式为 日志类型.日志级别 ，如authpriv.*表示记录所有级别的登录日志日志分类： 系统日志 &#x2F;var&#x2F;log&#x2F;messages 登录日志 &#x2F;var&#x2F;log&#x2F;secure 程序日志日志记录的日志级别：debug, info, notice, warning(warn), err(error), crit, alert, emerg(panic)最不严重 -&gt; 最严重配置日志备份服务器：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43252204&#x2F;article&#x2F;details&#x2F;105518163 WEB服务-apache 开启并使用apache 1234561. 启动服务 service httpd start2. 验证服务是否开启 ss -antpl | grep 803. 主页建立 vim &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html httpd配置文件 12345678910111213141516171819位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf默认会开启共享目录功能，这样会导致别人可以远程下载&#x2F;var&#x2F;www&#x2F;html中的内容，建议将其关闭： Options Indexes FollowSymLinks改为Options FollowSymLinks限制访问，将Require all granted修改为以下语句： &lt;RequireAll&gt; Require all granted Require not ip 192.168.1.10 192.168.2.0&#x2F;24 &#x2F;&#x2F;拒绝192.168.1.10和192.168.2.0网段客户机访问 &lt;&#x2F;RequireAll&gt;用户授权限制，只有通过指定的用户名密码才能访问网页： 设置用户名密码：htpasswd -c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser test (-c表示新建文件) 设置该文件只有apache用户可读： chown apache httpuser chmod 400 httpuser 修改配置文件： Authtype basic Authname &quot;Input username and password&quot; &#x2F;&#x2F; 提示信息 Authuserfile &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser Require valid-user lamp平台搭建 12345678910111213141. 安装apache2. 安装mysql yum install mysql-server &#x2F;&#x2F; 安装 service mysqld start &#x2F;&#x2F; 启动 mysqladmin -u root -p password &quot;123.sck&quot; &#x2F;&#x2F; 设置root密码 mysql -u root -p &#x2F;&#x2F; 登录数据库3. 安装php yum install php yum install php-mysqlnd yum install php-mbstring4. 配置php配置文件 vim &#x2F;etc&#x2F;php.ini 将short_open_tag从Off改为On5. 在&#x2F;var&#x2F;www&#x2F;html新建一个php文件 iptables防火墙 12345四个表： raw mangle nat 网络地址转换 filter 过滤","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]}],"categories":[{"name":"Useful skills","slug":"Useful-skills","permalink":"http://example.com/categories/Useful-skills/"},{"name":"Course Notes","slug":"Course-Notes","permalink":"http://example.com/categories/Course-Notes/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"},{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Cube","slug":"Cube","permalink":"http://example.com/categories/Cube/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"sq1","slug":"sq1","permalink":"http://example.com/tags/sq1/"},{"name":"cube","slug":"cube","permalink":"http://example.com/tags/cube/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"cdn","slug":"cdn","permalink":"http://example.com/tags/cdn/"},{"name":"安全协议","slug":"安全协议","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]}