{"meta":{"title":"Schenk - Blog","subtitle":"","description":"","author":"schenk","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-11-04T03:04:03.774Z","updated":"2020-11-04T03:04:03.774Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-11-04T03:12:18.440Z","updated":"2020-11-04T03:12:18.440Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友链 - Links","date":"2020-11-04T03:11:19.565Z","updated":"2020-11-04T03:11:19.565Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-04T03:12:28.561Z","updated":"2020-11-04T03:12:28.561Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"About","date":"2020-11-04T08:13:00.108Z","updated":"2020-11-04T08:13:00.108Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"SJTUer Major in Cyber Security Cubing Since 2017 Biiiiiig Fan of Christopher Nolan &amp; One Piece &amp; Hua Chenyu"},{"title":"所有标签","date":"2020-11-04T03:12:36.216Z","updated":"2020-11-04T03:12:36.216Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ubuntu连接PEAP网络","slug":"ubuntu-peap","date":"2021-10-21T16:00:00.000Z","updated":"2021-10-22T07:50:38.085Z","comments":true,"path":"2021/10/22/ubuntu-peap/","link":"","permalink":"http://example.com/2021/10/22/ubuntu-peap/","excerpt":"Ubuntu连接PEAP网络,以SJTU校园网为例","text":"创建配置文件： 12cd /etc/NetworkManager/system-connectionssudo gedit SJTU 在SJTU配置文件中添加内容： 1234567891011121314151617181920212223242526[connection]id&#x3D;SJTUuuid&#x3D;9e123fbc-0123-46e3-97b5-f3214e123456 # uniquetype&#x3D;802-11-wireless[802-11-wireless-security]key-mgmt&#x3D;wpa-eapauth-alg&#x3D;open[802-11-wireless]ssid&#x3D;SJTUmode&#x3D;infrastructuremac-address&#x3D;&lt;MAC address&gt;security&#x3D;802-11-wireless-security[802-1x]eap&#x3D;peap;identity&#x3D;&lt;username&gt;phase2-auth&#x3D;mschapv2password&#x3D;&lt;password&gt;[ipv6]method&#x3D;auto[ipv4]method&#x3D;auto 连接SJTU网络：","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"frp配置","slug":"frp-setup","date":"2021-09-21T16:00:00.000Z","updated":"2021-09-22T09:55:20.610Z","comments":true,"path":"2021/09/22/frp-setup/","link":"","permalink":"http://example.com/2021/09/22/frp-setup/","excerpt":"使用frp配置内网穿透","text":"frp安装 下载：https://github.com/fatedier/frp/releases 免费服务器：http://freefrp.wlphp.com/ frp配置 提供服务的内网机器 frpc.ini 12345678910[common]server_addr = vip.frp.wlphp.comserver_port = 7000token = 905507[secret_ssh]type = stcpsk = schenklocal_ip = 127.0.0.1local_port = 22 访问服务的机器 frpc.ini 123456789101112[common]server_addr = vip.frp.wlphp.comserver_port = 7000token = 905507[secret_ssh_visitor]type = stcprole = visitorserver_name = secret_sshsk = schenkbind_addr = 127.0.0.1bind_port = 6000 访问内网机器 内网机器 Ubuntu 1./frpc -c frpc.ini 访问Ubuntu的机器 Windows 1frpc.exe -c frpc.ini 在Windows上使用ssh连接 1ssh -oPort=6000 schenk@127.0.0.1","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://example.com/tags/frp/"}]},{"title":"论文阅读-Secure Multiparty Computation from SGX","slug":"paper-secure-mpc","date":"2021-08-15T16:00:00.000Z","updated":"2021-09-22T05:19:41.594Z","comments":true,"path":"2021/08/16/paper-secure-mpc/","link":"","permalink":"http://example.com/2021/08/16/paper-secure-mpc/","excerpt":"论文Secure Multiparty Computation from SGX阅读笔记","text":"1.Introduction 使用可信硬件实现MPC协议需要克服： 用户和远程机器之间缺乏专用通道 在异步通信以及仅有TEE介入的条件下对计算进行身份验证/达成一致 确保“正确”的各方参与计算 处理共存于同一TEE、共享内存空间的代码之间的交互，每段代码可能对应不同的用户 确保TEE内部运行的代码不会向外部泄露敏感信息 1.1 贡献 通用安全多方计算 一个高效的安全多方计算协议（非交互式） 加载进TEE的代码先执行密钥交换，再通过秘密信道执行任意函数 $F$ 标记验证计算LAC 经过验证的输出为计算序列提供完整性保护，输出的完整性可以进行公开验证 为输入添加标签，并将对应于特定标签的输入和输出绑定 对LAC进行正式建模，通过LAC原语将任意程序部署到TEE LAC可用于更多的依赖TEE的安全协议的模块化分析 实现和实验 两个实现： sgx-mpc-mbed ：依赖TLS库，使用RSA进行密钥交换 sgx-mpc-nacl ：依赖NaCl密码学库，使用椭圆曲线密码进行密钥交换和数字签名 3.TEE程序与机器 TEE程序 抽象为编程语言 $L$ ，包含TEE系统调用 TEE中的系统调用结果只能依赖于: 程序加载时定义的初始共享状态 显式传递的输入 新鲜的随机硬币","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"论文阅读-TZ4Fabric. Executing Smart Contracts with ARM TrustZone","slug":"paper-TZ4Fabric","date":"2021-06-12T16:00:00.000Z","updated":"2021-06-13T09:30:14.079Z","comments":true,"path":"2021/06/13/paper-TZ4Fabric/","link":"","permalink":"http://example.com/2021/06/13/paper-TZ4Fabric/","excerpt":"论文TZ4Fabric. Executing Smart Contracts with ARM TrustZone阅读笔记","text":"1.引入 Hyperledger Fabric私有链码（FPC）是一个开源项目，它使通道上的节点（区块链网络中节点的子集）在TEE内执行智能合约，特别是在Intel SGX Enclave内。由于物联网设备大多体积小，可能由电池供电，并嵌入低功耗处理器，FPC不容易在这种情况下部署，这极大地阻碍了其在论文的目标部署场景中的适用性。 Fig1描述了论文预想的部署场景：一个异构的、可能分布的节点集合加入了区块链；智能合约必须跨通道执行，只有少数节点受到保护，免受攻击。例如，攻击者可以破坏一个通道，获得对其节点的访问权并收集敏感信息。为了遏制攻击并防止攻击传播到其他通道，某些通道的智能合约可以在TEE内执行。受到TEE保护的节点可以免受恶意攻击，特别是作为物联网设备部署在“野外”的节点更容易受到此类攻击。 本论文提出了结合ARM TZ的Hyperledger Fabric链码执行的原型系统TZ4Fabric。TZ4Fabric体系结构受到FPC的启发，但它隔离了TEE组件。该设计不仅可以利用ARM TZ，还可以TZ4Fabric扩展到未来的TEE。 2.背景 区块链和智能合约 在许可的区块链中(如Ripple和Hyperledger Fabric)，网络的访问是受限制的，实体是已知的。 Hyperledger Fabric (HF)是一个支持智能合约的许可区块链，在HF中，智能合约称为链码。Fig2给出了HF的高层架构和工作流程，在链码函数被调用之前，它必须被安装(存储在文件系统上)并在对等端实例化。 1、2：客户端应用向对等端发送请求（交易提出），来调用链码函数；对等端执行链码函数 3：对等端向客户端发送交易响应，交易响应由对等端签名，并包含执行响应消息以及读集合和写集合，读集合代表对等端在执行期间通过 GetState 从账本中查询到的所有键值，写集合包含对等端通过 PutState 生成的所有键值对更新 4：当客户端收集了由认可策略定义的足够多的交易响应时，将它们发送给排序端，排序端将交易响应放入区块，并将它们分发给所有对等端，这是排序阶段。之后在验证阶段，每个对等端检查是否满足认可策略以及不同交易的读和写是否由冲突，然后就把交易写在账本上，账本包含两个促成部分：一个区块链和一个世界状态，世界状态是一个可插拔的数据库，用于存储和有效检索区块链中的键的当前值 ARM TrustZone 提供硬件组件，用于在ARM处理器上启用TEE。OP-TEE是一个流行的开源运行时，支持ARM TZ。ARM TZ的安全世界和正常世界的切换是通过安全监控呼叫(SMC)进行的。系统资源是严格隔离的：正常世界不能访问安全世界的资源(如内存、外设等)。在安全世界的引导过程中，将建立信任链，并对安全世界的软件映像进行完整性检查——这个过程称为安全引导。 3.威胁模型 考虑一个强大的攻击者，他拥有管理权限，并且可以物理访问所有支持ARM TZ的节点。进一步假设操作系统和用户空间在正常情况下是不可信的。但是假定TEE(包括引导加载程序、固件、OP-TEE和安全监视器)是可信的。 由于ARM TZ本身并不支持远程认证机制，因此攻击者可能会在协议执行之前试图破坏它。链码在正常情况下作为可信应用程序(TA)存储，并使用构建密钥进行签名。ARM TZ在运行时不提供完整性保护。本论文不考虑侧信道攻击。 4.TZ4Fabric架构 支持ARM TZ的设备通常是低功耗嵌入式设备，其中许多都是由电池供电的，它们资源（存储和内存）有限。TZ4Fabric依赖于Go编程语言环境、HF、OP-TEE以及gRPC等包，这些包不仅需要几百兆的持久存储，而且在运行时也需要几百兆的内存，因此论文提出通过代理将大型系统组件(如HF和Docker)与轻量级安全相关组件(如链码)解耦。 在设计中，链码操作及其响应中可以包含敏感信息，必须保护这些信息免受恶意攻击。因此，将链码存放到一个支持TEE的嵌入式设备。将TZ4Fabric分为三大组件：作为链码驻留在对等端上的包装器、代理、链码本身。包装器通过gRPC和代理通信，代理和链码运行在基于ARM的环境中，并使用TrustZone，其中代理在正常世界，链码在安全世界。论文的设计利用OP-TEE框架来进行代理和链码之间的交互。 包装器被安装和实例化为链码，并被用作对等端和账本的接口。它将来自客户端的输入调用转发到安全世界中的链码，处理与账本的通信，并将交易响应发送回对等端。 代理充当中介，在包装器和链码之间转发调用。它负责从正常世界到安全世界的上下文切换。 链码实现了区块链应用程序逻辑，并由客户端通过包装器调用。在执行过程中，链码可以使用代理通过 getState 和 putState 命令访问账本。 论文的设计允许在一个单一的安全世界中实例化和运行多个链码。 论文的原型侧重于在HF中包含ARM TZ，而没有实现一个机制在网络中复制链码。链码在原型中作为OP-TEE中的TAs执行，链码使用与机器上运行的OP-TEE相同的构建系统进行编译，TA使用原始的构建密钥进行签名，并可选地加密。因此，在调用链码之前，必须将每个链码编译到TA并在目标机器上安装，然后，链码可以在目标机器上复制并直接调用，而不必经过生成TA的过程。在原型中，为链码生成了一个TA，并将其部署在所有启用ARM TZ的代理上。","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"论文阅读-Ekiden. A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts","slug":"paper-Ekiden","date":"2021-06-12T16:00:00.000Z","updated":"2021-06-13T09:29:26.552Z","comments":true,"path":"2021/06/13/paper-Ekiden/","link":"","permalink":"http://example.com/2021/06/13/paper-Ekiden/","excerpt":"论文Ekiden. A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts阅读笔记","text":"1.引入 现有的智能合约系统因此缺乏保密性和隐私性，它们不能安全地存储或计算敏感数据；区块链共识需求也使得智能合约在计算能力、存储容量和事务吞吐量方面的性能低下。 区块链和TEE有互补特性： 区块链可以保证强可用性和持久性，而TEE不能保证可用性（因为宿主可以自行决定终止TEE），也不能可靠地访问网络或持久性存储 区块链的计算能力非常有限，必须公开其整个状态以供公共验证，而TEE与本地计算相比产生的开销很小，并通过远程认证提供具有机密性的可验证计算 区块链和TEE结合会产生新的安全问题：由于TEE的基本限制是恶意主机可以任意操纵它的调度和I/O，TEE可能在任意时间中止，导致区块链上丢失和冲突的状态。TEE缺少可信时钟，因此很难更新到区块链的最新状态。可能存在的攻击例如针对区块链的完整性攻击危及TEE保护内容的机密性（如，攻击者可以通过提供一个伪造的区块链来绕过TEE强制执行的隐私计算，以退回到执行前并向其请求任意多个查询） Ekiden采用计算与共识分离的架构。Ekiden在链下的TEE中使用计算节点执行私有数据的智能合约计算（避免了链上计算负担），然后验证它们在链上的正确执行，而区块链上的共识节点不需要使用TEE。Ekiden与共识机制无关，只需要一个能够验证来自计算节点的远程认证的区块链。 为了解决TEE的可用性和网络安全限制，Ekiden支持链上检查和合约状态存储。 主要贡献 正式安全建模：使用一个理想的功能$F_{Ekiden}$来表达Ekiden的全部安全需求，在通用可组合性(UC)框架中概述安全性证明，表明Ekiden协议在并发组合下与$F_{Ekiden}$匹配； TEE-区块链结合方案：系统地列举了区块链和TEE融合产生的基本缺陷，并提供了克服这些缺陷的通用技术； 性能：区块链可能是TEE-区块链混合系统的性能瓶颈。论文提供了优化，在不降低安全性的情况下最小化区块链的使用。 2.背景 智能合约 智能合约系统的限制： 对每个节点都完全复制的智能合约进行链上计算很昂贵 传统的智能合约系统不提供隐私保护，用户由假名区别，但是假名只提供很弱的隐私保护 合约状态和用户输入必须是公开的，以便矿工验证正确的计算，缺乏隐私 可信硬件 SGX生成的认证是不可伪造的 单单SGX不能保证可用性（恶意主机可以任意终止Enclave或丢弃消息） SGX容易遭受侧信道攻击 3.TEE-区块链系统的技术挑战 容忍TEE故障 可用性故障 在SGX中，恶意主机可以终止Enclave，即使是诚实主机也可能在电源循环中丢失Enclave。TEE-区块链系统必须能够容忍这样的主机故障，确保崩溃的TEE可以延迟执行。 论文将TEE视为可消耗和可互换的，依赖区块链来解决并发性导致的任何冲突。为了确保任何特定的TEE很容易被替换，TEE是无状态的，并且任何持久状态都由区块链存储。 侧信道 为了对付SGX的侧信道攻击，论文采用的方法是在空间和时间上进行划分，针对强敌手模型设计Ekiden中的关键组件，如密钥管理器，允许攻击者打破一小部分TEE的机密性，并限制其他组件对密钥管理器的访问。另外还采用了主动密钥旋转来限制泄漏密钥的权限。 时钟故障 SGX的时钟不可信，一个TEE-区块链混合协议必须尽量减少对TEE时钟的依赖。 在论文的设计中，不需要TEE拥有当前区块链的状态。具体来说，不需要TEE来区分陈旧状态和当前状态，而依赖于区块链主动拒绝任何陈旧输入状态的更新。 PoW区块链的发布证明 为了利用区块链作为持久存储，TEE必须能够有效地验证一个项目已经存储在区块链中，同时TEE也需要能够验证新块。这就需要一个可信时钟来防止敌手隔离Enclave而提供一个无效的子链。 论文利用了TEE的保密性，这样延迟时钟响应的攻击者就不能阻止Enclave成功验证区块链内容。 TEE中的密钥管理 使用区块链持久化TEE状态的一个基本限制是缺乏保密性。通常可以通过在多个TEE中保存相同的密钥副本来实现密钥存储，虽然这种方法能很好地抵抗状态丢失，但是会造成更大的攻击面，在可用性和暴露风险之间需要权衡。 论文针对强敌手模型设计密钥管理器，允许攻击者打破一小部分TEE的机密性，并限制其他组件对密钥管理器的访问。 执行结果的原子性交付 通常，对于有状态的TEE-区块链协议，TEE的执行产生两个消息： $m_1$：向调用者发送输出结果 $m_2$：向区块链发送状态更新 这两个消息必须原子性交付，要么都交付成功，有一个交付失败则系统不可用：$m_1$ 在调用者收到时交付成功，$m_2$ 在区块链接受时交付成功，被拒绝的状态更新不是交付成功。 若不要求两个消息的原子性交付，可能产生的攻击有： 如果只有 $m_1$ 被交付，可能会产生倒回攻击，由于TEE不能判断输入状态是否为新状态，因此攻击者可以提供旧状态以从旧状态恢复TEE的执行，直到获得想要的结果（公平性）； 如果只有 $m_2$ 被交付，用户可能永久丢失输出，因为一般不可能根据更新后的状态来重新产生相同的输出 4.Ekiden概述 为了支持像信用评分这样的大规模隐私敏感应用程序，智能合约系统满足数据机密性保护以及高性能的同时要保持区块链提供的完整性和可用性。 Ekiden概述 Ekiden实现了用户自定义智能合约的安全执行环境，Ekiden合约是一个确定性的有状态程序。将合约程序的形式定义为 $(outp,st_{new}):=Contract(st_{old},inp)$ ，其中合约的输入是 $st_{old}$（前一个状态）和 $inp$（用户输入），生成输出 $outp$ 和新状态 $st_{new}$。 一旦部署在Ekiden上，智能合约就有了强大的保密性、完整性和可用性保证。在Ekiden中，有三种实体： 客户是智能合约的用户，在Ekiden中，客户可以通过秘密输入创建合同或执行现有的合同。无论哪种情况，客户机都将计算委托给计算节点； 计算节点在合约TEE中执行合约并且生成用于证明状态更新正确性的证明，从而处理客户的请求。一组计算节点组成一个密钥管理委员会，并运行一个分布式协议来管理合约TEE使用的密钥，合约TEE通过密钥管理委员会来创建或恢复密钥； 共识节点构成区块链，合约状态和认证都保存在这个区块链上。共识节点负责使用TEE检查状态更新的有效性。 工作流程 简单起见，假设客户拥有使用的计算节点的优先级列表，客户记为 $P$ ，计算节点记为 $Comp$。 合约创建 创建合约时，$P$ 将合约代码 $contract$ 发送给 $Comp$，$Comp$ 将 $Contract$ 加载到合约TEE中，合约TEE创建一个新鲜的合约id $cid$，从密钥管理委员会获取新鲜的 $(pk{in}_{cid},sk{in}{cid})$ 对和 $k{cid}^{state}$ 并生成加密的初始状态 $Enc(k^{state}{cid},\\vec{0})$ 和一个证明 $\\sigma{TEE}$（用于证明TEE初始化的正确性以及 $pk_{cid}^{in}$ 是对应于合约 $cid$ 的公钥）。 最后，$Comp$ 从认证服务获取 $\\sigma_{TEE}$ 的正确性证明，该证明和 $\\sigma_{TEE}$ 绑定到一个“certified”证明 $\\pi$ 中。$Comp$ 接着发送 $(Contract,pk{in}_{cid},Enc(k{state}_{cid},\\vec{0}),\\pi)$ 到共识节点。 合约创建的完整协议由Fig2的 $Prot_{Ekiden}$ 中的 create 表示。 请求执行 描述Fig1的过程： (1) 为了使用输入 $inp$ 来执行合约 $cid$ ，$P$ 首先从区块链获取与合约 $cid$ 相关联的 $pk_{cid}^{in}$ ，计算 $inp_{ct}=Enc(pk^{in}{cid},inp)$ ，并将消息 $(cid,inp{ct})$ 发送给 $Comp$ 。如 $Prot_{Ekiden}$ 的Line8-11所示。 (2) $Comp$ 从区块链取出合约代码，以及合约 $cid$ 的加密过去状态 $st_{ct}=Enc(k^{state}{cid},st{old})$ ，并将 $st_{ct}$ 和 $inp_{ct}$ 加载到TEE中执行。 如 $Prot_{Ekiden}$ 的Line30-33所示。 (3-4) 合约TEE从密钥管理委员会获取 $k_{cid}^{state}$ 和 $sk^{in}{cid}$ ，并使用它们解密 $st{ct}$ 和 $inp_{ct}$ 。从而生成输出 $outp$ ，一个新的加密状态 $st{'}_{ct}=Enc(k_{cid}{state},st_{new})$ 和一个用于证明计算正确的签名 $\\pi$ 。如 $Prot_{Ekiden}$ 的Line7-13所示。 (5a, 5b) 最后，$Comp$ 和 $P$ 执行一个原子交付协议，将 $outp$ 交付给 $P$ ，并将 $(st^{'}{ct},\\pi)$ 交付给共识节点。共识节点先验证 $\\pi$ 再接受新状态 $st^{'}{ct}$ 并将其存放在区块链上，只有在这之后，$P$ 才能接收到 $outp$ 。 Ekiden将请求执行与共识解耦。在以太坊中，请求执行被网络中的所有节点复制以达成共识，使得整个网络的速度和单个节点一样慢。而在Ekiden中，请求只被K个计算节点执行，K通常比较小，共识节点只需要验证K个正确执行的证明。 论文的实现中，使用签名 $\\pi$ 来作为TEE正确执行的证明。一个计算节点 $Comp$ 通过如下方式获得签名 $\\pi$ 。假设 $Comp$ 执行结果为一个输出 $st^{‘}{ct}$ 和一个证明 $\\sigma{TEE}$（对合约代码和 $st^{’}{ct}$ 的签名），$Comp$ 将 $\\sigma{TEE}$ 发送到IAS，IAS验证 $\\sigma_{TEE}$ 并回复 $\\pi=(b,\\sigma_{TEE},\\sigma_{IAS})$ ，其中 $b\\in{0,1}$ 表明 $\\sigma_{TEE}$ 的有效性，$\\sigma_{IAS}$ 是IAS对 $b$ 和 $\\sigma_{TEE}$ 的签名。然后 $\\pi$ 被提交到共识节点作为 $st^{'}_{ct}$ 正确性的证明。 Ekiden安全目标 正确执行：合约状态转换反映了合约代码在给定状态和输入上的正确执行； 一致性：在任何时候，区块链都存储与每个计算节点一致的单一状态转换序列； 保密：Ekiden保证合约状态和来自诚实客户的输入对所有其他各方保密，另外Ekiden也能抵御一些密钥管理TEE的背叛； 优雅的机密性降级：如果有计算节点违反机密性，Ekiden提供前向保密，并与受影响的TEE进行合理隔离。假设机密性违反发生在 $t$ ，攻击者最多能够获取 $t-\\Delta$ 的历史。 Ekiden不对合约级别的隐私泄露进行防御，如合约中的隐蔽信道、bug或侧信道。 假设和威胁模型 TEE 假设SGX是正确实现和安全制造的，但由于SGX存在侧信道攻击，假设敌手可以危及一小部分TEE的机密性。 区块链 Ekiden对底层共识协议不可知。假设区块链正确执行规定的计算，并且总是可用的。Ekiden依赖共识节点来进行认证，进一步假设区块链提供发布证明，可以证明区块链上包含一些内容。 威胁模型 系统中的各方都必须信任Ekiden和TEE 假设敌手可以控制除了一个计算节点之外的所有操作系统和网络堆栈，在受控节点上，敌手可以任意排序消息和调度进程 敌手可以操控任意数量的客户 客户不需要自己执行合约，也不需要可信硬件 诚实用户信任自己的代码和平台，但不相信其他客户 每个合约都有一个明确的策略来规定如何处理数据和服务请求 Ekiden不能防止合约有意或无意地通过软件漏洞泄露机密 5.Ekiden重要模块 发布证明 为permissionless的区块链提出发布证明协议： 发布证明是一种在验证者 $\\varepsilon$ 、合约TEE和不可信证明提供者 $P$ 之间的交互式证明。总的来说，只给 $P$ 有限的时间在足够困难的子链的块上发布消息，从而敌手很难伪造。 $\\varepsilon$ 存储最近的一个checkpoint块 $CB$，可以通过 $CB$ 计算难度系数 $\\delta(CB)$ ， $\\varepsilon$ 向任何请求客户发出 $CB$ 版本，使客户能够验证 $CB$ 的新鲜度。给定一个有效的最近的 $CB$ ， $\\varepsilon$ 可以通过 $\\delta(CB)$ 来验证新的块。为了方便分析，论文中的难度系数是恒定的。 为了初始化 $m$ 的发布，$\\varepsilon$ 获取时间戳 $t_1$ ， $\\varepsilon$ 可能需要经过一段延时才能收到 $t_1$ 。收到 $t_1$ 之后，$\\varepsilon$ 生成一个随机数 $r$ 并要求 $P$ 发布 $(m,r)$ 。$\\varepsilon$ 收到 $P$ 发送的证明 $\\pi_{(m,r)}$ 之后，获取时间戳 $t_2$ 。令 $n_c$ 为发布 $(m,r)$ 所需要的确认次数，$\\tau$ 为期望的块间隔时间（区块链中的定值），$\\epsilon$ 为一个乘法松弛因子，代表块产生的时间变化。例如，$\\epsilon=1.5$ 表示 $\\pi_{(m,r)}$ 的产生可以比预期在主链上的速度慢1.5倍。$\\varepsilon$ 只有当 $t_2-t_1&lt;n_c\\times\\tau\\times\\epsilon$ 时才接受 $\\pi_{(m,r)}$。 将 $\\epsilon$ 设置为一个大的值可以降低错误拒绝的概率（拒绝诚实用户 $P$ 的证明会导致区块链增长速度减慢），然而大的 $\\epsilon$ 值也会导致错误接受的概率增大。对于 $\\epsilon&gt;1$ ，需要一个足够大的 $n_c$ 来使成功攻击的概率可忽略，然而大的 $n_c$ 意味着诚实用户 $P$ 需要等待很长时间才能获得输出，影响用户体验。 例如，假设攻击者有25%的算力，设置 $n_c=80$ 以及 $\\epsilon=1.6$ 意味着攻击者需要预期2112次哈希才能伪造一个发布证明，而诚实的证明只有2-19的几率被拒绝。攻击者的伪造时间只有 $t_2-t_1$ ，而若 $\\varepsilon$ 经过一段延时才收到 $t_1$ ，则 $t_2-t_1$ 就更短，对攻击者不利。 一旦一条消息在一个TEE中发布，其他TEE可以通过经认证的安全信道获取该消息及其证明，从而节省重复协议的成本。 密钥管理 每个Ekiden合约都和一系列密钥相关联，包括一个用于状态加密的对称密钥和用于加密客户输入的密钥对。 敌手模型 假设敌手可以打破一定比例（$f%$）的TEE的机密性 假设参与主体有抵御女巫攻击的身份（交押金才能参与协议） 假设随时有足够多（$2f%$）的用户在线，从而密钥的可用性得到保证（通过经济奖惩来激励参与） 所需属性 由于解密密钥最终会暴露给合约TEE，而合约TEE本身也可能受到威胁，因此采用的密钥必须是短期的，来自暴露机会更低的的长期主密钥。密钥管理协议应满足的属性： 机密性：敌手无法窃取长期主密钥 可用性：诚实的合约TEE能获取解密密钥 前向保密：如果一个短期密钥被窃取，它不能用于解密早于 $t-\\Delta$ 时间的加密消息 初步准备 分布式密钥生成（DKG）：DKG协议允许N个团体生成随机密钥，DKG协议允许的结果是一个秘密，通过秘密共享方案在各方之间共享； 分布式伪随机函数（PRF）：PRF是函数 $F={f_s}{s\\in{S}}$ 的集合，并且对于随机索引 $s\\leftarrow$S$，$f_s(·)$ 于一个随机函数不能区分。 令 $G$ 是一个Schnorr group，$g$ 是一个生成器，$H:{0,1}^*\\rightarrow G$ 是一个哈希函数，则 $f_s(x)=H(x)^s$ 是PRF族。 假设 $s$ 被多方采用 $(k,n)$-秘密分享方案分享，为了评估 $f_s(x)$ ，团体 $i$ 计算并输出 $y_i=H(x)^{s_i}$ ，在收集了至少 $k+1$ 的 ${y_i}$ 之后，可以通过多项式插值得到 $f_s(x)$：$f(x)=H(x)S=H(x){\\sum_{i\\in A}{S_i\\lambda_i}}=\\prod_{i\\in A}{y_i^{\\lambda_i}}$ ，其中 $\\lambda_i$ 是拉格朗日系数 $\\lambda_i=\\prod_{j\\neq i}{\\frac{-i}{i-j}}$ 。 协议 密钥管理委员会和长期密钥：对于抵抗女巫攻击的身份，可以抽取N 个节点来形成密钥管理委员会（KMC），其中N是系统参数。初始化一个合约 $c$ 时，KMC运行DKG协议来生成一个长期密钥 $k_c$ ，从而 $k_c$ 通过 $(\\lceil fN\\rceil,N)$-秘密分享方案在KMC成员之间秘密分享。 生成短期密钥：假设短期密钥在每一轮都过期，为了在第 $t$ 轮获得合约 $c$ 的短期密钥，一个计算节点 $Comp$ 首先建立安全信道并与KMC成员认证身份。一旦验证了 $Comp$ 确实在执行 $c$ ，每个KMC成员 $i$ 计算 $k_{c,t,i}=H(t){k_ci}$ ，并将 $k_{c,t,i}$ 发送给 $Comp$ 。在从 $A\\subseteq$ KMC 收集了 $f+1$ 个结果之后，$Comp$ 可以生成第 $t$ 轮的短期密钥 $k_{c,t}=\\prod_{i\\in A}{k_{c,t,i}^{\\lambda_i}}$ ，其中 $\\lambda_i$ 是拉格朗日系数 。 违规隔离：通过为每个计算节点强制执行隐私预算，主动隔离违反机密性的行为。为此，假设每个合约TEE有不可伪造的身份，密钥管理节点为每个计算节点 $Comp$ 维护一个计数器 $K_{Comp}$ 来记录请求次数。计数器会随着轮次增加而清零。只有当 $K_{Comp}&lt;K$ 时密钥管理节点才满足计算节点的请求，其中 $K$ 是一个系统参数。这样，无论一个被破坏的计算节点产生多少个TEE，它最多只能获得 $K$ 个密钥。 原子性交付 假设TEE和调用客户 $P$ 之间有一个安全信道，通过以下协议实现 $m_1$ 和 $m_2$ 的原子交付： TEE从密钥管理器获取新鲜的密钥 $k$ ，并将加密的认证消息 $m_1^c=Enc(k,m_1)$ 发送给 $P$ ; 一旦 $P$ 确认收到 $m_1^c$ ，TEE将 $m_2$ 发送给区块链； TEE得到 $m_2$ 的发布证明 $\\pi_{m_2}$ 之后，将 $k$ 发送给 $P$。 6.协议细节和安全证明 $Prot_{Ekiden}$ 的目的是实现一个通用可组合性(UC)理想功能 $F_{Ekiden}$ 。 初步准备和符号说明 认证执行 使用 $G_{att}$ 正式定义可信硬件上经过验证的执行。一个party首先将程序 $prog$ 通过 install 消息加载进TEE中，通过 resume 调用，程序根据给定输入运行，生成输出 $outp$ 以及一个硬件密钥 $sk_{TEE}$ 下的签名认证 $\\sigma_{TEE}=\\sum_{TEE}.Sig(sk_{TEE},(prog,outp))$ ，其中 $sk_{TEE}$ 可以通过 $G_{att}.getpk()$ 获取。 如果一个TEE程序产生一对输出 $(outp_1,outp_2)$ ，认证只对 $outp_1$ 签名，即 $\\sigma_{TEE}=\\sum_{TEE}.Sig(sk_{TEE},(prog,outp_1))$ ，在 $outp_1$ 中包含 $outp_2$ 的哈希。 使用合约包装器来抽象例行常用功能，如状态加密，密钥管理等。被包装器扩充的合约 $c$ 称为 $\\widehat{c}$ 。 区块链 $F_{blockchain}[succ]$ 定义了区块链，参数 $succ$ 指定添加到存储中的新item的条件，对交易有效性的概念进行建模。 除了读写接口，$F_{blockchain}$ 提供了一个接口使得客户可以确定一个item是否包含在区块链内，这个接口避免了提前下载整个区块链。 参数化 $F_{blockchain}$ 在Ekiden中，存储的内容被解析为状态转换的有序数组，定义为 $trans_i=(H(st_{i-1}),st_i,\\sigma_i)$ ，包含之前状态的哈希，新状态和对状态转换的正确性的TEE证明。存储可以被解释为一种特殊的初始状态，随后是一系列状态转换：$Storage=((Contract,st_0,\\sigma_0),{trans_i}_{i\\geq1})$ 。 状态转换必须扩展最新的状态，并且认证经过验证，它才是有效的。有效性验证是通过使用函数 $succ(·,·)$ 参数化 $F_{blockchain}$ 来实现的：当且仅当 $h=H(st_{old})$ 其中 $st_{old}$ 是 $Storage$ 中的最新状态，同时满足 $\\sum_{TEE}.Vf(pk_{TEE},\\sigma_{TEE},(h,st_{new}))$ 时，$succ(Storage,(h,st_{new},\\sigma_{TEE}))=true$ 。这保证了状态转换链不会分叉。 协议的正式规范 $Prot_{Ekiden}$ 是Ekiden协议的正式规范，依赖 $G_{att}$ 和 $F_{blockchain}$ 作为认证执行和区块链的理想功能。$Prot_{Ekiden}$ 使用电子签名方案 $\\sum(KGen,Sig,Vf)$ ，对称加密方案 $S\\varepsilon(KGen,Enc,Dec)$ 以及非对称加密方案 $A\\varepsilon(KGen,Enc,Dec)$。 状态密钥分享 每个合约都和一系列密钥绑定，合约TEE将管理密钥的工作委托给密钥管理TEE。在 $Prot_{Ekiden}$ 中，密钥管理的通信由 $keyManager$ 函数进行抽象。 合约创建 创建Ekiden中的合约时，客户 $P_i$ 输入合约代码 $Contract$ ，并调用计算节点 $Comp$ 的 create 子程序。$Comp$ 将 $\\widehat{Contract}$ 加载进TEE中，并调用 create 进行初始化。如Fig9所示，合约TEE创建一个新鲜的合约 $cid$ ，从密钥管理器获得新鲜的 $(pk_{cid}{in},sk{in}{cid})$ 和 $k{cid}^{state}$ ，并生成加密初始状态 $st_0$ 和一个证明 $\\sigma_{TEE}$ ，$\\sigma_{TEE}$ 证明了 $st_0$ 被正确初始化以及 $pk_{cid}^{in}$ 是合约 $cid$ 的对应公钥。计算节点 $Comp$ 将 $(Contract,cid,st_0,pk_{cid}^{in},\\sigma_{TEE})$ 发送到 $F_{blockchain}$ 并等待回复。$Comp$ 将合约 $cid$ 返回给 $P_i$ ，然后 $P_i$ 验证合约 $cid$ 确实存储在 $F_{blockchain}$ 上。 请求执行 为了执行合约 $cid$ ，客户 $P_i$ 首先从 $F_{blockchain}$ 获得输入加密密钥 $pk_{cid}^{in}$ 。然后 $P_i$ 输入 $(cid,inp_{ct})$ 其中 $inp_{ct}$ 是经过 $pk^{in}{cid}$ 加密和经过 $spk_i$ 认证的 $P_i$ 的输入，并调用 $Comp$ 的 request 子程序。$Comp$ 从 $F{blockchain}$ 获取加密的之前状态 $st_{ct}$ ，并使用 $\\widehat{Contract}$ 代码和输入 $(cid,inp_{ct},st_{ct})$ 启动一个合约TEE。 如Fig9所示，如果 $\\sigma_{P_i}$ 验证通过，合约TEE使用从密钥管理器获得的密钥解密 $st_{ct}$ 和 $inp_{ct}$ ，并且执行合约 $Contract$ 得到结果 $(st_{new},outp)$ 。为了确保新状态和输出的原子性交付，$Comp$ 和 $P_i$ 执行第5章中描述的原子交付协议： 首先合约TEE计算 $outp_{ct}=Enc(k^{out}{cid},outp)$ 以及 $st{ct}{'}=Enc(k{state}{cid},st{new})$ ，并且通过 $epk_i$ 建立的安全信道发送两个结果的认证给 $P_i$ ； $P_i$ 通过调用 $Comp$ 的 claim-output 子程序来确认接收，该子程序使得合约TEE发送 $m_1=(st_{ct}^{'},outp_{ct},\\sigma)$ 到 $F_{blockchain}$ 。$\\sigma$ 保护 $m_1$ 的完整性，并以加密方式将新状态和输出绑定到以前的状态和输入，从而恶意的 $Comp$ 无法篡改它； 一旦 $m_1$ 被 $F_{blockchain}$ 接受，合约TEE通过安全信道将解密后的 $outp_{ct}$ 发送给 $P_i$ 。 $Prot_{Ekiden}$ 的安全 定理1的证明在附录B 定理1（$Prot_{Ekiden}$ 的安全性）： 假设 $G_{att}$ 的认证方案 $\\sum_{TEE}$ 和数字签名 $\\sum$ 在选择消息攻击（EU-CMA）下不可伪造，$H$ 是弱抗碰撞性的，$A\\varepsilon$ 和 $S\\varepsilon$ 是IND-CPA安全的。则 $Prot_{Ekiden}$ 在 $(G_{att}, F_{blockchain})$-结合模型中安全地实现了对静态敌手的 $F_{Ediden}$ 。 减轻应用程序级别泄露 Ekiden通过启用持久化的应用程序状态来减少应用程序级的隐私泄露（由于智能合约编写的问题导致的隐私泄露等）。 7.实现 使用Rust SGX SDK实现了一个编译器，它可以自动将合约构建为可执行文件，并加载到计算节点中。 Ekiden与许多现有的区块链兼容。 应用 机器学习合约 为了演示对秘密数据的共享学习，论文实现了两个示例合约： 基于财务记录的信用评分 根据医疗记录预测心脏病的可能性 提供给这些示例合约的训练数据被视为敏感数据，不会在合约外作为明文公开。 智能建筑热力学模型 论文移植了一个非线性最小二乘的实现，用于基于智能建筑提供的时间序列热力学数据来预测温度。Ekiden允许合约运行其模型，同时对传感器数据和模型保密，这表明Ekiden对高度交互的工作负载具有足够的响应能力。 代币 最流行的以太坊合约是ERC20代币标准。论文实现了一个直接用Rust编写的代币合约，Ekiden会自动提供隐私和匿名性，而这是智能合约在以太坊主网上无法实现的。代币中每个用户的帐户余额是保密的。 扑克 论文实现了一个扑克合约，其中用户轮流向合约提交他们的行动，智能合约包含了洗牌和(有选择地)显示牌的所有游戏逻辑。扑克是区块链系统和安全多方计算的通用基准测试应用程序。Ekiden在每次行动后都将保存状态到区块链，并且可以从任何Enclave访问，所以如果玩家中止行动，秘密纸牌仍然能够被显示出来。 加密猫 加密猫是一款以太坊游戏，允许用户繁殖虚拟猫，虚拟猫以ERC721代币的形式存储在链上。每只猫都有一组独特的基因，这些基因决定了它的外观和价值。后代的特征是由一个混合了父母基因的智能合约决定的。基因混合合约的源代码并不公开：游戏开发者的目标是让繁殖过程变得不可预测。 论文从以太坊区块链获取了基因混合合约的字节码，并使用Ekiden EVM端口执行。论文通过从以太坊网络复制真实交易来验证正确性。这个例子展示了Ekiden可以执行以太坊合约，即使源代码不可用。 加密猫的基因混合算法经过了逆向工程，这使得玩家能够优化自己繁殖出具有罕见特征的猫的机会，从而破坏游戏的生态系统。相比之下，Ekiden合约可以访问硬件中的随机性来源，并允许加密存储游戏算法。 Origin Origin是一个在以太坊之上建立在线市场平台，论文移植了一个demo，允许用户使用Ether列出和购买道具。该应用进一步证明了以太坊的开发框架可以很容易地被Ekiden使用：在demo中使用的智能合约无需修改。基于Ekiden，区块链中的用户交易历史保持隐私，交易确认速度比以太坊更快。 8.评估 与以太坊主网上的ERC20合约相比，Ekiden-BT可以支持吞吐量提高600倍、延迟降低400倍、货币成本降低1000倍的代币合约。虽然论文预计在使用更大规模区块链部署时，会出现一些轻微的性能下降，但性能优化显著降低了区块链速度的影响。 此外，论文证明Ekiden可以有效地支持计算密集型工作，如机器学习应用程序，这在以太坊上是成本高昂的。 端到端延迟 吞吐量 共识对吞吐量的影响 to be continued","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"},{"name":"Formal Model","slug":"Formal-Model","permalink":"http://example.com/categories/Formal-Model/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"论文阅读-Hawk.The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts","slug":"paper-hawk","date":"2021-06-05T16:00:00.000Z","updated":"2021-06-13T09:29:14.000Z","comments":true,"path":"2021/06/06/paper-hawk/","link":"","permalink":"http://example.com/2021/06/06/paper-hawk/","excerpt":"论文 Hawk.The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts阅读笔记","text":"1.引入 区块链上的可信时钟的存在对于协议中实现公平交易至关重要：恶意用户可能会过早地中止协议以避免资金支付，但是有了可信时钟，过早地中止协议会被判定为超时，这样区块链就可以将恶意用户的抵押存款重新分配给诚实用户，以此来惩罚恶意用户。 尽管区块链和智能合约具有表现力和强大功能，但这些技术目前缺乏交易隐私：尽管各方可以创建匿名公钥以增加其匿名性，但每个匿名公钥的所有交易和余额都是公开可见的。缺乏隐私是去中心化智能合约广泛应用的主要障碍，因为一些金融交易，如保险合同或股票交易，被许多个人和组织视为高度机密。 Hawk概览 Hawk编译器负责将程序编译成区块链和用户之间的加密协议，一个Hawk程序包括两个部分： 隐私部分 $\\phi_{priv}$ ： 用于接收各方的输入数据和货币等，并执行计算来分配收益。$\\phi_{priv}$用于保护参与者的数据和资金交换； 公开部分 $\\phi_{pub}$ ：不涉及隐私数据和资金的部分。 Hawk编译器把Hawk程序编译成以下几个部分，这些部分共同定义了用户、管理员和区块链之间的加密协议： 被所有共识节点执行的区块链程序 由用户执行的程序 由管理员（一个特别协助方）执行的程序 安全保证 链上隐私：只有合约双方自愿公开信息，区块链才会将交易隐私向公众公布，$\\phi_{priv}$以加密形式展现在公众眼前。非正式地讲，链上隐私的实现通过向区块链发送“加密”信息，并依靠零知识证明来确保合同执行和资金保存的正确性。 合约安全：保护同一合约协议中的各方互不侵犯，不仅包括机密性和真实性等密码学概念，还包括存在欺骗和中止行为时的公平交易 最低限度信任管理员 Hawk合约的执行由管理员推动，管理员可以看到用户的输入，并被信任不会泄露用户的隐私数据。 管理员不是可信第三方：即使管理员可以任意偏离协议或与当事人串通，管理员也不能影响合约的正确执行，如果管理员中止了协议，就会受到经济上的惩罚，而用户则会得到相应的补偿； 管理人员不需要被信任来维护基础货币的安全性或隐私，如防止双花攻击等； 如果多个合约实例同时运行，则每个合约可以指定不同的管理员，而恶意管理员只会影响该实例； 可以用可信计算硬件实例化管理员，或使用用户自己之间的多方计算代替。 实例：密封拍卖 该实例用于实现一个密封的、第二价格的拍卖，其中出价最高的竞标者获胜，但支付第二高的价格，且竞标者在不知道其他人的出价的情况下提交出价。 该实例中$\\phi_{priv}$决定中标者和支付金额；$\\phi_{pub}$使用公共存款来防止管理员通过中止协议来损害竞标者利益。 合约的安全需求 前提： Hawk的安全建立在区块链本身的安全特性上：假设区块链的共识协议在对手不拥有大量计算能力的情况下是安全的； 在Hawk中，为了减少链上执行代码产生的费用，设计的协议在链下执行大部分计算 安全需求： 独立隐私输入：各用户在提交自己的投注资金之前无法查看其他用户的投注金额，即使与恶意管理员串通也无法查看； 交易后隐私保护：只要管理员不公布信息，即使在拍卖之后各用户的出价也不会公布； 公平交易：拍卖参与者可能试图提早退出协议，以避免付款或影响资金再分配。如果一方中止或拍卖管理员中止，中止方将受到经济惩罚，而其余方则获得补偿。Hawk在特定超时后强制执行退款； 防范不诚实管理员：除了中止协议外，不诚实的管理员不能影响拍卖结果和资金再分配。对于中止协议的管理员，对其进行罚款。 中止和超时 该实例定义了三种超时 $T_1&lt;T_2&lt;T_3$： $T_1$：Hawk合约在$T_1$之后停止招标； $T_2$：所有用户都需要在$T_2$内向管理员公布自己的出价，否则将视作0； $T_3$：如果管理员中止协议，用户可以在$T_3$后收回投标资金。 $\\phi_{pub}$实现额外的激励机制，本实例中如果管理员提前中止拍卖，将重新分配管理员的公共存款。 本文贡献 Hawk是第一个在去中心化加密货币系统中同时提供隐私交易和可编程性的系统： 去中心化智能合约的正式模型：针对密码学的区块链模型，提出了一种形式化的通用可组合性(UC)模型，这种形式模型是独立的，并且在区块链模型中定义协议的安全性时通常是有用的； 新的加密套件：实现了一个新的加密套件，它将私有事务与可编程逻辑绑定在一起，包含三个基本原语 freeze，compute 和 finalize ： freeze原语允许各方提交正常数据以及货币，提交的货币在合约中冻结，支付分配在之后由$\\phi_{priv}$确定； compute的过程中，各方将提交的数据和货币向管理员公开，以便管理员计算$\\phi_{priv}$函数，根据$\\phi_{priv}$的结果，管理员构造新的私有货币支付给各用户。然后，管理员向区块链提交新的私有货币以及它们的零知识证明。此时之前冻结的货币在用户中重新分配。 实现和评估：创建Hawk原型，实现一些应用来评估性能。提出协议优化，得到10倍性能。在约有100个参与方时，管理员使用四核进行密码计算（协议中最昂贵的部分），时间在2.85分钟内；所有的链上计算（由矿工执行）都十分便宜，都在20毫秒以内。 2.密码学的区块链模型 区块链模型 区块链在正确性和可用性方面受到信任，但在隐私方面不受信任。区块链不仅维护一个存储每个假名账户余额的全局账本，而且还执行用户定义的程序。论文给出了区块链的通用模型，可以运行任意图灵完备程序： 区块链的时钟是离散的，每一轮用 round 或 epoch 表示 所有链上用户都可以观察到区块链的状态，包括公共账本和任何用户定义的程序 发送到区块链的消息将在下一轮开始时到达。在同一轮中，敌手可以任意重新排序发送到区块链的消息，但不能丢弃消息，然而敌手可以在链下丢弃各方之间传递的消息。这意味着敌手可能会尝试抢先攻击（例如当观察到一个诚实用户正在交易一只股票时，对手会通过发送交易同一只股票的竞争交易来抢占先机） 用户在区块链上可以创建任意多的假名账户 假设区块链将正确执行任何规定好的计算 区块链正式建模 论文提供了正式的、精确的功能规范和安全性规范，并且设计的协议在通用可组合性(UC)框架下正式证明是安全的。 建模的程序分为理想程序（记为$IdealP$）、区块链程序（记为$B$）和用户/管理员程序（记为$UserP$）。同时论文定义包装器来将伪代码程序转换为UC框架下的程序： 理想包装器$F(·)$将理想程序$IdealP$转换为理想函数$F(IdealP)$ 区块链包装器$G(·)$将区块链程序$B$转换为区块链函数$G(B)$，可以延迟区块链上的消息在下一轮开始到达 协议包装器$\\Pi(·)$将用户/管理员程序$UserP$转换为用户端或管理员端的协议$\\Pi(UserP)$ 包装器还实现了智能合约应用的一些共同特征，包括时间、公共账本、假名和敌手对消息重新排序，这样就不需要为每个区块链应用重复这些符号。 正式UC建模及证明 附录B 编程约定 Timer激活点：理想函数包装器$F(·)$和区块链包装器$G(·)$实现了逐轮递增的时钟，并且每次时钟增加，包装器就会调用Timer激活点。因此理想程序和区块链程序可以定义Timer激活点来实现超时操作； 理想程序中的延迟处理：在灰色背景中编写的程序指令表示的是不会立即进行的计算，而是推迟到下一轮开始时执行。这是一种简写，因为在实际协议中，区块链函数完成的任何计算都将被延迟； 假名：在理想程序、区块链程序和用户端程序中出现的所有表示用户的标识符默认情况下都指假名； 账本和转账：$符号仅用于可读性（用于区分与货币相关的变量和其他变量），并没有特殊含义。 3.密码学抽象 论文使用理想程序的形式来描述密码学抽象。Hawk实现了以下规范： 私人账本和转账：定义理想程序$IdealP_{cash}$来描述私人账本的需求； Hawk-specific原语：定义 freeze、compute 和 finalize 三种Hawk-specific原语来同时满足交易隐私性和可编程性。 隐私资金规范$IdealP_{cash}$ Mint mint 操作允许用户 $P$ 将资金从他的公共总账 $ledger[P]$ 转移到私有货币池 $Coins[P]$ ，每次转账后用户 $P$ 的私有货币被创建，并与一个值 $val$ 关联。 为保证安全性，$IdealP_{cash}$ 在用户 $P$ 创建私有货币之前检查他的公共总账 $ledger[P]$ 中的余额是否足够。 Pour pour 操作允许用户 $P$ 私下在其私人货币池花钱。简单起见，采用两种输入货币和两种输出货币来模拟货币交换。 为保证安全性，$IdealP_{cash}$ 会检查： 对于两种输入货币，用户 $P$ 确实拥有其声明的量那么多的私有货币 两种输入货币的总价值和两种输出货币的总价值相等 隐私 当诚实用户 $P$ 执行 mint 操作时，敌手 $A$ 能获得 $(P, val)$。对于公共货币池的任何操作都会被敌手 $A$ 获得。 当诚实用户 $P$ 执行 pour 操作时，敌手 $A$ 只能获得动态生成的输出假名 $P_1$ 和 $P_2$ ，而不知道哪种在私人池的货币被花了，也不知道花钱的人是谁。如果恶意用户是 pour 操作的接收方，那他会额外获得货币的金额。 额外的微妙之处 诚实用户会跟踪一个装有不同货币的钱包，每当诚实用户执行 pour 操作时，首先会检查本地钱包中是否有相同的货币，如果有，会立即将货币从钱包中取出，通过这种方式，如果诚实用户在一轮中进行了多次 pour 操作，将为每次 pour 操作选择不同的货币； 诚实用户在下一轮之前是不能花掉同一轮中自己获得的货币的，但是恶意用户可以（因为任何消息都立即被敌手获得，敌手也可以为区块链在同一轮中收到的所有消息选择排序方式） 诚实用户总会 pour 给存在的假名，但敌手可以 pour 给不存在的假名 $\\bot$ ，这种情况下私人货币实际上进入了一个黑洞，并且无法取回。 Hawk规范$IdealP_{Hawk}$ Freeze 用户 $P$ 从私有货币池 $Coins$ 中移除一种货币，并将其添加到 $FrozenCoins$ 中进行冻结，用户的私有输入 $in$ 也会记录在 $FrozenCoins$ 中。$IdealP_{Hawk}$ 检查 $P$ 之前没有调用过 freeze，并且货币 $(P, val)$ 存在在 $Coins$ 中。 Compute 用户 $P$ 调用 compute​ 时，其私有输入 $in$ 和冻结的货币 $val$ 将公开给管理员 $P_M$ Finalize 管理员 $P_M$ 提交一个公共输入 $in_M$ 到 $IdealP_{Hawk}$ ，$IdealP_{Hawk}$ 根据所有用户的输入和冻结的货币价值计算 $\\phi_{priv}$ 的结果，并根据这个结果重新分配 $FrozenCoins$ 。为了保证安全，$IdealP_{Hawk}$ 检查冻结货币的总价值等于输出货币的总价值。 与公共合约交互 $IdealP_{Hawk}$ 的功能由公共Hawk合约 $\\phi_{pub}$ 参数化，在 finalize 过程中，$IdealP_{Hawk}$ 调用 $\\phi_{pub}.check$ 。$\\phi_{pub}$ 的作用如下： 检查管理员的输入 $in_M$ 的格式是否正确 重新分配公共存款：如果用户或管理员提前中止协议，或者用户提供了无效的资金投入（例如少于最低赌注），$\\phi_{pub}$ 可以重新分配用户的公开存款 安全和隐私需求 当诚实用户 $P$ freeze 冻结一笔金额时，敌手不能看到该金额，但能看到诚实用户的假名 $P$ 。这不会损害诚实用户的隐私，因为他可以随时创建新的假名； 当诚实用户调用 compute 时，只有管理员 $P_M$ 能看到用户的输入 和冻结的金额，其他用户不能看到； 在 finalize 操作期间，输出 $out$ 会公开该所有用户，如果不希望公开，$out$ 可以为空。 时间和中止 freeze 操作在 $T_1$ 内完成，$compute$ 操作在 $T_2$ 内完成，如果用户冻结了货币但是在 $T_2$ 内没有公布，则这些冻结的货币会丢失，即 $(in_i, val_i):=(0, \\bot)$ 简化的假设 论文实现的协议不支持管理员中止协议时冻结货币的退款 假设参与合约的假名集和超时 $T_1, T_2$ 硬编码在程序中 4.加密协议 协议分为两部分： 隐私资金转移 区块链程序 $Blockchain_{cash}$ 维护一系列私有货币 $Coins$ ，每一种货币的形式为 $(P, coin:=Comm_s($val))$ ，其中 $P$ 是用户假名，$coin$ 是根据随机数 $s$ 生成的货币值 $$val$ 的承诺。 在 pour 操作期间，用户 $P$ 选择两种 $Coins$ 中的货币来花费，分别为 $(P, coin_1)$ 和 $(P, coin_2)$ 。pour 操作将 $val^{‘}_1$ 和 $val^{’}_2$ 分别付给两个输出假名 $P_1$ 和 $P_2$ ，并且保证 $val_1+val_2=val{'}_1+val{‘}2$ 。支付用户选择新的随机数 $s_i^{'}(i\\in{1,2})$ 并计算输出货币 $(P_i,coin_i:=Comm{s{'}_i}($val_i{’}))$ ，支付用户将 $s_i^{‘}$ 和 $val_i^{’}$ 发送给收款用户 $P_i$ 。发送者计算一个零知识证明来证明输出的货币是适当构造的，其中正确性涉及以下方面： 货币的存在性：$(P, coin_1)$ 和 $(P, coin_2)$ 确实是私有货币池 $Coins$ 的一部分，这里使用零知识证明可以确保支付用户隐藏其花费的货币种类。为了提高效率，$Blockchain_{cash}$ 维护一个 $Coins$ 的Merkle树 $MT$ 来证明货币的存在性； 不会双重支付：每一个货币 $(P, coin)$ 都有一个唯一的序列号 $sn$ ，在 pour 货币时，必须提供货币的 $sn$ 以及其零知识证明来证明 $sn$ 的正确性，$Blockchain_{cash}$ 确保 $sn$ 不会被用两次； 保护金额：零知识证明确保输入的货币和输出的货币的总价值相等。 当诚实用户向诚实用户 pour 时，敌手 $A$ 不会知道承诺方案 $Comm$ 隐藏的输出货币的值，敌手 $A$ 可以看到接收两种输出货币的用户假名； 当不诚实用户 $P^$ 向诚实用户 $P$ pour 时，尽管敌手知道 $coin$ 公开，然而一旦交易在$Blockchain_{cash}$生效，敌手就不能使用 $(P,coin)$，因为 $P^$ 不知道 $P$ 的密钥。 PRF：伪随机函数 ENC：加密 DEC：解密 同时实现隐私和可编程逻辑 Freeze freeze 操作不直接向用户支出，而是将资金以及附带的隐私输入提交给智能合约，这是使用类似pour​的协议完成的： 用户 $P$ 选择一个私有货币 $(P,coin)\\in Coins$，其中 $coin:=Comm_s($val)$。$P$使用自己的密钥计算 $coin$ 的序列号 $sn$ 并公开，用于防止双重支付； 用户 $P$ 计算承诺 $(val||in||k)$ ，其中 $in$ 是用户输入，$k$ 是一个对称加密密钥（用于实际优化）； 用户 $P$ 进行零知识证明，类似 pour 操作。 Compute compute 操作在链下计算 ${val_i^{‘}}_{i\\in[n]}$以及进行正确性证明。Hawk依赖管理员 $P_M$ 来进行计算，所有用户将自己的输入经过管理员的公钥加密后发送给管理员：$ct:=ENC(P_M.epk,r,($val||in||k||s^{’}))$ ，其中 $ct$ 是密文， $P_M.epk$ 是管理员的公钥。 在获取用户的公开信息后，管理员通过私有合约 $\\phi_{priv}$ 计算 ${val_i^{'}}_{i\\in[n]}$ 以及公开输出 $out$。管理员同时也会构建一个零知识证明来证明结果。 Finalize 管理员提交$\\phi_{priv}$的结果以及零知识证明到$Blockchain_{cash}$之后，$Blockchain_{cash}$验证证明并重新分配冻结的资金，与此同时还将管理员的公开输入 $in_M$ 和公开输出 $out$ 发送给公开Hawk合约 $\\phi_{pub}$。 定理1 假设Merkle树使用的哈希算法是抗碰撞的，承诺方案 $Comm$ 是 perfectly binding 和计算隐藏的，零知识证明的NIZK方案满足零知识需求，加密方案ENC和SENC是正确并且安全的，PRF方案是安全的，则协议 $UserP_{cash}$ 和 $UserP_{hawk}$ 安全地模拟了静态模型中抵抗恶意对手的理想功能$F(IdealP_{hawk})$ 。 证明在文献[37]: A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. http://ia.cr/2015/675. 扩展和讨论 使用可信硬件实例化管理员 使用可信硬件SGX实例化管理员从而在安全秘密地进行链下计算。但是任何不与区块链交互的链下协议都不能在中止的情况下提供公平交易——即使使用了可信硬件。 5.在UC协议中采用SNARKS以及实际优化 在UC协议中采用SNARKS 简洁非交互式知识论证（Succinct Non-interactive ARguments of Knowledge）对一般计算任务进行了简洁的证明，并已在多个系统中实现。 论文的UC协议实现采用高效的SNARK-lifting转换。 实际考虑 高效SNARK电路 一个SNARK证明器的性能主要取决于代数电路中乘法门的数量，为了更高效，论文通过两种方式设计优化电路： 使用SNARK友好的密码原语 构建定制的电路生成器来友好地实现SNARK，而不是依赖编译器来编译更高级别的实现 Hawk中在主要的密码学构造块包括：针对Merkle树的抗碰撞哈希函数、伪随机函数、承诺和加密。在实现中，模数q被设置为底层SNARK实现的254位素数，维数d在80位的安全级别下设置为3，在112位的安全级别下设置为4。 更多性能优化略。。。 6.实现和评估 略","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"},{"name":"Formal Model","slug":"Formal-Model","permalink":"http://example.com/categories/Formal-Model/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"Substrate入门","slug":"substrate入门","date":"2021-04-14T16:00:00.000Z","updated":"2021-04-16T06:54:03.229Z","comments":true,"path":"2021/04/15/substrate入门/","link":"","permalink":"http://example.com/2021/04/15/substrate%E5%85%A5%E9%97%A8/","excerpt":"Substrate框架入门","text":"Start 架构 substrate客户端的基本构成： 存储(storage)：存储区块链的状态，使用简单而高效的键值对存储机制 运行时(Runtime)：定义处理块的逻辑，包括状态转换逻辑。运行时代码的编译方式有两种： 编译为wasm并且存储在区块链上（使得forkless运行时升级成为可能） 使用本机运行时编译为客户端的本机代码 点对点网络(peer-to-peer network)：使用rust的 libp2p 实现 共识(consensus)：substrate可以定制共识引擎，也提供一些建立在Web3 Foundation研究之上的共识机制 RPC(remote procedure call)：使区块链用户可以与网络交互，substrate提供HTTP和WebSocket RPC服务器 Telemetry：由嵌入式Prometheus服务器公开的客户端度量 基本概念 Extrinsics extrinsic指来自链外的信息，并且会被纳入区块中。分为三类： inherents 签名交易 无签名交易 **注：**执行函数时触发的事件不属于extrinsic 区块结构 substrate的每一个区块都是由一个区块头和一组extrinsic组成的，区块头包含区块高度、父区块哈希值、extrinsic根哈希值、链上状态根哈希值，以及摘要等信息。 Extrinsics 被打包到当前区块中并会被执行，每个extrinsic都在runtime进行了定义。 Extrinsic根哈希值主要有两个用途： 它可以在区块头构建和分发完成之后，防止任何人对该区块头中所含extrinsic内容进行篡改 它提供了一种方法，在只有区块头信息的条件下，可以帮助轻客户端快速地验证某一区块中存在某笔交易 Inherents Inherent指的是那些仅能由区块创建者插入到区块当中的无签名信息，他们不会在网络上传播或存储在交易队列中 只要足够多的区块验证人认可该Inherent的合理性，那么这条Inherent就是有效的 签名交易 签名交易包含了签发该交易的账户私钥签名，这意味着此账户同意承担相应的区块打包费用 由于签名交易打包上链的费用在交易执行前就可以被识别，所以在网络节点中传播此类交易造成信息泛滥的风险很小 无签名交易 无签名交易意味着无人支付交易费用，这使得交易队列无法用有效的手段来防止其被滥用 无签名交易里缺失nonce字段来辅助识别交易执行顺序，从而难以防止重放攻击 少数交易能够安全使用不具签名的形式，前提是它们需要提供 SignedExtension 的自定义实现，来防止垃圾交易 Signed Extension SignedExtension 是一个trait ，通过它可以使用额外的数据或逻辑来扩展交易 在交易执行之前，任何时候需要获取某笔特定交易信息时，都可以使用 SignedExtension 来实现。 因此SignedExtension 在交易队列中被大量使用 Runtime会使用 SignedExtension 提供的一些数据，比如用来计算可调用函数Call的交易费用 SignedExtension 还包含一个名为AdditionalSigned的字段，这个字段可存放任意可编码数据，因而能够在打包或者发送交易之前，被用来执行自定义逻辑 为了避免将可能失败的交易打包进区块中，交易队列还会定期调用 SignedExtension 的函数来验证即将进入区块的交易 SignedExtension 也可以用于验证无签名交易：通过实现*_unsigned 的一系列方法，来封装信息核验、防垃圾信息和重放保护等逻辑，供交易池使用 交易池 交易池包含所有在网络广播的，已被本地节点接收和验证的交易（签名和未签名的） 有效性 交易池检查交易是否有效（由Runtime决定）： 检查交易索引 (nonce) 是否正确 检查帐户是否有足够的资金来支付相关费用 检查签名是否有效 交易池还定期检查池内现有交易的有效性： 如果发现无效或过期的普通交易，该交易将被交易池删除 排序 如果交易是有效的，交易队列会将交易分为两组： 就绪队列：包含所有可放到新的待处理区块中的交易。 对于随 FRAME 构建的 Runtime，所有交易必须严格遵循就绪队列中的顺序 未来队列：包含所有可能在未来变成有效的交易。例如，一个交易可能有一个对其账户来说过高的 nonce 值，此交易将在未来队列中等待，直到之前的交易上传至区块链上 交易依赖关系 ValidTransaction 结构体定义了 requires 、 provides 和 priority 参数来构建交易的依赖关系。 这个依赖关系允许交易池产生有效线性顺序的交易 对于用 FRAME 构建的 Runtime，节点基于不同账户对交易进行排序。 所有签名交易都需要包含一个交易索引 (nonce)，该索引值在每次进行新的交易时都会递增1 FRAME 交易包括一个 provides 标签（值为 encode(sender ++ nonce) ），和 requires 标签（值为 encode(sender ++ (nonce -1)) if nonce &gt; 1 ）。来自单一发送人的所有交易将形成一个序列。 交易优先级 ValidTransaction 结构体中的 priority 决定了就绪队列中的交易顺序，priority 定义了当一个交易可解锁多个依赖交易时，所应有的线性排序 当某个节点成为下一个区块生成者时，它将在下一个区块把交易按优先级别从高到低排序，直到达到区块的长度限制 对于用 FRAME 构建的 Runtime，priority 定义为交易要支付的 fee (费用)。 例如： 如果我们从不同的发送者那里收到 2 个交易（而且 nonce=0 时），我们通过 priority 来确定哪个交易更为重要，并优先把它打包进区块中 如果我们从同一个发送方收到 2 个相同 nonce 的交易，那么只会有一个交易会被打包到链上。 我们使用 priority 来选择 fee 较高的交易，并把它储存到交易池中。 注意：交易池并不知道费用、账户、或签名，它只处理交易的有效性和 priority、requires 和 provides 参数这些抽象概念。 所有其他详细信息都是由 Runtime 通过 validate_transaction 函数定义的。 交易的流程 交易可以遵循两条路径： 我们的节点生成的区块 我们的节点会监听网络上的交易 每一笔交易都要经过验证，而有效的交易会被放入交易池 交易池负责对交易进行排序，并返回可被纳入区块的交易。在就绪队列中的交易将被用来打包到区块内 交易会被执行，而状态变化会存在本地内存中。来自就绪队列的交易也会在网络上传播给其他节点 构建好的区块会被发布到网络上，而网络上其他所有节点都会接收并执行该区块 注意：交易在区块生成时不会从就绪队列中被删除，只有在区块导入时才被删除，这是因为最新生成的区块有可能进不了规范链里 从网络接收的区块 该区块被执行后，整个区块要么成功，要么失败 交易有效性 validate_transaction 是在 Runtime 里被调用的，检查有效的签名和 nonce 并返回一个 Result validate_transaction 只会个别地检查交易，所以它不会捡测到类似同一输出被使用两次的错误。 validate_transaction 并不会检查对模块的调用是否成功 validate_transaction 函数应专注于为交易池提供必要的信息，以便对交易进行排序和优先处理，并快速拒绝所有无效或过时的交易 账户 substrate用公私钥对来表示网络参与者 账户密钥 密钥对代表一个账户，并可以控制资金 账户密钥是通过泛型定义的，在 Runtime 中进行实例化 Stash密钥 Stash 账户的公私钥对，这个账户就像一个 “储蓄账户”，不应该用它进行频繁的交易。因此，应以最安全的方式来保存其私钥 Controller密钥 Controller 帐户的公私钥对，在 Substrate 的 NPOS 模型中，Controller 密钥会代表某个账户进行验证或提名 Controller 账户只需要支付交易费用，所以它只需要最少量的资金 会话密钥 会话密钥是验证者用来签署和共识相关消息的 “热密钥” 更改会话密钥的方式：通过Controller账户对会话公钥签名并创建一个证书，再将证书通过 extrinsic 广播 会话密钥是通过泛型定义的，在 Runtime 中进行实例化 交易权重 链可用的资源是有限的，包括内存、存储 I/O、算力、交易/区块大小和状态数据库的大小 权重用于管理验证一个区块所用的时间，常用于限制存储I/O和算力 区块中可包含的权重总量是有限的，并且可用的权重消耗通常也会受到交易费的限制 最大区块权重应等于目标区块时间的三分之一，为区块构造分配、网络传播、导入和验证各分配三分之一 权重基础 对权重的计算应该满足： 在被调用之前可计算。区块创建者在实际决定是否接受某个交易之前应该能够检查其权重 本身消耗很少的资源。 如果计算交易的权重会消耗与执行交易消耗相似的资源，那这样就没有意义了。因此，权重计算应该比执行交易更轻量级 无需访问链上状态即可确定使用的资源。权重有利于表示固定的度量或仅基于少量 I/O 的可调用函数参数的测量 如果权重十分依赖于链上状态，则可以： 强制使用可调用函数可能消耗的权重上限。 如果可调用函数使用的强制权重上限与其下限差别只是很少，则可直接使用其权重上限而无需访问链上状态。 但是如果两者差别巨大，那么即使进行很少的交易，其经济成本也可能很大，这将破坏激励措施，并降低链上吞吐量 要求有效权重作为参数传递到可调用函数中。 消耗的权量应基于这些参数，同时也应包含在调用时验证它们所花费的时间。 必须经过这一验证过程以确保权重参数准确对应于链上状态，如果对应不上，则报错 链下功能 使用预言机(Oracle)先对链下的数据作查询或处理，然后才将其提交到链上 预言机是一种外部服务，通常用于监听区块链事件，并根据条件触发任务。 当这些任务执行完毕，执行结果会以交易的形式提交至区块链上。 虽然这种方法可行，但在安全性、可扩展性，和效率方面仍然存在一些缺陷 因此substrate提供一些链下特性： Off-Chain Worker (OCW) 执行长时间运行的和可能不确定的任务（如web请求、加解密、数据签名、随机数生成、cpu密集型计算、链上数据枚举/聚合等） Off-Chain Storage 为substrate节点提供本地存储 Off-Chain Indexing 允许Runtime独立于OCW直接写入链下存储 Runtime Runtime 用于定义区块链的业务逻辑 在 Runtime 中定义了用于表示区块链状态的存储项，同时也定义了允许区块链用户对该状态进行更改的函数 为了能够提供无须分叉的升级功能，Substrate采用了可编译成 WebAssembly (Wasm)字节码的 Runtime 形式 FRAME 是Parity 的 Substrate runtime 开发系统， FRAME 定义了额外的 runtime 基础类型，并提供了一个框架，使得通过编写模块 (称为 “pallets”) 来构建 runtime 变得十分容易，每个 pallet 用于封装特定于该域的逻辑，这些逻辑可表示为一组存储项、事件、错误和可调用函数的集合 Runtime基本类型 核心原语 runtime必须提供给substrate其他层的最小化内容： Hash：数据摘要， 通常是一个256位的数值 DigestItem Digest：一系列 DigestItem 的组合， 它对当前区块中轻客户端所需知晓的所有信息进行了编码 Extrinsic：这种类型代表着一段来自链外、且被区块链认可的数据。 它通常包括一个或多个签名，以及某种编码指令(例如转移资金所有权或调用智能合约) Header：包含了单个区块所有信息 (以加密或其它形式) 的类型。 它包括父区块哈希、存储根哈希和 extrinsic 根哈希、区块摘要及区块号 Block：基本上就是 Header 和一系列 Extrinsics 的组合，以及所使用的哈希算法说明 BlockNumber：一种类型，代表一个有效区块的祖先区块的总数量。 通常是32字节数值 FRAME原语 如果是通过Substrate FRAME搭建的runtime，还可以使用如下的FRAME原语： Call: 通过extrinsic调用的可调用函数类型 Origin: 代表着函数调用方，例如可以是签名消息(交易)、无签名消息(区块链内生数据)，或者runtime本身(根调用) Index: 帐户的交易索引 (nonce) 类型， 存储交易发送方账户曾经发出的交易总数 Hashing：在runtime中使用的哈希系统 (算法) AccountId： 用于在runtime中识别用户账户的类型 Event：代表runtime发出的事件类型 Version：代表runtime版本的类型 FRAME Framework for Runtime Aggregation of Modularized Entities (FRAME) 是一组可简化 runtime 开发的模块（pallet）和支持库 FRAME 提供了一些与 Substrate Primitives 交互的帮助模块，而 Substrate Primitives 则提供了与核心客户端的交互接口 Pallet Pallets是一种可组合成为Substrate runtime的特殊Rust模块。每个pallet都拥有独立的逻辑，可修改相应区块链状态转换函数的特征和功能 Pallet架构 123456789101112131415161718192021// 1. 导入库和依赖项// 此pallet支持使用任何带有`no_std`标志编译的Rust库。use support::&#123;decl_module, decl_event, decl_storage, ...&#125;// 2. Runtime配置Trait // 所有runtime类型和常量都放在这里。// 如果此pallet依赖于其他特定的pallet，则应将依赖pallet的配置trait添加到继承的trait列表中pub trait Config: system::Config &#123; ... &#125;// 3. Runtime事件// 事件是一种用于报告特定条件和情况发生的简单手段，用户、Dapp和区块链浏览器都可能对事件的感兴趣。没有它就很难发现。decl_event!&#123; ... &#125;// 4. Runtime存储// Runtime存储允许在保证“类型安全“前提下使用Substrate存储数据库，因而可在块与块之间留存内容。decl_storage!&#123; ... &#125;// 5. Pallet声明 // 此模块定义了最终从此pallet导出的&quot;Module&quot;结构体// 它定义了该pallet公开的可调用函数，并在区块执行时协调该pallet行为decl_module! &#123; ... &#125; Substrate内置模块 汇总链接 Runtime宏 decl_storage! 在 pallet 中定义一个存储项目，存储项目的定义包括： 数据类型，为下列其中一种： StorageValue类型: rust-type StorageMap类型: map hasher($hasher) rust_type =&gt; rust_type StorageDoubleMap类型: doublemap hasher($hasher) rust_type, hasher($hasher) rust_type =&gt; rust_type getter函数 键类型及其哈希函数 (如果是map或double-map类型) 存储的名称 默认值 这些存储值可通过其后的add_extra_genesis模块在其创世区块中进行初始化 12345678910decl_storage! &#123; trait Storage for Module&lt;T: Config&gt; as MyModule &#123; // ... &#125; add_extra_genesis &#123; build (|config| &#123; //... &#125;); &#125;&#125; API文档 decl_event! 通过实现 Event枚举类型来定义pallet事件，而宏中的每个事件类型都是Event枚举类型内的一个成员 API 文档 decl_error! 定义 pallet 在可调用函数中可能返回的错误类型 DispatchError 。宏自动为DispatchError 实现了 From&lt;Error&lt;T&gt;&gt; trait， 因此，DispatchError 能为特定的错误类型返回正确的模块索引、错误代码、错误字符串 API 文档 decl_module! 定义pallet中的可调用函数，在此宏中，pallet声明了一个名为 Module的结构体，以及一个名为 Call 的枚举类型。除了为 Module 和 Call实现了各种辅助trait，如 Copy、StructuralEq、 Debug以外，该宏还为Module实现了生命周期trait，如 frame_support::traits::OnInitialize， frame_support::traits::OnFinalize， frame_support::traits::OnRuntimeUpgrade，和frame_support::traits::OffchainWorker API 文档 construct_runtime! 用于构造Substrate runtime，将各个pallets集成到runtime。该宏声明及实现了各种不同的结构体和枚举类型，如Runtime、Event、Origin、 Call、GenesisConfig 等，同时也为这些结构体类型实现了不同的辅助trait API 文档 Runtime 结构类型是为Substrate runtime而定义的 Event 枚举类型的成员变量是所有可发出事件的pallets，并且实现了辅助trait和编码/解码trait。Event 实现了TryInto&lt;pallets::Event&lt;Runtime&gt;&gt; trait，以从枚举类型中提取事件 Origin枚举类型是通过实现辅助traits来定义的，如 PartialEq、Clone、 Debug等trait。 此枚举类型定义了是谁调用了extrinsic：NONE、 ROOT还是由特定帐户签名调用 Call枚举类型由所有的集成pallet作为成员变量来定义的。 它包含每个集成pallet的数据和元数据，并通过实现frame_support::traits::UnfilteredDispatchable trait将调用重定向到特定pallet 该宏定义了GenesisConfig 结构类型，并实现了sp_runtime:: BuildStorage trait以建立存储的创世配置 该宏收集每一个pallet对 frame_support::unsigned::ValidateUnsigned 这个trait的实现， 如果没有任何一个pallet实现了 ValidateUnsigned trait，则所有的无签名交易都将被拒绝 parameter_types! 用于在构造runtime时声明参数类型，这些参数类型将赋值给各pallet的可配置trait关联类型。该宏使用get()函数返回的具体值，来替换掉结构体中指定的类型。 每个参数的结构体类型还实现了 frame_support::traits::Get&lt;I&gt; 这个trait，以将类型转换为其指定的值 API 文档 impl_runtime_apis! 通过RuntimeApi和RuntimeApiImpl这两个结构体类型为客户端实现API API 文档 add_crypto! 指定交给pallet管理的密钥对及其签名算法。该宏声明了三种结构体类型: Public、Signature和Pair Public 类型用于生成密钥对、签名和验证签名 Signature 类型用于在确定了签名加密方法情况下保存签名属性 Pair 类型用于使用种子生成一个公私密钥对 API 文档 impl_outer_origin! 用于为runtime构造一个 Origin结构体类型，它通常由construct_runtime!自动调用 API 文档 impl_outer_event! 用于在runtime时构造一个 Event 结构体类型， 它通常由 construct_runtime!宏自动调用 API 文档 impl_outer_dispatch! 用于实现一个元调用模块，以把调用分派给其它调用者，它通常是由 construct_runtime!自动调用的 API 文档 Runtime元数据 建立在 Substrate 上的区块链会暴露出元数据，以便能轻松与其交互。 元数据根据不同的 pallets来源被分隔成不同模块，对于每个模块，元数据都提供该模块对外暴露的 存储项、extrinsic 调用、事件、常量和错误的相关信息。 Substrate 会自动生成这些元数据，并通过 RPC 函数使它可被调用 可使用特定语言库或者与语言无关的HTTP和WebSocket API这两种渠道，来从Substrate节点中获取元数据 具体参考 Runtime执行流程 Substrate runtime的执行由Executive模块来协调，它负责调用区块链中包含的各种runtime模块 Executive模块对外暴露了 execute_block 函数，以实现如下功能： 初始化区块 执行extrinsics 完结区块 验证交易 在区块开始执行前，检查签名交易的有效性 执行区块 只要有效交易的队列不为空，Executive模块就开始执行区块 初始化区块 区块初始化时，System模块和其他runtime模块都会首先调用其on_initialize 函数，把由模块定义的、需要前置的业务逻辑在交易执行前全部处理掉。 除System模块总是优先处理外，其余模块均按照在construct_runtime!宏里定义的顺序来执行 接下来是初始检查，该步骤将验证区块头中的父哈希是否正确，以及extrinsics trie的根是否囊括了所有的extrinsics 执行Extrinsics 按照交易优先级顺序执行每一个有效的extrinsic。 Extrinsics一定不能在rutnime逻辑中引起程序崩溃，否则系统将很容易受到用户攻击，而通过这种攻击，用户可不受任何惩罚地消耗计算资源 当extrinsic执行时，原有存储状态不会提前被缓存下来，修改将直接应用到存储上。 因此，在更改存储状态之前，runtime开发人员应进行所有必要检查，以确保extrinsic能执行成功。 一旦extrinsic在执行过程中失败了，存储更改将不能回滚 extrinsic执行时触发的事件也会写入存储。 因此，在完成所有待执行动作之前，不应该触发相关事件。 否则，倘若extrinsic在事件触发后才执行失败的话，该事件将不能回滚 完结区块 执行完所有队列中的extrinsic之后，Executive模块调用各模块的 on_idle 和 on_finalize 函数来执行区块的最后业务逻辑 智能合约 概述 智能合约与Runtime开发的关系 Substrate Runtime 开发和 Substrate 智能合约是使用 Substrate 框架来构建 “去中心化应用” 的两种不同途径 智能合约 传统的智能合约平台允许用户在核心区块链逻辑之上发布额外的逻辑，为保证安全性，智能合约平台内建了一些安全防护手段，包括： Fees：确保合约开发者在使用了区块链的计算和存储资源来执行智能合约之后付费，这样出块节点的资源就不会被他们滥用 沙箱：一个合约无法直接修改核心区块链存储或其他合约的存储 状态租赁：合约会因为占用了区块链的空间而需要为其付费 回滚：合约可能有导致逻辑错误的情况，我们对合约开发者开发能力的期望很低，因此增加了额外的开销，以支持在交易失败时回滚整个交易 Runtime开发 Runtime 开发不向开发者提供智能合约所提供的那些保护或安全措施，相反，可以完全控制网络上每个节点运行的基本逻辑，也拥有修改和控制所有模块的每一个存储条目的完整权限 Substrate Runtime 开发的目的是为区块链提供精炼、高性能、和快速的节点。 它不提供任何保护，不提供交易回退的开销， 也不隐式地引入区块链上节点运行的收费系统 两者对比 智能合约 Runtime 对网络来说是天生安全 提供对整个区块链的底层访问权限 通过经济激励来防止滥用 没有任何原生的经济激励机制来抵御作恶 通过额外的计算开销来支持错误处理 没有内置安全措施带来的性能开销 开发门槛更低 开发者需要逾越一定的门槛 ink!智能合约 Substrate使用ink!作为其智能合约的语言，ink!是一个基于 Rust 的嵌入式领域专用语言（eDSL），专用于编写Contracts模块的 Wasm 智能合约，其设计宗旨是正确性、简洁性、高效性 ink! 设计上尽可能接近 Rust 编程语言，使用属性宏将标准的 Rust 结构标记为可理解的合约组件 1#[ink(...)] ink!的合约开发组件包括： 事件 (Events) 事件主题 (Event Topics) 存储 (Storage) 构造函数 (Constructor Functions) 消息函数 (Message Functions) 因为是采用 Rust 编写，ink! 可以提供编译时的溢出/下溢安全保护 ink!语言基础 合约(Contracts)模块 合约模块为 Runtime 提供部署和执行wasm智能合约的能力 Wasm引擎 合约模块依赖于 Wasm 的沙盒接口，它定义了 Runtime 内可用的 Wasm 执行引擎（wasmi） 功能 合约模块在智能合约的部署和执行上有许多合约开发者熟悉的功能以及一些新功能 合约账户 对 Substrate Runtime 来说，合约账户就像普通的用户账户一样；但是，除了普通账户所拥有的 AccountID 和 Balance 之外，合约账户还有相关的合约代码和一些持久的合约存储 部署合约 用 Contracts 模块部署合约需要两个步骤： 在区块链上存储 Wasm 合约 开启一个由新存储空间的新账户，与该智能合约挂勾 这意味着可以使用同一个 Wasm 代码初始化多个具有不同的构造参数的合约实例，从而减少区块链上 Contracts 模块所需的存储空间 合约调用 调用合约可以改变合约内的储存、创建新合约，或调用其他合约。 由于可以编写自定义 Runtime 模块，Contracts 模块也可以用合约账户直接异步调用那些 Runtime 函数 沙箱保护 Contracts 模块旨在供公共网络上的所有用户使， 这意味着合约只能直接修改他们自己所拥有的存储。 为了给底层区块链状态提供安全保障，合约模块实现了可逆交易，可回滚那些对存储进行改动而没有成功完成的合约调用 手续费 为了限制一次交易可使用的计算资源，合约调用需要收取手续费 (gas fee)，在构造合约交易时，需要指定 gas 限额。随着合约的执行，gas 根据计算的复杂性逐步被消耗。如果在合约执行完成前达到 gas 限额，则交易失败，合约存储被还原，gas 费用 并不会 退还给用户；如果合约执行完成时还有剩余 gas，则在交易结束时退还给用户 存储租金 与 gas 限制了交易的计算资源类似，存储租金限制了合约在区块链存储中的占用率，合约账户按其使用的存储量所占的比例支付租金。 当合约可用余额低于某个限额时，合约账户会变成一个 “墓碑”，其存储被清空。 墓碑合约可通过提供能激活它的最少资金和被清除的数据，来重新激活合约","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"},{"name":"substrate","slug":"substrate","permalink":"http://example.com/tags/substrate/"}]},{"title":"论文阅读-TWINE An Embedded Trusted Runtime","slug":"paper-twine","date":"2021-04-11T16:00:00.000Z","updated":"2021-04-12T12:54:06.144Z","comments":true,"path":"2021/04/12/paper-twine/","link":"","permalink":"http://example.com/2021/04/12/paper-twine/","excerpt":"论文TWINE：An Embedded Trusted Runtime阅读笔记","text":"1.Introduction TWINE（Trusted Wasm in Enclave） 使用标准Intel工具链实现 允许本地执行遗留Wasm应用程序，而无需重新编译 动态地将WASI操作转换为系统调用或安全库函数 将文件操作映射到英特尔的受保护文件系统，持久的数据是透明加密的，并且永远不会以明文的形式从enclave之外访问 实现了完整的安全SQLite嵌入 Contributions 通用的Enclave内wasm运行时环境，支持文件系统加密 广泛评估性能和瓶颈 改进英特尔受保护文件系统的建议 3.Background LLVM 不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR) 如果需要支持一种新的编程语言，那么只需要实现一个新的前端 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改 WASI 让 WebAssembly 也可以运行在非浏览器环境中 需要实现可移植的二进制文件（.wasm）和一个跨平台的运行时（runtime） 实现细粒度的权限控制： 先定义一套标准的系统调用接口：wasi-core 各个平台（windows、unix）对标准接口进行平台实现 对于一个具体的 wasm 程序，需要把其允许调用的接口在运行的时候传入，比如对于一个 wasm 模块，我只传入“__wasi_path_open”这样一个接口，因此 wasm 中就只能用这样一个接口 同样的，对于文件路径也是，只允许对传入的文件路径进行操作，例如只传入 /tmp 路径，wasm 模块就没有办法对 /usr 路径下的文件进行操作 wasm代表抽象的虚拟机，wasi代表其抽象的OS WASM运行时 使用WAMR作为底层运行时： 支持两种解释执行模式，一种慢但内存占用少，另一种快但内存占用多 支持两种二进制执行模式，AoT和JIT，都使用LLVM 使用C语言实现，外部依赖很少 4.Trusted Runtime for WebAssembly TWINE由两大模块组成：Wasm运行时和WASI接口 Wasm运行时完全在TEE中运行，而WASI作为可信环境和不可信环境之间的桥梁与OS通信（相当于OCALL） WASI的优势在于提供三种抽象： 开发者可以自由选择开发语言，只要能够被LLVM等编译器编译为WASI TEE从应用程序中抽象出来：只要TEE能够解释或执行Wasm(由WASI支持)，应用程序就可以安全执行 WASI与系统无耦合，只要OS提供WASI需要的API就可以使用 安全性 WASI可以通过沙箱的方式控制安全性（权限控制） SGX和WASI组成双向沙箱 系统（Enclave认为untrusted）不能损害enclave代码的完整性或是内存中的数据的机密性 Wasm应用（OS认为untrusted）不能直接与OS交互，除非WASI给与权限 威胁模型 没有物理攻击，且TEE提供了指定的保护级别，并且标准加密不能被破坏 对于SGX Enclave：enclave内的代码和数据是可信的，而来自外部的任何东西都是不可信的 外部只能读取经过加密的enclave内存 侧信道攻击和拒绝服务攻击可能存在，需要enclave中的应用程序解决 对于OS：遵循honest-but-curious模型 WASI WASI是Wasm应用程序与外部世界通信的接口 WAMR的工具包提供了一个预先编译器，能够在Wasm应用程序到达TWINE的enclave之前，使用LLVM将其编译为本地代码（native code）。因此，TWINE不包含Wasm解释器，只能执行预先编译的应用程序（执行本地代码比代码编译更快） Wasm运行时比代码解释器占用的内存更小 WASI实现细节 大部分WASI调用被直接转换为OCALL TWINE为WAMR实现了一个不同的WASI接口，更适合SGX使用： 保留其沙箱实现 将剩下部分分为两层：一层用于特定功能实现，一层用于一般调用 一般调用通过在enclave外调用类POSIX库来处理，同时提供额外的安全措施和健全性检查；一般调用只有某个功能没有可信实现时才会使用 TWINE包含一个编译标志，可以全局禁用enclave中的不受信任的POSIX实现（接口可能泄漏主机调用中的敏感数据，例如使用模式和参数） IPFS（Intel Protected File System） IPFS分为两部分： 1.可信库，在enclave中运行，为文件管理提供了类似POSIX的API 2.不可信库，与enclave之外的POSIX函数交互，这些函数进行实际文件读写 写操作：先由可信库对内容加密，再由不可信库写到存储介质（加密后的文件以Merkle树的结构存在） 读操作：由可信库进行完整性校验 IPFS实现细节 IPFS自动创建用于加密文件的密钥，这些密钥由enclave签名和处理器的密钥导出 TWINE持久化的文件在enclave之外被视为密文，而在Wasm应用程序处理之前会透明地解密并进行完整性检查","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"wasm","slug":"wasm","permalink":"http://example.com/tags/wasm/"}]},{"title":"EOS入门","slug":"eos入门","date":"2021-04-08T16:00:00.000Z","updated":"2021-04-16T06:54:20.039Z","comments":true,"path":"2021/04/09/eos入门/","link":"","permalink":"http://example.com/2021/04/09/eos%E5%85%A5%E9%97%A8/","excerpt":"EOS开发入门","text":"简介 平台和工具链 Nodeos EOSIO节点守护进程的核心 处理区块链数据持久层、点对点网络和智能合约调度 在开发环境中，可以使用nodeos建立单节点区块链网络 Cleos 命令行工具，调用nodeos暴露的接口API 部署和测试EOSIO智能合约 Keosd 密钥管理器守护进程，用于存储私钥和对消息签名 keosd为要在相关钱包文件中加密的密钥提供安全密钥存储介质 keosd守护进程还定义了一个安全的enclave，用于对cleos或第三方库创建的交易进行签名 EOSIO.CDT WASM工具链 对EOSIO智能合约的编译进行EOSIO-specfic优化 EOSJS JavaScript API SDK，集成基于EOSIO的区块链 核心概念 账户 存储在区块链上的人类可读的名字 用于转移或提交有效的交易到区块链上 钱包 存储密钥的客户端 理想情况下，钱包有一个加密状态和一个解密状态 授权和权限 定义交易的需求，通过linking authorization或linkauth来为特殊合约分配权限 智能合约 在链上执行，一旦执行就永久留存在链上且不可变 DPOS共识 Delegated Proof of Stake 委托权益证明 若在链上持有token，可以通过投票系统选择block producer 任何人都可以参与block producer的竞选 RAM 被视为永久存储，用于存放账户名、权限、代币余额等需要快速访问的链上数据 RAM需要购买，并且不是基于权益分配，因为RAM是一个有限的持久性资源 CPU 代表区块链上一个动作的执行时间 在cleos的 get account 命令的输出中，CPU被称为 cpu bandwidth，代表一个账户在将动作提交到合约时可以支配的处理时间 CPU是一个瞬态系统资源，属于EOSIO的权益机制 NET NET是交易的网络带宽，单位为byte 在cleos的 get account 命令的输出中，NET被称为 net bandwidth NET是一个瞬态系统资源，属于EOSIO的权益机制 技术特征 WebAssembly C++编译 EOSIO使用C++编写智能合约 在EOSIO核心层的顶端是一个Wasm虚拟机：EOS VM ，用于执行智能合约（它是为区块链应用的高要求而设计的，对WebAssembly引擎的要求远远高于为web浏览器标准开发而设计的引擎） 使用Wasm标准有利于将其他语言移植到EOSIO平台 高吞吐量、更快的确认、低延迟 通过智能合约分配和管理资源 权益机制 通过权益机制来获取系统资源（CPU和NET） 用户使用权益token换取CPU和NET的使用，按照占所有用户的token比例分配 商业模型灵活性 综合的权限架构 可升级 高效能源消耗 环境配置 安装EOSIO和CDT 根据官网指示安装EOSIO和CDT，在Ubuntu20.04上，下载github上对应的Pre-release包 创建开发钱包 创建钱包 注意保存密码 1cleos wallet create --to-console 打开钱包 1cleos wallet open 查看钱包列表 1cleos wallet list 解锁钱包 1cleos wallet unlock 向钱包导入密钥 1cleos wallet create_key 导入开发密钥 1cleos wallet import 输入如下私钥（所有新的EOSIO链都有相同的开发密钥） 15KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 对应的开发公钥为： 1EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 开启keosd和nodeos 开启keosd 1keosd &amp; 若遇到报错： 1&quot;3120000 wallet_exception: Wallet exception Failed to lock access to wallet directory; is another keosd running?&quot; 先使用命令 pkill keosd 再重新开启 开启nodeos 运行Nodeos，加载所有基本插件，设置服务器地址，开启CORS，添加合约debug和日志 123456789101112nodeos -e -p eosio \\--plugin eosio::producer_plugin \\--plugin eosio::producer_api_plugin \\--plugin eosio::chain_api_plugin \\--plugin eosio::http_plugin \\--plugin eosio::history_plugin \\--plugin eosio::history_api_plugin \\--filter-on=&quot;*&quot; \\--access-control-allow-origin=&#x27;*&#x27; \\--contracts-console \\--http-validate-host=false \\--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp; 查看日志 查看Nodeos是否正在出块 1tail -f nodeos.log 如果报错 Database dirty flag set (likely due to unclean shutdown): replay required ，先使用命令 pkill nodeos 安全关闭nodeos，再重新开启 确保RPC API正常运行 1curl http://localhost:8888/v1/chain/get_info 创建开发账户 账户是授权的集合，保存在区块链上 账户可以标识一个用户，也可以标识智能合约（一个账户只能有一个智能合约） 账户可以由一个用户或一组用户控制 创建测试账户 每个EOSIO账户都和一个公钥绑定 123cleos create account eosio bob EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CVcleos create account eosio alice EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 查看账户信息 1cleos get account alice 得到如下结果： 12345678910111213141516permissions: owner 1: 1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV active 1: 1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CVmemory: quota: unlimited used: 2.66 KiB net bandwidth: used: unlimited available: unlimited limit: unlimitedcpu bandwidth: used: unlimited available: unlimited limit: unlimited 用户可以暴露active公钥，自己保存owner公钥，这样，如果active公钥被泄露，用户可以使用owner公钥取回账户控制权（所以建议使用不同的active公钥和owner公钥） 智能合约编写 Hello World 创建hello目录并编写hello.cpp 12345678#include &lt;eosio/eosio.hpp&gt;class [[eosio::contract]] hello : public eosio::contract &#123;public: using eosio::contract::contract; [[eosio::action]] void hi(eosio::name user) &#123; print(&quot;Hello, &quot;, user); &#125;&#125;; 编译cpp，会产生两个文件：hello.wasm和hello.abi 1eosio-cpp -abigen -o hello.wasm hello.cpp 部署智能合约 首先创建一个新的hello账户，在hello目录下生成hello账户的公私钥 1cleos create key --file hello_key 使用生成的公钥创建hello账户 1cleos create account eosio hello &lt;public key&gt; 向钱包导入hello私钥 1cleos wallet import 部署hello智能合约到hello账户（先cd到contracts目录） 1cleos set contract hello ./hello -p hello@active 调用智能合约 1cleos push action hello hi &#x27;[&quot;bob&quot;]&#x27; -p bob@active 设置智能合约调用权限 修改hello.cpp并重新编译以及部署 123456789#include &lt;eosio/eosio.hpp&gt;class [[eosio::contract]] hello : public eosio::contract &#123;public: using eosio::contract::contract; [[eosio::action]] void hi(eosio::name user) &#123; require_auth(user); print(&quot;Hello, &quot;, eosio::name&#123; user &#125;); &#125;&#125;; 测试：bob说hi，但交易由alice签名（失败） 1234cleos push action hello hi &#x27;[&quot;bob&quot;]&#x27; -p alice@activeError 3090004: Missing required authorityEnsure that you have the related authority inside your transaction!; 测试：bob说hi，交易由bob签名（成功） 12345cleos push action hello hi &#x27;[&quot;bob&quot;]&#x27; -p bob@activeexecuted transaction: 033b54bd4a79a9bc868910087bd769e108ffe6f0db29b2b51c61007b03880f51 104 bytes 116 us# hello &lt;= hello::hi &#123;&quot;user&quot;:&quot;bob&quot;&#125;&gt;&gt; Hello, bob Tokens 获取源代码，在contracts目录下： 123git clone https://github.com/EOSIO/eosio.contracts --branch v1.7.0 --single-branchcd eosio.contracts/contracts/eosio.token 创建一个账户来部署token合约（公钥是EOSIO开发公钥） 1cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 编译智能合约 1eosio-cpp -I include -o eosio.token.wasm src/eosio.token.cpp --abigen 部署智能合约（cd到 eosio.token/…/ 目录下） 1cleos set contract eosio.token ./eosio.token --abi eosio.token.abi -p eosio.token@active 创建token：需要指定一个颁发者和token名称以及最大供应量；同时为了创建token，需要eosio.token账户的权限 1cleos push action eosio.token create &#x27;[ &quot;alice&quot;, &quot;1000000000.0000 SYS&quot;]&#x27; -p eosio.token@active 颁发token：拥有颁发权的alice颁发100个token（可以加上 -d -j 参数来debug） 1cleos push action eosio.token issue &#x27;[ &quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot; ]&#x27; -p alice@active 交易token：alice转了25个token给bob 1cleos push action eosio.token transfer &#x27;[ &quot;alice&quot;, &quot;bob&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot; ]&#x27; -p alice@active 查看bob以及alice的账户余额 123cleos get currency balance eosio.token bob SYScleos get currency balance eosio.token alice SYS ABI文件 Application Binary Interface（ABI）用来描述如何将用户操作在JSON格式和二进制格式之间转换 ABI文件结构 12345678910&#123; &quot;version&quot;: &quot;eosio::abi/1.0&quot;, &quot;types&quot;: [], &quot;structs&quot;: [], &quot;actions&quot;: [], &quot;tables&quot;: [], &quot;ricardian_clauses&quot;: [], &quot;abi_extensions&quot;: [], &quot;___comment&quot; : &quot;&quot;&#125; types 自定义数据类型需要在ABI文件中进行描述，但是对于EOS.IO的内建类型，无需在ABI文件中说明，之前的hello和eos.token合约的ABI文件中，types都是[]，因为没有自定义类型 如下，给account_name建立一个笔名，在ABI文件里用name可以代替account_name 1234&quot;types&quot;: [&#123; &quot;new_type_name&quot;: &quot;account_name&quot;, &quot;type&quot;: &quot;name&quot;&#125;] structs 声明各个action需要传入的参数，系统根据actions部分中声明的type，在structs部分寻找对应的数据结构，也就是说，函数声明部分并没包含具体内容，具体数据需要到structs中寻找 1234567&#123; &quot;name&quot;: &quot;issue&quot;, // 数据结构名 &quot;base&quot;: &quot;&quot;, // 继承的父结构名 &quot;fields&quot;: [ // 参数数组，包含参数名和类型 &#123;&quot;name&quot;:&quot;&quot;, &quot;type&quot;:&quot;&quot;&#125;, ] &#125; 例子： 1234567891011121314151617181920212223242526272829&quot;structs&quot;: [&#123; &quot;name&quot;: &quot;transfer&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: [ &#123;&quot;name&quot;:&quot;from&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;to&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;quantity&quot;, &quot;type&quot;:&quot;asset&quot;&#125;, &#123;&quot;name&quot;:&quot;memo&quot;, &quot;type&quot;:&quot;string&quot;&#125; ] &#125;,&#123; &quot;name&quot;: &quot;create&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: [ &#123;&quot;name&quot;:&quot;issuer&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;maximum_supply&quot;, &quot;type&quot;:&quot;asset&quot;&#125;, &#123;&quot;name&quot;:&quot;can_freeze&quot;, &quot;type&quot;:&quot;uint8&quot;&#125;, &#123;&quot;name&quot;:&quot;can_recall&quot;, &quot;type&quot;:&quot;uint8&quot;&#125;, &#123;&quot;name&quot;:&quot;can_whitelist&quot;, &quot;type&quot;:&quot;uint8&quot;&#125; ] &#125;,&#123; &quot;name&quot;: &quot;issue&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: [ &#123;&quot;name&quot;:&quot;to&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;quantity&quot;, &quot;type&quot;:&quot;asset&quot;&#125;, &#123;&quot;name&quot;:&quot;memo&quot;, &quot;type&quot;:&quot;string&quot;&#125; ] &#125;] actions 用于声明智能合约有哪些可以调用的action 12345&#123; &quot;name&quot;: &quot;transfer&quot;, // 在智能合约中定义的函数名 &quot;type&quot;: &quot;transfer&quot;, // 在structs中声明的数据结构名 &quot;ricardian_contract&quot;: &quot;&quot; // 可选参数，开发中&#125; tables 列出智能合约需要建立的数据表的名称以及数据表中存储的结构体名称 1234567&#123; &quot;name&quot;: &quot;&quot;, // 数据表的名称 &quot;type&quot;: &quot;&quot;, // 数据表对应的struct &quot;index_type&quot;: &quot;&quot;, // 主键类型 &quot;key_names&quot; : [], // 键名列表，长度与key_types相同 &quot;key_types&quot; : [] // 键的类型列表，长度与key_names相同&#125; 例子： 1234567&#123; &quot;name&quot;: &quot;accounts&quot;, &quot;type&quot;: &quot;account&quot;, &quot;index_type&quot;: &quot;i64&quot;, &quot;key_names&quot; : [&quot;primary_key&quot;], &quot;key_types&quot; : [&quot;uint64&quot;]&#125;","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"},{"name":"eos","slug":"eos","permalink":"http://example.com/tags/eos/"}]},{"title":"Makefile学习","slug":"makefile","date":"2021-03-08T16:00:00.000Z","updated":"2021-03-09T14:18:07.640Z","comments":true,"path":"2021/03/09/makefile/","link":"","permalink":"http://example.com/2021/03/09/makefile/","excerpt":"makefile文件编写","text":"makefile概览 规则的基本形式 1234target ... : prerequisites ... command ... ... target：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label） prerequisites：生成该target所依赖的文件 command：该target要执行的命令（任意的shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说: prerequisites中如果有一个以上的文件比target文件要新 (比较修改日期) 的话，command所定义的命令就会被执行 一个简单的例子 123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o clean 不是一个文件，它只不过是一个label，其冒号后什么也没有，make不会自动去找它的依赖性，也就不会自动执行其后所定义的命令；要执行其后的命令，就要在make命令后明显得指出这个label的名字 make的工作方式 只输入 make 命令： make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。 如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。 使用变量 12345objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o edit $(objects)... makefile自动推导 只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个 whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，因此上述makefile可简化为： 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : -rm edit $(objects) .PHONY 表示 clean 是个伪目标文件 rm 前的 - 表示也许某些文件出现问题，但不要管，继续做后面的事 依赖关系也可以合并，如下： 12345678910111213objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : -rm edit $(objects) makefile文件名 默认使用 makefile 或 Makefile ，如果使用其他名称，如 make.linux ，那么需使用命令 make -f make.linux 引用其他makefile 你有这样几个Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含了 e.mk 和 f.mk ： 123include foo.make *.mk $(bar)# 等价于include foo.make a.mk b.mk c.mk e.mk f.mk 如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。 如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。 make的执行步骤 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 书写规则 通配符 make支持三个通配符： * ， ? 和 ~ * : 匹配0个或多个字符 ? : 匹配一个字符 ~ : home目录？ 在变量中使用通配符有所不同： objects = *.o 表示 objects 的值就是 *.o ，而不会展开 objects := $(wildcard *.o) 表示所有以 .o 结尾的文件 文件搜索 特殊变量 VPATH 如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件；如果定义了这个变量，那么make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件 1VPATH = src:../headers 多个目录使用冒号隔开，依次搜索 关键字vpath 12345678# 为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;vpath &lt;pattern&gt; &lt;directories&gt;# 清除符合模式&lt;pattern&gt;的文件的搜索目录vpath &lt;pattern&gt;# 清除所有已被设置好了的文件搜索目录vpath &lt;pattern&gt;需要包含 % 字符，表示匹配零或若干字符，例如， %.h 表示所有以 .h 结尾的文件 12vpath %.c foo:barvpath % blish 表示搜索 .c 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录 伪目标 为了避免和文件重名，使用特殊标记 .PHONY 来显式地指明一个目标是伪目标，不管是否有这个文件 123.PHONY : cleanclean : rm *.o temp 伪目标也可以指定所依赖的文件，可以用来在一个Makefile文件生成若干个可执行文件： 1234567891011all : prog1 prog2 prog3.PHONY : allprog1 : prog1.o utils.o cc -o prog1 prog1.o utils.oprog2 : prog2.o cc -o prog2 prog2.oprog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 伪目标的命名 all：所有目标的目标，其功能一般是编译所有的目标 clean：删除所有被make创建的文件 install：安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去 print：列出改变过的源文件 tar：把源程序打包备份，也就是一个tar文件 dist：创建一个压缩文件，一般是把tar文件压成Z文件，或是gz文件。 TAGS：更新所有的目标，以备完整地重编译使用 check和test：一般用来测试makefile的流程 静态模式 123456objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 目标从objects中获取， %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o ； 依赖模式 %.c 则取模式 %.o 的 % ，也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 命令中的 $&lt; 和 $@ 则是自动化变量， $&lt; 表示第一个依赖文件， $@ 表示目标集（也就是“foo.o bar.o”） 于是，上面的规则展开后等价于下面的规则： 1234foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 自动生成依赖 把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件， .d 文件中就存放对应 .c 文件的依赖关系，产生 .d 文件的模式规则如下： 12345%.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\ sed &#x27;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \\ rm -f $@.$$$$ 所有的 .d 文件依赖于 .c 文件 rm -f $@ 的意思是删除所有的目标，也就是 .d 文件 -M 参数表示自动找寻源文件中包含的头文件，并生成一个依赖关系 第二行的意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件， $@ 表示模式 %.d 文件，如果有一个C文件是name.c，那么 % 就是 name ， $$$$ 意为一个随机编号，第二行生成的文件有可能是name.d.12345 第三行使用sed命令做了一个替换 第四行删除临时文件 书写命令 每条命令的开头必须以 Tab 键开头，除非，命令是紧跟在依赖规则后面的分号后的 显示命令 通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 @ 字符在命令行前，那么，这个命令将不被make显示出来，如： 123456@echo 正在编译XXX模块......# 输出： 正在编译XXX模块……echo 正在编译XXX模块......# 输出： echo 正在编译XXX模块......# 正在编译XXX模块...... 带入make参数 -n 或 --just-print ，那么其只是显示命令，但不会执行命令，这个功能有利于我们调试Makefile，看看命令执行的顺序等 命令执行 如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令，如： 123456exec1: cd /home/hchen pwd exec2: cd /home/hchen; pwd 执行 make exec1，打印当前Makefile目录，cd 没有作用 执行 make exec2，打印出“/home/hchen” 命令出错 有时候希望能忽略命令出错，继续执行： 对于单个命令，最前面加- 12clean: -rm -f *.o 全局方法：给make加上 -i 或是 --ignore-errors 参数，那么，Makefile中所有命令都会忽略错误； -k 或是 --keep-going 参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则 对于单个规则，以 .IGNORE 作为目标，那么这个规则中的所有命令将会忽略错误 嵌套执行make 我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写： 12subsystem: cd subdir &amp;&amp; $(MAKE) 总控Makefile的变量可以传递到下级的Makefile中： 要传递变量到下级Makefile中： 1export &lt;variable ...&gt;; 不想让某些变量传递到下级Makefile中： 1unexport &lt;variable ...&gt;; 传递所有的变量，只要一个export就行了，后面什么也不用跟 注： 两个变量，一个是 SHELL ，一个是 MAKEFLAGS ，这两个变量不管你是否export，总是要传递到下层Makefile中 -w 或是 --print-directory 参数会在make的过程中输出一些信息，让你看到目前的工作目录 定义命令包（函数） 1234define run-yaccyacc $(firstword $^)mv y.tab.c $@endef 调用： 12foo.c : foo.y $(run-yacc) 命令包“run-yacc”中的 $^ 就是 foo.y ， $@ 就是 foo.c 使用变量 变量的基础 变量在声明时需要给予初值 在使用时，需要给在变量名前加上 $ 符号，使用小括号 () 或是大括号 &#123;&#125; 把变量给包括起来 如果要使用真实的 $ 字符，那么需要用 $$ 来表示 变量中的变量 使用变量的值定义变量 使用 = 123456foo = $(bar)bar = $(ugh)ugh = Huh?all: echo $(foo) = 右侧的变量的值可以定义在文件的任何一处 这种方法的缺点在于可能造成递归定义，如 12A = $(B)B = $(A) 使用 := 123x := fooy := $(x) barx := later 最终y的值为&quot;foo bar&quot;，x的值为&quot;later&quot; 前面的变量不能使用后面的变量，只能使用前面已定义好了的变量 使用 ?= 1FOO ?= bar 如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做 定义一个空格 12nullstring :=space := $(nullstring) # end of the line nullstring是一个Empty变量，其中什么也没有 space的值是一个空格：先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止 注： 如果以如下方式定义目录路径的变量： 1dir := /foo/bar # directory to put the frobs in dir这个变量的值是“/foo/bar”，后面还跟了4个空格 变量高级用法 变量值替换 替换变量中的共有的部分，其格式是 $(var:a=b) 或是 $&#123;var:a=b&#125; ，其意思是，把变量var中所有以a字串结尾的a替换成b字串。这里的结尾意思是空格或是结束符，如： 123foo := a.o b.o c.obar := $(foo:.o=.c)# bar的值为 a.c b.c c.c 也可以使用静态模式进行替换： 123foo := a.o b.o c.obar := $(foo:%.o=%.c)# bar的值为 &quot;a.c b.c c.c&quot; 变量值作为变量 1234x = yy = za := $($(x))# a的值为 &quot;z&quot; 12345first_second = Helloa = firstb = secondall = $($a_$b)# all的值为 &quot;Hello&quot; 追加变量值 1234567objects = main.o foo.o bar.o utils.oobjects += another.o# 相当于objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o override指示符 如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是: 123override &lt;variable&gt;; = &lt;value&gt;;override &lt;variable&gt;; := &lt;value&gt;; 多行变量 使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令 define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束 1234define two-linesecho fooecho $(bar)endef 环境变量 make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中 但如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖 如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量 目标变量 可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和全局变量同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值，其语法为： 123&lt;target ...&gt; : &lt;variable-assignment&gt;;&lt;target ...&gt; : overide &lt;variable-assignment&gt; 例子： 123456789101112prog : CFLAGS = -gprog : prog.o foo.o bar.o $(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c $(CC) $(CFLAGS) prog.cfoo.o : foo.c $(CC) $(CFLAGS) foo.cbar.o : bar.c $(CC) $(CFLAGS) bar.c 不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， $(CFLAGS) 的值都是 -g 模式变量 模式变量的好处是，可以给定一种“模式”，把变量定义在符合这种模式的所有目标上，如： 1%.o : CFLAGS = -O 给所有以 .o 结尾的目标定义目标变量 CFLAGS 条件判断 语法为： 1234567891011&lt;conditional-directive&gt;&lt;text-if-true&gt;endif# 或&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 其中 &lt;conditional-directive&gt; 表示条件关键字，在 &lt;conditional-directive&gt; 这一行上，多余的空格是被允许的，但是不能以 Tab 键作为开始（不然就被认为是命令）。而注释符 # 同样也是安全的。 else 和 endif 也一样，只要不是以 Tab 键开始就行了。 条件关键字有以下四种： ifeq 12345ifeq (&lt;arg1&gt;, &lt;arg2&gt;)ifeq &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;ifeq &quot;&lt;arg1&gt;&quot; &#x27;&lt;arg2&gt;&#x27;ifeq &#x27;&lt;arg1&gt;&#x27; &quot;&lt;arg2&gt;&quot; 比较参数 arg1 和 arg2 的值是否相同，相同则为真 参数可以使用make的函数 ifneq 12345ifneq (&lt;arg1&gt;, &lt;arg2&gt;)ifneq &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;ifneq &quot;&lt;arg1&gt;&quot; &#x27;&lt;arg2&gt;&#x27;ifneq &#x27;&lt;arg1&gt;&#x27; &quot;&lt;arg2&gt;&quot; 比较参数 arg1 和 arg2 的值是否相同，如果不同，则为真 ifdef 1ifdef &lt;variable-name&gt; 如果变量 &lt;variable-name&gt; 的值非空，那到表达式为真 &lt;variable-name&gt; 同样可以是一个函数的返回值 ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置，如： 123456789101112131415161718# 示例1bar =foo = $(bar)ifdef foo frobozz = yeselse frobozz = noendif# frobozz的结果为yes# 示例2foo =ifdef foo frobozz = yeselse frobozz = noendif# frobozz的结果为no ifndef 1ifndef &lt;variable-name&gt; 与 ifdef 相反 使用函数 函数调用语法 以 $ 来标识： 1$(&lt;function&gt; &lt;arguments&gt;) &lt;function&gt; 就是函数名 &lt;arguments&gt; 为函数的参数，参数间以逗号 , 分隔 函数名和参数之间以“空格”分隔 字符串处理函数 subst 1$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;) 名称：字符串替换函数 功能：把字串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt; 返回：函数返回被替换过后的字符串 示例： 1$(subst ee,EE,feet on the street) 把 feet on the street 中的 ee 替换成 EE ，返回结果是 fEEt on the strEEt patsubst 1$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 名称：模式字符串替换函数 功能：查找 &lt;text&gt; 中的单词（单词以空格、Tab或回车换行分隔）是否符合模式 &lt;pattern&gt; ，如果匹配的话，则以 &lt;replacement&gt; 替换 &lt;pattern&gt; 可以包括通配符 % 如果 &lt;replacement&gt; 中也包含 % ，那么， &lt;replacement&gt; 中的这个 % 将是 &lt;pattern&gt; 中的那个 % 所代表的字串 可以用 \\ 来转义，以 \\% 来表示真实含义的 % 字符 返回：函数返回被替换过后的字符串 示例： 1$(patsubst %.c,%.o,x.c.c bar.c) 把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o 注： $(var:&lt;pattern&gt;=&lt;replacement&gt;;) 相当于 $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var)) $(var: &lt;suffix&gt;=&lt;replacement&gt;) 相当于$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var)) 如： 1objects = foo.o bar.o baz.o， 那么， $(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的 strip 1$(strip &lt;string&gt;) 名称：去空格函数 功能：去掉 &lt;string&gt; 字串中开头和结尾的空字符 返回：返回被去掉空格的字符串值 示例： 1$(strip a b c ) 把字串 &quot;a b c “去掉开头和结尾的空字符，结果为&quot;a b c” findstring 1$(findstring &lt;find&gt;,&lt;in&gt;) 名称：查找字符串函数 功能：在字串 &lt;in&gt; 中查找 &lt;find&gt; 字串 返回：如果找到，那么返回 &lt;find&gt; ，否则返回空字符串 示例： 12$(findstring a,a b c)$(findstring a,b c) 第一个函数返回 a 字符串，第二个返回空字符串 filter 1$(filter &lt;pattern...&gt;,&lt;text&gt;) 名称：过滤函数 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词。可以有多个模式 返回：返回符合模式 &lt;pattern&gt; 的字串 示例： 123sources := foo.c bar.c baz.s ugh.hfoo: $(sources) cc $(filter %.c %.s,$(sources)) -o foo $(filter %.c %.s,$(sources)) 返回的值为 foo.c bar.c baz.s filter-out 1$(filter-out &lt;pattern...&gt;,&lt;text&gt;) 名称：反过滤函数 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，去除符合模式 &lt;pattern&gt; 的单词。可以有多个模式 返回：返回不符合模式 &lt;pattern&gt; 的字串 示例： 12objects=main1.o foo.o main2.o bar.omains=main1.o main2.o $(filter-out $(mains),$(objects)) 返回值为 foo.o bar.o sort 1$(sort &lt;list&gt;) 名称：排序函数 功能：给字符串 &lt;list&gt; 中的单词排序（升序） 返回：返回排序后的字符串 示例： $(sort foo bar lose) 返回 bar foo lose 备注： sort 函数会去掉 &lt;list&gt; 中相同的单词 word 1$(word &lt;n&gt;,&lt;text&gt;) 名称：取单词函数 功能：取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从1开始数） 返回：返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串 示例： $(word 2, foo bar baz) 返回值是 bar wordlist 1$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;) 名称：取单词串函数 功能：从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。 &lt;ss&gt; 和 &lt;e&gt; 是一个数字 返回：返回字符串 &lt;text&gt; 中从 &lt;ss&gt; 到 &lt;e&gt; 的单词字串。如果 &lt;ss&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。如果 &lt;e&gt; 大于 &lt;text&gt; 的单词数，那么返回从 &lt;ss&gt; 开始，到 &lt;text&gt; 结束的单词串 示例： $(wordlist 2, 3, foo bar baz) 返回值是 bar baz words 1$(words &lt;text&gt;) 名称：单词个数统计函数 功能：统计 &lt;text&gt; 中字符串中的单词个数 返回：返回 &lt;text&gt; 中的单词数 示例： $(words, foo bar baz) 返回值是 3 备注：如果我们要取 &lt;text&gt; 中最后的一个单词，我们可以这样： $(word $(words &lt;text&gt;),&lt;text&gt;) firstword 1$(firstword &lt;text&gt;) 名称：首单词函数 功能：取字符串 &lt;text&gt; 中的第一个单词 返回：返回字符串 &lt;text&gt; 的第一个单词 示例： $(firstword foo bar) 返回值是 foo 备注：这个函数可以用 word 函数来实现： $(word 1,&lt;text&gt;) 函数应用实例 make使用 VPATH 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS ，如： 1override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH))) 如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers ，这正是cc或gcc搜索头文件路径的参数 文件名操作函数 dir 1$(dir &lt;names...&gt;) 名称：取目录函数 功能：从文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./ 返回：返回文件名序列 &lt;names&gt; 的目录部分 示例： $(dir src/foo.c hacks) 返回值是 src/ ./ notdir 1$(notdir &lt;names...&gt;) 名称：取文件函数 功能：从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分 返回：返回文件名序列 &lt;names&gt; 的非目录部分 示例: $(notdir src/foo.c hacks) 返回值是 foo.c hacks basename 1$(basename &lt;names...&gt;) 名称：取前缀函数 功能：从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分 返回：返回文件名序列 &lt;names&gt; 的前缀序列，如果文件没有前缀，则返回空字串 示例： $(basename src/foo.c src-1.0/bar.c hacks) 返回值是 src/foo src-1.0/bar hacks addsuffix 1$(addsuffix &lt;suffix&gt;,&lt;names...&gt;) 名称：加后缀函数 功能：把后缀 &lt;suffix&gt; 加到 &lt;names&gt; 中的每个单词后面 返回：返回加过后缀的文件名序列 示例： $(addsuffix .c,foo bar) 返回值是 foo.c bar.c addprefix 1$(addprefix &lt;prefix&gt;,&lt;names...&gt;) 名称：加前缀函数 功能：把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词前面 返回：返回加过前缀的文件名序列 示例： $(addprefix src/,foo bar) 返回值是 src/foo src/bar join 1$(join &lt;list1&gt;,&lt;list2&gt;) 名称：连接函数 功能：把 &lt;list2&gt; 中的单词对应地加到 &lt;list1&gt; 的单词后面。如果 &lt;list1&gt; 的单词个数要比 &lt;list2&gt; 的多，那么， &lt;list1&gt; 中的多出来的单词将保持原样。如果 &lt;list2&gt; 的单词个数要比 &lt;list1&gt; 多，那么， &lt;list2&gt; 多出来的单词将被复制到 &lt;list1&gt; 中 返回：返回连接过后的字符串 示例： $(join aaa bbb , 111 222 333) 返回值是 aaa111 bbb222 333 foreach函数 1$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) 把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中 然后再执行 &lt;text&gt; 所包含的表达式 每一次 &lt;text&gt; 会返回一个字符串，循环过程中，&lt;text&gt; 的所返回的每个字符串会以空格分隔 最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值 &lt;var&gt; 一般是变量名，&lt;list&gt; 可以是表达式，&lt;text&gt; 一般使用 &lt;var&gt; 这个参数来枚举 &lt;list&gt; 中的单词 &lt;var&gt; 参数是一个临时的局部变量，foreach函数执行完后，参数 &lt;var&gt; 的变量将不在作用 示例： 12345names := a b c dfiles := $(foreach n,$(names),$(n).o)# files的值为 &quot;a.o b.o c.o d.o&quot; if函数 12345$(if &lt;condition&gt;,&lt;then-part&gt;)# 或$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;) if函数的返回值：如果 &lt;condition&gt; 为真（非空字符串）， &lt;then-part&gt; 会是整个函数的返回值；如果 &lt;condition&gt; 为假（空字符串），那么 &lt;else-part&gt; 会是整个函数的返回值，此时如果 &lt;else-part&gt; 没有被定义，那么，整个函数返回空字串 call函数 可以用来创建新的参数化的函数： 1$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;) &lt;expression&gt; 参数中的变量，如 $(1) 、 $(2) 等，会被参数 &lt;parm1&gt; 、 &lt;parm2&gt; 、 &lt;parm3&gt; 依次取代。而 &lt;expression&gt; 的返回值就是 call 函数的返回值，如： 1234reverse = $(2) $(1)foo = $(call reverse,a,b)# foo的值为 &quot;b a&quot; 需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。 origin函数 1$(origin &lt;variable&gt;) 注意， &lt;variable&gt; 是变量的名字，不应该是引用。所以你最好不要在 &lt;variable&gt; 中使用 $ 字符。 origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值: undefined ： &lt;variable&gt; 从来没有定义过， default ： &lt;variable&gt; 是一个默认的定义，比如“CC”这个变量 environment ： &lt;variable&gt; 是一个环境变量，并且当Makefile被执行时， -e 参数没有被打开 file ： &lt;variable&gt; 被定义在Makefile中 command line ：&lt;variable&gt; 是被命令行定义的 override ：&lt;variable&gt; 是被override指示符重新定义的 automatic ：&lt;variable&gt; 是一个命令运行中的自动化变量 假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写： 12345ifdef bletch ifeq &quot;$(origin bletch)&quot; &quot;environment&quot; bletch = barf, gag, etc. endifendif shell函数 shell函数的参数是操作系统shell的命令，shell函数把执行操作系统命令后的输出作为函数返回，于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如： 12contents := $(shell cat foo)files := $(shell echo *.c) 这个函数会新生成一个Shell程序来执行命令，所以要注意其运行性能 控制make的函数 检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止： error函数 1$(error &lt;text ...&gt;) 产生一个致命的错误， &lt;text ...&gt; 是错误信息 示例1： 1234ifdef ERROR_001 $(error error is $(ERROR_001))endif# 在变量ERROR_001定义了后执行时产生error调用 示例2： 1234567ERR = $(error found an error!).PHONY: errerr: $(ERR)# 在目录err被执行时发生error调用 warning函数 1$(warning &lt;text ...&gt;) 和 error 函数很像，但是不会让make退出，只是输出一段警告信息，而make继续执行 make的运行 make的退出码 make命令执行后有三个退出码： 0：表示成功执行 1：如果make运行时出现任何错误，返回1 2：如果使用make的“-q”选项，并且make使得一些目标不需要更新，那么返回2 指定makefile 使用 -f 或 --file 或 --makefile 参数： 1make –f hchen.mk 指定目标 一般来说，make的最终目标是makefile中的第一个目标 可以指示make，让其完成你所指定的目标：需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式） 有一个make的环境变量叫 MAKECMDGOALS ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值，使用方法如： 1234sources = foo.c bar.cifneq ( $(MAKECMDGOALS),clean) include $(sources:.c=.d)endif 只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile 检查规则 有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列，可以使用以下参数： -n, --just-print, --dry-run, --recon ：不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行 -t, --touch ：把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态 -q, --question ：找目标，如果目标存在，那么什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息 -W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt; ：指定一个文件。一般是是源文件（或依赖文件），make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令 make的参数 -b, -m ：忽略和其它版本make的兼容性 -B, --always-make ：认为所有的目标都需要更新（重编译） -C &lt;dir&gt;, --directory=&lt;dir&gt; ：指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog” -debug[=&lt;options&gt;] ：输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值： a: 也就是all，输出所有的调试信息（会非常的多） b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标 v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等 i: 也就是implicit，输出所以的隐含规则 j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等 m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息 -d ：相当于“–debug=a” -e, --environment-overrides ：指明环境变量的值覆盖makefile中定义的变量的值 -f=&lt;file&gt;, --file=&lt;file&gt;, --makefile=&lt;file&gt; ：指定需要执行的makefile -h, --help ：显示帮助信息 -i, --ignore-errors ：在执行时忽略所有的错误 -I&lt;dir&gt;, --include-dir=&lt;dir&gt; ：指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录 -j [&lt;jobsnum&gt;], --jobs[=&lt;jobsnum&gt;] ：指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的 -k, --keep-going ：出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了 -l &lt;load&gt;, --load-average[=&lt;load&gt;], --max-load[=&lt;load&gt;] ：指定make运行命令的负载 -n, --just-print, --dry-run, --recon ：仅输出执行过程中的命令序列，但并不执行 -o &lt;file&gt;, --old-file=&lt;file&gt;, --assume-old=&lt;file&gt; ：不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它 -p, --print-data-base ：输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用 “make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号 -q, --question ：不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生 -r, --no-builtin-rules ：禁止make使用任何隐含规则 -R, --no-builtin-variables ：禁止make使用任何作用于变量上的隐含规则 -s, --silent, --quiet ：在命令运行时不输出命令的输出 -S, --no-keeping-going, --stop ：取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效 -t, --touch ：相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行 -v, --version ：输出make程序的版本、版权等关于make的信息 -w, --print-directory ：输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用 --no-print-directory ：禁止“-w”选项 -W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt; ：假定目标&lt;file&gt;;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作；如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;;的修改时间为当前时间 --warn-undefined-variables ：只要make发现有未定义的变量，那么就输出警告信息 隐含规则 使用隐含规则 12foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 这个Makefile中并没有写下如何生成 foo.o 和 bar.o 这两目标的规则和命令。因为make调用的隐含规则，把 .o 的目标的依赖文件置成 .c ，并使用C的编译命令 cc –c $(CFLAGS) foo.c 来生成 foo.o 的目标 一些语言的隐含规则 编译C程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS) 编译C++程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.cc 或是 &lt;n&gt;.C ，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS) 。（建议使用 .cc 作为C++源文件的后缀，而不是 .C ） 编译Pascal程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.p ，并且其生成命令是 $(PC) –c $(PFLAGS) 。 编译Fortran/Ratfor程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F 或 &lt;n&gt;.f ，并且其生成命令是: .f $(FC) –c $(FFLAGS) .F $(FC) –c $(FFLAGS) $(CPPFLAGS) 预处理Fortran/Ratfor程序的隐含规则。 &lt;n&gt;.f 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是： .F $(FC) –F $(CPPFLAGS) $(FFLAGS) .r $(FC) –F $(FFLAGS) $(RFLAGS) 编译Modula-2程序的隐含规则。 &lt;n&gt;.sym 的目标的依赖目标会自动推导为 &lt;n&gt;.def ，并且其生成命令是： $(M2C) $(M2FLAGS) $(DEFFLAGS) 。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.mod ，并且其生成命令是： $(M2C) $(M2FLAGS) $(MODFLAGS) 。 汇编和汇编预处理的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.s ，默认使用编译器 as ，并且其生成命令是： $ (AS) $(ASFLAGS) 。 &lt;n&gt;.s 的目标的依赖目标会自动推导为 &lt;n&gt;.S ，默认使用C预编译器 cpp ，并且其生成命令是： $(AS) $(ASFLAGS) 。 链接Object文件的隐含规则。 &lt;n&gt; 目标依赖于 &lt;n&gt;.o ，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是： $(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则: 1x : y.o z.o 并且 x.c 、 y.c 和 z.c 都存在时，隐含规则将执行如下命令: 1234567cc -c x.c -o x.occ -c y.c -o y.occ -c z.c -o z.occ x.o y.o z.o -o xrm -f x.orm -f y.orm -f z.o 如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。 Yacc C程序时的隐含规则。 &lt;n&gt;.c 的依赖文件被自动推导为 n.y （Yacc生成的文件），其生成命令是： $(YACC) $(YFALGS) 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料） Lex C程序时的隐含规则。 &lt;n&gt;.c 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。（关于“Lex”的细节请查看相关资料） Lex Ratfor程序时的隐含规则。 &lt;n&gt;.r 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。 从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。 &lt;n&gt;.ln （lint生成的文件）的依赖文件被自动推导为 n.c ，其生成命令是： $(LINT) $(LINTFALGS) $(CPPFLAGS) -i 。对于 &lt;n&gt;.y 和 &lt;n&gt;.l 也是同样的规则。 隐含规则使用的变量 关于命令的变量 AR : 函数库打包程序。默认命令是 ar AS : 汇编语言编译程序。默认命令是 as CC : C语言编译程序。默认命令是 cc CXX : C++语言编译程序。默认命令是 g++ CO : 从 RCS文件中扩展文件程序。默认命令是 co CPP : C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77 GET : 从SCCS文件中扩展文件的程序。默认命令是 get LEX : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex PC : Pascal语言编译程序。默认命令是 pc YACC : Yacc文法分析器（针对于C程序）。默认命令是 yacc YACCR : Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r MAKEINFO : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo TEX : 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex TEXI2DVI : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi WEAVE : 转换Web到TeX的程序。默认命令是 weave CWEAVE : 转换C Web 到 TeX的程序。默认命令是 cweave TANGLE : 转换Web到Pascal语言的程序。默认命令是 tangle CTANGLE : 转换C Web 到 C。默认命令是 ctangle RM : 删除文件命令。默认命令是 rm –f 关于命令参数的变量 如果没有指明默认值，则为空 ARFLAGS : 函数库打包程序AR命令的参数。默认值是 rv ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时） CFLAGS : C语言编译器参数 CXXFLAGS : C++语言编译器参数 COFLAGS : RCS命令参数 CPPFLAGS : C预处理器参数。（ C 和 Fortran 编译器也会用到） FFLAGS : Fortran语言编译器参数 GFLAGS : SCCS “get”程序参数 LDFLAGS : 链接器参数。（如： ld ） LFLAGS : Lex文法分析器参数。 PFLAGS : Pascal语言编译器参数 RFLAGS : Ratfor 程序的Fortran 编译器参数 YFLAGS : Yacc文法分析器参数 隐含规则链 有些时候，一个目标可能被一系列的隐含规则所作用。 例如，一个 .o 的文件生成，可能会是先被 Yacc的[.y]文件生成 .c ，然后再被C的编译器生成： 如果文件 .c 存在，那么就直接调用C的编译器的隐含规则 如果没有 .c 文件，但有一个 .y 文件，那么Yacc的隐含规则会被调用，生成 .c 文件，然后，再调用C编译的隐含规则最终由 .c 生成 .o 文件，达到目标 我们把这种 .c 的文件（或是目标），叫做中间目标 除非中间的目标不存在，才会引发中间规则 只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以 rm -f 删除 中间目标 显式说明一个文件或是目标是中间目标：.INTERMEDIATE : mid 阻止make自动删除中间目标：.SECONDARY : sec 在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况 模式规则 使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 % 字符；在依赖目标中同样可以使用 % ，只是依赖目标中的 % 的取值，取决于其目标。 注意： % 的展开发生在变量和函数的展开之后 变量和函数的展开发生在make载入Makefile时 模式规则中的 % 展开发生在运行时 模式规则示例 12%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@ 把所有的 .c 文件都编译成 .o 文件 12%.tab.c %.tab.h: %.y bison -d $&lt; 这条规则告诉make把所有的 .y 文件都以 bison -d &lt;n&gt;.y 执行，然后生成 &lt;n&gt;.tab.c 和 &lt;n&gt;.tab.h 文件（其中， &lt;n&gt; 表示一个任意字符串） 如果我们的执行程序 foo 依赖于文件 parse.tab.o 和 scan.o ，并且文件 scan.o 依赖于文件 parse.tab.h ，如果 parse.y 文件被更新了，那么根据上述的规则， bison -d parse.y 就会被执行一次，于是， parse.tab.o 和 scan.o 的依赖文件就齐了。（假设， parse.tab.o 由 parse.tab.c 生成，和 scan.o 由 scan.c 生成，而 foo 由 parse.tab.o 和 scan.o 链接生成，而且 foo 和其 .o 文件的依赖关系也写好，那么，所有的目标都会得到满足） 自动化变量 把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完 $@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， $@ 就是匹配于目标中模式定义的集合 $% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ，那么， $% 就是 bar.o ， $@ 就是 foo.a 。如果目标不是函数库文件（Unix下是 .a ，Windows下是 .lib ），那么，其值为空 $&lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的 $? : 所有比目标新的依赖目标的集合。以空格分隔 $^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份 $+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标 $* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么， $* 的值就是 dir/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 $* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为 .c 是make所能识别的后缀名，所以， $* 的值就是 foo 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 $* 就是空值 当你希望只对更新过的依赖文件进行操作时， $? 在显式规则中很有用，例如，假设有一个函数库文件叫 lib ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是： 12lib : foo.o bar.o lose.o win.o ar r lib $? 在上述所列出来的自动量变量中。四个变量（ $@ 、 $&lt; 、 $% 、 $* ）在扩展时只会有一个文件，而另三个的值是一个文件列表。 这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 D 或 F 字样： $(@D)：表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录） $(@F)：表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。 $(*D), $(*F)：和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ，而 $(*F) 返回 `foo`` ``$(%D), $(%F)：分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member)形式的目标中的member` 中包含了不同的目录很有用。 $(&lt;D), $(&lt;F)：分别表示依赖文件的目录部分和文件部分。 $(^D), $(^F)：分别表示所有依赖文件的目录部分和文件部分。（无相同的） $(+D), $(+F)：分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） $(?D), $(?F)：分别表示被更新的依赖文件的目录部分和文件部分 重载内建隐含规则 重新构造和内建隐含规则不同的命令，如： 12%.o : %.c $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date) 取消内建的隐含规则，只要不在后面写命令就行。如： 1%.o : %.s 隐含规则搜索算法 比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。如果目标是 archive(member) 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 member 当作T来搜索。 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 src/foo.o ，那么，D就是 src/ ，N就是 foo.o ） 创建所有匹配于T或是N的模式规则列表。 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。 移除列表中没有命令的规则。 对于第一个在列表中的模式规则： 推导其“茎”S，S应该是T或是N匹配于模式中 % 非空的部分。 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”） 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则： 如果规则是终止规则，那就忽略它，继续下一条模式规则。 计算依赖文件。（同第5步） 测试所有的依赖文件是否存在或是理当存在。 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。 一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。 使用make更新函数库文件 函数库文件也就是对Object文件（程序编译的中间文件）的打包文件 在Unix下，一般是由命令 ar 来完成打包工作 函数库文件的成员 一个函数库文件由多个文件组成，指定函数库文件及其组成： 1archive(member) 从而在 ar 命令中，如此使用： 12foolib(hack.o) : hack.o kludge.o ar cr foolib(hack.o kludge.o) 函数库成员的隐含规则 当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m) 。于是，如果我们的成员是 %.o 的模式定义，并且如果我们使用 make foo.a(bar.o) 的形式调用Makefile时，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，make会去找 bar.c 文件来生成 bar.o ，如果找得到的话，make执行的命令大致如下: 123cc -c bar.c -o bar.oar r foo.a bar.orm -f bar.o","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"Rust更换项目编译的Channel","slug":"rustup-channel","date":"2021-03-02T16:00:00.000Z","updated":"2021-03-02T18:30:20.000Z","comments":true,"path":"2021/03/03/rustup-channel/","link":"","permalink":"http://example.com/2021/03/03/rustup-channel/","excerpt":"使用非稳定版的nightly环境编译项目","text":"查看可用的Channel： 1rustup toolchain list 在项目根目录输入命令修改本项目的编译环境： 1rustup override set nightly","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Rust-SGX环境配置","slug":"sgx-rust-install","date":"2020-12-09T16:00:00.000Z","updated":"2021-02-14T18:29:26.000Z","comments":true,"path":"2020/12/10/sgx-rust-install/","link":"","permalink":"http://example.com/2020/12/10/sgx-rust-install/","excerpt":"Rust-SGX-SDK的移植使用","text":"安装Intel SGX SGX Driver：根据官方github安装 SGX PSW：根据安装手册安装 SGX SDK：下载sgx_linux_x64_sdk_2.12.100.3.bin，根据安装手册安装 下载Rust-SGX-SDK 1git clone --depth 1 https://github.com/apache/incubator-teaclave-sgx-sdk.git ~/sgx/sgx-rust-sdk 添加环境变量 在~/.bashrc文件最后添加： 12export SGX_SDK_RUST=$HOME/sgx/sgx-rust-sdkexport SGX_SDK=/opt/intel/sgxsdk 再在终端执行 source ~/.bashrc 解决：Enclave代码运行出错（Invalid SGX Driver） 不清楚什么原因，反正重装一遍SGX Driver就好了 卸载： 1234$ sudo /sbin/modprobe -r isgx$ sudo rm -rf &quot;/lib/modules/&quot;`uname -r`&quot;/kernel/drivers/intel/sgx&quot;$ sudo /sbin/depmod$ sudo /bin/sed -i &#x27;/^isgx$/d&#x27; /etc/modules cd到 /opt/intel/linux-sgx-driver： 1234567$ sudo make clean$ sudo make$ sudo mkdir -p &quot;/lib/modules/&quot;`uname -r`&quot;/kernel/drivers/intel/sgx&quot; $ sudo cp isgx.ko &quot;/lib/modules/&quot;`uname -r`&quot;/kernel/drivers/intel/sgx&quot; $ sudo sh -c &quot;cat /etc/modules | grep -Fxq isgx || echo isgx &gt;&gt; /etc/modules&quot; $ sudo /sbin/depmod$ sudo /sbin/modprobe isgx","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Ubuntu设置终端只显示当前所在目录","slug":"ubuntu-terminal-path","date":"2020-12-08T16:00:00.000Z","updated":"2021-04-07T08:43:27.774Z","comments":true,"path":"2020/12/09/ubuntu-terminal-path/","link":"","permalink":"http://example.com/2020/12/09/ubuntu-terminal-path/","excerpt":"Ubuntu终端显示路径设置为当前目录，而不是全路径","text":"修改~/.bashrc文件： 1234if [ &quot;$color_prompt&quot; = yes ]; then PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ &#x27;else PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ &#x27; 将上面语句中的 w 改为大写的 W 若要查看绝对路径，使用命令 pwd 即可","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Useful","slug":"Useful","permalink":"http://example.com/categories/Useful/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Rust错误处理","slug":"rust-error","date":"2020-12-03T16:00:00.000Z","updated":"2020-12-03T18:04:46.000Z","comments":true,"path":"2020/12/04/rust-error/","link":"","permalink":"http://example.com/2020/12/04/rust-error/","excerpt":"Rust中的错误处理方法整理","text":"对于 Result、Option等类型，如果使用 unwrap、expect等方法，会直接导致panic 对于 Result 类型，如果遇到错误只需要返回 None，那么可以使用如下简单的语法来替代 match : 1let some_var = something_that_returns_result().ok()?; 其中，Result::ok() 函数将 Result 转换为 Option： 对于 Ok(val)，返回 Some(val)； 对于 Err(some_error)，返回 None ? 提取 Option 中的内容，如果为 None，则返回 None","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Vscode快捷键","slug":"Vscode快捷键","date":"2020-12-02T16:00:00.000Z","updated":"2021-04-07T08:42:16.393Z","comments":true,"path":"2020/12/03/Vscode快捷键/","link":"","permalink":"http://example.com/2020/12/03/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"记录一些好用的vscode快捷键","text":"Ctrl+J : 隐藏(显示)底下的控制台/终端面板 Ctrl+Shift+P : 调出搜索设置 Ctrl+Shift+C : 在当前目录调出外部终端 Home ：光标移动到行首 End ：光标移动到行尾","categories":[{"name":"Useful","slug":"Useful","permalink":"http://example.com/categories/Useful/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}]},{"title":"解决 Blocking waiting for file lock on package cache","slug":"rust-cargo-block","date":"2020-12-02T16:00:00.000Z","updated":"2020-12-03T08:07:36.728Z","comments":true,"path":"2020/12/03/rust-cargo-block/","link":"","permalink":"http://example.com/2020/12/03/rust-cargo-block/","excerpt":"解决rust程序在cargo run时由于Blocking waiting for file lock on package cache无法编译的问题","text":"删除 home/.cargo/.package-cache 文件再重新编译即可","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"cargo","slug":"cargo","permalink":"http://example.com/tags/cargo/"}]},{"title":"翻译-SGX Analysis","slug":"translation-sgx-analysis","date":"2020-11-28T16:00:00.000Z","updated":"2020-11-29T09:01:38.983Z","comments":true,"path":"2020/11/29/translation-sgx-analysis/","link":"","permalink":"http://example.com/2020/11/29/translation-sgx-analysis/","excerpt":"论文Intel SGX Explained中的SGX Analysis部分翻译","text":"放在博客上链接不能跳转指定标题，暂时没有办法解决 6.1 SGX实现概述 SGX设计实现的一个未被记录和忽视的成就是，在英特尔处理器上实现它对芯片的硬件设计有非常低的影响。SGX对处理器执行核心(§2.9.4)的修改要么非常小，要么根本不存在。CPU的非核心(§2.9.3，§2.11.3)接收一个新的模块，内存加密引擎，它看起来是相当独立的。 SGX的大部分实现都归属于处理器的微码(§2.14)，它支持比芯片电路高得多的开发速度。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Translation","slug":"Translation","permalink":"http://example.com/categories/Translation/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"翻译-SGX Programming Model","slug":"translation-sgx-programming-model","date":"2020-11-27T16:00:00.000Z","updated":"2021-02-27T15:57:00.373Z","comments":true,"path":"2020/11/28/translation-sgx-programming-model/","link":"","permalink":"http://example.com/2020/11/28/translation-sgx-programming-model/","excerpt":"论文Intel SGX Explained中的SGX Programming Model部分翻译","text":"放在博客上链接不能跳转指定标题，暂时没有办法解决 SGX的核心概念是enclave，一个受保护的环境，其中包含与安全敏感计算相关的代码和数据。 启用sgx的处理器通过将每个enclave的环境与enclave外部的不受信任的软件隔离，并实现允许远程方对运行在enclave内部的软件进行身份验证的软件认证方案，从而提供可信的计算。SGX的隔离机制旨在保护在enclave内执行的计算的机密性和完整性，防止来自同一台计算机上的恶意软件的攻击，以及一小部分物理攻击。 5.1 SGX物理内存组织 Enclave的代码和数据存储在 Processor Reserved Memory (PRM)中，PRM是DRAM的一个子集，不能被其他软件(包括系统软件和SMM代码)直接访问。CPU的集成内存控制器也拒绝针对PRM的DMA传输，从而保护它不被其他外设访问。 PRM是一个连续的内存范围，其边界使用一个基地址和一个掩码寄存器来决定，与可变内存类型范围具有相同的语义。因此，PRM的大小必须是2的整数次幂，并且它的起始地址必须对齐到同样的2次幂。由于这些限制，检查一个地址是否属于PRM可以在硬件上很容易地完成。 5.1.1 Enclave页面缓存 (EPC) Enclave的内容和相关的数据结构存储在Enclave页面缓存(EPC)中，EPC是PRM的一个子集，PRM是DRAM的一个连续范围，不能被系统软件或外设访问。如图所示： SGX设计支持同时在一个系统上有多个enclaves，这在多进程环境中是必需的。这是通过将EPC拆分为4 KB的页面来实现的，这些页面可以分配给不同的enclaves。EPC使用与体系结构的地址转换特性相同的页面大小。 EPC由管理计算机其余物理内存的系统软件管理。系统软件(可以是管理程序或操作系统内核)使用SGX指令将未使用的页面分配给enclaves，并释放之前分配的EPC页面。系统软件将向应用程序软件公开enclave创建和管理服务。 非enclave软件不能直接访问EPC，因为它包含在PRM中。这一限制在SGX的enclave隔离保证中发挥了关键作用，但当系统软件需要将初始代码和数据加载到新创建的enclave中时，就会造成障碍。SGX通过将分配EPC页面的指令同时也用作初始化页面的指令来解决这个问题。大多数EPC页是通过从非PRM内存页复制数据来初始化的。 5.1.2 Enclave页面缓存映射表 (EPCM) SGX设计期望系统软件将EPC页面分配给enclave。然而，由于系统软件不受信任，SGX处理器会检查系统软件分配的正确性，并拒绝执行任何危及SGX安全保证的行为。例如，如果系统软件试图将相同的EPC页面分配给两个enclaves，则执行分配的SGX指令将失败。 为了执行安全检查，SGX在 Enclave Page Cache Map (EPCM)中记录一些关于系统软件对每个EPC页面的分配决策的信息。EPCM是一个数组，每个EPC页面对应一个条目，因此计算页面的EPCM入口地址只需要逐位移位操作和加操作。 EPCM的内容仅用于SGX的安全检查。在正常操作下，EPCM不会产生任何软件可见的行为，因而enclave作者和系统软件开发人员基本上可以忽略它。因此，SDM (Intel’s Software Developer Manual) 只在非常高的级别上描述EPCM，列出其中包含的信息，并指出EPCM是“受信任的内存”，而没有公开EPCM使用的存储介质或内存布局。 EPCM使用下表中的字段来跟踪每个EPC页面的所有权。我们将EPCM的完整讨论推迟到后面的部分，因为它的内容与SGX的所有特征紧密结合，这将在接下来的几节中进行描述。 分配EPC页的SGX指令将相应EPCM条目的VALID位设置为1，并拒绝对已经设置了VALID位的EPC页进行操作。 分配EPC页的指令还决定了该页的预期用途，该用途记录在相应EPCM条目的 page type (PT)字段中。存储enclave代码和数据的页面被认为具有常规类型 PT_REG 。专用于存储SGX支持数据结构的页面被标记为特殊类型。例如，PT_SECS 类型标识保存SGX Enclave控制结构的页面，这将在下一节中进行描述。其他EPC页面类型将在以后的章节中描述。 最后，页面的EPCM条目还标识拥有EPC页面的enclave，此字段防止一个enclave访问另一个enclave的私有信息。由于EPCM为每个EPC页面标识一个具有所有权的enclave，因此enclave不可能使用EPC页面通过共享内存进行通信。幸运的是，enclaves可以共享不可信的非EPC内存，这将在§5.2.3中讨论。 5.1.3 SGX Enclave控制结构 (SECS) SGX将每个Enclave元数据存储在与每个Enclave关联的 SGX Enclave Control Structure (SECS)中。每个SECS存储在专用的EPC页面中，页面类型为 PT_SECS。 Enclave的身份几乎等同于它的SECS。启用enclave的第一步是分配EPC页面作为enclave的SECS，销毁enclave的最后一步是释放保存其SECS的页面。标识拥有EPC页面的enclave的EPCM入口字段指向enclave的SECS。当调用SGX指令时，系统软件使用SECS的虚拟地址来识别enclave。 所有SGX指令都以虚拟地址作为输入。由于SGX指令使用SECS地址来标识enclave，系统软件必须在其页表中创建指向其管理的enclave的SECS的条目。但是，系统软件不能访问任何SECS页面，因为这些页面存储在PRM中。SECS页面不会映射到它们的enclave的虚拟地址空间中，并且启用SGX的处理器显式地阻止enclave代码访问SECS页面。 这个看似随意的限制是为了使SGX实现能够在SECS内存储敏感信息，并且能够假定没有潜在的恶意软件能够访问该信息。例如，SDM声明每个enclave的度量都存储在SECS中。如果软件能够修改enclave的测量，SGX的软件认证方案将不能提供安全保证。 5.2 SGX Enclave的内存布局 SGX的设计目的是尽量减少[转换应用程序代码以利用enclave的优势]所需要的工作。历史表明，这是一个明智的决定，因为在英特尔架构的持续主导地位中，一个很大的因素是它保持向后兼容性的能力。为此，SGX enclave在概念上与领先的软件模块化结构，动态加载库类似。动态加载库在Unix上打包为.so文件，在Windows上打包为.dll文件。 为简单起见，我们描述enclave和非enclave软件之间的交互时假设每个enclave都由一个应用程序进程使用，我们将其称为enclave的主进程。但是，我们注意到SGX的设计并没有明确地禁止多个应用程序进程共享一个enclave。 5.2.1 Enclave线性地址范围 (ELRANGE) 每个enclave在其虚拟地址空间中指定一个区域，称为 Enclave Linear Address Range (ELRANGE)，该区域用于映射存储在enclave的EPC页面中的代码和敏感数据。ELRANGE之外的虚拟地址空间用于访问主进程的其他内存，内存映射使用系统软件管理的页表建立。如下图所示: SGX的设计保证了enclave在ELRANGE内部的内存访问服从虚拟内存抽象，而在ELRANGE外部的内存访问没有得到保证。因此，enclave必须将其所有代码和私有数据存储在ELRANGE内，并且必须将ELRANGE外的内存视为对外部世界的不可信接口。 ELRANGE中的“线性”一词指的是64位Intel架构中残余分割特性产生的线性地址。在大多数情况下，“linear”可以看作是“virtual”的同义词。 ELRANGE在enclave的SECS(§5.1.3)中使用一个基地址(BASEADDR字段)和一个大小(SIZE)来指定。ELRANGE必须满足与可变内存类型范围和PRM范围(§5.1)相同的约束条件，即大小必须是2的幂，并且基地址必须与大小对齐。有了这些限制，SGX实现就可以容易地检查一个地址是否属于enclave的ELRANGE，无论是在硬件上还是在软件上。 非enclave软件不能访问PRM内存。在PRM内部的内存访问将导致一个中断，该中断在体系结构级别上未定义，在当前处理器上，中断的写将被忽略，中断的读将返回一个所有bit都设置为1的值。在上面描述的场景中，这就发挥了作用，在该场景中，enclave作为动态加载的库加载到主应用程序进程中。该系统软件将ELRANGE中的enclave代码和数据映射到EPC页面。如果应用程序软件试图访问ELRANGE内的内存，它将经历中断原语。当前原语不会导致应用程序崩溃(例如，由于页面错误)，但也保证了主应用程序不能篡改enclave或读取其私有信息。 5.2.2 SGX Enclave属性 Enclave的执行环境很大程度上受到enclave SECS(§5.1.3)中ATTRIBUTES字段的值的影响。此工作的其余部分会将ATTRIBUTES字段的子字段(如下表所示)称为enclave属性。 从安全性的角度来看，最重要的属性是 DEBUG 标志。设置此标志后，将启用SGX的调试特性用于此enclave。这些调试特性包括读取和修改大部分enclave内存的能力。因此，调试应该只在开发环境中设置，因为这会导致enclave失去SGX的所有安全性保证。 SGX保证enclave代码将始终在XCR0寄存器设置为 extended features request mask (XFRM) 所指示的值的情况下运行。Enclave作者希望使用XFRM指定用于生成Enclave代码的编译器所支持的一组架构扩展。显式地指定XFRM允许Intel设计新的架构扩展来改变现有指令的语义，比如内存保护扩展(MPX)，而不必担心在开发时没有注意到新特性的enclave代码的安全影响。 对于使用64位Intel架构的enclave, MODE64BIT标志设置为true。从安全的角度来看，这个标志甚至不应该存在，因为支持次要架构会给SGX实现增加不必要的复杂性，并增加安全漏洞潜入的可能性。32位架构支持很可能是由于英特尔提供广泛向后兼容性的策略，到目前为止，这一策略取得了相当好的效果。清除MODE64BIT标志位可能会造成SGX漏洞，有待研究人员研究。 最后，在创建enclave的SECS时，INIT标志总是为false。这个标志在enclave生命周期的某个时刻被设置为true，这将在§5.3中进行总结。 5.2.3 SGX Enclaves地址转换 在SGX下，操作系统和管理程序仍然完全控制页表和EPT，每个enclave的代码使用和其主应用程序相同的地址转换过程和页表。这将使向现有系统软件添加SGX支持所需的更改量最小化。同时，让不受信任的系统软件管理页表会使SGX遭受§3.7所述的地址转换攻击。正如未来章节将揭示的，SGX设计的复杂性很大程度上可以归因于防止这些攻击的需要。 SGX的主动内存映射攻击防御机制围绕着确保每个EPC页面只能映射到一个特定的虚拟地址。在分配EPC页面时，它的预期虚拟地址记录在该页面的EPCM条目的ADDRESS字段中。 当地址转换的结果是EPC页面的物理地址时，CPU保证提供给地址转换过程的虚拟地址与页面EPCM条目中记录的预期虚拟地址相匹配。 通过确保每个EPC页面的访问权限始终与enclave作者的意图相匹配，SGX还可以防止一些被动内存映射攻击和故障注入攻击。每个EPC页面的访问权限是在分配页面时指定的，并记录在页面EPCM条目中的可读®、可写(W)和可执行(X)字段中，如下表所示: 当一个地址转换解析为一个EPC页面时，相应的EPCM条目的字段将覆盖页表中指定的访问权限属性。例如，EPCM条目中的W字段覆盖可写(W)属性，而X字段覆盖禁用执行(XD)属性。 因此，enclave作者必须在包含enclave的同时包含内存布局信息，这样，加载enclave的系统软件将知道每个enclave页面的预期虚拟内存地址和访问权限。作为回报，SGX设计向enclave作者保证，管理页表和EPT的系统软件将不能以与作者预期不一致的方式设置enclave的虚拟地址空间。 .so和.dll文件格式是SGX打算使用的enclave运载工具，它们已经规定了指定软件模块要使用的虚拟地址，以及模块的每个内存区域所需的访问权限。 最后，启用SGX的CPU将确保ELRANGE内的虚拟内存(§5.2.1)映射到EPC页面。这可以防止系统软件执行地址转换攻击，即将enclave的整个虚拟地址空间映射到PRM之外的DRAM页面，而PRM不会触发上述任何检查，系统软件可以直接访问这些页面。 5.2.4 线程控制结构 (TCS) SGX设计完全采用多核处理器。多个逻辑处理器可以通过不同的线程同时并发地执行同一个enclave的代码。 SGX实现为执行enclave代码的每个逻辑处理器使用一个 Thread Control Structure (TCS)。因此，enclave的作者必须至少提供与enclave支持的最大并发线程数相同的TCS实例。 每个TCS存储在专用的EPC页面中，其EPCM条目类型为 PT_TCS。SDM描述了TCS中的前几个字段。这些字段被认为属于结构的体系结构部分，因此保证在所有支持SGX的处理器上具有相同的语义。 保存TCS的EPC页面的内容不能直接访问，甚至不能由拥有TCS的enclave的代码访问。此限制类似于对访问持有SECS实例的EPC页面的限制。但是，TCS中的体系结构字段可以通过enclave调试指令读取。TCS中的体系结构字段列出了逻辑处理器在执行非enclave代码和enclave代码之间转换时执行的上下文切换。例如，OENTRY字段指定当TCS用于开始执行enclave代码时加载在 指令指针(RIP) 中的值，因此enclave作者可以严格控制enclave的主程序可用的入口点。此外，OFSBASGX和OFSBASGX字段指定了加载在FS和GS段寄存器中的基地址，这通常指向 线程本地存储(TLS)。 5.2.5 状态保存区域 (SSA) 当处理器在enclave中执行代码时遇到硬件异常，比如中断时，它会执行特权级别切换并调用系统软件提供的硬件异常处理程序。然而，在执行异常处理程序之前，处理器需要一个安全的区域来存储enclave代码的执行上下文，这样执行上下文中的信息就不会泄露给不受信任的系统软件。 在SGX设计中，在处理硬件异常时用于存储enclave线程的执行上下文的区域称为 State Save Area (SSA)，如下图所示（enclave虚拟地址空间的一种可能的布局。每个enclave有一个SECS，每个支持的并发线程有一个TCS。每个TCS指向一个SSA序列，并为RIP以及FS和GS的基址指定初始值）。每个TCS引用一个连续的SSA序列。SSA数组偏移量(OSSA)字段指定了第一个SSA在enclave的虚拟地址空间中的位置。SSA数量(NSSA)字段表示可用的SSAs的数量。 每个SSA从EPC页面的开头开始，并使用在enclave的SECS的SSAFRAMESIZE字段中指定的EPC页面数量。通过减少需要处理的特殊情况的数量，这些对齐和大小限制很可能简化了SGX的实现。 Enclave线程的执行上下文由通用寄存器(GPRs)和XSAVE指令的结果组成。因此，执行上下文的大小取决于XSAVE使用的 请求特性位图(RFBM)。enclave中的所有代码都使用相同的RFBM，它是在XFRM enclave属性(§5.2.2)中声明的。为每个SSA保留的EPC页面数量(在SSAFRAMESIZE中指定)必须足够大，以适合XSAVE输出的XFRM指定的特性位图。 SSA存储在常规EPC页面中，其EPCM页面类型为 PT_REG。因此，enclave软件可以访问SSA内容。SSA布局是体系结构的，并且完全记录在SDM中。这为主机应用程序在发生硬件异常后调用enclave异常处理程序并对SSA中的信息进行操作提供了可能性。 5.3 SGX Enclave的生命周期 Enclave的生命周期与资源管理密切相关，特别是EPC页面的分配。因此，在不同生命周期状态之间转换的指令只能由系统软件执行。系统软件将公开以下描述的SGX指令，作为enclave加载和销毁的服务。 下面的小节描述了enclave生命周期中的主要步骤，如下图所示: 5.3.1 创建 当系统软件发出 ECREATE 指令时，一个enclave就诞生了，该指令将一个空闲的EPC页面转换为用于新enclave的SECS(§5.1.3)。 ECREATE 使用系统软件拥有的非EPC页面中的信息初始化新创建的SECS。这个页面指定SDM中定义的所有SECS字段的值，比如BASEADDR和SIZE，使用的是一种体系结构布局，未来的实现保证会保留这种布局。 虽然最初的SGX实现使用的实际SECS布局很可能与架构布局非常接近，但是未来的实现可以自由地改变这个布局，只要它们保持使用架构布局初始化SECS的能力。软件不能访问包含SECS的EPC页面，因此它不能依赖于SECS的内部布局。这是在虚拟机控制结构(VMCS，§2.8.3)中使用的更强的封装版本。 ECREATE 验证用于初始化SECS的信息，如果信息无效，则会导致页面错误(#PF，§2.8.2)或一般保护错误(#GP，§2.8.2)。例如，如果SIZE字段不是2的幂，ECREATE结果是#GP。这种验证，加上软件无法访问SECS这一事实，简化了其他SGX指令的实现，这可以假设SECS内部的信息是有效的。 最后，ECREATE将enclave的INIT属性(§5.2.2)初始化为false值。在INIT属性被设置为true之前，enclave的代码不能执行，在初始化阶段会将INIT设置为true，这将在§5.3.3中描述。 5.3.2 加载 ECREATE 将新创建的SECS标记为未初始化。当enclave的SECS处于这种状态时，系统软件可以使用EADD指令将初始代码和数据加载到enclave中。EADD用于创建TCS页面(§5.2.4)和常规页面。 EADD 从页面信息(PAGEINFO)结构中读取其输入数据，如下图所示。该结构的内容仅用于与SGX实现通信，因此它完全是体系结构的，并在SDM中记录。 目前，PAGEINFO结构包含的将要分配的EPC页面的虚拟地址(LINADDR)、非EPC页面的虚拟地址（其内容将被复制到新分配的EPC页面(SRCPGE)）、一个虚拟地址，解析为SECS的enclave的页面(SECS)以及与新分配的EPC页面相关联的EPCM条目的某些字段的值(SECINFO)。 PAGEINFO结构中的SECINFO字段实际上是一个虚拟内存地址，并指向一个安全信息(SECINFO)结构，其中一些结构如上图所示。SECINFO结构包含新分配的EPC页面的访问权限(R、W、X)及其EPCM页面类型(PT_REG或PT_TCS)。与PAGEINFO一样，SECINFO结构仅用于与SGX实现通信数据，因此它的内容也完全是体系结构的。但是，该结构的大部分64字节内容被保留以备将来使用。 PAGEINFO和SECINFO结构都是由调用EADD指令的系统软件准备的，因此必须包含在非EPC页面中。两个结构必须按照其大小对齐——PAGEINFO是32字节长，因此每个PAGEINFO实例必须是32字节对齐的，而SECINFO是64字节对齐的，因此每个SECINFO实例必须是64字节对齐的。对齐要求可能通过减少必须处理的特殊情况的数量来简化SGX实现。 EADD在修改新分配的EPC页面或其EPCM条目之前验证其输入。最重要的是，尝试将一个页面EADD到SECS处于初始化状态（INIT属性为true）的enclave将导致一个#GP。此外，尝试EADD已经分配的EPC页面(其EPCM条目中的VALID字段为1)将导致一个#PF。EADD还确保页面的虚拟地址位于enclave的ELRANGE内，并且SECINFO中的所有保留字段都被设置为零。 EADD 指令将EPCM条目中的VALID字段置为1？ 在加载enclave时，系统软件还将使用EEXTEND指令，该指令将更新在软件认证过程中使用的enclave度量值。软件认证在§5.8中进行了讨论。 5.3.3 初始化 在将初始代码和数据页面加载到enclave后，系统软件必须使用Launch enclave(LE)来获取EINIT令牌结构，这是通过一个未文档化的过程实现的，将在§5.9.1中详细描述。然后将令牌提供给EINIT指令，该指令将enclave的SECS标记为initialized。 LE是由Intel提供的特权enclave，是使用由Intel以外的第三方编写的enclave的先决条件。LE是SGX的Enclave，因此必须使用本节中描述的进程来创建、加载和初始化它。然而，LE是用一个特殊的Intel密钥加密签名的(§3.1.3)，这个密钥被硬编码到SGX的实现中，这导致**EINIT在初始化LE时没有检查有效的EINIT令牌结构**。 当EINIT成功完成时，它将enclave的INIT属性设置为true。这就为ring 3(§2.3)应用软件使用§5.4中描述的SGX指令执行enclave的代码开辟了道路。另一方面，一旦INIT设置为true，就不能再在该enclave上调用EADD，因此在执行EINIT指令之前，系统软件必须加载构成enclave初始状态的所有页面。 5.3.4 销毁 Enclave完成了它要执行的计算之后，系统软件执行EREMOVE指令来释放enclave使用的EPC页面。 EREMOVE将EPC页面的EPCM条目的VALID字段设置为0，从而将该页面标记为可用。在释放页面之前，EREMOVE确保在拥有要删除的页面的enclave内部没有执行代码的逻辑处理器。 当保存SECS的EPC页面被释放时，enclave将被完全销毁。如果SECS页面被任何其他EPCM条目的ENCLAVESECS字段引用，EREMOVE将拒绝释放该页面，因此，只有在所有enclave页面都被释放之后，才能释放enclave的SECS页面。 5.4 SGX线程的生命周期 在enclave被初始化(§5.3.3)和被销毁(§5.3.4)这段时间内，任何将enclave的EPC页面映射到其虚拟地址空间的应用程序进程都可以执行enclave的代码。 当在enclave中执行代码时，逻辑处理器被称为处于enclave模式，它执行的代码可以访问属于当前执行的enclave的常规(PT_REG，§5.1.2)EPC页面。当逻辑进程处于enclave模式之外时，它会退回处理器保留内存范围(PRM, §5.1)内的任何内存访问，包括EPC。 每个执行enclave代码的逻辑处理器都使用一个线程控制结构(TCS，§5.2.4)。当一个TCS被一个逻辑处理器使用时，它被认为是忙碌的，并且它不能被任何其他逻辑处理器使用。下图演示了主进程用于执行enclave代码的指令，以及它们与目标TCS的交互，这是具有两个状态保存区(SSAs)的SGX线程控制结构(TCS)的生命周期的各个阶段。 假设没有发生硬件异常，enclave的主进程使用§5.4.1中描述的EENTER指令来执行enclave代码。当enclave代码完成它的任务时，它使用EEXIT指令(参见§5.4.2)将执行控制权返回给调用enclave的主进程。 如果在逻辑处理器处于enclave模式时发生硬件异常，则在调用系统软件的异常处理程序之前，使用异步enclave退出(AEX)将处理器从enclave模式中取出(§5.4.3)。在系统软件的处理程序被调用后，enclave的主进程可以使用§5.4.4中描述的ERESUME指令重新输入enclave并恢复它退出之前正在执行的计算。 5.4.1 同步Enclave进入 在较高的级别上，EENTER执行受控跳转到enclave代码，同时执行SGX的安全保证所需要的处理器配置。遍历所有配置步骤是一项冗长乏味的工作，但这是理解SGX使用的所有数据结构如何协同工作的必要先决条件。由于这个原因，EENTER和它的兄弟指令描述的比其他的SGX指令更详细。 下图所示的EENTER只能由运行在Ring 3(§2.3)的非特权应用程序软件执行，如果由系统软件执行，则会导致未定义指令(#UD)故障。 EENTER将逻辑处理器切换到enclave模式，但不执行特权级别切换。因此，enclave代码总是在Ring3执行，具有与调用它的应用程序代码相同的特权。这使得基础设施所有者可以允许用户提供的软件创建和使用enclave，同时保证OS内核和管理员仍然可以保护基础设施免受bug或恶意软件的攻击。 EENTER将TCS的虚拟地址作为它的输入，并要求TCS可用，并且TCS中至少有一个状态保存区域(SSA，§5.2.5)可用。后者是通过确保TCS中的当前SSA索引(CSSA)字段小于SSAs (NSSA)的数量来实现的。在执行enclave代码时发生硬件异常时，将使用CSSA所指示的SSA(应该称为当前SSA)。 EENTER将逻辑处理器转换为enclave模式，并将指令指针(RIP)设置为它接收到的TCS中的入口点偏移(OENTRY)字段所指示的值。EENTER被不受信任的调用者用来在一个受保护的环境中执行代码，因此它与用于调用系统软件的SYSCALL(§2.8)具有相同的安全考虑。将RIP设置为OENTRY所指示的值，可以向enclave作者保证enclave代码只会在定义良好的节点上调用，并防止恶意主机应用程序绕过enclave作者可能执行的任何安全检查。 EENTER还将XCR0(§2.6)设置为enclave属性的值XFRM(§5.2.2)，XCR0是一个寄存器，用于控制正在使用的扩展架构特性。确保XCR0是根据enclave作者的意图设置的，从而防止恶意操作系统通过启用enclave尚未准备处理的体系结构特性来绕过enclave的安全性。 此外，EENTER使用TCS中指定的值加载段寄存器(§2.7)FS和GS的基底。段的选择器和类型是硬编码为安全值的Ring3数据段。SGX设计的这个方面使得实现每个线程的线程本地存储(TLS)变得很容易。对于64位的enclave，这是一种方便的特性，而不是一种安全措施，因为enclave代码可以使用WRFSBASE和WRGSBASE指令安全地将新的基底加载到FS和GS中。 EENTER将备份它修改的寄存器的旧值，以便在enclave完成其计算时恢复这些值。就像SYSCALL一样，EENTER将以下指令的地址保存在RCX寄存器中。 有趣的是，SDM声明XCR0、FS和GS寄存器的旧值保存在专用于SGX实现的新寄存器中。但是，鉴于它们只用于enclave退出，我们希望寄存器保存在DRAM中，在TCS的保留区域中。 与SYSCALL一样，EENTER不修改堆栈指针寄存器(RSP)。为了避免任何安全漏洞，enclave代码应该将RSP设置为指向完全包含在EPC页面中的堆栈区域。通过设置每个线程的TLS区域以包含指向线程堆栈的指针，并将RSP设置为通过读取FS或GS段所指向的TLS区域获得的值，多线程enclave可以很容易地实现每个线程的堆栈区域。 最后，当EENTER进入enclave模式时，它会暂停一些处理器的调试特性，比如硬件断点和精确的基于事件的采样(PEBS)。从概念上讲，附加到主进程的调试器将enclave的执行看作一条单处理器指令。 5.4.2 同步Enclave退出 EEXIT只能在逻辑处理器处于enclave模式时执行，如果在任何其他情况下执行，则会导致一个(#UD)。简而言之，该指令将处理器返回到Ring3外部enclave模式，并恢复由EENTER保存的寄存器。 与SYSRET不同，EEXIT在退出enclave模式后将RIP设置为从RBX读取的值。这与EENTER不一致，EENTER将RIP值保存到RCX。除非这种不一致性源于SDM中的错误，否则enclave代码必须确保注意到这种差异。 SDM明确声明**EEXIT不会修改大多数寄存器**，因此enclave作者必须确保在将控制权返回给主进程之前清除存储在处理器寄存器中的任何秘密。此外，如果enclave软件没有将堆栈指针RSP和堆栈帧基指针RBP恢复到它们在EENTER被调用时拥有的值，那么它很可能会在调用者中造成错误。 Enclave代码可能会在其调用者中引发错误，这似乎很不幸。无论好坏，这完全符合应用程序调用动态加载模块的情况。更具体地说，模块的代码还负责保存与堆栈相关的寄存器，有bug的模块可能会跳转到主进程的应用程序代码中的任何位置。 本节描述64位enclave的EENTER行为。32位enclave的EENTER实现要复杂得多，因为在32位Intel架构中仍然存在成熟的分段模型引入了额外的特殊情况。 5.4.3 异步Enclave退出 如果在逻辑处理器执行enclave代码时发生了硬件异常，比如错误(§2.8.2)或中断(§2.12)，处理器在调用系统软件的异常处理程序之前执行异步enclave退出(AEX)，如下图所示： AEX保存enclave代码的执行上下文(§2.6)，恢复EENTER保存的状态，并设置处理器寄存器，以便系统软件的硬件异常处理程序返回到enclave的主进程中的异步退出处理程序。退出处理程序将使用ERESUME指令恢复被硬件异常中断的enclave计算。 除了§5.4.1中描述的行为外，EENTER还向当前SSA写入一些信息，这只在AEX发生时使用。EENTER将堆栈指针寄存器RSP和堆栈帧基指针寄存器RBP存储到当前SSA中的U_RSP和U_RBP字段中。最后，EENTER将值存储在当前SSA的异步退出处理程序指针(AEP)字段中的RCX中。 当在enclave模式下发生硬件异常时，SGX实现执行一系列步骤，将逻辑处理器从enclave模式中取出，并在系统软件中调用硬件异常处理程序。从概念上讲，SGX首先执行AEX以使逻辑处理器脱离enclave模式，然后使用§2.8.2中描述的标准英特尔架构的行为来处理硬件异常。实际的Intel处理器可能会将AEX实现与异常处理实现交错使用。然而，为了简单起见，该工作将AEX描述为一个单独的过程，在采取任何异常处理步骤之前执行。 在英特尔架构中，如果发生硬件异常，应用程序代码的执行上下文可以被系统软件的异常处理程序读取和修改(§2.8.2)。当应用程序软件信任系统软件时，这是可以接受的。然而，在SGX的威胁模式下，系统软件不被Enclave信任。因此，AEX步骤通过将其所有寄存器重置为预定义值来清除执行状态中可能存在的任何秘密。 在重置enclave的执行状态之前，将它备份到当前SSA中。具体来说，AEX备份SSA中的GPRSGX区域中的通用寄存器(GPRs，§2.6)，然后使用enclave SECS中的XFRM字段中指定的请求特性位图(RFBM)执行XSAVE(§2.6)。由于每个SSA都完全存储在分配给enclave的EPC页面中，因此系统软件不能读取或篡改备份的执行状态。当SSA接收到enclave的执行状态时，通过递增当前TCS中的CSSA字段，将其标记为used。 在清除执行上下文后，AEX进程将RSP和RBP设置为EENTER在当前SSA中保存的值，将RIP设置为当前SSA的AEP字段中的值。这样，当系统软件的硬件异常处理程序完成时，处理器将在enclave的主进程中执行异步退出处理程序代码。SGX的设计使得在包含EENTER指令的例程中将异步处理程序代码设置为异常处理程序变得很容易，因为RSP和RBP寄存器拥有的值与执行EENTER时相同。 AEX在enclave模式之外获取逻辑处理器所采取的许多操作都与EEXIT匹配。段寄存器FS和GS恢复到EENTER保存的值，所有被EENTER抑制的调试工具恢复到它们以前的状态。 5.4.4 从异步退出恢复 当在enclave模式下发生硬件异常时，处理器在调用系统软件设置的异常处理程序之前执行AEX。AEX设置执行上下文的方式是，当系统软件完成异常处理时，它返回到enclave的主进程中的异步退出处理程序。异步异常处理程序通常执行ERESUME指令，这将导致逻辑处理器返回到enclave模式并继续被硬件异常中断的计算。 ERESUME与EENTER共享其大部分功能。如下图所示： EENTER和ERESUME接收相同的输入，即§5.4.1中描述的TCS指针和§5.4.3中描述的AEP指针。最常见的应用程序设计将每个EENTER实例与使用完全相同的参数调用ERESUME的异步退出处理程序配对。 ERESUME和EENTER之间的主要区别在于前者使用一个由AEX“填写”的SSA(§5.4.3)，而后者使用一个空的SSA。因此，如果提供的TCS中的CSSA字段为0，则ERESUME会导致#GP故障，而如果CSSA大于或等于NSSA，则EENTER会失败。 当成功时，ERESUME递减TCS的CSSA字段，并恢复TCS中CSSA字段所指向的SSA备份的执行上下文。具体来说，ERESUME实现从SSA中的GPRSGX字段中恢复GPRs(§2.6)，并执行XRSTOR(§2.6)来加载与enclave所使用的扩展体系结构特性相关联的执行状态。 ERESUME与EENTER共享以下行为。这两个指令都写入当前SSA中的U_RSP、U_RBP和AEP字段。这两个指令遵循相同的过程来备份XCR0、FS和GS段寄存器，并基于当前TCS及其enclave的SECS将它们设置为相同的值。最后，这两个指令都禁用了逻辑处理器的调试特性的同一子集。 ERESUME正确处理的一个有趣的情况是，它在执行XRSTOR之前将XCR0设置为enclave属性XFRM 。如果SSA中的请求特性位图(RFBM)不是XFRM的子集，那么ERESUME就会失败。这很重要，因为尽管AEX总是使用XFRM值作为RFBM，但在另一个线程上执行的enclave代码可以在调用ERESUME之前自由地修改SSA内容。 ERESUME实现中正确的操作顺序可以防止恶意应用程序使用enclave修改与未在XFRM中声明的扩展体系结构特性相关联的寄存器。这将破坏系统软件提供线程级执行上下文隔离的能力。 5.5 EPC页面交换 现代操作系统内核利用地址转换(§2.5)来实现页面交换，也称为分页(§2.5)。简而言之，通过将很少使用的内存页交换到称为磁盘等较慢的存储介质，分页允许OS内核过量提交计算机的DRAM。 分页是有效利用计算机资源的关键因素。例如，用户并发运行多个程序的桌面系统可以退出分配给不活动应用程序的内存页，而不会显著降低用户体验。 不幸的是，不能允许OS通过像在PRM范围之外的DRAM内存页面交换一样来交换enclave的EPC页面。在SGX的威胁模型中，enclave不相信系统软件，因此SGX的设计提供了一种EPC页面交换方法，可以防御试图进行§3.7中所述的任何主动地址转换攻击的恶意操作系统。 SGX所提供的安全性的代价是，支持交换EPC页面的操作系统内核必须使用经过修改的页面交换实现，该实现与SGX机制交互。Enclave作者基本上可以忽略EPC交换，类似于今天的应用程序开发人员可以忽略OS内核的分页实现。 如下图所示，SGX支持将EPC页面交换到PRM范围之外的DRAM页面。系统软件使用现有的页交换技术实现将这些页的内容从DRAM中交换到磁盘上。 SGX的交换特性围绕着EWB指令，在§5.5.4中有详细描述。实际上，EWB将EPC页交换到EPC之外的DRAM页，并通过将该页EPCM条目中的VALID字段置零将EPC页标记为可用。 SGX设计依赖于对称密钥加密来保证被交换的EPC页面的机密性和完整性，并依赖于nonces(§3.1.4)来保证带回EPC的页面的新鲜度。这些nonces存储在§5.5.2中介绍的版本数组(VA)中，它们是专门用于nonce存储的EPC页面。 在EPC页面被交换并释放给其他enclaves使用之前，SGX实现必须确保没有TLB拥有与被交换的页面相关联的地址转换，以避免§3.7.4中描述的基于TLB的地址转换攻击。 正如§5.1.1中所解释的，SGX让系统软件负责管理EPC。自然地，本节中描述的用于实现EPC分页的SGX指令只对运行在Ring 0(§2.3)上的系统软件可用。 在今天的软件栈(§2.3)中，只有操作系统内核实现了页面交换，以支持DRAM的过度使用。管理程序仅用于在操作系统之间划分计算机的物理资源。因此，在编写本节时，我们期望OS内核也将承担EPC页面交换的责任。为了简单起见，我们经常使用术语“操作系统内核”而不是“系统软件”。读者应该知道，SGX设计并不排除系统管理程序实现自己的EPC页面交换的系统。因此，“OS内核”实际上应该理解为“执行EPC分页的系统软件”。 5.5.1 页面交换和TLB SGX没有向内存执行单元添加任何安全检查(§2.9.4，§2.10)。相反，SGX的访问控制检查是在地址转换(§2.5)完成之后进行的，就在转换结果写入TLBs之前(§2.11.5)。在整个SDM中，这个方面通常被忽略，但是在解释SGX的EPC页面清除机制时，它就变得显而易见了。 关于SGX的内存访问保护检查的完整讨论值得单独一节来讨论，请参见§6.2。只需使用SGX的安全模型中的两个需求就可以解释EPC页面清除机制。首先，当一个逻辑处理器通过EEXIT(§5.4.2)或AEX(§5.4.3)退出一个enclave时，它的TLB被刷新。其次，当从enclave释放EPC页面时，必须使得执行该enclave代码的所有逻辑处理器退出enclave。这足以保证删除任何针对已释放的EPC的TLB条目。 系统软件可以通过发送处理器间中断(IPI，§2.12)，使逻辑处理器退出enclave，这将在接收时触发AEX。 SGX不相信系统软件。因此，在将EPC页面的EPCM条目标记为free之前，SGX必须确保OS内核已经清除了所有可能包含该页面转换的TLB。此外，为每个页面清除执行IPIs和TLB刷新会给分页实现增加很大的开销，因此SGX设计允许使用一个IPI/TLB刷新序列来清除一批页面。 TLB刷新验证逻辑依赖于一个名为BLOCKED的1位EPCM条目字段。如下图所示，VALID和BLOCKED字段产生三种可能的EPC页面状态。当两个位都为零时，页面是空闲的；当VALID为1，BLOCKED为0时使用；当两个位都为1时，页面被阻塞。 被阻塞的页面被认为不能被enclave访问。如果一个地址转换导致一个被阻塞的EPC页面，SGX实现会导致一个页面错误(#PF，§2.8.2)。这保证了一旦一个页面被阻塞，CPU将不会创建任何新的指向它的TLB条目。 此外，每条SGX指令都确保它所操作的EPC页面不会被阻塞。例如，EENTER确保它提供的TCS没有被阻塞，它的enclave的SECS没有被阻塞，以及当前SSA中的每个页面没有被阻塞。 为了交换一批EPC页面，OS内核必须首先针对这些页面发出EBLOCK指令。SGX还希望OS从页表中删除EPC页的映射，但并不信任OS。 在所有所需的页面都被阻塞之后，操作系统内核必须执行一条ETRACK指令，这条指令指示SGX实现跟踪哪些逻辑处理器的TLBs已被刷新。ETRACK要求enclave的SECS(§5.1.3)的虚拟地址。如果OS希望交换属于多个enclave的一批EPC页面，它必须为每个enclave发出一个ETRACK。 按照ETRACK指令，操作系统内核必须在所有执行enclave代码的逻辑处理器上的enclave退出。SGX设计期望操作系统将使用IPIs在逻辑处理器中导致AEXs，而逻辑处理器的TLBs必须被刷新。 当OS对每个要交换的EPC页面执行EWB指令时，EPC页面交换过程就完成了。这条指令将在§5.5.4中详细描述，它将写入EPC页面的加密版本并将其交换到DRAM中，然后通过清除其EPCM条目中的VALID和BLOCKED位来释放该页面。在执行其任务之前，EWB确保它所目标的EPC页面已经被阻塞，并检查ETRACK设置的状态，以确保所有相关的TLB都已被刷新。 可以通过ELDU和ELDB指令将被交换的页面加载回EPC。这两个指令启动时都有一个空闲的EPC页面和一个DRAM页面(其中包含EPC页面的已交换内容)，然后将DRAM页面的内容解密到EPC页面，并恢复相应的EPCM条目。ELDU和ELDB之间的唯一区别是后者在页面的EPCM条目中设置阻塞位，而前者将其清除。 ELDU和ELDB类似于ECREATE和EADD，因为它们填充了一个空闲的EPC页面。由于他们操作的页面是空闲的，因此SGX安全模型断言没有TLB条目可能针对它。因此，这些指令不需要类似于EBLOCK或ETRACK的机制。 5.5.2 版本数组 (VA) 当EWB交换EPC的内容时，它会创建一个8字节的nonce(§3.1.4)，英特尔的文档将其称为页面版本。SGX的新鲜度保证是建立在安全存储nonces的假设之上的，所以EWB将它创建的nonce存储在一个版本数组(VA)中。 版本数组是EPC页面，专门用于存储由EWB生成的nonces。每个VA被划分成槽，每个槽都足够存储一个nonce。假设EPC页面的大小是4KB，每个nonce占用8字节，那么每个VA就有512个槽。 页是使用EPA指令分配的，该指令接受空闲EPC页的虚拟地址，并将其转换为具有空槽的版本数组。每一页在其EPCM条目中以PT_VA类型标识。与SECS页面一样，VA页面的EPCM条目中的ENCLAVEADDRESS字段设置为零，任何软件(包括enclave)都不能直接访问它们。 与到目前为止讨论的其他页面类型不同，VA页面不与任何enclave关联。这意味着可以通过EREMOVE释放它们，而不受任何限制。但是，将一个槽正在使用的VA页面释放时会丢弃这些槽中的nonces，这将导致丢失将相应的被交换的页面加载回EPC的能力。因此，一个正确的操作系统实现不太可能在一个非空闲槽的VA调用EREMOVE。 根据SDM中EPA和EWB的伪代码，SGX使用零值来表示VA中的空槽，这意味着所有生成的nonces必须是非零的。这还意味着EPA通过将底层EPC页面归零来初始化VA。然而，由于软件不能访问VA的内容，无论是使用一个特殊值，或值本身都不是体系结构的。 5.5.3 Enclave IDs EWB和ELDU / ELDB指令使用一个enclave ID (EID)来标识拥有被交换页面的enclave。EID与EPCM条目中的ENCLAVESECS(§5.1.2)字段具有相同的用途，后者也用于标识拥有EPC页面的enclave。本节通过比较两个值及其用法，说明使用两个值表示相同概念的必要性。 SDM声明EPCM条目中的ENCLAVESECS字段用于标识拥有相关EPC页面的enclave的SECS，但没有描述其格式。理论上，ENCLAVESECS字段可以在SGX实现之间更改，因为SGX指令从不向软件暴露其值。 然而，我们稍后将讨论，ENCLAVESECS最可信的表示是其字段中的enclave物理地址。因此，如果从EPC中交换出enclave的SECS并在另一个位置加载回该enclave，则与给定enclave关联的ENCLAVESECS值将发生更改。由此可见，ENCLAVESECS值仅适用于标识某个enclave，而其SECS仍在EPC中。 根据SDM, EID字段是存储在enclave的SECS中的64位字段。SDM中的ECREATE伪代码显示，在分配SECS时，通过原子递增全局计数器生成enclave的ID。假设计数器不会发生滚动，此过程将确保在电源循环期间创建的每个enclave都具有唯一的EID。 尽管SDM没有明确保证这一点，但enclave SECS中的EID字段似乎不会被任何指令修改。这使得EID的值适合在整个enclave的生命周期内标识它，甚至在从EPC中将其SECS页面驱逐出去时也是如此。 5.5.4 EPC页面交换 系统软件使用EWB指令交换EPC页面，EWB指令在稍后通过ELDU指令生成恢复交换页面所需的所有数据，如下图所示。 EWB的输出包括被交换的EPC页面内容的加密版本、与该页面对应的EPCM条目中的字段子集、§5.5.2中讨论的nonce和消息身份验证代码(MAC，§3.1.3)标记。除了nonce之外，EWB将其输出写入PRM区域之外的DRAM中，因此系统软件可以选择进一步将其交换出磁盘。 EPC页面内容被加密，以保护enclave数据的机密性，同时页面存储在PRM范围之外的不受信任的DRAM中。在不使用加密的情况下，系统软件可以通过将EPC页面从EPC中交换出来从而了解该页面的内容。 页面元数据存储在页面信息(PAGEINFO)结构中，如下图所示。这个结构类似于§5.3.2中描述的PAGEINFO结构，除了SECINFO字段被一个PCMD字段所取代，它包含一个页面加密元数据(PCMD)结构的虚拟地址。 PAGEINFO结构中的LINADDR字段用于存储EPCM条目中的地址字段，该字段指示用于访问页面的虚拟地址。PCMD结构嵌入了§5.3.2中描述的安全信息(SECINFO)，用于在EPCM条目中存储页面类型(PT)和访问权限标志(R, W, X)。PCMD结构还存储了enclave的ID (EID，§5.5.3)。这些字段稍后由ELDU或ELDB用于填充重新加载的EPC页面的EPCM条目。 上面描述的元数据是未加密存储的，因此操作系统可以选择按原样使用内部信息进行自己的记帐。这对安全性没有负面影响，因为元数据不是机密的。实际上，除了enclave ID之外，所有元数据字段都是在调用ECREATE时由系统软件指定的。enclave ID仅用于标识EPC页面所属的enclave，而且系统软件也已经拥有该信息。 除了上面描述的元数据之外，PCMD结构还存储由EWB生成的MAC标签。MAC标记涵盖EPC页面内容的真实性、元数据和nonce。MAC标记由ELDU和ELDB检查，只有在MAC验证确认了页面数据、元数据和nonce的真实性时，它们才会将一个被交换的页面加载回EPC。这个安全检查可以防止在§3.7.3中描述的页面交换攻击。 与EREMOVE类似，如果没有其他EPCM条目的ENCLAVESECS字段引用该SECS，则EWB只会交换包含enclave SECS的EPC页面。同时，作为一种优化，SGX实现在交换SECS时不执行与ETRACK相关的检查。这是安全的，因为只有在EPC没有属于SECS的页面时，才会交换SECS，这意味着EPC中没有属于enclave的任何TCS，因此没有处理器可以执行enclave代码。 与任何其他EPC页面一样，可以清除持有版本数组的页面。VA页面永远不能被软件访问，所以他们不能有任何TLB条目指向他们。因此，EWB在不执行任何ETRACK相关检查的情况下交换VA页面。 EWB的数据流(如下图所示)有一个方面可能会让操作系统开发人员感到困惑。该指令从寄存器(RBX)中读取将要被交换出的EPC页面的虚拟地址，并将其写入提供给它的PAGEINFO结构的LINADDR字段。可以通过在LINADDR字段中提供EPC页面的地址来删除单独的输入(RBX)。 5.5.5 将交换的页面加载回EPC 在交换出属于enclave的EPC页面之后，任何从enclave代码访问该页面的尝试都将导致页面错误(#PF，§2.8.2)。#PF将导致逻辑处理器通过AEX退出enclave模式(§5.4.3)，然后调用OS内核的页面错误处理程序。 页面错误从AEX流程接受特殊处理。当离开enclave时，AEX逻辑专门检查触发AEX的硬件异常是否为#PF。如果是这样，AEX实现将清除CR2寄存器中最不重要的12位，该寄存器存储虚拟地址，其转换导致了页面错误。 通常，操作系统内核的页面处理程序需要能够从CR2中提取虚拟页码(VPN，§2.5.1)，这样它就知道需要将哪些内存页加载回DRAM。操作系统内核还可以使用12个最不重要的地址位，这不是VPN的一部分，从而更好地预测应用程序软件的内存访问模式。然而，与组成VPN的位不同，最下面的12位对于故障处理程序执行其工作不是绝对必要的。因此，SGX的AEX实现清除这12位，以限制页面错误处理程序得到的信息量。 当OS页面错误处理程序检查CR2寄存器中的地址并确定错误地址在EPC中时，通常希望使用ELDU或ELDB指令将被交换的页面加载回EPC中。如果EWB的输出已经从DRAM中被交换到较慢的存储介质中，操作系统内核将不得不在调用ELDU / ELDB之前将输出读回DRAM中。 ELDU和ELDB验证由EWB产生的MAC标签，如§5.5.4所述。这可以防止操作系统内核执行§3.7.3中描述的基于页面交换的主动地址转换攻击。 5.5.6 交换树 SGX允许从EPC中交换VA页面，就像enclave页面一样。当从EPC中交换一个VA页面时，处理器将无法访问由VA槽存储的所有nonces。因此，在操作系统将VA页面加载回EPC之前，ELDB无法恢复与这些nonces关联的被交换的页面。 换句话说，一个被交换的页面依赖于存储其nonce的VA页面，并且在VA页面也被重新加载之前不能被加载回EPC。由此关系创建的依赖图是一个交换树的森林。如下图所示，一个交换树将EPC页面作为叶子，将VA页面作为内部节点。页面的父页面是保存其nonce的VA页面。由于EWB总是在一个页面中输出一个nonce，所以每个交换树的根节点在EPC中总是一个页面。 一个简单的归纳表明，当OS希望将一个交换的enclave页面加载回EPC时，它需要在从交换树的根到与该enclave页面对应的叶的路径上加载所有VA页面。因此，在EPC中满足页面错误所需的页面加载数量取决于包含该页面的交换树的形状。 SGX让OS完全掌控交换树的形状。这对安全性没有负面影响，因为树的形状只影响交换方案的性能，而不影响其正确性。 5.6 SGX Enclave度量 SGX实现了一个软件认证方案，该方案遵循了§3.3中概述的一般原则。对于本节而言，最相关的原则是远程方根据其度量对enclave进行身份验证，该度量用于识别正在enclave内部执行的软件。远程方将可信硬件报告的enclave度量与预期的度量进行比较，只有在两个值匹配时才进行。 §5.3解释了SGX enclave是使用ECREATE(§5.3.1)、EADD(§5.3.2)和EEXTEND指令构建的。在通过EINIT(§5.3.3)初始化enclave之后，上面提到的指令就不能再使用了。SGX度量的方案遵循§3.3.2中概述的原则，SGX enclave的度量是通过计算安全散列(§3.1.3)输入ECREATE, EADD和EEXTEND。EINIT结束了表示enclave度量值的散列。 除了enclave的内容之外，enclave作者还需要指定应该使用的指令序列，以便创建一个enclave，该enclave的度量将与软件认证过程中远程方使用的期望值相匹配。.so和.dll动态加载库文件格式是SGX打算使用的enclave传递方法，它们已经包含了加载算法的非正式规范。我们期望非正式的加载规范作为规范的起点，这些规范规定了应该用于从.so和.dll文件创建enclave的SGX指令的确切序列。 如§3.3.2所述，enclave的度量是使用安全的哈希算法计算的，因此系统软件只能按照enclave作者指定的指令顺序构建与预期度量匹配的enclave。 SGX设计使用256位SHA-2安全哈希函数来计算其度量值。SHA-2是一个块哈希函数(§3.1.3)，它对64字节的块进行操作，使用32字节的内部状态，并产生32字节的输出。每个enclave的度量都存储在enclave SECS的MRENCLAVE字段中。32字节字段存储256位SHA-2安全哈希函数的内部状态和最终输出。 5.6.1 ECREATE度量 在§5.3.1中概述的ECREATE指令，首先使用256位SHA-2初始化算法在新创建的SECS中初始化MRENCLAVE字段，然后使用下表中描述的64字节块扩展哈希。 enclave的度量不包括BASEADDR字段。此处省略是有意的，因为它允许系统软件在满足ELRANGE限制的主进程内的任何虚拟地址加载enclave，而不会改变enclave度量值。此特性可以与生成位置无关的enclave代码的编译器结合使用，以获得可重定位的enclave。 enclave的度量包括SSAFRAMESIZE字段，它保证AEX创建、EENTER(§5.4.1)和ERESUME(§5.4.4)使用的SSAs(§5.2.5)具有enclave作者所期望的大小。如果将此字段排除在enclave的度量之外，会允许恶意的enclave加载程序通过指定比enclave作者预期的更大的SSAFRAMESIZE来试图攻击enclave的安全检查，这可能导致AEX编写的SSA内容覆盖enclave的代码或数据。 5.6.2 度量Enclave属性 enclave的度量不包括在SECS中的ATTRIBUTES字段中指定的enclave属性(§5.2.2)。相反，它直接包含在认证签名所涵盖的信息中，这将在§5.8.1中讨论。 SGX软件认证需要涵盖enclave属性。例如，如果XFRM(§5.2.2 §5.2.5)不被覆盖，一个恶意的enclave装载机可以通过设置XFRM值试图颠覆一个enclave的安全检查，让体系结构扩展指令使用的enclave的语义变化，但仍然是产生符合SSAFRAMESIZE的XSAVE输出。 应用到ATTRIBUTES SECS字段的特殊处理从安全角度来看似乎是有问题的，因为它给软件认证验证器增加了额外的复杂性，从而转化为可利用的漏洞的更多机会。这个决定也增加了SGX软件认证设计的复杂性，在§5.8中有描述。 尽管存在上述问题，SGX设计决定走这条路的最可能的原因是希望能够使用单一度量来表示一个能够利用一些架构扩展的enclave，但也可以在没有它们的情况下执行其任务。 例如，考虑使用OpenCV这样的库执行图像处理的enclave，它具有针对SSE和VX优化的例程，但还包括针对不具备这些特性的处理器的通用回退。enclave的作者可能希望允许enclave加载器将位1(SSE)和位2(VX)设置为真或假。如果ATTRIBUTES(以及XFRM)是enclave度量的一部分，则enclave作者必须指定enclave有4个有效度量。通常，允许n个架构扩展独立使用将导致2n个无效度量。 5.6.3 度量EADD §5.3.2中描述的EADD指令用下表中所示的64字节块扩展了MRENCLAVE中的SHA-2哈希。 度量中包含的地址是EADD页面预期映射到enclave的虚拟地址空间中的地址。这可以确保系统软件根据enclave作者的规范设置enclave的虚拟内存布局。如果恶意的enclave加载程序试图错误地设置enclave的布局，可能是为了挂载一个活动的地址转换攻击(§3.7.2)，所加载的enclave的度量结果将与enclave作者期望的度量结果不同。 新创建的页面的虚拟地址相对于enclave的ELRANGE的起点进行度量。换句话说，度量中包含的值是LINADDR - BASEADDR。这使得enclave的度量对BASEADDR的变化保持不变，这对于可重定位的enclave是理想的。度量相对地址仍然保留了关于ELRANGE内内存布局的所有信息，因此没有负面的安全影响。 EADD同时也度量提供给EADD的SECINFO(§5.3.2)结构的前48字节，其中包含用于初始化页面的EPCM条目的页面类型(PT)和访问权限(R, W, X)字段值。同样，在度量中包含这些值可以保证加载enclave的系统软件构建的内存布局与enclave作者的规范相匹配。 上面提到的EPCM字段值在SECINFO结构中只占不到一个字节，其余的字节被保留，并被初始化为零。这为SGX未来的功能留下了大量的扩展空间。 上表中最值得注意的省路是用于初始化新创建的EPC页面的数据。因此，EADD提供的度量数据保证了enclave的内存布局将具有在所需虚拟地址上分配的有指定访问权限的页面。但是，度量不包括在这些页面中加载的代码或数据。 例如，EADD的度量数据保证enclave的内存布局由三个可执行页面和五个可写数据页面组成，但它不能保证任何代码页面包含enclave作者提供的代码。 5.6.4 度量EEXTEND EEXTEND指令的存在仅仅是为了度量加载在enclave的EPC页面中的数据。该指令读入一个虚拟地址，并使用下表中的5个64字节块扩展enclave的度量散列，这有效地保证了enclave内存中256字节数据块的内容。 在检查EEXTEND的细节之前，我们注意到，SGX的安全保证只有在对enclave的关键页面的内容进行测量时才有效。例如，EENTER(§5.4.1)只有在测量了所有线程控制结构(TCS，§5.2.4)页面的内容后，才保证在enclave的代码中执行受控跳转。否则，恶意的enclave加载程序可以在构建enclave时更改TCS中的OENTRY字段(§5.2.4，§5.4.1)，然后恶意的操作系统可以使用TCS在enclave代码中执行任意跳转。同样的道理，所有enclave的代码都应该用EEXTEND来度量。任何无法测量的代码片段都可以被恶意的enclave加载程序替换。 考虑到这些缺陷，令人惊讶的是SGX设计选择将由EADD完成的虚拟地址空间布局度量与由EEXTEND完成的内存内容度量分离。 乍一看，这种解耦似乎只有一个好处，即能够在构建enclave时将未测量的用户输入加载到该enclave中。但是，这种好处只会转化为很小的性能改进，因为可以将enclave设计为在初始化后从不受信任的DRAM复制用户输入。与此同时，由于没有通过EEXTEND调用度量所有重要数据，这种分离打开了依赖于一个没有提供有意义的安全保证的enclave的可能性。 然而，EADD / EEXTEND分离背后的真正原因是由SDM中的EINIT伪代码所暗示的，它表明该指令在执行计算密集型RSA签名检查时打开了一个中断窗口(§2.12)。如果在检查期间发生中断，EINIT会失败并出现错误代码，然后中断。对于处理器指令来说，这种非常不寻常的方法表明，SGX实现受到了其指令被允许添加到中断处理进程中的延迟时间的限制。 考虑到上面的问题，可以合理地推断引入了EEXTEND，因为使用256位SHA-2度量整个页面非常耗时，而且在EADD中这样做会导致指令超出SGX的延迟预算。需要达到某个延迟目标，这是对似乎任意的256字节块大小的合理解释。 如果使用构建当前动态加载模块(似乎是SGX设计的目标工作流)的相同工具编写enclave，那么EADD / EEXTEND分离将不会导致安全问题。在此工作流中，构建enclave的工具可以轻松识别需要度量的enclave数据。 从安全性的角度来看，让EEXTEND提供给散列函数的消息块除了包含数据内容外，还包含256字节块的地址是正确的，也是有意义的。如果地址不包括在内，恶意的enclave加载器就会装载§3.7.2中描述的内存映射攻击。 更具体地说，恶意加载程序将在用于泄漏的虚拟地址处EADD errorOut页面内容，在用于泄漏的虚拟地址处EADD disclose页面内容，然后以错误的顺序EEXTEND页面。如果EEXTEND不包含被测量的数据块的地址，那么上面的步骤将产生与正确构造的enclave相同的测量结果。 EEXTEND值得分析的最后一个方面是它对enclave迁移的支持。与EADD类似，EEXTEND测量的虚拟地址是相对于enclave的BASEADDR的。此外，唯一的SGX结构的内容将被EEXTEND测量是TCS。SGX的设计已经仔细地为所有代表enclave地址的TCS字段使用了相对地址，这是OENTRY, OFSBASGX和OGSBASGX。 5.6.5 度量EINIT EINIT指令(§5.3.3)结束了enclave的构建过程。在enclave上成功调用EINIT之后，enclave的内容是“密封的”，这意味着系统软件不能使用EADD指令将代码和数据加载到enclave中，也不能使用EEXTEND指令更新enclave的度量。 EINIT在enclave的SECS的MRENCLAVE字段上使用SHA-2算法(§3.1.3)。在EINIT之后，字段不再存储SHA-2算法的中间状态，而是存储安全哈希函数的最终输出。该值在EINIT完成后保持不变，并包含在SGX软件认证过程生成的认证签名中。 5.7 SGX Enclave版本支持 由可信平台模块(§4.4)引入的软件认证模型(§3.3)依赖于度量，它本质上是一个内容散列，用于识别容器内的软件。使用内容哈希进行标识的缺点是，存放同一软件的不同版本的容器的标识之间没有关系。 在实践中，基于安全容器的系统在初始软件认证过程中不访问远程方来处理软件更新是非常理想的。这需要有能力在拥有旧版本软件的容器和拥有更新版本的容器之间迁移秘密。这一需求转化为对能够识别同一软件的两个版本之间关系的独立身份系统的需求。 SGX支持在表示同一软件的不同版本的enclave之间迁移秘密，如下图所示。 秘密迁移特性依赖于一个一级证书层次结构(§3.2.1)，其中每个enclave作者都是一个证书颁发机构，每个enclave从作者那里收到一个证书。这些证书必须格式化为签名结构(SIGSTRUCT)，这在§5.7.1中有描述。这些证书中的信息是§5.7.2中介绍的enclave身份方案的基础，它可以识别同一软件的不同版本之间的关系。 EINIT指令(§5.3.3)检查目标enclave的证书，并使用其中的信息填充SECS(§5.1.3)字段，这些字段描述了enclave基于证书的标识。这个过程在§5.7.4中进行了总结。 最后，实际的秘密迁移过程是基于EGETKEY指令实现的密钥派生服务，在§5.7.5中进行了描述。发送enclave使用EGETKEY指令根据其身份获得一个对称密钥(§3.1.1)，用该密钥加密其秘密，并将加密的秘密交给不受信任的系统软件。接收enclave将发送enclave的身份传递给EGETKEY，获得与上面相同的对称密钥，并使用该密钥解密从系统软件接收到的秘密。 从EGETKEY获得的对称密钥可以与加密原语一起使用，这些原语可以在不受信任的系统软件迁移到另一个enclave时保护enclave秘密的机密性(§3.1.2)和完整性(§3.1.3)。但是，仅凭对称密钥无法提供新鲜度保证(§3.1)，因此秘密迁移容易受到重放攻击。当被迁移的秘密是不可变的，例如当秘密是通过软件认证获得的加密密钥时，这是可以接受的。 5.7.1 Enclave证书 SGX的设计要求每个enclave都有其作者颁发的证书。这一要求是由EINIT强制执行的(§5.3.3)，它拒绝在没有有效证书的enclave上操作。 SGX实现使用格式化为签名结构(SIGSTRUCT)的证书，这些证书将由enclave构建工具链生成，如下图所示。 SIGSTRUCT证书由元数据字段和保证元数据真实性的（其中最有趣的字段在下表中显示）。字段的语义将在下面的部分中揭示。 RSA签名组成格式如下表所示： enclave证书必须由RSA签名(§3.1.3)签名，该签名遵循RFC 3447中描述的方法，使用256位SHA-2]作为哈希函数来减少输入大小，以及PKCS #1 v1.5中描述的填充方法。 5.7.2 基于证书的Enclave身份 enclave的身份由其证书中的三个字段决定(§5.7.1)：用于签署证书的RSA密钥的模数(模数)、enclave的产品ID(ISVPRODID)和安全版本号(ISVSVN)。 用于颁发证书的公共RSA密钥标识enclave的作者。用于颁发enclave证书的所有RSA密钥必须将公开指数设置为3，因此它们仅通过模量进行区分。SGX不使用密钥的整个模量，而是模量的256位SHA-2哈希。这称为签名者度量(MRSIGNER)，与标识enclave内容的SHA-2散列的enclave度量(MRENCLAVE)名称量级相同。 SGX实现依赖于一个硬编码的MRSIGNER值来识别由Intel颁发的证书。拥有英特尔颁发的证书的enclave可以获得额外的特权，这在§5.8中有讨论。 enclave作者可以使用相同的RSA密钥为表示不同软件模块的enclave颁发证书。每个模块由一个唯一的产品ID(ISVPRODID)值标识。相反，假定证书具有相同ISVPRODID并由相同RSA密钥(因此具有相同的MRENCLAVE)颁发的所有enclave代表同一软件模块的不同版本。通常假定证书由不同密钥签名的enclave包含不同的软件模块。 表示模块的不同版本的enclave可以具有不同的安全版本号(SVN)。SGX的设计不允许秘密从具有较高SVN的enclave迁移到具有较低SVN的enclave。此限制旨在帮助分发安全补丁，如下所示。 如果在enclave中发现安全漏洞，作者可以发布具有更高SVN的固定版本。随着用户升级，SGX将帮助机密从enclave的脆弱版本转移到固定版本。一旦用户的秘密迁移完成，SGX中的SVN限制将基于构建易受攻击的enclave版本并使用它读取迁移后的秘密来转移任何攻击。 增加功能的软件升级不应该伴随着SVN的增加，因为SGX允许秘密在具有匹配SVN值的enclave之间自由迁移。如上所述，只有在发现安全漏洞时，软件模块的SVN才应该增加。SIGSTRUCT只给ISVSVN字段分配2个字节，转换成65,536个可能的SVN值。如果一个大型团队(错误地)设置了一个连续构建系统，为它生成的每个软件构建分配一个新的SVN，并且每个代码更改触发一个构建，那么这个空间就会耗尽。 5.7.3 CPU安全版本号 SGX实现本身有一个安全版本号(CPUSVN)，除了enclave的身份信息之外，它还用于EGETKEY实现的密钥派生过程中。CPUSVN是一个128位的值，根据SDM，它反映了处理器的微码更新版本。 SDM没有描述CPUSVN的结构，但是它指出使用整型比较来比较CPUSVN的值是没有意义的，并且只有一些CPUSVN值是有效的。此外，CPUSVNs承认的排序关系与enclave SVNs之间的排序关系具有相同的语义。特别地，一个SGX实现将考虑所有具有较低SVN的SGX实现由于安全漏洞而受到损害，并且不会信任它们。 SGX的一项专利披露，CPUSVN是小整数的串联，这些小整数表示构成SGX实现的各种组件的svn。这种结构与SDM中所做的所有声明一致。 5.7.4 建立Enclave身份 当EINIT(§5.3.3)指令准备执行代码的enclave时，它还会设置SECS(§5.1.3)字段，这些字段组成enclave的基于证书的标识，如下图所示。 EINIT需要颁发给enclave的SIGSTRUCT证书的虚拟地址，并使用证书中的信息初始化enclave的SECS中的基于证书的标识信息。在使用证书中的信息之前，EINIT首先验证其RSA签名。SIGSTRUCT字段Q1和Q2，以及RSA指数3，简化了验证算法，这在§6.5中讨论。 如果发现SIGSTRUCT证书被正确签名，EINIT将按照下面几段中讨论的步骤确保将证书颁发给正在初始化的enclave。检查完成后，EINIT计算MRSIGNER, SIGSTRUCT中模数字段的256位SHA-2哈希，并将其写入enclave的SECS中。EINIT还将ISVPRODID和ISVSVN字段从SIGSTRUCT复制到enclave的SECS中。正如在§5.7.2中所解释的，这些字段构成了enclave的基于证书的标识。 在验证了SIGSTRUCT中的RSA签名之后，EINIT将签名的填充复制到enclave的SECS中的填充字段中。PKCS #1 v1.5填充方案不包含随机性，因此填充对于所有enclave应该具有相同的值。 EINIT执行一些检查，以确保正在进行初始化的enclave确实是由提供的SIGSTRUCT证书授权的。最明显的检查包括确保SIGSTRUCT中的MRENCLAVE值等于enclave的度量，后者存储在enclave的SECS中的MRENCLAVE字段中。 但是，MRENCLAVE没有涵盖enclave的属性，这些属性存储在SECS的ATTRIBUTES字段中。正如在§5.6.2中所讨论的，从MRENCLAVE中省略一个ATTRIBUTES有助于编写具有优化实现的enclave，这些实现可以在存在时使用架构扩展，也可以在没有扩展的情况下在CPU上工作的回退实现。当使用XFRM(§5.2.2 §5.2.5)属性中的各种值构建时，这样的enclave可以正确执行。与此同时，允许系统软件在ATTRIBUTES字段中使用任意值，将危及SGX的安全保证。 当enclave使用软件认证(§3.3)访问机密时，用于构建该机密的附加值包含在SGX认证签名(§5.8)中。这使认证过程中的远程方有机会拒绝使用不需要的ATTRIBUTES值构建的enclave。但是，当使用基于证书的身份验证的迁移过程获得机密时，没有远程方可以检查enclave的属性。 SGX设计通过让enclave作者在为enclave颁发的SIGSTRUCT证书的ATTRIBUTES和ATTRIBUTEMASK字段中为enclave传递一组可接受的属性值来解决这个问题。如果在SECS中的ATTRIBUTES字段和SIGSTRUCT中的ATTRIBUTESMASK字段之间的位不等于SIGSTRUCT中的ATTRIBUTES字段，EINIT将拒绝使用SIGSTRUCT初始化enclave。此检查可防止具有不需要的属性的enclave在迁移过程中获取或泄漏机密。 任何enclave作者都可以使用SIGSTRUCT来请求enclave的ATTRIBUTES字段中的任何位为零。但是，对于由Intel签署的enclave，某些位只能设置为1。EINIT有一个限制ATTRIBUTES比特的掩码，在§5.8中讨论过。EINIT实现包含一个硬编码的MRSIGNER值，该值用于标识英特尔的特权enclave，并且只允许使用与受限制掩码中的任何位匹配的ATTRIBUTES值构建特权enclave。这个检查对于SGX软件认证过程的安全性是至关重要的，这在§5.8中描述。 最后，EINIT还检查SIGSTRUCT中的VENDOR字段。专用于SIGSTRUCT的一节中对VENDOR字段的SDM描述表明，该字段本质上用于区分由Intel签名的特殊enclave(使用VENDOR值0x8086)和其他所有人的enclave(使用VENDOR值0)。然而，EINIT伪代码似乎暗示了SGX实现只检查VENDOR是否为0或0x8086。 5.7.5 Enclave密钥分发 SGX的秘密迁移机制基于EGETKEY指令提供给enclave的对称密钥分发服务，如下图所示。 EGETKEY生成的密钥是基于当前enclave的SECS中的身份信息和存储在支持SGX的处理器内的安全硬件中的两个秘密分发的。其中一个秘密是对基本没有文档记录的一系列转换的输入，这些转换为密钥分发过程背后的加密原语生成对称密钥。另一个秘密，在SDM中称为CR_SEAL_FUSES，是在关键推导材料中使用的信息片段之一。 SDM没有指定密钥分发算法，但SGX专利披露密钥是使用FIPS SP 800-108中描述的方法，使用AES-CMAC]作为伪随机函数(PRF)。同样的专利声明，用于密钥分发的秘密存储在CPU的e-fuse中，这一点在ISCA 2015 SGX教程中得到证实。 这一附加信息意味着，使用相同密钥分发材料的所有EGETKEY调用将产生相同的密钥，即使是跨CPU能量周期。此外，如果不访问存储在CPU e-fuse中的密钥，对手是不可能从特定密钥派生材料中获得密钥的。SGX的关键层次结构在§5.8.2中有进一步的描述。 下面的段落讨论密钥分发材料中使用的数据片段，这些数据片段由下表中所示的密钥请求(KEYREQUEST)结构选择： KEYREQUEST中的KEYNAME字段总是参与密钥生成，它指示要生成的键的类型。虽然SGX设计定义了一些密钥类型，但秘密迁移特性总是使用密封密钥。其他关键类型由SGX软件认证过程使用，将在§5.8中概述。 KEYREQUEST中的KEYPOLICY字段有两个标志，用于指示是否将使用enclave的SECS中的MRENCLAVE和MRSIGNER字段进行密钥分发。虽然字段允许4个值，但只有两个值是有意义的，如下所述。 在KEYPOLICY中设置MRENCLAVE标志将分发的密钥与反映其内容的当前enclave度量绑定。其他enclave将无法获得相同的密钥。当分发的密钥用于加密enclave秘密时，这是非常有用的，因此它们可以由系统软件存储在非易失性内存中，从而在电源周期中存活。 如果设置了KEYPOLICY中的MRSIGNER标志，则分发的密钥将绑定到发布enclave证书的公共RSA密钥。因此，由同一作者发布的其他enclave可能能够获得相同的密钥，但要遵守下面的限制。这是唯一允许秘密迁移的KEYPOLICY值。 在KEYPOLICY中不设置标志没有什么意义。在这种情况下，分发的密钥没有有用的安全属性，因为它可以由与调用EGETKEY的enclave完全无关的其他enclave获得。相反，设置两个标志是多余的，因为仅设置MRENCLAVE就会导致分发的密钥绑定到当前enclave，这是最严格的策略。 KEYREQUEST结构指定了密钥分发过程中使用的enclave SVN (ISVSVN，§5.7.2)和SGX实现SVN (CPUSVN，§5.7.3)。但是，如果期望的enclave SVN大于当前enclave的SVN，或者期望的SGX实现的SVN大于当前实现的SVN, EGETKEY将拒绝派生请求并生成一个错误代码。 SVN限制可以防止秘密从具有较高SVN的集合转移到具有较低SVN的集合，或者从具有较高SVN的SGX实现转移到具有较低SVN的实现。§5.7.2认为SVN限制可以减少enclave和SGX实施中安全漏洞的影响。 EGETKEY总是使用来自当前enclave的SECS的ISVPRODID值进行密钥分发。因此，秘密永远不能在其SIGSTRUCT证书为其分配不同产品ID的enclaves之间流动。 类似地，密钥分发材料总是包含128位所有者轮数(OWNEREPOCH)SGX配置寄存器的值。这个寄存器是由计算机的固件设置为一个秘密生成一次，并存储在非易失性内存。在计算机更改所有权之前，旧的所有者可以从非易失性内存中清除OWNEREPOCH，从而使新所有者无法解密任何可能留在计算机上的enclave机密。 由于密钥分发过程的加密特性，外部观察者无法关联使用不同的OWNEREPOCH值分发的密钥。这使得软件开发人员不可能使用本节中描述的EGETKEY分发的密钥来跟踪处理器更改所有者。 EGETKEY分发材料还在KEYID字段中包含由enclave提供的256bit值。这使得enclave可以从EGETKEY生成密钥集合，而不是单个密钥。SDM规定KEYID应该用随机数填充，目的是帮助防止密钥损耗。 最后，密钥分发材料包括enclave的SECS中的ATTRIBUTES(§5.2.2)字段的位和和KEYREQUEST结构中的ATTRIBUTESMASK字段。该掩码的作用是从密钥分发材料中删除一些ATTRIBUTES比特，从而使在具有不同属性的enclave之间迁移秘密成为可能。§5.6.2和§5.7.4解释此功能的需要及其安全含义。 在将掩码属性值添加到密钥生成材料之前，EGETKEY强制掩码位对应INIT和调试属性(§5.2.2)。从实用的角度来看，这意味着秘密永远不会支持调试和生产的enclave之间迁移。 如果没有此限制，enclave作者使用相同的RSA密钥向调试和生产enclave颁发证书将是不安全的。调试enclave没有从SGX获得完整性保证，因此攻击者有可能修改调试enclave内的代码，使其泄漏它所能访问的任何秘密。 5.8 SGX软件认证 SGX实施的软件认证方案遵循了§3.3中概述的原则。启用SGX的处理器计算加载在每个enclave中的代码和数据的度量，这类似于TPM计算的度量(§4.4)。enclave内部的软件可以启动一个进程，从而产生SGX认证签名，其中包括enclave的度量和enclave消息。 SGX认证签名中使用的密码原语过于复杂，无法在硬件上实现，因此签名过程是由英特尔发行的一个有特权的引用Enclave来执行的，它可以访问SGX认证密钥。这个enclave在§5.8.2中进行了讨论。 图79: 建立一个SGX enclave并进行软件认证过程涉及到SGX指令EINIT和EREPORT，以及两个由英特尔编写的特殊enclave，SGX启动enclave和SGX引用enclave。 将签名功能推入引用Enclave，就需要在正在进行软件认证的Enclave和引用Enclave之间建立安全通信路径。SGX设计通过本地认证机制解决了这个问题，enclave可以使用该机制向同一启用SGX的CPU托管的任何其他enclave证明其身份。§5.8.1中描述的这个方案是通过EREPORT指令实现的。 引用enclave使用的SGX认证密钥在启用SGX的处理器离开工厂时不存在。认证密钥是稍后提供的，使用的过程包括一个由Intel发布的配置Enclave和两种特殊的EGETKEY(§5.7.5)密钥类型。这一过程的公开细节概述在§5.8.2中。 SGX启动enclave和EINITTOKEN结构将在§5.9中讨论。 5.8.1 本地认证 enclave通过如图80所示的EREPORT指令向另一个目标enclave证明其身份。SGX指令生成一个认证报告(报告)，该报告以加密方式将enclave提供的消息与enclave的基于度量(§5.6)和基于证书(§5.7.2)的身份绑定。加密绑定由MAC标签(§3.1.3)完成，MAC标签使用对称密钥计算，该密钥仅在目标enclave和SGX实现之间共享。 ​ 图80：EREPORT数据流 EREPORT指令从enclave的SECS(§5.1.3)中读取当前enclave的标识信息，并使用它填充报告结构。具体来说，EREPORT会复制SECS字段，这些字段表示enclave的度量(MRENCLAVE)、基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)和属性(ATTRIBUTES)。认证报告还包括SGX实现的SVN(CPUSVN)和enclave提供的64字节(512位)消息。 接收认证报告的目标enclave可以确信报告的真实性，如图81所示。这份报告的真实性证明是它的MAC标签。验证MAC所需的密钥只能由目标enclave获得，通过要求EGETKEY(§5.7.5)分发一个报告密钥。SDM声明MAC标记是使用基于块加密的MAC (CMAC)计算的，但是没有指定底层密码。SGX文件之一声明CMAC是基于128位AES。 EGETKEY返回的报告密钥来自于嵌入在处理器中的一个秘密(§5.7.5)，密钥材料包括目标enclave的度量。可以确保目标enclave报告中的MAC标签是由SGX产生的，原因如下。底层密钥分发的加密特性推导和MAC算法确保只有SGX所实现可以产生MAC标签，因为它是唯一的实体，可以访问处理器的秘密，这是不可能对攻击者获得报告密钥不知道处理器的秘密。SGX的设计保证了EGETKEY生成的密钥依赖于调用enclave的度量，因此只有目标enclave才能获得报告中用于生成MAC标签的密钥。 当KEYNAME设置为与报告密钥相关联的值时，EREPORT使用与EGETKEY相同的密钥分发过程。因此，EREPORT需要报告目标信息(TARGETINFO)结构的虚拟地址，该结构包含基于度量的标识和目标enclave的属性。 在分发一个报告密钥时，EGETKEY的行为与它在密封密钥情况下的行为略有不同，如图81所示。密钥生成材料从不包括与enclave的基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)对应的字段，并且KEYREQUEST结构中的KEYPOLICY字段将被忽略。因此，该报告只能由目标enclave加以核实。 图81: 由EREPORT创建的报告结构的真实性可以而且应该由报告的目标enclave验证。目标代码使用EGETKEY获取嵌入在报告结构中的MAC标记使用的密钥，然后验证标记。 此外，SGX实现用于密钥生成的SVN (CPUSVN)值是由当前的CPUSVN决定的，而不是从密钥请求结构中读取。因此，SGX实现升级，增加CPUSVN使所有未完成的报告无效。鉴于CPUSVN的增加与安全修复有关，§5.7.2中的论证表明，这一限制可能会减少SGX实现中漏洞的影响。 最后，EREPORT将密钥生成材料中的KEYID字段设置为SGX配置寄存器(CR_REPORT_KEYID)的内容，该寄存器在初始化SGX时以随机值初始化。KEYID值也保存在认证报告中，但是它不包含在MAC标签中。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Translation","slug":"Translation","permalink":"http://example.com/categories/Translation/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"CSDN博客保存为PDF","slug":"csdn-pdf","date":"2020-11-26T14:30:42.000Z","updated":"2021-04-07T08:42:26.506Z","comments":true,"path":"2020/11/26/csdn-pdf/","link":"","permalink":"http://example.com/2020/11/26/csdn-pdf/","excerpt":"将CSDN博客去除无用信息并保存为PDF","text":"F12打开开发者工具，在Console输入以下js代码： 123456789101112131415161718(function()&#123; &#x27;use strict&#x27;; var articleBox = $(&quot;div.article_content&quot;); articleBox.removeAttr(&quot;style&quot;); $(&quot;#btn-readmore&quot;).parent().remove(); $(&quot;#side&quot;).remove(); $(&quot;#comment_title, #comment_list, #comment_bar, #comment_form, .announce, #ad_cen, #ad_bot&quot;).remove(); $(&quot;.nav_top_2011, #header, #navigator&quot;).remove(); $(&quot;.csdn-side-toolbar,.template-box,.reward-user-box,.blog-footer-bottom&quot;).remove(); $(&quot;.p4course_target, .comment-box, .recommend-box, #csdn-toolbar, #tool-box,#dmp_ad_58, .more-toolbox, .article-info-box, .btn-readmore, .pub-footer-new&quot;).remove(); $(&quot;aside&quot;).remove(); $(&quot;.tool-box&quot;).remove(); $(&quot;main&quot;).css(&#x27;display&#x27;,&#x27;content&#x27;); $(&quot;main&quot;).css(&#x27;float&#x27;,&#x27;left&#x27;); $(&quot;#mainBox&quot;).width(&quot;100%&quot;); document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8; window.print();&#125;)(); 或者： 12345678910111213141516(function doPrint()&#123; &#x27;use strict&#x27;; var articleBox = $(&quot;div.article_content&quot;); articleBox.removeAttr(&quot;style&quot;); var head_str = &quot;&quot;; var foot_str = &quot;&quot;; var older = document.body.innerHTML; var title= document.getElementsByClassName(&#x27;article-title-box&#x27;)[0].innerHTML; var main_body = document.getElementsByClassName(&#x27;article_content&#x27;)[0].innerHTML; document.body.innerHTML = head_str + title + main_body + foot_str; $(&quot;#mainBox&quot;).width(&quot;100%&quot;); document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8; window.print(); document.body.innerHTML = older; return false;&#125;)();","categories":[{"name":"Useful","slug":"Useful","permalink":"http://example.com/categories/Useful/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"现代密码学 Notes","slug":"现代密码学-notes","date":"2020-11-25T11:09:27.000Z","updated":"2020-12-29T14:19:13.028Z","comments":true,"path":"2020/11/25/现代密码学-notes/","link":"","permalink":"http://example.com/2020/11/25/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/","excerpt":"现代密码学课程笔记","text":"古典替换密码 恺撒密码 每个字母用其后的第三个字母替换，即 Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC 恺撒密码的一般形式，可以将字母移动的位数由3变为1-25中的任何一个 混合单表替换密码 每个字母可以用其它任何一个字母替换（不能重复） 密钥长度为26个字母，因为每个字母需要一个映射 简单的单表替换密码 设置一个没有重复字母的“密钥字”，其它字母按顺序写在密钥字最后字母后面 给定密钥字 JULISCAER Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: JULISCAERTVWXYZBDFGHKMNOPQ 多字母替换密码 使用多个单字母替换表，因此一个字母可以被多个字母替换：用一个密钥选择每个字母使用哪个字母表，密钥的第i个字母表示使用第i个字母表，依次使用每个字母表，当密钥的字母使用完后，再从头开始 古典置换密码 方法：通过重新编排消息字母隐藏信息 特点：没有改变原来消息的字母集 关键思想：按一定规则写出明文，按另一规则读出密文 密钥：用于读密文的方法和写明文的方法 分组密码 在分组密码中，消息被分成许多块，每块都要被加密 替换运算 S-boxes 一个二进制字用其它二进制字替换，这种替换函数就构成密钥，可以看作是一个大的查表运算 混淆：使作用于明文的密钥和密文之间的关系复杂化 置换运算 P-boxes 二进制字次序被打乱，重新排序的方法构成密钥 扩散：将明文及密钥的影响尽可能迅速地散布到较多个输出的密文中 雪崩效应 输入改变1bit, 导致近一半的比特发生变化 保证小的输入变化导致大的输出变化 完备性效应 每个输出比特是所有输入比特的复杂函数的输出 保证每个输出比特依赖于所有的输入比特 Feistel密码 把输入块分成左右两部分 轮函数g是一个S-P网络 由第i个密钥控制（子密钥） L(i) = R(i-1) R(i) = L(i-1) xor g(K(i), R(i-1)) 求逆很容易 实际中，一些这样的连续变换形成完整密码变换 Feistel密码设计 分组大小：增加分组长度会提高安全性, 但降低了密码运算速度 密钥大小：增加密钥长度可以提高安全性(使得穷搜索困难)，但降低了密码速度 轮数：增加轮数可以提高安全性，但降低速度 子密钥生成：子密钥生成越复杂就越安全，但降低速度 Lucifer 分组长度是128-bit，密钥长度是128-bit 每轮使用的子密钥是密钥的左半部分 密钥每次要向左旋转56-bits，所以密钥的每部分都参加运算 轮函数的具体结构： 现代分组加密算法 简化的DES (S-DES) 加密算法涉及五个函数： 初始置换 IP 复合函数 fk1 ，由密钥K确定，具有转换和替换的运算 转换函数 SW 复合函数 fk2 初始置换IP的逆置换 IP-1 加解密流程 密文 = IP-1(fk2(SW(fk1(IP(明文))))) 明文 = IP-1(fk1(SW(fk2(IP(密文))))) 密钥生成： P10(k1, k2, k3, k4, k5, k6, k7, k8, k9, k10) = (k3, k5, k2, k7, k4, k10, k1, k9, k8, k6) P8(k1, k2, k3, k4, k5, k6, k7, k8, k9, k10) = (k6, k3, k7, k4, k8, k5, k10, k9) LS-1为循环左移1位，LS-2为循环左移2位 IP函数： IP= 1 2 3 4 5 6 7 8 ​ 2 6 3 1 4 8 5 7 IP-1= 1 2 3 4 5 6 7 8 ​ 4 1 3 5 7 2 8 6 函数fk：fk(L, R) = (L xor F(R, SK), R) , 其中SK为子密钥 F是一个4-bit到4-bit的映射： 首先对R做扩张/置换(E/P)运算 E/P运算：(1, 2, 3, 4) =&gt; (4, 1, 2, 3, 2, 3, 4, 1) 将子密钥SK（对应具体算法中的K1和K2）与E/P运算的结果异或得到8-bit数 P0,0 P0,1 P0,2 P0,3 P1,0 P1,1 P1,2 P1,3 第一行进入S盒S0，第二行进入S盒S1，分别产生2-bit输出 第1和第4输入比特决定行，第2和第3输入比特决定列，以确定选取S-盒元素的位置 如 (P0,0 P0,3)=(0 0),并且(P0,1 P0,2)=(1 0)，则选取S盒矩阵的第0行第2列的元素作为2-bit输出 加密具体过程 数据加密标准DES DES加密流程 对明文X，通过一个固定的初始置换IP得到X0： X0 = IP(X) = L0R0 , 分为左右两部分。 函数F的16次迭代：LiRi (1&lt;=i&lt;=16） Li = Ri-1 , Ri = Li-1 xor F(Ri-1, Ki) 其中Ki是长为48位的子密钥。 对比特串R16L16使用逆置换IP-1得到密文Y： Y = IP-1(R16L16) 加密相关的表见附录 DES一轮加密 轮函数F F(Ri-1, Ki) ，输入为32-bit的Ri-1和48-bit的子密钥Ki 对Ri-1使用扩展函数E，扩展为48-bit 计算 E(Ri-1) xor Ki ，结果写成8个6-bit串 B=b1b2b3b4b5b6 使用8个4*16的S盒，其中的元素取0~15的整数，每个S盒输出为4-bit串： b1b6确定S盒的行数，b2b3b4b5确定S盒的列数 最后，P为固定置换，输出为32-bit串 密钥K计算子密钥 密钥K是长度为64的位串：56位参加子密钥编排，8位是奇偶校验位，在密钥编排的计算中，不参加运算。 给定64位的密钥K，放弃奇偶校验位(8, 16, …, 64)，先进行PC-1固定置换，结果为前28-bit的C0和后28-bit的D0 对1 &lt;= i &lt;= 16，计算 Ci = LSi(Ci-1) Di = LSi(Di-1) 其中LSi表示循环左移1或2位，当i=1,2,9,16时移1位，其他情况移2位 计算 Ki = PC-2(CiDi) DES的S盒 DES的核心是S盒 S盒不是它输入变量的线性函数 改变S盒的一个输入位至少要引起两位的输出改变 对任何一个S盒，如果固定一个输入比特，其它输入变化时，输出数字中0和1的总数近于相等 双重DES 加密：C = EK2[EK1[P]] 解密：P = DK1[DK2[P]] 三重DES 两个密钥加密：C = EK1[DK2[EK1[P]]] IDEA 分组长度为64位，子分组长度为16位 密钥长度为128位 进行8轮循环 同一算法既可以加密也可以解密 IDEA加密总体方案 IDEA加密具体过程 是整数模216+1乘 (IDEA的S盒) 是整数模216加 IDEA的密钥生成 52个16-bit的加密子密钥从128-bit的密钥中生成： 前8个子密钥直接从密钥中取出； 对密钥进行25-bit循环左移，接下来的密钥从中取出； 重复进行直到52个子密钥全部生成。 解密密钥从加密子密钥中导出： 解密循环 i 的前4个子密钥从加密循环 10-i 的前4个子密钥中导出： 解密密钥的第1、4个子密钥对应于1、4加密子密钥的乘法逆元； 解密密钥的第2、3个子密钥对应于2、3加密子密钥的加法逆元 对前8个循环来说，循环 i 的最后两个子密钥等于加密循环 9-i 的最后两个子密钥 AES-Rijndael 可变块长、可变密钥长度 分组长度指定为128位 密钥长度为128，192或256位，相应的迭代轮数为10、12和14 AES框架 AES轮函数 每一轮迭代的结构都一样，只是最后一轮省略了列混合变换： 字节替换(Byte Sub) 对数据的每一字节应用一个非线性变换； 替换表是一个16×16的矩阵。表中纵向的x取自状态矩阵中的高4比特，横向的y取自低4比特。 行移位(Shift Row) 对每一行的字节循环重新排序，可以表示为: Bi,j = Ai,(i+j)mod4 列混合(Mix Column) 对矩阵的列应用一个线性变换: 将状态的每一列视为GF(28)上的多项式S(x)，然后乘以固定多项式a(x)，并模除x4+1。其中a(x) = {03}x3+{01}x2+{01}x+{02} a(x)存在关于x4+1的逆元，变换的矩阵为： 列混合变换的结果为： 轮密钥加(Add Round Key) 把轮密钥混合到中间数据，对状态和每轮的子密钥进行简单的异或操作 每轮子密钥是通过密钥调度算法从主密钥中产生，子密钥长度等于分组长度 轮密钥加运算需要用到4个导出的32比特子密钥 AES子密钥生成 Rijindael算法每一轮需要用到Nb比特的子密钥，共有Nr轮，另外，第一次轮密钥加的时候也需要用一轮子密钥，于是总共需要Nb*(Nr+1)比特的子密钥，对于AES-128来说就是用1408比特的子密钥 AES解密过程 逆字节替换、逆行移位、逆列混合、轮密钥加(其逆变换就是本身) 分组密码工作模式 ECB 电码本模式 消息分成相互独立的加密模块 每块独立使用DES算法 适合少量的数据加密 如果最后一个分组长度不够，需要填充 对于同一个明文分组，如果出现多次，其密文是相同的，因为每次的加密密钥都相同 (缺陷) CBC 密码分组链接模式 使重复的明文分组产生不同的密文分组：每次加密使用相同加密密钥，但是输入是当前明文分组盒前一个密文分组的异或 适合加密长度大于64比特的消息 如果最后一个分组长度不够，需要填充 可以用来进行用户鉴别 错误传播 解密时，每一个密文分组被解密后，再与前一个密文分组异或，便能得到明文分组 产生第一个密文分组时，需要一个初始向量IV与第一个明文分组异或，IV对于收发方都是已知的，且应该像密钥一样被保护 CFB 密码反馈模式 消息作为比特流，不需要对消息填充 适合数据以比特或字节为单位出现 错误传播 可以用于认证 加密过程： 解密过程： 将收到的密文单元和加密函数的输出进行异或 仍然使用加密算法而不是解密算法 OFB 输出反馈模式 结构类似CFB，不同之处在于OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器 消息作为比特流，不需要对消息填充 比特错误不会被传播 加密过程： 解密过程： CTR 计算器模式 可并行加密 预处理 吞吐量仅受可使用并行数量的限制 加密数据块随机访问 流密码 流密码简单结构 密钥源是一个容易记住的密钥 密钥流生成器生成一个周期较长、可用于加解密运算的伪随机序列 同步流密码与自同步流密码 同步流密码 密钥流的产生与明文消息流相互独立 无错误传播：在传输期间一个密文字符被改变只影响该符号的恢复，不会对后继的符号产生影响 自同步流密码 密钥流的产生与之前已经产生的若干密文有关 线性反馈移位寄存器 LFSR 用于生成密钥流： LFSR的结构非常适合硬件实现 LFSR的结构便于使用代数方法进行理论分析 产生的序列的周期可以很大 产生的序列具有良好的统计特性 反馈函数为：， 其中加法运算为模2加，乘法为普通乘法 第t+1时刻第i级寄存器的内容为： LFSR的联接多项式为： LFSR的周期与m序列 一个n级LFSR序列的周期最大只能是2n-1 若n级LFSR产生的非零序列的周期为2n-1，则称其为m序列 一个n级LFSR为最长移位寄存器的充要条件是它的联接多项式为F2上的n次本原多项式 2n-1为素数时，F2上的每一个n次不可约多项式均为n次本原多项式 伪随机序列 Golomb随机性假设 注：游程指一段连续的相同数字 m序列的伪随机性 线性复杂度 线性复杂度：能够输出该序列的最小线性移位寄存器的级数，即次数最小的联接多项式 如果序列的线性复杂度为l(&gt;=1)，则只要知道序列中任意相继的2l位，就可确定整个序列 安全的密钥流 周期充分长，一般不少于1016 随机统计特性好，即基本满足Golomb的随机性假设 大的线性复杂度，为序列长度的一半 基于LFSR的伪随机序列生成器 在LFSR的基础上加入非线性化的手段，产生适合于流密码应用的密钥序列(伪随机序列) 滤波生成器 由一个n级线性移位寄存器和一个m(&lt;n)元非线性滤波函数组成，滤波函数的输出为密钥流序列 g是一个m元布尔函数 组合生成器 若干个线性移位寄存器LFSRi(i=1, …, n)和一个非线性组合函数组成，组合函数的输出构成密钥流序列 其中LFSRi为n个级数分别为r1, r2, …, rn的线性移位寄存器 f是n元布尔函数 钟控制生成器 用一个或多个移位寄存器来控制另一个或多个移位寄存器的时钟 当LFSR1输出1时，移位时钟脉冲通过与门使LFSR2进行一次移位，从而生成下一位 当LFSR1输出0时，移位时钟脉冲无法通过与门影响LFSR2，因此LFSR2重复输出前一位 当LFSR1的输出是1时，LFSR2被时钟驱动 当LFSR1的输出是0时，LFSR3被时钟驱动 LFSR1的输出与LFSR2的输出做异或运算即为这个交错式停走生成器的输出 实用流密码 全球移动通信系统GSM中的A5算法 A5的钟控机制：如果在某一时刻钟控单元中三个值的某两个或三个相同，则对应的移位寄存器在下一时刻被驱动，而剩下的一个(或0个)值对应的移位寄存器则停走 RC4 参数n，长为n的秘密内部状态(2n数组)，当n取8时，内部状态有256(=2n)个元素(S[0], S[1], …, S[255])构成，每个元素都是0~255之间的一个数字 输入：一个可变长的密钥，用于初始化内部状态 输出：状态中按照一定方式选出的某一个元素K，该输出构成密钥流的一个字节，加解密时，K与一个明文/密文字节执行XOR运算 每生成一个K值，内部状态中的元素会被重新置换一次，以便下次生成K值 密钥调度算法 用来设置内部状态的随机排列，最开始设置为S[i]=i (i=0, 1, …, 255) 密钥长度可变，设为L个字节(K[0],…, K[L-1])，一般L在5~32之间，用这L个字节不断重复填充，直到得到 K[0],…, K[255]。该数组K将被用于对内部状态S进行随机化 伪随机生成算法 从内部状态中选取一个随机元素作为密钥流中的一个字节，并修改内部状态以便下一次选取 例子 公钥密码 对称密码体制的缺陷 密钥分配问题：缺少安全信道 密钥管理问题：任意两个用户之间都需要共享密钥，数量级很大 没有签名功能 公钥算法分类 Public Key Distribution Schemes (PKDS) 密钥交换 用于交换秘密信息(依赖于双方主体) 常用于交换对称加密算法的密钥 Public Key Encryption (PKE) 公钥加密 用于加密任何消息 任何人可以用公钥加密消息 私钥的拥有者可以解密消息 任何公钥加密方案能够用于密钥分配方案PKDS 许多公钥加密方案也是数字签名方案 Signature Schemes 用于生成对某消息的数字签名 私钥的拥有者生成数字签名 任何人可以用公钥验证签名 Diffie-Hellman密钥分配 不能用于交换任意消息 基于有限域上的指数问题 安全性是基于计算离散对数的困难性 能抵抗被动攻击，不能抵抗主动攻击（中间人） RSA 素数p, q要求足够大 通常选择小的加密指数E，可以对所有用户都相同 RSA快速实现 加密快，指数小；解密慢，指数大 利用中国剩余定理CRT快速实现RSA解密(M=CD mod N)： M1 = M mod p = (C mod p)Dmod(p-1) M2 = M mod q = (C mod q)Dmod(q-1) 解方程：M = M1 mod p 和 M = M2 mod q 具有唯一解(利用CRT)：M = (quM1 + pu’M2) mod N，其中pu mod q =1，qu’ mod p = 1 RABIN公钥密码体制 基于二次剩余问题和模n平方根问题 加密密钥为2，安全性等价于对大整数n的分解；解密更为困难 不能抵抗选择密文攻击 EI Gamal公钥加密 D-H算法的变形，用于安全交换密钥 安全性基于离散对数 缺点：增加消息长度（2倍） 认证和哈希函数 认证的主要目的： 实体认证(发送者非冒充) 消息认证(验证信息的完整性) 三类产生认证符的函数： 消息加密 消息认证码(MAC) 哈希函数 消息加密 对称加密：提供保密与一定程度的认证，不提供签名 公钥加密：(A -&gt; B) E(KUb, M) =&gt; 提供保密，不提供认证 E(KRa, M) =&gt; 提供认证和签名 E(KUb, E(KRa, M)) =&gt; 提供保密、认证和签名 消息认证码(MAC) 对选定消息使用一个密钥产生一个短小的定长数据分组，附加在消息中提供认证功能 (MAC = Ck(M)) 基本用法： M || Ck(M) =&gt; 提供认证 Ek2(M || Ck1(M)) =&gt; 提供认证(K1)和保密(K2) Ek2(M) || Ck1(Ek2(M)) =&gt; 提供认证(K1)和保密(K2) 适用于消息广播、比消息加密的工作量小、认证与保密分离、延长消息的保护期限 不可逆，且不提供数字签名 哈希函数 基本用法： Ek(M || H(M)) =&gt; 提供保密和鉴别 M || Ek(H(M)) =&gt; 提供鉴别 M || EKRa(H(M)) =&gt; 提供鉴别和数字签名 Ek(M || EKRa(H(M))) =&gt; 提供鉴别、数字签名以及保密 M || H(M || S) =&gt; 提供鉴别(S是通信双方共享的一个秘密值) Ek(M || H(M || S)) =&gt; 提供鉴别和保密 哈希函数要求： 消息长度任意，输出定长 易于计算 单向性 弱抗碰撞性：任意给定分组x，寻求不等于x的y，使得H(y)= H(x)在计算上不可行 强抗碰撞性：寻求对任何的(x,y)对使得H(x)=H(y)在计算上不可行 简单的异或哈希函数 每个n比特长度分组按比特异或，得到长度为n的哈希码 改进：(使得输入数据完全随机化，掩盖输入的数据格式) 先将n比特的哈希值设置为0 当前的哈希值循环左移一位 数据分组与哈希值异或形成新的哈希值 Merkle-Damgard结构： MD5 输入任意长度报文，输出128比特的摘要；输入分组长度为512比特；符合Merkle-Damgard结构 算法流程 在消息的最后添加填充位（一个1和若干个0），使得数据的长度满足length = 448 mod 512，填充完后，信息的长度为N*512+448(bit) 记录信息长度，用64位来存储填充前信息长度，如果信息长度超过264位，则只保留低64位。这64位加在第一步结果的后面，这样信息长度就变为(N+1)*512(bit) 初始化MD缓存，使用一个128位缓存存放哈希的中间和最后结果，缓存表示为4个32位的缓存器（A,B,C,D），初始化格式为低位字节存放在高地址字节 四轮循环处理512bit分组 输入：当前处理的512位分组Yq与上一轮输出CVq 循环：4轮循环依次记为F，G，H，I；借助列表T[1,…,64]（T[i]=232 * |sin(i)|的整数部分），列表提供随机化的32位模板以消除输入的规律 每个循环包括16步操作，每一步的基本形式： $$ b \\leftarrow b + ((a + g(b, c, d) + X[k] + T[i]) &lt;&lt;&lt; s) $$ +：模232加 a, b, c, d：MD缓存中的4个字，一开始被初始化，之后每一步操作结果都会替换其中一个字 &lt;&lt;&lt; s：循环左移s位 T[i]：矩阵T中的第i个32比特字，i = 1,…,16 g：循环函数F、G、H、I X[k]：当前分组的第k个字 输出：第4次循环输出加到第1轮循环的输入上产生CVq+1，相加是缓存中的4个字分别与CVq中对应的4个字以模232相加 MD5应用 对明文消息生成消息摘要 用于数字签名（UNIX、Linux等操作系统保护用户口令） MD5口令逆向 SHA-1 输入最大长度为264位的消息，输出160比特 ，分组为512比特 算法流程 在消息的最后添加填充位（一个1和若干个0），使得数据的长度满足length = 448 mod 512，填充完后，信息的长度为N*512+448(bit) 记录信息长度，用64位来存储填充前信息长度，如果信息长度超过264位，则只保留低64位。这64位加在第一步结果的后面，这样信息长度就变为(N+1)*512(bit) 初始化MD缓冲区，使用160位MD缓冲区来保存中间和最终哈希结果，表示为5个32位寄存器（A,B,C,D,E），存储为低位字节放在低地址字节上 以512位数据块为单位处理消息，4轮，每轮20步，每次循环分别使用一个额外的常数Kt 每一步的基本形式： $$ A,B,C,D,E\\leftarrow (E+f_t(B,C,D)+S5(A)+W_i+K_t),A,S{30}(B),C,D $$ +：模232加法 ft：逻辑函数，每轮循环不同 Si：32位常数循环左移i位 Kt：额外的常数 Wi：当前512位数据导出的一个32位字；共80个 前16个直接来自当前分组的16个字 其余： $$ W_t=S^1(W_{t-16}\\bigoplus W_{t-14}\\bigoplus W_{t-8}\\bigoplus W_{t-3}) $$ 第4次循环输出加到CVq，得到160位CVq+1（模232加） 哈希函数对比 SHA = MD4 ＋ 扩展变换 ＋ 外加一轮 ＋ 更好的雪崩 MD5 = MD4 ＋ 改进的比特杂凑 ＋ 外加一轮 ＋ 更好的雪崩 数字签名算法 只对消息的哈希签名，否则交换信息长度增加一倍；数字签名可以提供消息的不可否认性 RSA 给定(e, R), (d, p, q) 计算明文M的哈希h，S = hd(mod R)，发送(M, S) 接收方同样计算哈希h，Se mod R = h’ mod R，对比h和h’ 若先加密后签名，签名可能被替换 EI Gamal 加密算法不可交换——需要专门的签名算法 安全性基于离散对数的计算困难性 公钥：(y, g, p)，私钥(x) 签名方案: 随机数k，与p-1互素 计算K = gk mod p 计算S = k−1(M − Kx) mod (p−1) 发送签名(M, K, S)，销毁k 验证yKKS mod p=gM mod p 签名长度为消息的两倍 DSA El Gamal的变形，生成320位签名 安全性基于离散对数的计算困难性 密钥生成 公开参数 (p, q, g) p：大素数，2L，L为512到1024位且为64的倍数 q：160位（p-1）的素因子 g：h(p−1)/q, h &lt; p−1 且 h(p−1)/q(mod p) &gt; 1 选择私钥x，计算y = gx mod p，公钥为 (p, q, g, y) 签名生成（SHA：哈希函数） r = (gk mod p) mod q s = k−1(SHA(M) + xr) mod q 发送 (M, r, s) 签名验证 w = s−1 mod q u1 = SHA(M)w mod q u2 = rw mod q v = (gu1yu2 mod p) mod q 验证 v = r HMAC 以上为需要私钥的认证方案，计算量大 密钥与消息同时参加运算：KeyedHash = Hash(Key | Message)或Hash(Key1 | Hash(Key2 | Message)) HMAC：使用带密钥hash函数的结果 HMACK = Hash((K′ ⨁ opad) || Hash((K′ ⨁ ipad) || M)) K’：经过填充的密钥 opad、ipad：特殊的填充值 安全性基于原始的hash 信息隐藏与隐写分析 信息隐藏的基本概念 信息隐藏是将信息秘密嵌入在数字图像、声音、文档、视频等数字产品中，用以隐蔽通信、隐蔽标识，或识别所有者、完整性、发源地、使用权、序列号等。 信息隐藏技术的主要分支 隐蔽信道：系统存在的一些安全漏洞，通过某些非正常的访问控制操作，能形成隐秘数据流，而基于正常安全机制的软硬件不能觉察和有效控制 匿名通信 源重写技术：采用路由转发策略，发送者匿名 隐写术 版权标志 水印的分类 根据应用分类： 隐蔽通信 版权保护 认证和完整性 内容标注 根据嵌入域分类： 空域，如LSB 变换域，如DFT、DCT、DWT等 根据是否可见分类 可见水印 不可见水印 根据密钥分类 密钥水印 公钥水印 根据原始数据分类 私有水印：检测时需要原始数据 盲水印：检测时不需要原始数据 根据载体恢复分类 可逆水印 不可逆水印 根据鲁棒性分类 鲁棒水印：用于认证、版权保护 半易碎水印 易碎水印：对恶意改动敏感，用于完整性判定 鲁棒水印特性 不可见性 安全可靠性 鲁棒性 复杂性 容量 信息隐藏的一般过程 水印生成 类似噪声，具有不可预测的随机性 Arnold置乱技术：置乱96次回到原图 扩频技术 基于片率 基于伪随机序列 水印嵌入 加法嵌入：Xw(k) = X0(k) + a(k)w(k) 乘法嵌入：Xw(k) = X0(k)(1 + a(k)w(k)) 信息隐藏的常见算法 空域信息隐藏算法 通过直接修改像素值实现信息嵌入 优点：简单、快速、容量大 缺点：鲁棒性差 图像位平面特性： 位平面越高，对灰度值的贡献越大，相邻比特的相关也越强 最低位平面类似随机噪声 LSB算法 Patchwork算法 Checksum算法 频域水印算法 通过修改频域空间的系数实现水印嵌入 离散傅里叶变换（DFT） 离散余弦变换（DCT） 离散小波变换（DWT） 优点：鲁棒性好 缺点：复杂度高 附录 DES算法相关表 初始置换IP (对明文输入进行次序打乱) 初始置换的逆置换IP-1 扩展置换E (32-bit到48-bit) 置换函数P PC1 PC2 S-box 例子 AES算法相关表 字节替换表","categories":[{"name":"Course Notes","slug":"Course-Notes","permalink":"http://example.com/categories/Course-Notes/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"论文阅读-SGX Support for Dynamic Memory Management Inside an Enclave","slug":"paper-sgx-support-for-dynamic-memory-management-inside-an-enclave","date":"2020-11-25T00:20:42.000Z","updated":"2020-11-26T09:31:41.670Z","comments":true,"path":"2020/11/25/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/","link":"","permalink":"http://example.com/2020/11/25/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/","excerpt":"论文SGX Support for Dynamic Memory Management Inside an Enclave阅读笔记","text":"1. Introduction SGX1 shortcomings enclave建立时必须分配其所需的所有内存，并且难以根据工作量自适应分配enclave，需要根据最坏情况的工作量来分配内存 enclave页的访问控制由EPCM来管理，当页被加入enclave时其权限就得写入EPCM中，并且不能再改变，这就意味着必须允许页上将来可能执行的任何操作，不能做到权限最小化 library OS，异常处理和代码延迟加载 2. SGX2 Considerations &amp; Requirements 动态内存管理需要满足的条件 enclave需要自己掌控其内存和权限 enclave代码在enclave不知情的情况下被改变时，将不会被执行 系统的资源管理器能够正常管理和分配资源 需要同时有EPCM权限和系统权限才能更改内存权限 安全考量 enclave软件需要改变页的权限来进行访问控制 权限更改时要保证旧的权限从TLB中移除 如果enclave要将页还回系统，并且想要在以后使用相同的内存地址，则enclave需要知道页是什么时候被还回的 软件考量 enclave内部的内存管理机构需要能够重新分配内存资源 3. SGX2 Overview and Usage SGX2新增的指令 Enclave内存分配 To implement dynamic memory allocation and commitment, the enclave runtime system and the operating system have to agree on a protocol that coordinates the operating system usage of EAUG and the enclave runtime system usage of EACCEPT. Committed： Virtual Size减去为程序保留的内存（未分配）。怎么理解为程序保留的但未分配的内存？就是告诉系统我要一块内存，但暂时还用不上，不过分配的地址得给我，系统就给程序一个不用的地址，但不分配内存，等程序真的要使用时（读写），就从页面或物理内存中分配出来映射到那个地址上。 提交的内存： 系统从物理内存或者换页内存分配给进程的那一部分。这部分内存在虚拟内存的线性地址中是连续的，不过在物理内存或者换页内存中，不一定是连续的。提交但未使用的内存一般都在换页内存里面，只有去使用的时候，才会换到物理内存里面，这点要注意。 Enclave内存释放 SGX2 provides a more robust reclamation of committed memory. OS and enclave runtime system need to coordinate the execution of EMODT, ETRACK, and EREMOVE by the OS and execution of EACCEPT by the enclave runtime. 改变页的权限 分为扩大权限和缩减权限。 扩大权限： The internal manager executes EMODPE to extend the page permissions in the EPCM. The internal manager requests the system manager to extend page permissions in the page tables. 缩减权限： The internal manager requests that the system manager to restrict permissions on a page. The system manager executes EMODPR and updates page table permissions. After permissions have been updated, the system manager executes ETRACK on the SECS of the calling enclave and sends IPIs (处理器间中断：允许一个CPU向系统其他的CPU发送中断信号) to all processors that may be executing inside the enclave to flush TLB mappings. After all IPIs have been acknowledged, control is returned to the internal manager. The internal manager verifies that page permissions have been restricted and TLB mappings flushed by executing EACCEPT. 权限的更改(同时包含扩大和缩减权限)：先缩减后扩大 —— 避免产生不安全的中间临时情况 线程控制机构TCS分配 The software protocol is very similar to page restriction except that instead of executing EMODPR the OS executes EMODT. 动态加载模块 To support dynamic loading of modules, SGX2 provides EACCEPTCOPY which allows the internal manager to atomically initialize the contents and permission of a page. Library OS支持 提供异常处理 由enclave产生的异常 异常的类型 错误情况的具体信息 SGX2还另外提供enclave运行时产生的enclave内部的异常","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"SGX程序基础","slug":"sgx-programming","date":"2020-11-23T23:27:01.780Z","updated":"2020-11-24T07:29:19.728Z","comments":true,"path":"2020/11/24/sgx-programming/","link":"","permalink":"http://example.com/2020/11/24/sgx-programming/","excerpt":"Intel SGX程序SampleCode Notes","text":"项目目录结构 以SampleEnclave为例，目录结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940.├── App│ ├── App.cpp│ ├── App.h│ ├── Edger8rSyntax│ │ ├── Arrays.cpp│ │ ├── Functions.cpp│ │ ├── Pointers.cpp│ │ └── Types.cpp│ └── TrustedLibrary│ ├── Libc.cpp│ ├── Libcxx.cpp│ └── Thread.cpp├── Enclave│ ├── Edger8rSyntax│ │ ├── Arrays.cpp│ │ ├── Arrays.edl│ │ ├── Functions.cpp│ │ ├── Functions.edl│ │ ├── Pointers.cpp│ │ ├── Pointers.edl│ │ ├── Types.cpp│ │ └── Types.edl│ ├── Enclave.config.xml│ ├── Enclave.cpp│ ├── Enclave.edl│ ├── Enclave.h│ ├── Enclave.lds│ ├── Enclave_private_test.pem│ └── TrustedLibrary│ ├── Libc.cpp│ ├── Libc.edl│ ├── Libcxx.cpp│ ├── Libcxx.edl│ ├── Thread.cpp│ └── Thread.edl├── Include│ └── user_types.h├── Makefile└── README.txt App目录：存放应用程序中的不可信代码部分 App.cpp文件：应用程序中的不可信部分代码，其中包括了创建Enclave及销毁Enclave的代码，也定义了一些相关的返回码供使用者查看Enclave程序的执行状态。其中的main函数是整个项目的入口函数。 App.h文件：应用程序中的不可信部分代码的头文件，定义了一些宏常量和函数声明。 Edger8rSyntax文件夹：提供了一些工具。 TrustedLibrary文件夹：提供了一些函数库。 Enclave目录：存放应用程序中的可信代码部分和可信与不可信代码接口文件 Enclave.config.xml文件：Enclave的配置文件，定义了Enclave的元数据信息。 Enclave.cpp文件：应用程序中的可信部分代码，包括了可信函数的实现。 Enclave.h文件：应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明。 Enclave.edl文件：Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口，trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。 Enclave.lds文件：定义了一些Enclave可执行文件信息。 Enclave_private_test.pem文件：SGX生成的私钥。 Edger8rSyntax文件夹：提供了一些工具。 TrustedLibrary文件夹：提供了一些函数库。 Include目录：存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义 user_types.h文件：定义了用户自定义的类型 Makefile文件：项目的编译文件，定义了项目的编译信息","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Ubuntu将安装的应用固定到桌面","slug":"ubuntu-show-application","date":"2020-11-23T10:23:08.000Z","updated":"2020-11-26T14:34:54.918Z","comments":true,"path":"2020/11/23/ubuntu-show-application/","link":"","permalink":"http://example.com/2020/11/23/ubuntu-show-application/","excerpt":"Ubuntu20.04将国内版本的firefox固定到桌面","text":"升级了一下ubuntu，从18.04升到了20.04，发现自动安装了国际版的firefox，之前安装的国内版firefox目录还在/opt下，但是桌面显示的firefox是国际版的，且启动栏也没有国内版的firefox应用。 Step1 卸载国际版firefox 12dpkg --get-selections | grep firefoxsudo apt-get purge firefox ... # 所有上一步列出的应用 Step2 在/usr/share/applications/目录新建firefox.desktop，并添加内容： 123456[Desktop Entry]Name&#x3D;FirefoxExec&#x3D;&#x2F;opt&#x2F;firefox&#x2F;firefoxIcon&#x3D;&#x2F;opt&#x2F;firefox&#x2F;browser&#x2F;chrome&#x2F;icons&#x2F;default&#x2F;default128.pngTerminal&#x3D;FalseType&#x3D;Application Step3 更改firefox.desktop文件权限： 1sudo chmod 755 firefox.desktop Step4 在启动栏可以看见新建的应用图标，并且可以添加到侧边栏","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"SGX Developer Guide - Reading Notes","slug":"SGX-Developer-Guide-Notes","date":"2020-11-16T13:14:04.602Z","updated":"2020-11-23T03:06:52.375Z","comments":true,"path":"2020/11/16/SGX-Developer-Guide-Notes/","link":"","permalink":"http://example.com/2020/11/16/SGX-Developer-Guide-Notes/","excerpt":"Intel SGX Developer Guide 学习笔记","text":"专业名词 ECall：“Enclave Call”一个调用enclave内部接口函数的操作 OCall：“Out call”从enclave内部向外部的应用发起调用的操作 Trusted：任何在enclave内部 trusted 环境下执行的代码或者数据结构 Trusted Thread Context：线程的上下文存放在enclave中，主要包括以下几个部分组成： Thread Control Structure（TCS）线程控制结构 Thread Data/Thread Local Storage 在enclave中的线程相关的数据 State Save Area(SSA) 线程异常处理机制 Stack 线程栈 Untrusted：指代任何运行在应用的 untrusted 环境下（等价于enclave外部）的代码或者数据结构。 Enclave 编程模型 Enclave开发原则 enclave是一个庞大而单一的软件实体，目标在于将对于一个应用而言的可信计算基降低至可信运行时系统，ISV代码和第三方可信库。在上述组件中的任一个bug将会导致enclave的安全问题。 非可信域控制了enclave 接口函数什么时候被调用的顺序。 当调用进入enclave中，是由不可信域来在enclave中选择可信线程上下文去执行。 并不保证传递进去enclave（ecall）中的参数和从enclave向外部发送的参数（ocall）是正确的，因为这是由不可信域提供的。 enclave向外部发送的调用 OCall，不能保证不可信函数一定正确地被执行。 任何人都可以加载一个enclave。更为严重的是，攻击者可能使用攻击性应用程序去加载一个enclave，利用该enclave存在的安全漏洞，窃取相关数据。 Enclave文件格式 一个 enclave library 文件包括可信代码和数据部分，当enclave被创建时，这些将会被导入到受保护的 enclave 内存（即EPC）中 在一个enclave文件中，还存在着Intel SGX特定的数据结构，enclave元数据： 元数据没有导入EPC中，而是被不可信的加载器加载，并决定enclave如何导入到EPC中 元数据中定义了可信线程上下文的数量，包括可信堆和可信栈的大小，在enclave初始化的时候，可信堆和可信栈被可信运行时系统初始化 元数据同时包括enclave的签名，这对于enclave的认证和初始化时非常重要的 **注：**不管enclave中定义了多少个可信线程，在设计的过程中不能假设不可信应用将会以特定的顺序去调用 Enclave 中的接口函数。一旦enclave被初始化，一个攻击者可以调用 Enclave 接口函数，以任何可能的顺序去发起调用并且提供相应的输入参数。 Enclave可信计算基 Enclave Interface 函数 (ECalls) enclave无法控制哪个ECall被执行，或者ECall将会以怎样的顺序被调用 ISV接口函数仅仅只能在enclave初始化后被调用，这意味着： 任何必要的地址基地址重置被正确地执行。 可信全局数据，例如栈等被正确地初始化。 可信线程的上下文，可信线程被正确地初始化。 不直接说明的可信初始化函数执行完成。（例如ISV全局构造函数） Enclave的输入 Enclave输入和输出可以被不可信的代码观察和修改 为了防止针对输入函数的攻击，软件开发者应该采用加密的方式和完整性检测来保证enclave执行的可信性 当一个encalve函数被调用时： 函数的参数和其他任何通过引用传递的序列化数据参数进入到可信环境中，并且对于攻击者无法访问的。 在参数上进行读写操作，返回值和其他序列化的引用，根据enclave开发者的参数与特殊定义，将不会影响ISV代码和数据的保密和完整性。 参数和返回值，序列化数据被可信运行时分配和管理，不对任何ISV代码和数据进行覆盖。 参数，返回值和序列化引用的大小被ISV所指定。 通过引用传递的输入参数 当ISV接口函数被调用时，输入参数将被停留在enclave中。然而，当一个输入参数通过引用的形式传递，只有引用（或指针）将会放置到enclave中。引用所指向的值停留在外部，并且会不断地变化。例如，一个攻击者可能在enclave检查函数参数后改变所引用的值。 外部Enclave调用 (OCalls) Enclave无法直接访问OS提供的服务。作为替代的是，encalve必须发起一个OCall将其传递到不可信应用中。 当一个enclave内的ISV函数发起OCall时： OCall仅仅暴露其参数和返回值到不可信域中。 当一个OCall发生时，返回值和任何序列化数据的引用将传递进入可信执行环境中，对攻击者不可以访问。另外enclave需要检查指针。 当一个OCall发生时，可信线程上下文与OCall之前的相同，除了在栈上的数据和易变寄存器上的值。 Enclave签名 在软件中通过enclave建立信任的过程中主要有着以下三种行为： Measurement（度量）：作为enclave在可信环境中初始化时用来验证文件准确性的身份。 Attestation（认证）：向其它实体证明当前的环境被正确的初始化。 Sealing（数据的密封）：通过某种方式保证可信环境上的数据可以正确地持久化和重新加载。 Enclave签名包含允许Intel SGX硬件检测enclave的完整性是否被篡改的信息，同时可以识别enclave持有人的身份。encalve 签名包含这几个如下的重要字段，对于外部实体的认证非常重要。 Enclave Measurement - 一个简单的256位哈希值用来标注代码和放入到enclave中的初始化数据，包括他们放入到EPC中期待的顺序和位置，以及这些页面的安全属性。当enclave代码/数据加载到EPC中，CPU开始计算enclave measurement并且将这个值存储在MRENCLAVE 寄存器中。接着CPU比较MRENCLAVE寄存器中的内容和存放在SIGSTRUCT中的enclave measurement值。当且仅当它们相等的时候，CPU允许enclave被初始化。 Enclave所有者的公钥 - 当一个enclave被正确地初始化，CPU将enclave所有者的公钥的hash存放在MRSIGNER寄存器中。MRSIGNER中的内容将会用作enclave所有者的身份证明。被同一个key认证的enclave在MRSIGNER寄存器中的值相同。 Enclave的安全版本号（ISVSVN）- enclave所有者对于enclave的每个版本号分配一个安全版本号。安全版本号反映了enclave的安全属性级别，并且需要单调递增，随着安全属性的不断上升。在一个enclave被正确初始化后，CPU记录SVN，并且在远程认证的过程中被使用。一个有着相同安全属性的enclave的不同版本应该分配相同的安全版本号。例如，一个没有解决安全相关bug的新版本enclave需要与旧版本的enclave持有相同的安全版本号。 Enclave的产品ID（ISVPRODID）- enclave所有者针对每一个enclave分配一个产品ID。产品ID允许enclave所有者使用相同的enclave所有者身份去分割enclave。当一个enclave被正确的初始化后，CPU记录Product ID，在远程认证的过程中可以被使用。 Enclave认证 本地认证 一个enclave可以请求硬件生成一个证书，即report，其中通过密码学证据证明着enclave存在这个平台上。这个report可以给其他的enclave，让其进行验证report是同一平台上生成。内部enclave之间认证机制使用的是对称密钥，只有验证report结构的enclave和创建enclave report的硬件可以访问到，并且嵌入到硬件平台中。 一个enclave report包含着以下的信息： enclave中的code和初始化数据的measurement。 enclave初始化的时候记录ISV证书公钥的哈希值。 用户后来添加的数据。 其他安全相关的状态信息。 上述所有数据的一个签名，可以被生成report的同一平台去进行验证。 本地认证过程 在上图中，应用A持有enclave A，应用B持有enclave B。在不可信应用A和B为两个enclave建立通信后，enclave B向enclave A发送了MRENCLAVE的值。（应用A和B可以是同一应用） 有两种方法对于应用而言可以提取enclave的MRENCLAVE measurement: 应用B从enclave B的enclave证书中提取MRENCLAVE的值。 enclave B提供了一个接口来导出该值，通过创建一个report。 Encalve A请求硬件生成一份report送至enclave B，并且其中包含着从enclave B获取到的数据。enclave A通过不可信应用将数据发送给enclave B。 当enclave B收到了来自enclave A的报告，enclave B要求硬件去验证report来确认enclave A和B在同一平台上运行。enclave B从enclave A中提取相应的MRENCLAVE，然后请求硬件生成自己的report，接着发送给enclave A。 enclave A验证enclave B的report，并且验证enclave B和自己运行在同一平台上。 远程 (跨平台) 认证 一个持有enclave的应用可以要求enclave去生成一份report，接着将这份report传到平台服务去生成一种类型的证书，反映着enclave和平台的状态。这种类型的证书被称为quote。这个quote可以传递到平台外的实体，并且使用Intel Enhanced Privacy ID（Intel EPID）签名技术去进行验证。作为结果，CPU的密钥并没有直接从平台内部暴露出去。 一个quote包含这以下的数据： enclave中代码和初始化数据的measurement。 enclave初始化的时候记录ISV证书公钥的哈希值。 enclave的产品ID和安全版本号。 enclave的属性，例如，encalve是否运行在debug mode。 enclave中添加的用户数据。提供了一种方式由enclave向外部实体提供数据。 上述所有数据的一个签名，借助于Intel EPID组签名技术。 包含在quote中的enclave 数据（MRENCLAVE, MRSIGNER, ISVPRODID, ISVSVN, ATTRIBUTES等等）在远程认证过程的末尾提供给远程服务使用上。服务提供者将根据这些数据去进行判断是否可信。 EPID Intel EPID是一种组签名技术，允许平台去匿名签名对象并且可以保护签名者的隐私（如果使用机器的CPUID签名，会导致隐私的泄露）。通过Intel EPID签名技术，组里面的每一个签名者都有他们各自的私钥，但是验证者使用相同的公钥去验证个人的签名。因此，用户无法识别出两个交易是否来自于同一个机构，因为用户无法检测中是组里面哪个成员做了签名。在Intel SGX中，这个组是所有支持Intel SGX平台的集合。 QE Intel中内嵌了一种特殊的enclave，成为Quoting Enclave（QE），QE验证report正确地按照其MRENCLAVE mesurement值进行创建，然后将它用一个硬件特定的非对称密钥（Intel EPID key）进行签名，输出的内容就是quote。当enclave 系统正在运行的过程中，只有QE有权限访问Intel EPID key。因此quote可以看作直接来自于硬件本身，但是CPU key永远不会暴露到平台外部。 远程认证过程 当应用需要在平台外部的服务，它首先和外部服务提供系统建立连接。服务提供者发起挑战(包含一个nonce)来证明应用确实运行在enclave中 应用从应用的enclave请求一份report，并将来自外部服务提供商的nonce传递进enclave中 enclave生成一份report结构，并将其连同一个清单返回给应用，清单包含report中用户数据部分的值以及nonce和用于挑战应答交互的密钥 report发送给QE去做签名 QE验证report QE转换report的body转换为quote，并对其使用EPID进行签名 QE返回quote structure 应用返回quote结构体和其他相关的信息到外部服务者 外部服务者使用EPID验证公钥去验证quote的签名信息。 外部服务者对比来自enclave的信息，并与其它可信配置的信息进行比较。判断enclave是否满足条件。其中包括检测enclave是否运行在debug模式，及其的measurement，产品ID和enclave所有人等等。 区分不同的Enclave运行实例 Intel SGX不直接提供一种机制（例如，通过自动生成的REPORT字段）来区分同一个enclave的两个不同的实例。 如果想要尝试的话，可以使用RDRAND函数生成随机数，并作为作为用户数据，嵌入到REPORT中。 Enclave密封 为了保护和持久化数据，提供了一种由enclave软件从特定的enclave中提取key的机制。这个Key只能在特定的平台上被某个enclave生成。enclave 软件使用那个key去在平台上加密数据或者从平台上解密已经存在的数据。我们把这种加密和解密的操作成为密封和解封。 软件密封技术 密封到当前的enclave（依照于enclave度量） 密封到当前enclave 使用enclave measurement的当前版本（MRENCLAVE），当enclave创建的时候，将这个值绑定到密封操作所需要使用的key上。这个绑定操作由硬件执行通过EGETKEY指令。 只有有着相同的MRENCLAVE度量的enclave才能够将密封的数据进行解密。如果enclave的DLL，Dynamic Library，或者Shared Object文件被篡改，那么enclave的measurement将会发生改变。作为影响，密封的key同样会发生变化，数据将不会被还原。 密封到enclave当前的所有者 将数据密封到enclave的当前的所有者需要使用enclave所有者的身份，这个值由CPU在enclave初始化的过程中存储在MRSIGNER寄存器中，并且这个值被绑定到密封数据函数所需要使用到的key中。这个绑定是由硬件通过EGETKEY指令完成。被密封数据函数使用的key同时也被绑定到enclave的产品ID上。产品ID在enclave初始化时存储在CPU中。 当MRSIGNER度量寄存器的值和产品ID相同时，enclave才能解密。 这种机制的好处是： 它允许enclave的所有者对enclave进行升级，但是不需要进行复杂的升级过程来解密之前密封在之前版本的enclave（MRENCLAVE 度量值不同）中的数据，并且重新使用密封到新的版本 它允许来自相同的所有者的enclave实现共享数据 Enclave所有者生产出enclave后，可以为之指定安全版本号。这个安全版本号同样在enclave初始化的时候存储在CPU中。一个enclave在从CPU中获取密封key的请求中必须提供一个相应的安全版本号。一个enclave不能指定一个比它当前安全版本号靠后的enclave，但是encalve可以指定一个在当前安全版本号之前的安全版本号。这个选项使enclave获得了解封之前版本的enclave中的数据，对于enclave软件更新，是有着巨大的好处的。 密封和解封过程 在enclave中密封数据的主要过程如下： 为加密数据和密封数据结构在enclave中分配内存。其中密封数据结构主要包括要加密的数据和额外认证数据(AAD, 额外的参与MAC计算但不进行加密的数据或文本)。额外认证数据中的信息可能包括应用enclave，版本号，数据等 调用加密数据的API来执行加密操作，一个加密操作算法如下： 验证输入参数是有效的。例如，如果作为参数进行传递的是一个指向加密数据结构的指针，它指向的缓存必须存在于enclave中。 初始化并向其中填充一个将要被EGETKEY指令来执行密钥请求的数据结构。过程如下： 获取EREPORT去获得安全ISV和TCB安全版本号，将在key获取中使用 Key 名称：识别获取key的名字，在这种情况下即为Seal key Key Policy：识别即将使用的软件密封策略。使用MRSIGNER来表示密封到enclave的所有者上，使用MRENCLAVE来表示密封到当前的enclave（enclave measurement）中。保留位必须被清除 Key ID：调用RDRAND来获取一个随机数 属性字段：表明密封密钥应该与什么属性进行绑定 使用上一步构造出的密钥请求结构调用EGETKEY获取Seal key 使用加密算法来使用密封密钥来执行密封操作。推荐使用AES-GCM加解密函数，例如Rijndael128GCM 从内存删除seal key以防泄露 将密封数据结构（包括密钥请求结构）从enclave中保存到外部内存中。密钥请求结构将用来在今后的enclave初始化后去获取密封密钥。 在enclave中对加密数据进行解密主要包括以下过程： 为待解密的数据分配内存。 调用解密api去执行解密操作。一个解密操作算法如下： 验证输入参数的合法性。 从密封数据结构中提取密钥请求结构 借助密钥请求结构去通过EGETKEY指令获取密封密钥 调用解密算法使用密封密钥解密 从内存中删除密封密钥以防止泄露 验证解密算法生成的hash与加密过程中生成的hash一致 区分不同的Enclave实例 即使同一个enclave的两个不同的实例可以在它们认证时区分，但是当两个enclave都使用EGETKEY指令时，目前Intel SGX不提供一种机制来阻止一个enclave实例去访问另一个enclave的密封数据，两个实例将会返回相同的密钥值。 如果要区分enclave实例的SEAL key，推荐： Intel recommends that enclave writers use the KEYID field of the KEYREQUEST structure passed into the EGETKEY instruction to pass an enclave instance specific nonce. This will provide a different key even when the same enclave is in a different virtual machine. 处理器特征 在enclave中可以执行大部分Ring3软件能执行的指令 程序性能 Enclave创建 enclave的大小很大程度上影响了创建enclave的时间，主要是由于在enclave的度量（measurement）过程中，需要进行一系列操作以保证所有的代码加载到enclave中是可信的。 在enclave的创建过程中，一系列的EADD和EEXTEND指令将被运行，主要用于加载和度量enclave的页面。 EADD每次加载4k字节的数据。 EEXTEND每次度量256字节的数据。这意味着对于EADD添加的4KB的数据，需要发起16次的EEXTEND调用。 相关的性能优化建议： 减小enclave的大小。仔细检查在enclave中每段代码和数据元素，如有必要，将其移除。（使用工具：Intel VTune Amplifier）。例如，将即将静态链接的.o 文件先转换为诶.a文件。 Intel SGX 允许enclave通过 Enclave Dynamic Memory Management（EDMM）的方式去进行扩展。当你的OS支持EDMM，那么可以先创建一个比较小的enclave，然后扩展它。 通过在application中添加加载条的方式来获取用户的注意力，借此隐藏应用的加载时间。 避免频繁的enclave创建和重新加载，进而最小化重复的加载性能损耗。 Enclave切换 在enclave之间的频繁转变需要在上下文之间切换非常多次。当一个EENTER指令触发进入enclave时，为了保证enclave可以正常运行，属于不可信运行时的注册状态（register state）和其它信息被存储，enclave中的线程状态和其它属于可信状态的信息被加载，这部分工作主要是由SDK生成的代码执行。一个相反的过程发生在从enclave中退出（被EEXIT指令触发）：可信线程状态信息被保存，不可信的注册状态和其它信息被还原，在这个过程中同样执行着安全检查，这部分工作也主要由SDK生成的代码自动执行。这些行为构成了在应用和enclave之间控制权切换所带来的固定负载。 然而，这个转变中有一些可变变量影响着损耗，即传递参数的大小。参数在从不可信应用部分到可信enclave传递的过程中被序列化，并且返回值被反序列化。在可信enclave中，来自不可信应用的参数被反序列化，并且将返回值序列化。如果应用传递大量的参数，将会有显著的性能损耗。 如果在enclave和应用之间的控制权的转变很大程度地冲击着性能，考虑通过通过以下的方式降低影响： 减小传递参数的总大小。（使用工具：Intel VTunte Amplifier） 当确实有大量数据需要进行传递的时候，考虑使用指针的方式。需要说明的是，使用指针会带来一部分安全风险，为此你必须自己去实现指针检查器，如果使用这种方式的话。 过多缓存未命中 encalve所存储的内存内容在处理器cache之外的部分都是加密受保护的。这种类型的保护在从内存中获取cache lines带来了相应的负载。这种负载和Intel SGX实现方式有直接关系。 Intel SGX架构中在缓存未命中的情况下，相对于其他传统的负载，新增了两种类型的负载： 对于不在处理器cache中的每一条cache line所执行的完成check/anti-replay 检查，以及在系统内存中更新相应的数据结构（如果必要的话）。这种类型的负载依赖于内存访问模式。 在cache和内存中加载和移除数据所带来的加解密。 如果你的系统受到大量的缓存未命中而相关的性能损耗的冲击，可以考虑下面的步骤： 减小enclave中的数据的大小。观察数据，以保证只有必要的数据才能装载进入enclave中。更少的数据意味着更少的加减密和更少的数据结构检查，在Intel SGX内存控制/保护机制下。可以使用Intel VTune Amplifier来观察应用中的cache行为。 可以查看下面的文档去创建一个更加“缓存友好”的应用：PDF地址 过多的页写入 需要考虑Intel SGX应用频繁大量的页面切换对性能的影响，并且如何最小化这方面的后果： Intel SGX使用安全存储 EPC 来存储enclave中的内容。Enclave页面大小为4KB。当enclave比EPC总可用的内存要大的话，enclave分页机制可能会被某些特权软件来使用。当OS尝试交换enclave页面时，CPU使用EWB指令执行以下的步骤： 读取要替换出去的Intel SGX页面（移出） 加密页面中的内容 将加密的页面写到未收到保护的系统内存中 由于这个过程有着固定的负载，因此越多的页面被替换出去，越多的性能损耗发生。为了阻止应用频繁经历这种页面的交换，尽可能确保enclave的大小小于EPC。尽可能只将秘密数据和在这之上的操作放入enclave中，从而最小化页面交换的可能性。可以使用Intel VTune Amplifier工具来观察应用中页面替换的行为，来保证做出正确的决定 多线程下的性能 如果应用是多线程的，从数据同步，锁，线程模型和内存分配算法上去寻找改善性能的方法。 Intel SGX SDK 的一些关于同步和锁的原语已经被优化。 对于较重的多线程应用，推荐选择更好的内存分配算法。Intel SGX SDK针对linux提供了TCMalloc内存分配算法，相对于默认的dlmalloc内存分配算法，有着更好的性能表现。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Rust - Learn","slug":"Rust-notes","date":"2020-11-13T04:36:04.487Z","updated":"2020-11-16T07:49:22.339Z","comments":true,"path":"2020/11/13/Rust-notes/","link":"","permalink":"http://example.com/2020/11/13/Rust-notes/","excerpt":"Rust基础学习笔记","text":"Ch0 安装Rust 使用rustup安装 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装时出现的问题（未完全解决）：默认.cargo环境变量设置为了/home/&lt;username&gt;/~/.cargo，导致在用户家目录下又新建了~目录，在安装完rust后，将.cargo目录移动到~/家目录下，并修改所有可能会更改环境变量的文件，包括~/.profile、/etc/profile、/etc/bash.bashrc、~/.cargo/env，将其中的/home/&lt;username&gt;/~/.cargo改为~/.cargo。但是每当打开终端时，环境变量PATH还是会自动添加/home/&lt;username&gt;/~/.cargo/bin 暂时的解决方案：在~/.bashrc文件中添加语句，覆盖错误的环境变量(重启后就成功了) 1export PATH=~/.cargo/bin:$PATH Ch1 Cargo 1.1 使用Cargo创建项目 创建hello_world目录，并在其中新建二进制项目hello_world 1$ cargo new hello_world 创建库项目 1$ cargo new hello_world --lib 1.1.1 Cargo.toml Cargo.toml是项目的配置文件，通过cargo new自动生成 1234567[package]name = &quot;hello_world&quot;version = &quot;0.1.0&quot;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]edition = &quot;2018&quot;[dependencies] [package]片段：配置一个包，包含项目名称、版本、作者和Rust版本 [dependencies]片段：罗列项目依赖 1.1.2 源代码目录src 包含main.rs以及其他源文件 1.2 构建并运行Cargo项目 编译项目 1$ cargo build 编译并运行项目 1$ cargo run 快速检查代码确保其可以编译，但不生成可执行文件 1$ cargo check 以上命令会生成以下文件： 1.2.1 可执行文件 存放目录为./target/debug/hello_world 1.2.2 Cargo.lock Cargo.lock记录项目依赖的实际版本，确保项目构建是可重现的，这个文件不需要人为修改 1.3 发布(release)构建 当项目最终准备好发布时，可以优化编译项目是的Rust代码运行更快 1$ cargo build --release 此时生成的可执行文件在./target/release/目录下 Ch2 引入 - guess_number 2.1 创建变量 1let mut guess = String::new(); let 创建变量，变量默认不可变 mut 使得变量可变 :: 表明new是String类型的一个关联函数 2.2 从标准输入读取 123use std::io;io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;); io::stdin函数返回一个终端标准输入句柄 read_line将标准输入存入字符串 &amp;表示这个参数是一个引用 read_line函数返回一个Result类型（枚举），成员有Ok和Err Result实例有expect方法： 若Result值为Ok，expect获取Ok中的值并原样返回 若Result值为Err，expect导致程序崩溃，并显式当做参数传给expect的信息 2.3 crate crate是一个Rust代码包 我们构建的项目是一个二进制crate rand crate是一个库crate 2.3.1 导入外部crate 以rand crate为例 在使用rand编写代码之前需要修改Cargo.toml文件 123[dependencies]rand = &quot;0.5.5&quot; 再进行cargo build，此时会从Crates.io拷贝数据并下载对应的库文件，需要更换国内镜像源进行加速，编辑.cargo/config文件，加入以下内容 12345[source.crates-io]registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;replace-with &#x3D; &#39;ustc&#39;[source.ustc]registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot; 2.3.2 更新crate 1$ cargo update 2.3.3 获取所有本地依赖提供的文档 查看应该 use哪个trait以及该从crate中调用哪个方法 1$ cargo doc --open Ch3 常见编程概念 3.1 变量和可变性 使用let声明的变量默认是不可改变的 12let x = 3;x = 5; // 非法 在变量名之前加mut来使其可变 12let mut x = 3;x = 5; // 合法 3.1.1 变量和常量的区别 常量使用关键字const声明，并且必须注明值的类型 不能对常量使用mut 常量只能被设置为常量表达式，而不能是函数调用的结果 3.1.2 隐藏 定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量 12let x = 5;let x = x + 1; 当再次使用let时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字 3.2 数据类型 Rust 是 静态类型语言，在编译时就必须知道所有变量的类型 3.2.1 标量类型 标量类型代表一个单独的值 整型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 数字字面值 例子 Decimal 98_222 Hex 0xff Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b'A' 浮点型 Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位 默认类型是 f64 布尔型 bool，两个可能的值true和false 字符类型 char 类型的大小为四个字节，并代表了一个 Unicode 标量值 3.2.2 复合类型 元组类型 元组长度固定：一旦声明，其长度不会增大或缩小 元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的 12345let tup: (i32, f64, u8) = (500, 6.4, 1);let (x, y, z) = tup; // 解构let five_hundred = tup.0; // 使用索引访问 数组类型 数组中的每个元素的类型必须相同 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小 1234567let a = [1, 2, 3, 4, 5];let a: [i32; 5] = [1, 2, 3, 4, 5];let b = [0; 10]; // 初始化一个长度为10的全零数组let first = a[0]; // 使用索引访问 3.3 函数 fn 关键字声明新函数 在函数签名中，必须声明每个参数的类型 1234fn another_function(x: i32, y: i32) &#123; println!(&quot;The value of x is: &#123;&#125;&quot;, x); println!(&quot;The value of y is: &#123;&#125;&quot;, y);&#125; 3.3.1 具有返回值的函数 以表达式结尾 123fn plus_one(x: i32) -&gt; i32 &#123; x + 1&#125; 3.4 注释 // 单行注释 3.5 控制流 3.5.1 if表达式 123456789if number % 4 == 0 &#123; println!(&quot;number is divisible by 4&quot;);&#125; else if number % 3 == 0 &#123; println!(&quot;number is divisible by 3&quot;);&#125; else if number % 2 == 0 &#123; println!(&quot;number is divisible by 2&quot;);&#125; else &#123; println!(&quot;number is not divisible by 4, 3, or 2&quot;);&#125; Rust 不会尝试自动地将非布尔值转换为布尔值，所以if后跟的表达式必须是bool 在let语句中使用if 12345let number = if condition &#123; 5&#125; else &#123; 6&#125;; 代码块的值是其最后一个表达式的值 if和else中返回的类型要相同 3.5.2 循环 loop 无限循环，直到按下ctrl+c，或有break 内循环可以 continue 或者 break 外循环，此时需要在外循环添加生命周期： 1234567891011121314#![allow(unreachable_code)]fn main() &#123; &#x27;outer: loop &#123; println!(&quot;Entered the outer loop&quot;); &#x27;inner: loop &#123; println!(&quot;Entered the inner loop&quot;); // This would break only the inner loop //break; // This breaks the outer loop break &#x27;outer; &#125; &#125;&#125; loop 可以返回值，返回 break 后的表达式 12345678910fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; &#125; &#125;; assert_eq!(result, 20);&#125; while 12345let mut number = 3;while number != 0 &#123; println!(&quot;&#123;&#125;!&quot;, number); number = number - 1;&#125; for遍历集合 123456789101112131415161718let a = [10, 20, 30, 40, 50];// iter引用集合a，在循环结束后仍然可以使用afor element in a.iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element);&#125;// into_iter移动集合a的所有权，在循环结束后不能使用afor element in a.into_iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element);&#125;let mut b = [1, 2, 3];// iter_mut引用可变集合b，可以在循环中改变b中的元素for element in b.iter_mut() &#123; *element += 1;&#125; Ch4 所有权 4.1 什么是所有权 Rust管理内存的方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查 4.1.1 所有权规则： Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 值有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 4.1.2 变量作用域 12345&#123; // s 在这里无效, 它尚未声明 let s = &quot;hello&quot;; // 从此处起，s 是有效的 // 使用 s&#125; // 此作用域已结束，s 不再有效 4.1.3 String类型 字符串的字面值是不可变的，而String类型的字符串是可变的 String类型的字符串被分配到堆上，所以能够存储在编译时未知大小的文本 12// 基于字符串字面值来创建Stringlet s = String::from(&quot;hello&quot;); 4.1.4 内存与分配 对于String类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着： 必须在运行时向操作系统请求内存 需要一个当我们处理完String时将内存返回给操作系统的方法 Rust处理第二点的策略：内存在拥有它的变量离开作用域后就被自动释放 4.1.5 存储在堆上的变量 1. 移动 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; String 由三部分组成，如上图所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。 当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做二次释放的错误，两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。 在Rust中，经过以上语句，会认为s1不再有效，即s1 被移动到了 s2 中，因此当s1离开作用域时不会释放内存。 克隆 12let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone(); s2深度复制了s1堆上的内容，而不仅仅是栈上的指针。 以上只针对存储在堆上的类型，而对于类似整型等存储在栈上的类型，可以直接拷贝，变量值不会被移动 4.1.6 所有权与函数 123456789101112131415161718192021222324fn main() &#123; let s1 = gives_ownership(); // gives_ownership 将返回值移给 s1 let s2 = String::from(&quot;hello&quot;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃fn gives_ownership() -&gt; String &#123; // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数&#125;// takes_and_gives_back 将传入字符串并返回该值fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数&#125; 4.2 引用与借用 当String类型的变量传入函数中时，如何以引用的方式传入而不是将所有权交给函数？ 12345678910fn main() &#123; let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);&#125;fn calculate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权， // 所以什么也不会发生 &amp;s1语法让我们创建一个指向值s1的引用，但是并不拥有它 我们将获取引用作为函数参数称为借用 引用默认不允许被修改 4.2.1 可变引用 12345678fn main() &#123; let mut s = String::from(&quot;hello&quot;); change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(&quot;, world&quot;);&#125; 可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用，如以下代码是非法的： 12345let mut s = String::from(&quot;hello&quot;);// s被引用了两次，非法let r1 = &amp;mut s;let r2 = &amp;mut s; 这样的限制可以避免数据竞争，即 两个或更多指针同时访问同一数据 至少有一个指针被用来写入数据。 没有同步数据访问的机制 可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能同时拥有 12345let mut s = String::from(&quot;hello&quot;);&#123; let r1 = &amp;mut s;&#125; // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用let r2 = &amp;mut s; 可变引用和不可变引用不能同时存在，如以下代码非法： 1234567let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题let r3 = &amp;mut s; // 大问题println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3); 由于一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，所以以下代码合法： 123456789let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);// 此位置之后 r1 和 r2 不再使用let r3 = &amp;mut s; // 没问题println!(&quot;&#123;&#125;&quot;, r3); 4.2.2 悬垂引用 所谓悬垂指针是其指向的内存可能已经被分配给其它持有者 在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域，如以下函数非法： 1234fn dangle() -&gt; &amp;String &#123; // dangle 返回一个字符串的引用 let s = String::from(&quot;hello&quot;); // s 是一个新字符串 &amp;s // 返回字符串 s 的引用&#125; // 这里 s 离开作用域并被丢弃。其内存被释放。危险！ 而应该直接返回String，将所有权移动出去 4.3 Slice类型 slice是一个没有所有权的数据类型 slice允许你引用集合中一段连续的元素序列，而不用引用整个集合 4.3.1 字符串slice 字符串 slice是String中一部分值的引用 12345let s = String::from(&quot;hello world&quot;);let hello = &amp;s[0..5];let world = &amp;s[6..11];let all_s = &amp;s[..]; 字符串字面值就是slice，如let s = &quot;Hello world&quot;中，s的类型是&amp;str，是一个指向二进制程序特定位置的slice 4.3.2 其他类型的slice 如数组slice: 123let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3]; Ch5 结构体 5.1 结构体的定义和实例化 123456789101112131415161718// 定义struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125;// 实例化let mut user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1,&#125;;// 获取并修改字段user1.email = String::from(&quot;anotheremail@example.com&quot;); 想要修改实例中的字段，必须将整个结构体声明为可变 12345let user2 = User &#123; email: String::from(&quot;another@example.com&quot;), username: String::from(&quot;anotherusername567&quot;), ..user1&#125;; ..语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值 5.1.1 元组结构体 元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型 12345struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0);let origin = Point(0, 0, 0); 5.1.2 结构体数据的所有权 结构体可以直接存放自身拥有所有权的类型，如String等 结构体在存储引用、slice等没有自身所有权的类型时，需要用上生命周期 5.2 结构体引用和打印 5.2.1 函数调用结构体 函数引用结构体时，不需要获得其所有权，所以采用引用的方式调用: 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, area(&amp;rect1) );&#125;fn area(rectangle: &amp;Rectangle) -&gt; u32 &#123; rectangle.width * rectangle.height&#125; 5.2.2 结构体打印 需要使用派生trait 1234567891011#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1); // 或 println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);&#125; 5.3 方法语法 使用关键字impl给结构体定义方法，可以避免另外定义函数 1234567891011121314151617181920#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 将self以不可变引用的方式调用 fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, rect1.area() );&#125; 5.3.1 关联函数 在impl块中定义不以self作为参数的函数，通常用作返回一个结构体实例的构造函数： 123456789101112#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 返回一个正方形的实例 fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, height: size &#125; &#125;&#125; 使用let sq = Rectangle::square(3);调用关联函数 Ch6 枚举和模式匹配 6.1 定义枚举 以IP地址类型为例，通过enum定义一个枚举类型： 1234enum IpAddrKind &#123; V4(u8, u8, u8, u8), V6(String),&#125; 创建IpAddrKind实例： 12let four = IpAddrKind::V4(127.0.0.1);let six = IpAddrKind::V6(String::from(&quot;::1&quot;)); 枚举类型也可以像结构体一样使用impl为其定义方法 6.1.1 Option枚举 Option是标准库定义的另一个枚举，且被包含在preclude中 Rust没有空值，但拥有Option枚举来编码存在或不存在 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; Some可以包含任意类型的数据 使用None需要指定类型 1234let some_number = Some(5);let some_string = Some(&quot;a string&quot;);let absent_number: Option&lt;i32&gt; = None; Option&lt;T&gt;类型的值不能和T类型的值直接运算，必须提前进行转换，因此空值在使用前必须被检查 6.2 match控制流运算符 123456789101112131415161718enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(&quot;Lucky penny!&quot;); 1 &#125;, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个match表达式的返回值 6.2.1 匹配Option&lt;T&gt; 12345678910fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125;let five = Some(5);let six = plus_one(five);let none = plus_one(None); 用于空值处理 匹配是有穷的，必须覆盖变量的所有情况 6.2.2 _通配符 可以在match的所有分支的最后使用_来匹配剩余的所有情况 12345678let some_u8_value = 0u8;match some_u8_value &#123; 1 =&gt; println!(&quot;one&quot;), 3 =&gt; println!(&quot;three&quot;), 5 =&gt; println!(&quot;five&quot;), 7 =&gt; println!(&quot;seven&quot;), _ =&gt; (),&#125; 6.3 if let 简单控制流 123456let some_u8_value = Some(0u8);if let Some(3) = some_u8_value &#123; println!(&quot;three&quot;);&#125; else &#123; println!(&quot;other&quot;);&#125; 可以用于替代只有两分支的match语句 Ch7 使用包、Crate和模块管理项目 7.1 包和crate crate是一个二进制项或者库 包 (package) 是提供一系列功能的一个或者多个 crate，一个包会包含有一个Cargo.toml文件，阐述如何去构建这些 crate 一个包中至多只能包含一个库 crate 一个包中可以包含任意多个二进制 crate 一个包中至少包含一个 crate，无论是库的还是二进制的 使用cargo new创建项目时，src/main.rs就是一个与包同名的二进制 crate 的 crate根 通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate 7.2 模块 模块定义： 123456789101112mod front_of_house &#123; mod hosting &#123; fn add_to_waitlist() &#123;&#125; fn seat_at_table() &#123;&#125; &#125; mod serving &#123; fn take_order() &#123;&#125; fn server_order() &#123;&#125; fn take_payment() &#123;&#125; &#125;&#125; 对应的模块树： 123456789crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 7.3 引用模块树中项的路径 路径的两种形式，都是通过::连接： **绝对路径 ** 从 crate 根开始，以 crate 名或者字面值 crate 开头。 相对路径 从当前模块开始，以 self、super 或当前模块的标识符开头。 7.3.1 使用pub关键字暴露路径 Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，父模块不能使用子模块的私有项，但子模块可以使用父模块中的项，同级的两个模块可以互相引用 当父模块需要使用子模块的项的，需要在子模块中将其声明为pub 7.3.2 使用super起始的相对路径 super相当于文件系统中的..，即当前模块的父模块 7.3.3 创建公有的结构体和枚举 如果在一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的 1234567891011121314151617181920212223mod back_of_house &#123; pub struct Breakfast &#123; pub toast: String, seasonal_fruit: String, &#125; impl Breakfast &#123; pub fn summer(toast: &amp;str) -&gt; Breakfast &#123; Breakfast &#123; toast: String::from(toast), seasonal_fruit: String::from(&quot;peaches&quot;), &#125; &#125; &#125;&#125;pub fn eat_at_restaurant() &#123; // Order a breakfast in the summer with Rye toast let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;); // Change our mind about what bread we&#x27;d like meal.toast = String::from(&quot;Wheat&quot;); println!(&quot;I&#x27;d like &#123;&#125; toast please&quot;, meal.toast);&#125; 因为 back_of_house::Breakfast 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造实例 Breakfast，否则无法在 eat_at_restaurant 中创建实例 7.4 use关键字 使用use关键字可以简化模块中项的调用： 123456789101112131415mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;use crate::front_of_house::hosting; // 绝对路径// 或 use front_of_house::hosting; 相对路径pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;fn main() &#123;&#125; 可以使用 as 关键字提供新名称 123456789101112use std::fmt::Result;use std::io::Result as IoResult;fn function1() -&gt; Result &#123; // --snip--# Ok(())&#125;fn function2() -&gt; IoResult&lt;()&gt; &#123; // --snip--# Ok(())&#125; 当使用 use 关键字将名称导入作用域时，在新作用域中可用的名称是私有的，可以使用 pub use 重导出，使得名称可以引入任何代码的作用域中 7.4.1 使用嵌套路径精简代码 123456789use std::cmp::Ordering;use std::io;// 可以精简为：use std::&#123;cmp::Ordering, io&#125;;use std::io;use std::io::Write;// 可以精简为：use std::io::&#123;self, Write&#125;; 7.4.2 glob运算符 如果希望将一个路径下所有公有项引入作用域，可以指定路径后跟 * 1use std::collections::*; 7.5 将模块分割进不同文件 先使用如下语句引入模块： 1mod front_of_house; Ch8 常见集合 8.1 vector 在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值 vector 只能储存相同类型的值 8.1.1 新建vector 新建空vector时需要指明类型 1let v: Vec&lt;i32&gt; = Vec::new(); 使用 vec! 宏来定义含有初值的vector 1let v = vec![1, 2, 3]; 8.1.2 vector添加元素 1234let mut v = Vec::new();v.push(5);v.push(6); 当vector离开作用域时，会连同其元素全部销毁 8.1.3 读取vector元素 1let v = vec![1, 2, 3, 4, 5]; 使用索引访问，若越界，则会报错崩溃(适用于访问边界严格的vector) 12let third: &amp;i32 = &amp;v[2];println!(&quot;The third element is &#123;&#125;&quot;, third); 使用 get 方法返回一个 Option&lt;&amp;T&gt;，若越界，则会返回None(适用于vector索引可能由用户输入而越界) 1234match v.get(2) &#123; Some(third) =&gt; println!(&quot;The third element is &#123;&#125;&quot;, third), None =&gt; println!(&quot;There is no third element.&quot;),&#125; 当获取了vector的一个元素的不可变引用后，不能在其末尾添加元素，如下代码非法： 1234let mut v = vec![1, 2, 3, 4, 5];let first = &amp;v[0];v.push(6); 8.1.4 遍历vector中的元素 遍历不可变引用 1234let v = vec![100, 32, 57];for i in &amp;v &#123; println!(&quot;&#123;&#125;&quot;, i);&#125; 遍历可变引用 1234let mut v = vec![100, 32, 57];for i in &amp;mut v &#123; *i += 50;&#125; 8.1.5 结合枚举来存储多种类型 1234567891011enum SpreadsheetCell &#123; Int(i32), Float(f64), Text(String),&#125;let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(&quot;blue&quot;)), SpreadsheetCell::Float(10.12),]; 8.2 字符串 8.2.1 新建字符串 新建空字符串 1let mut s = String::new(); 往空字符串中装载数据 1let s = &quot;initial contents&quot;.to_string(); 新建有初始值的字符串 1let s = String::from(&quot;initial contents&quot;); 8.2.2 更新字符串 使用 push_str 方法来附加字符串 slice 12let mut s = String::from(&quot;foo&quot;);s.push_str(&quot;bar&quot;); 使用 push 附加一个字符 12let mut s = String::from(&quot;lo&quot;);s.push(&#x27;l&#x27;); 使用 + 运算符 123let s1 = String::from(&quot;Hello, &quot;);let s2 = String::from(&quot;world!&quot;);let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用 使用 format! 宏 12345let s1 = String::from(&quot;tic&quot;);let s2 = String::from(&quot;tac&quot;);let s3 = String::from(&quot;toe&quot;);let s = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, s1, s2, s3); 8.2.3 索引字符串 Rust的 String 字符串不支持索引单个值，但能够创建字符串slice 12let hello = &quot;Здравствуйте&quot;;let s = &amp;hello[0..4]; 8.2.4 遍历字符串 遍历每个元素（每个元素可能不止一个字节） 123for c in &quot;नमस्ते&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; 遍历每个原始字节 123for b in &quot;नमस्ते&quot;.bytes() &#123; println!(&quot;&#123;&#125;&quot;, b);&#125; 8.3 哈希map HashMap&lt;K, V&gt; 类型储存了一个键类型 K 对应一个值类型 V 的映射 8.3.1 新建一个哈希map 12345678use std::collections::HashMap;// 新建一个空的Hashmaplet mut scores = HashMap::new();// 插入键值对scores.insert(String::from(&quot;Blue&quot;), 10);scores.insert(String::from(&quot;Yellow&quot;), 50); 哈希 map 将它们的数据储存在堆上 所有的键必须是相同类型，值也必须都是相同类型 也可以通过vector的 collect 方法创建 123456use std::collections::HashMap;let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];let initial_scores = vec![10, 50];let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect(); 8.3.2 哈希map和所有权 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map 对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者 8.3.3 访问哈希map中的值 12let team_name = String::from(&quot;Blue&quot;);let score = scores.get(&amp;team_name); get 方法返回的 score 是 Option&lt;T&gt; 类型 8.3.4 遍历哈希map 123for (key, value) in &amp;scores &#123; println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);&#125; 8.3.5 更新哈希map 使用相同的键插入不同的值，会覆盖旧值 使用 entry 方法，只有在键没有对应的值存在的时候插入 12scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);scores.entry(String::from(&quot;Blue&quot;)).or_insert(50); 根据旧值更新一个值 123456789101112use std::collections::HashMap;// 统计单词出现的次数let text = &quot;hello world wonderful world&quot;;let mut map = HashMap::new();for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); *count += 1;&#125;println!(&quot;&#123;:?&#125;&quot;, map); or_insert 方法事实上会返回这个键的值的一个可变引用（&amp;mut V） Ch9 错误处理 9.1 panic!与不可恢复的错误 遇到错误时，Rust 有 panic!宏，当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出 9.1.1 backtrace backtrace 是一个执行到目前位置所有被调用的函数的列表 使用backtrace来找到自己写的代码中错误出在哪一行 1$ RUST_BACKTRACE=1 cargo run 9.2 Result与可恢复的错误 Result 枚举： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; T 代表成功时返回的 Ok 成员中的数据的类型 E 代表失败时返回的 Err 成员中的错误的类型 9.2.1 匹配不同的错误 使用 match 代码比较冗长，且较难理解 123456789101112131415161718use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(&quot;hello.txt&quot;); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; match error.kind() &#123; ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) &#123; Ok(fc) =&gt; fc, Err(e) =&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e), &#125;, other_error =&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error), &#125;, &#125;;&#125; 9.2.2 unwrap 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值 如果 Result 是成员 Err，unwrap 会为我们调用 panic! 12345use std::fs::File;fn main() &#123; let f = File::open(&quot;hello.txt&quot;).unwrap();&#125; 9.2.3 expect 12345use std::fs::File;fn main() &#123; let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);&#125; 使用方法类似 unwrap ，但是可以自己指定显示的错误信息 9.2.4 传播错误 12345678910111213use std::io;use std::io::Read;use std::fs::File;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; // 若文件打开失败，函数会返回相应的错误 let mut f = File::open(&quot;hello.txt&quot;)?; let mut s = String::new(); // 若文件内容写入字符串失败，函数会返回相应的错误 f.read_to_string(&amp;mut s)?; // 若函数执行完成没有出错，则返回Ok Ok(s)&#125; Rust提供了fs::read_to_string 的函数来简化从文件读取到一个字符串中的操作： 123456use std::io;use std::fs;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; fs::read_to_string(&quot;hello.txt&quot;)&#125; 9.3 panic!的使用场景 在当有可能会导致有害状态的情况下建议使用 panic! —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况： 有害状态并不包含 预期 会偶尔发生的错误 之后的代码的运行依赖于处于这种有害状态 当没有可行的手段来将有害状态信息编码进所使用的类型中的情况 Ch10 泛型、trait和生命周期 10.1 泛型 使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型 10.1.1 在函数定义中使用泛型 12345678910fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list.iter() &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，所以需要在函数名称之后写上 &lt;T&gt; 10.1.2 结构体定义中的泛型 字段 x 和 y 必须是相同的类型 123456789struct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; 字段 x 和 y 可以是不同的类型 12345678910struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;fn main() &#123; let both_integer = Point &#123; x: 5, y: 10 &#125;; let both_float = Point &#123; x: 1.0, y: 4.0 &#125;; let integer_and_float = Point &#123; x: 5, y: 4.0 &#125;;&#125; 10.1.3 枚举定义中的泛型 Option&lt;T&gt; 枚举： 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; Result&lt;T, E&gt; 枚举： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; 10.1.4 方法定义中的泛型 123456789101112131415struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Point&lt;T&gt; &#123; fn x(&amp;self) -&gt; &amp;T &#123; &amp;self.x &#125;&#125;fn main() &#123; let p = Point &#123; x: 5, y: 10 &#125;; println!(&quot;p.x = &#123;&#125;&quot;, p.x());&#125; 在 Point&lt;T&gt; 结构体上实现方法 x，它返回 T 类型的字段 x 的引用 必须在 impl 后面声明 T，这样 Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型 10.1.5 泛型代码的性能 Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失 Rust 通过在编译时进行泛型代码的单态化来保证效率，即在编译时填充泛型所使用的具体类型，从而将通用代码转换为特定代码 10.2 trait：定义共享的行为 trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能 10.2.1 定义并使用trait 12345678910111213141516171819202122232425262728293031pub trait Summary &#123; // 实现这个 trait 的类型所需要的行为的方法签名 fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;// 在impl关键字之后，提供需要实现trait的名称，接着是for和需要实现trait的类型的名称impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content) &#125;&#125; 只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait 不能为外部类型实现外部 trait：例如，不能在 aggregator crate 中为 Vec&lt;T&gt; 实现 Display trait。这是因为 Display 和 Vec&lt;T&gt; 都定义于标准库中，它们并不位于 aggregator crate 本地作用域中 10.2.2 默认实现 有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为 123456// trait提供默认实现pub trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; String::from(&quot;(Read more...)&quot;) &#125;&#125; 10.2.3 trait作为参数 123pub fn notify(item: impl Summary) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 对于 item 参数，指定了 impl 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 notify 函数体中，可以调用任何来自 Summary trait 的方法，比如 summarize 使用trait bound重写上面的函数 123pub fn notify&lt;T: Summary&gt;(item: T) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; trait bound适合函数传入多个相同类型的参数 12345// item1和item2的类型可以不同，只要它们都实现了Summarypub fn notify(item1: impl Summary, item2: impl Summary) // item1和item2的类型必须相同pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) 指定多个trait bound 123pub fn notify(item: impl Summary + Display)// 或pub fn notify&lt;T: Summary + Display&gt;(item: T) 通过 where 简化trait bound 1234fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32 where T: Display + Clone, U: Clone + Debug&#123; 10.2.4 返回trait类型 12345678fn returns_summarizable() -&gt; impl Summary &#123; Tweet &#123; username: String::from(&quot;horse_ebooks&quot;), content: String::from(&quot;of course, as you probably already know, people&quot;), reply: false, retweet: false, &#125;&#125; 通过使用 impl Summary 作为返回值类型，我们指定了 returns_summarizable 函数返回某个实现了 Summary trait 的类型，但是不确定其具体的类型 只适用于返回单一类型的情况，如果有分支结构，每个分支返回不同类型，则编译不能通过 10.3 生命周期与引用有效性 10.3.1 生命周期防止悬垂引用 Rust 编译器有一个借用检查器，它比较作用域来确保所有的借用都是有效的 避免了引用比数据的生命周期短的情况 10.3.2 函数的泛型生命周期 1234567891011121314fn main() &#123; let string1 = String::from(&quot;abcd&quot;); let string2 = &quot;xyz&quot;; let result = longest(string1.as_str(), string2); println!(&quot;The longest string is &#123;&#125;&quot;, result);&#125;fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 x 或 y 生命周期注解语法 123&amp;i32 // 引用&amp;&#x27;a i32 // 带有显式生命周期的引用&amp;&#x27;a mut i32 // 带有显式生命周期的可变引用 当有两个或以上的引用参数的生命周期注解都定义为 &amp;'a i32 ，则这些参数的生命周期必须与这泛型生命周期一样长 函数签名中的生命周期注解 12345678// 重写上面的longest函数，指定了签名中所有的引用必须有相同的生命周期&#x27;afn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 10.3.3 结构体定义生命周期注解 有生命周期注解的结构体可以存放引用 123struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125; 10.3.4 生命周期省略 编译器采用三条规则来判断引用何时不需要明确的注解，这些规则适用于 fn 定义，以及 impl 块 每一个是引用的参数都有它自己的生命周期参数 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数 如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 &amp;self 或 &amp;mut self，那么 self 的生命周期被赋给所有输出生命周期参数 10.3.5 方法定义中的生命周期注解 （实现方法时）结构体字段的生命周期必须总是在 impl 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。 12345678910struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125; 10.3.6 静态生命周期 'static 其生命周期能够存活于整个程序期间 所有的字符串字面值都拥有 'static 生命周期 Ch11 编写自动化测试 11.1 如何编写测试 Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作： 设置任何所需的数据或状态 运行需要测试的代码 断言其结果是我们所期望的 11.1.1 测试函数剖析 为了将一个函数变成测试函数，需要在 fn 行之前加上 #[test] 使用 cargo test 命令运行测试 使用 Cargo 新建一个库项目时，它会自动为我们生成一个测试模块和一个测试函数 1234567#[cfg(test)]mod tests &#123; #[test] fn exploration() &#123; assert_eq!(2 + 2, 4); &#125;&#125; 11.1.2 使用assert!宏来检查结果 如果值是 true，assert! 什么也不做，同时测试会通过 如果值为 false，assert! 调用 panic! 宏，这会导致测试失败 11.1.3 使用assert_eq!和assert_ne!宏来测试相等 assert_eq! 判断是否相等，assert_ne! 判断是否不等 断言失败时他们会打印出这两个值具体是什么，以便于观察测试为什么失败 11.1.4 自定义失败信息 为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值 12345678#[test]fn greeting_contains_name() &#123; let result = greeting(&quot;Carol&quot;); assert!( result.contains(&quot;Carol&quot;), &quot;Greeting did not contain name, value was `&#123;&#125;`&quot;, result );&#125; 11.1.5 使用 should_panic 检查 panic #[should_panic] 属性位于 #[test] 之后，对应的测试函数之前 这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败 11.1.6 将 Result&lt;T, E&gt; 用于测试 1234567891011#[cfg(test)]mod tests &#123; #[test] fn it_works() -&gt; Result&lt;(), String&gt; &#123; if 2 + 2 == 4 &#123; Ok(()) &#125; else &#123; Err(String::from(&quot;two plus two does not equal four&quot;)) &#125; &#125;&#125; 11.2 运行测试 11.2.1 并行或连续的运行测试 当运行多个测试时， Rust 默认使用线程来并行运行 应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境 如果有依赖，可以限制线程： 1$ cargo test -- --test-threads=1 11.2.2 显示函数输出 默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容 如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 --nocapture 参数来禁用： 1$ cargo test --nocapture 11.2.3 通过指定名字来运行部分测试 运行单个测试，向 cargo test 传递任意测试的名称来只运行这个测试 1$ cargo test one_hundred 过滤运行多个测试，指定部分测试的名称，任何名称匹配这个名称的测试会被运行，以下命令运行了所有名字中带有 add 的测试 1$ cargo test add 11.2.4 忽略某些测试 使用 ignore 属性来标记耗时的测试并排除他们 12345678910#[test]fn it_works() &#123; assert_eq!(2 + 2, 4);&#125;#[test]#[ignore]fn expensive_test() &#123; // 需要运行一个小时的代码&#125; 如果只希望运行被忽略的测试，可以使用 cargo test -- --ignored 11.3 测试的组织结构 11.3.1 单元测试 单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。 单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。 规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块。 测试模块 测试模块的 #[cfg(test)] 注解告诉 Rust 只在执行 cargo test 时才编译和运行测试代码 11.3.2 集成测试 集成测试的目的是测试库的多个部分能否一起正常工作 二进制项目，即只有 src/main.rs 而没有 src/lib.rs 不能进行集成测试 为了编写集成测试，需要在项目根目录创建一个 tests 目录，与 src 同级，可以随意在这个目录中创建任意多的测试文件 需要在文件顶部添加 use 123456use adder;#[test]fn it_adds_two() &#123; assert_eq!(4, adder::add_two(2));&#125; Ch12 I/O项目：命令行程序 12.1 接受命令行参数 使用标准库提供的函数：std::env::args ，返回一个传递给程序的命令行参数的迭代器 1234567891011use std::env;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let query = &amp;args[1]; let filename = &amp;args[2]; println!(&quot;Searching for &#123;&#125;&quot;, query); println!(&quot;In file &#123;&#125;&quot;, filename);&#125; 12.2 读取文件 使用标准库 std::fs 来处理文件 123let contents = fs::read_to_string(filename) .expect(&quot;Something went wrong reading the file&quot;);println!(&quot;With text:\\n&#123;&#125;&quot;, contents); 12.3 重构改进模块性和错误处理 在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程: 将程序拆分成 main.rs 和 lib.rs 并将程序的逻辑放入 lib.rs 中。 当命令行解析逻辑比较小时，可以保留在 main.rs 中。 当命令行解析开始变得复杂时，也同样将其从 main.rs 提取到 lib.rs 中。 经过这些过程之后保留在 main 函数中的责任应该被限制为： 使用参数值调用命令行解析逻辑 设置任何其他的配置 调用 lib.rs 中的 run 函数 如果 run 返回错误，则处理这个错误 12.4 采用测试驱动开发完善库的功能 测试驱动开发（Test Driven Development, TDD）模式，是一个软件开发技术，它遵循如下步骤： 编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。 编写或修改刚好足够的代码来使得新的测试通过。 重构刚刚增加或修改的代码，并确保测试仍然能通过。 从步骤 1 开始重复！ 12.6 将错误信息输出到标准错误 使用 eprintln! 将错误信息写入标准错误而不是标准输出 使用输出重定向： 1$ cargo run to poem.txt &gt; output.txt 若出错，会输出到标准错误，即显示在命令行，而不写入 output.txt 若正常执行，会输出到标准输出，即重定向到 output.txt Ch13 迭代器和闭包 13.1 闭包 可以保存进变量或作为参数传递给其他函数的匿名函数 使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它 13.1.1 定义闭包 12345678910use std::thread;use std::time::Duration;let expensive_closure = |num| &#123; println!(&quot;calculating slowly...&quot;); thread::sleep(Duration::from_secs(2)); num&#125;;expensive_closure(5); 闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数 如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2| 13.1.2 闭包类型推断和注解 闭包不用于暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用 闭包定义会为每个参数和返回值推断一个具体类型 如果尝试调用闭包两次，第一次使用 String 类型作为参数而第二次使用 u32，则会得到一个错误 13.1.3 使用带有泛型和Fn trait的闭包 可以创建一个存放闭包和调用闭包结果的结构体，该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值 1234567891011121314151617181920212223242526272829303132333435struct Cacher&lt;T&gt; // 闭包有一个 u32 的参数并返回一个 u32 where T: Fn(u32) -&gt; u32&#123; calculation: T, value: Option&lt;u32&gt;,&#125;impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32&#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; /*检查self.value是否已经有了一个 Some 的结果值； 如果有，它返回 Some 中的值并不会再次执行闭包*/ Some(v) =&gt; v, /* 如果 self.value 是 None， 则会调用 self.calculation 中储存的闭包， 将结果保存到 self.value 以便将来使用， 并同时返回结果值*/ None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125;&#125; 在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果。 Cacher 实现的限制： 第一次初始化 value 的值之后，就无法再改动；可以通过使 Cacher 存储一个哈希map而不是一个单独的值解决 它的应用被限制为只接受获取一个 u32 值并返回一个 u32 值的闭包 13.1.4 闭包会捕获其环境 闭包周围的作用域被称为其环境 闭包可以捕获其环境并访问其被定义的作用域的变量 123456789fn main() &#123; let x = 4; /* x 并不是 equal_to_x 的一个参数， 但equal_to_x 闭包也被允许使用变量 x， 因为它与 equal_to_x 定义于相同的作用域*/ let equal_to_x = |z| z == x; let y = 4; assert!(equal_to_x(y));&#125; 闭包有三种方式捕获其环境 FnOnce 消费从周围作用域捕获的变量。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次 FnMut 获取可变的借用值，所以可以改变其环境 Fn 从其环境获取不可变的借用值 13.2 迭代器 迭代器（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑 迭代器是惰性的，即在调用方法使用迭代器之前它都不会有效果 123456789let v1 = vec![1, 2, 3];// 创建一个迭代器，但是没有任何效果let v1_iter = v1.iter();/* 使用迭代器遍历，迭代器中的元素才开始迭代用 for 循环时无需使 v1_iter 可变，因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变*/for val in v1_iter &#123; println!(&quot;Got: &#123;&#125;&quot;, val);&#125; 13.2.1 Iterator trait 和 next方法 123456789// Iterator 是定义于标准库的 traitpub trait Iterator &#123; // Item类型将是迭代器next方法返回元素的类型 type Item; // next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; // 此处省略了方法的默认实现&#125; 在迭代器上直接调用 next 方法 1234567891011#[test]fn iterator_demonstration() &#123; let v1 = vec![1, 2, 3]; // 需要将迭代器定义为可变，因为next方法会改变迭代器 let mut v1_iter = v1.iter(); assert_eq!(v1_iter.next(), Some(&amp;1)); assert_eq!(v1_iter.next(), Some(&amp;2)); assert_eq!(v1_iter.next(), Some(&amp;3)); assert_eq!(v1_iter.next(), None);&#125; 13.2.2 消费适配器 调用 next 方法的方法，如 sum 123456789#[test]fn iterator_sum() &#123; let v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); // 调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权 let total: i32 = v1_iter.sum(); assert_eq!(total, 6);&#125; 13.2.3 迭代器适配器 将当前迭代器变为不同类型的迭代器，如 map 1234let v1: Vec&lt;i32&gt; = vec![1, 2, 3];// 调用 map 方法创建一个新迭代器，接着调用collect方法消费新迭代器并创建一个vectorlet v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();assert_eq!(v2, vec![2, 3, 4]); 13.2.4 创建自定义迭代器 可以实现 Iterator trait 来创建任何我们希望的迭代器 123456789101112131415161718192021222324252627282930313233struct Counter &#123; count: u32,&#125;impl Counter &#123; fn new() -&gt; Counter &#123; Counter &#123; count: 0 &#125; &#125;&#125;impl Iterator for Counter &#123; type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; self.count += 1; if self.count &lt; 6 &#123; Some(self.count) &#125; else &#123; None &#125; &#125;&#125;// 使用自定义的Counter迭代器的多种方法// 获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加#[test]fn using_other_iterator_trait_methods() &#123; let sum: u32 = Counter::new().zip(Counter::new().skip(1)) .map(|(a, b)| a * b) .filter(|x| x % 3 == 0) .sum(); assert_eq!(18, sum);&#125; Ch14 进一步认识Cargo和Crates.io 14.1 采用发布配置自定义构建 Cargo 有两个主要的配置： 运行 cargo build 时采用的 dev 配置 运行 cargo build --release 的 release 配置 dev 配置被定义为开发时的好的默认配置，release 配置则有着良好的发布构建的默认配置 可以在 Cargo.toml 文件中定义 [profile.*] 部分来覆盖默认配置 12345[profile.dev]opt-level = 0[profile.release]opt-level = 3 opt-level 设置控制 Rust 会对代码进行何种程度的优化，值从0到3，越高的优化级别需要更多的时间编译 14.2 将 crate 发布到 Crates.io 14.3 Cargo工作空间 14.4 从 Crates.io 安装二进制文件 使用命令 cargo install 可以从crates.io下载二进制crate，安装到 ~/.cargo/bin Ch15 智能指针 15.1 Box&lt;T&gt; box 允许将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针 使用场景： 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候 15.1.1 Box创建递归类型 Rust 需要在编译时知道类型占用多少空间，而递归类型无法在编译的时候知道大小 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了 以cons list为例 cons list 的每一项都包含两个元素：当前项的值和下一项。 其最后一项值包含一个叫做 Nil 的值且没有下一项。 cons list 通过递归调用 cons 函数产生。 代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。 12345678910enum List &#123; Cons(i32, List), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Cons(2, Cons(3, Nil)));&#125; Rust编译器无法计算一个 List 需要的大小，因为编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons成员储存了一个 i32 值和一个List值，这样的计算将无限进行下去。 使用Box&lt;T&gt;给递归类型一个已知的大小 12345678910111213enum List &#123; Cons(i32, Box&lt;List&gt;), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));&#125; 任何 List 值最多需要一个 i32 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了。 15.2 Deref trait 实现 Deref trait 允许我们重载解引用运算符 * 15.2.1 像引用一样使用 Box&lt;T&gt; 1234567fn main() &#123; let x = 5; let y = Box::new(x); assert_eq!(5, x); assert_eq!(5, *y);&#125; 15.2.2 自定义智能指针 定义 MyBox&lt;T&gt; 类型: 1234567struct MyBox&lt;T&gt;(T);impl&lt;T&gt; MyBox&lt;T&gt; &#123; fn new(x: T) -&gt; MyBox&lt;T&gt; &#123; MyBox(x) &#125;&#125; 15.2.3 在自定义智能指针实现 Deref trait 12345678910use std::ops::Deref;impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123; // 定义trait的关联类型 type Target = T; fn deref(&amp;self) -&gt; &amp;T &#123; // deref返回了我希望通过*运算符访问的值的引用 &amp;self.0 &#125;&#125; 当运行如下代码： 1234let x = 5;let y = MyBox::new(x);assert_eq!(5, *y); *y 在Rust底层运行了 *(y.deref()) 15.2.4 函数和方法的隐式解引用强制多态 解引用强制多态是 Rust 在函数或方法传参上的一种便利。将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。 123456789fn hello(name: &amp;str) &#123; println!(&quot;Hello, &#123;&#125;!&quot;, name);&#125;fn main() &#123; let m = MyBox::new(String::from(&quot;Rust&quot;)); // 解引用强制多态将 &amp;MyBox&lt;String&gt; 自动转换为 &amp;str hello(&amp;m);&#125; 15.3 Drop trait 允许我们在值要离开作用域时执行一些代码，可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源 通过 Drop trait 中的 drop 方法，可以在变量离开作用域时自动丢弃该值 15.3.1 通过 std::mem::drop 提早丢弃值 Rust不允许我们主动调用 Drop trait 的 drop 方法 当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop，其位于preclude，可以直接通过 drop(variable); 调用 15.4 Rc&lt;T&gt; 引用计数智能指针 有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。 Rust 使用引用计数 Rc&lt;T&gt; 的类型来启用多所有权，记录了一个值引用的数量来知晓这个值是否仍在被使用。 Rc&lt;T&gt; 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。 Rc&lt;T&gt; 只能用于单线程场景 15.4.1 使用 Rc&lt;T&gt; 共享数据 使用 Box&lt;T&gt; 定义的 cons list 的两个列表 b 和 c, 共享第三个列表 a 的所有权 12345678910111213enum List &#123; Cons(i32, Rc&lt;List&gt;), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;use std::rc::Rc;fn main() &#123; let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(&amp;a)); let c = Cons(4, Rc::clone(&amp;a));&#125; Rc::clone 只会增加引用计数，而不会深拷贝 在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 Rc::strong_count 函数获得 15.5 RefCell&lt;T&gt; 和内部可变性模式 内部可变性是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的 15.6 引用循环与内存泄漏 Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存，但是创建引用循环从而造成内存泄漏的可能性是存在的 Ch16 并发 16.1 使用线程同时运行代码 线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题： 竞争状态，多个线程以不一致的顺序访问数据或资源 死锁，两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行 只会发生在特定情况且难以稳定重现和修复的 bug 16.1.1 使用 spawn 创建新线程 为了创建一个新线程，需要调用 thread::spawn 函数并传递一个闭包，并在其中包含希望在新线程运行的代码 123456789101112131415161718192021222324252627282930use std::thread;use std::time::Duration;fn main() &#123; thread::spawn(|| &#123; for i in 1..10 &#123; println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i); // thread::sleep调用强制线程停止执行一小段时间，允许其他不同的线程运行 thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125;&#125;/*输出：hi number 1 from the main thread!hi number 1 from the spawned thread!hi number 2 from the main thread!hi number 2 from the spawned thread!hi number 3 from the main thread!hi number 3 from the spawned thread!hi number 4 from the main thread!hi number 4 from the spawned thread!hi number 5 from the spawned thread!*/ 当主线程结束时，新线程也会结束，而不管其是否执行完毕 16.1.2 使用 join 等待所有线程结束 thread::spawn 的返回值类型是 JoinHandle JoinHandle 是一个拥有所有权的值，当对其调用 join 方法时，它会等待其线程结束 通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束 12345678910111213141516171819use std::thread;use std::time::Duration;fn main() &#123; // 从thread::spawn保存一个JoinHandle来确保该线程能够运行结束 let handle = thread::spawn(|| &#123; for i in 1..10 &#123; println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125; handle.join().unwrap();&#125; 16.1.3 线程与 move 闭包 在参数列表前使用 move 关键字强制闭包获取其使用的环境值的所有权，可用于创建新线程时将值的所有权从一个线程移动到另一个线程 1234567891011use std::thread;fn main() &#123; let v = vec![1, 2, 3]; let handle = thread::spawn(move || &#123; println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v); &#125;); handle.join().unwrap();&#125; 16.2 线程间消息传递 Rust 中一个实现消息传递并发的主要工具是通道 1234567891011121314use std::thread;use std::sync::mpsc;fn main() &#123; let (tx, rx) = mpsc::channel(); thread::spawn(move || &#123; let val = String::from(&quot;hi&quot;); tx.send(val).unwrap(); &#125;); let received = rx.recv().unwrap(); println!(&quot;Got: &#123;&#125;&quot;, received);&#125; 使用 mpsc::channel 函数创建一个新的通道，可以有多个发送端，但只能有一个接收端， mpsc::channel 函数返回一个元组：(发送端，接收端)，或 (tx, rx) 通道的发送端有一个 send 方法用来获取需要放入通道的值，返回一个 Result&lt;T, E&gt; 类型 send 函数获取其参数的所有权并移动这个值归接收者所有，所以线程在发送 val 之后就不能再使用它了 通道的接收端有两个有用的方法：recv 和 try_recv recv 会阻塞主线程执行直到从通道中接收一个值，一旦发送了一个值，recv 会在一个 Result&lt;T, E&gt; 中返回它；当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了 try_recv 不会阻塞，立刻返回一个 Result&lt;T, E&gt;：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息 可以将 rx 作为迭代器来接收发送端发送的多个数据，并通过 for 循环打印 可以通过 clone 方法来创建多个发送端: 12let (tx, rx) = mpsc::channel();let tx1 = mpsc::Sender::clone(&amp;tx); 16.3 共享状态并发 16.3.1 互斥器 通过锁来保证任意时刻只有一个线程能访问某些数据 使用方式： 在使用数据之前尝试获取锁。 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。 使用 Mutex&lt;T&gt; 实现 通过关联函数 new 来创建 Mutex&lt;T&gt; 使用 lock 方法获取锁，该方法会阻塞当前线程，直到拥有锁为止 lock 调用返回一个叫做 MutexGuard 的智能指针，当其离开作用域时，会自动释放锁 16.3.2 在线程间共享 Mutex&lt;T&gt; 12345678910111213141516171819202122use std::sync::&#123;Mutex, Arc&#125;;use std::thread;fn main() &#123; let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 &#123; let counter = Arc::clone(&amp;counter); let handle = thread::spawn(move || &#123; let mut num = counter.lock().unwrap(); *num += 1; &#125;); handles.push(handle); &#125; for handle in handles &#123; handle.join().unwrap(); &#125; println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());&#125; 使用原子引用计数 Arc&lt;T&gt; 来实现 Mutex&lt;T&gt; 在多线程之间共享所有权 Ch17 Rust面向对象 17.1 面向对象语言的特征 对象包含数据和行为：结构体和枚举包含数据，impl 块提供对应方法 封装隐藏了实现细节：不添加 pub 就是私有的 通过继承重用代码：使用 trait 对象 17.2 为使用不同类型的值而设计的 trait 对象 17.3 面向对象设计模式的实现 Ch18 模式 18.1 用到模式的位置 18.1.1 match分支 在形式上 match 表达式由 match 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式 12345match VALUE &#123; PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION,&#125; 18.1.2 if let 表达式 等同于只关心一个情况的 match 语句简写 if let 表达式的缺点在于其穷尽性没有为编译器所检查，而 match 表达式则检查了 18.1.3 while let 条件循环 允许只要模式匹配就一直进行 while 循环 18.1.4 for循环 1for (index, value) in v.iter().enumerate() &#123;&#125; 使用 (index, value) 来匹配 enumerate 18.1.5 let语句 1let PATTERN = EXPRESSION; 18.1.6 函数参数 123fn foo(x: i32) &#123; // 代码&#125; x 部分就是一个模式 18.2 可反驳和不可反驳 能匹配任何传递的可能值的模式被称为是不可反驳的，如 let x = 5; 中的 x 对某些可能的值进行匹配会失败的模式被称为是可反驳的，如 if let Some(x) = a_value 中的 Some(x) 函数参数、 let 语句和 for 循环只能接受不可反驳的模式 匹配分支必须使用可反驳模式，如 if let 18.3 模式语法 18.3.1 匹配字面值 12345678let x = 1;match x &#123; 1 =&gt; println!(&quot;one&quot;), 2 =&gt; println!(&quot;two&quot;), 3 =&gt; println!(&quot;three&quot;), _ =&gt; println!(&quot;anything&quot;),&#125; 18.3.2 匹配命名变量 命名变量是匹配任何值的不可反驳模式，当其用于 match 表达式时，情况会不一样 123456789101112131415161718fn main() &#123; let x = Some(5); let y = 10; match x &#123; Some(50) =&gt; println!(&quot;Got 50&quot;), Some(y) =&gt; println!(&quot;Matched, y = &#123;:?&#125;&quot;, y), _ =&gt; println!(&quot;Default case, x = &#123;:?&#125;&quot;, x), &#125; println!(&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;, x, y);&#125;/*会打印：Matched, y = 5at the end: x = Some(5), y = 10*/ 在 match 表达式的新作用域中， y 是一个新变量，而不是开头声明为值 10 的那个 y ，新的 y 绑定会匹配任何 Some 中的值，在这里是 x 中的值 18.3.3 多个模式 使用 | 语法匹配多个模式 1234567let x = 1;match x &#123; 1 | 2 =&gt; println!(&quot;one or two&quot;), 3 =&gt; println!(&quot;three&quot;), _ =&gt; println!(&quot;anything&quot;),&#125; 18.3.4 通过 …= 匹配值的范围 使用 1..=5 替代 1 | 2 | 3 | 4 | 5 对 char 类型也适用：'a'..='j' 18.3.5 忽略模式中的值 使用 _ 忽略整个值 通过 _x 来忽略未使用的变量 使用 .. 忽略剩余的值 123456789fn main() &#123; let numbers = (2, 4, 8, 16, 32); match numbers &#123; (first, .., last) =&gt; &#123; println!(&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;, first, last); &#125;, &#125;&#125; 18.3.6 匹配守卫 匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支 1234567let num = Some(4);match num &#123; Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: &#123;&#125;&quot;, x), Some(x) =&gt; println!(&quot;&#123;&#125;&quot;, x), None =&gt; (),&#125; 18.3.7 @绑定 @ 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式 使用 @ 可以在一个模式中同时测试和保存变量值 12345678910111213141516171819enum Message &#123; Hello &#123; id: i32 &#125;,&#125;let msg = Message::Hello &#123; id: 5 &#125;;match msg &#123; // 将id值保存在id_variable中 Message::Hello &#123; id: id_variable @ 3..=7 &#125; =&gt; &#123; println!(&quot;Found an id in range: &#123;&#125;&quot;, id_variable) &#125;, // 无法保存id值 Message::Hello &#123; id: 10..=12 &#125; =&gt; &#123; println!(&quot;Found an id in another range&quot;) &#125;, Message::Hello &#123; id &#125; =&gt; &#123; println!(&quot;Found some other id: &#123;&#125;&quot;, id) &#125;,&#125; Ch19 高级特征 19.1 不安全的Rust 19.2 高级trait 19.3 高级类型 19.4 高级函数与闭包 19.5 宏","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Pointers on C - Learn","slug":"C和指针notes","date":"2020-11-11T02:30:39.921Z","updated":"2020-11-11T02:37:04.647Z","comments":true,"path":"2020/11/11/C和指针notes/","link":"","permalink":"http://example.com/2020/11/11/C%E5%92%8C%E6%8C%87%E9%92%88notes/","excerpt":"C学习记录","text":"Ch2 基本概念 2.1 环境 2.1.1 翻译环境 翻译过程：各源文件通过编译过程分别转为目标代码 -&gt; 各目标代码文件由链接器捆绑为单一完整的可执行程序 编译过程：预处理器处理 -&gt; 源代码经过解析判断语句的意思，从而生成目标代码 -&gt; 优化器对目标代码进一步处理 2.1.4 执行环境 程序执行过程：程序载入内存 -&gt; 启动程序调用main函数 -&gt; 程序的终止 程序运行过程中使用一个运行时的堆栈，用于存储函数的局部变量和返回地址；同时，程序也可以使用静态内存，其中的值在程序整个执行过程都会保留 2.2 词法规则 2.2.1 字符 \\ddd：三个八进制数字表示的字符 \\xddd：三个十六进制数字表示的字符 2.2.2 注释 //：单行注释 /* */：多行注释 TIPS: 有的程序从标准输入读取数据，读到EOF停止，在终端输入时Ctrl+D即为输入EOF Ch3 数据 3.1 基本数据类型 3.1.1 整型 变量的最小范围 类型 最小范围 char 0 ~ 27-1 signed char -(27-1) ~ 27-1 unsigned char 0 ~ 28-1 short int -(215-1) ~ 215-1 unsigned short int 0 ~ 216-1 int -(215-1) ~ 215-1 unsigned int 0 ~ 216-1 long int -(231-1) ~ 231-1 unsigned long int 0 ~ 232-1 short int至少16位，long int至少32位 头文件limits.h说明各种不同的整型的特点 一、整型常量 声明为const，初始化之后不能被改变 十进制整型常量可能是int、long、unsigned long。缺省情况下为最短类型但能完整容纳这个值 八进制整数以0开头 十六进制整数以0x开头 字符常量：类型为int，是单引号包围的单个字符 1&#x27;M&#x27; &#x27;\\n&#x27; 宽字符常量：多字节字符常量的前面有个L 1L&#x27;X&#x27; L&#x27;e^&#x27; 二、枚举类型 12345// 声明类型enum Jar_Type &#123;CUP, PINT, QUART, HALF_GALLON, GALLON&#125;;// 定义变量enum Jar_Type milk_jug, gas_can, medicine_bottle; 以整型方式存储，符号名实际值都是整型值。如CUP=0，PINT=1，以此类推 可以显式定值，若未指定值，则比前一个符号名大1 3.1.2 浮点类型 包括float、double、long double类型 所有浮点类型至少能容纳从10-37到1037之间的任何值 头文件float.h说明各种不同的浮点型的特点 浮点数默认为double类型；后面跟L/l表示long double；后面跟F/f表示float 3.1.3 指针 一、指针常量 一般都通过操作符来获得一个变量的地址，而不是通过表示为字面值的指针常量，如0xff2044ec 二、字符串常量 字符串：以NUL字节结尾的零个或多个字符，存储在字符数组中 字符串常量：直接值是一个“指向字符的指针”，而不是这些字符本身 3.2 基本声明 3.2.2 声明简单数组 1int value[20]; 编译器不检查数组的下标是否在合法范围内，所以当下标是通过用户输入计算而来的，必须检测是否越界 如果越界，不会报错，只会返回null 3.2.3 声明指针 1234567int *a;char *message = &quot;Hello World&quot;;// 把message声明为一个指向字符的指针，并用字符串常量中的第1个字符的地址对其初始化// 等价于以下语句char *message;message = &quot;Hello World&quot;; 3.3 typedef 为各种数据类型定义新名字 12345// 将变量ptr_to_char声明为一个指向字符的指针类型的新名字typedef char *ptr_to_char;// 声明a是一个指向字符的指针ptr_to_char a; 3.4 常量 const 123456789// 声明整数常量const int a;int const a;// 声明一个指向整型常量的指针int const *pci;// 声明一个指向整型的常量指针int * const cpi; #define 1#define MAX_LEN 20 3.5 作用域 3.5.1 代码块作用域 代码块：位于一对花括号之间的所有语句 嵌套代码块中，内层可以访问外层变量，而外层无法访问内层变量，但是当内外层有名字相同的变量时，内层无法访问外层的那个同名变量 非嵌套的代码块中，作用域没有重叠，所以编译器可以把它们存储在同一个内存地址 3.5.2 文件作用域 任何在所有代码块之外声明的标识符都具有文件作用域，在声明处到源文件末尾都可以访问 3.5.3 原型作用域 只适用于在函数原型中声明的参数名 3.5.4 函数作用域 只适用于语句标签，语句标签用于goto语句 3.6 链接属性 一、none 没有链接属性 声明的同名标识符被当作独立不同的实体 二、internal属性 单个文件中声明的同名标识符表示同一个实体 三、external属性 多个文件中声明的同名标识符表示同一个实体 只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。 默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体。 四、关键字extern和static 如果某个标识符在正常情况下具有external链接属性(只能是具有文件作用域的标识符)，在其前面加上static关键字可以将其链接属性变为internal 链接属性只能修改一次，也就是说一旦将标识符的链接属性变为internal，就无法变回external了 3.7 存储类型 存储变量的内存类型，有普通内存、运行时堆栈、硬件寄存器 在任何代码块之外声明的变量存储在静态内存中，为静态变量，在程序运行之前创建 在代码块内部声明的变量的缺省存储类型是自动的，即存储于堆栈中，进入代码块创建，离开代码块销毁 在代码块内部声明的变量加上static关键字，变为静态变量，但作用域不变。如在函数中声明static变量a，则a在程序开始执行时就被初始化，并且每次函数被调用时，a不会重新初始化 关键字register声明自动变量，存储在硬件寄存器中，为寄存器变量 初始化 如果不显式指定初值，静态变量将初始化为0，而自动变量初始值不确定 3.8 static关键字 用于函数定义或在代码块外声明变量时，将标识符的链接属性从external改为internal，但变量的存储类型和作用域不受影响 在代码块内部声明变量时将标识符的存储类型从自动变量改为静态变量，但变量的链接属性和作用域不受影响 3.9 总结 Ch4 语句 4.1 空语句 1; 只包含一个分号，不执行任何任务 4.2 表达式语句 C不存在赋值语句，赋值通过表达式语句(在表达式之后加上一个分号)实现，如： 1x = y + 3; 以下语句也是合法的，但结果被立即丢弃： 1y + 3; 4.3 代码块 位于一对花括号之内的可选的声明和语句列表 4.4 if语句 123456if (expression) &#123; statement&#125;else &#123; statement&#125; C语言不存在布尔变量，而使用整型的0和1代替，所以expression的结果不是0就是1 4.5 while语句 123while (expression) &#123; statement&#125; break终止所在while代码块的所有循环；continue终止所在while代码块的当前循环 4.6 for语句 123for (初始化部分; 条件部分; 调整部分)&#123; statement&#125; 4.7 do语句 123do &#123; statement&#125; while (expression); 循环体至少执行一次 4.8 switch语句 123456789switch (expression) &#123; case constant-expression-1: statement-1 break; case constant-expression-2: statement-2 break; ......&#125; switch的条件expression必须为整型值 每个case标签必须具有唯一的值 每个switch语句都应该添加一条并且只能添加一条default语句，可以在case语句列表的任何位置 4.9 goto语句 1goto 语句标签; 语句标签是在标识符后添加一个冒号，并跟上一些表达式语句 要尽可能避免使用goto语句 Ch5 操作符和表达式 5.1 操作符 5.1.1 算术操作符 1+ - * / % 5.1.2 移位操作符 左移：&lt;&lt; 右移：&gt;&gt; 无符号数的所有移位操作都是逻辑移位，有符号数是逻辑移位还是算术移位取决于编译器 5.1.3 位操作符 12&amp; | ~// 与或非 将value指定位置1 1value = value | 1 &lt;&lt; bit_number; 将value指定位置0 1value = value &amp; ~ (1 &lt;&lt; bit_number); 5.1.5 单目操作符 !：逻辑取反，产生整型结果0或1 ~：操作数每一位取反 -：取负 &amp;：取操作数的地址 *：间接访问，访问指针所指向的值 sizeof：判断操作数的类型长度，以字节为单位，操作数可以是变量，也可以是加上括号的类型 sizeof (a = b + 1)并没有向a赋值 强制类型转换，如获得整型变量a对应的浮点数值 1(float) a c+：增值操作符，a在变量被使用之前增加它的值，a在变量被使用之后增加它的值 5.1.6 关系操作符 1&gt; &gt;= &lt; &lt;= == != 产生的结果是整型的0或1 5.1.7 逻辑操作符 &amp;&amp;：对于expression1 &amp;&amp; expression2，若expression1为假，则不再对expression2求值 ||：对于expression1 || expression2，若expression1为真，则不再对expression2求值 5.1.8 条件操作符 expression1 ? expression2 : expression3 5.2 布尔值 C没有显式的布尔类型，用整数代替，0是假，任何非零值都是真 5.4 表达式求值 函数进行表达式求值时应该尽量避免以下形式： 1f() + g() + h() 而使用以下形式，因为如果函数的返回值和执行顺序相关，则会产生不确定性 123temp = f();temp += g();temp += h(); Ch6 指针 6.1 内存和地址 内存中的每个位置由一个独一无二的地址标识 内存中的每个位置都包含一个值 编译器帮助实现通过变量访问内存位置，但是硬件仍然通过地址访问内存位置 6.2 值和类型 不能简单地通过检查一个值的位来判断它的类型，因为不同的数据类型和指令会将其解释为不同的类型 6.5 未初始化和非法的指针 在对指针进行间接访问之前，一定要进行初始化，下面是一个错误例子，因为指针a指向的位置不能确定： 12int *a;*a = 12; 6.6 NULL指针 NULL指针不指向任何东西 要使一个指针变量为NULL，可以给它赋一个零值；测试一个指针变量是否为NULL，可以将它与零值比较 6.7 指针、间接访问和左值 12345678int a;int *d = &amp;a;// 合法，对指针d指向的值(a)进行修改*d = 10 - *d;// 非法，整型数的计算结果赋给指针d = 10 - *d; 6.10 指针的指针 123int a = 12;int *b = &amp;a;int **c = &amp;b; 表达式 相当的表达式 a 12 b &amp;a *b a, 12 c &amp;b *c b, &amp;a **c *b, a, 12 6.11 指针表达式 6.13 指针运算 6.13.1 算术运算 当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据对应变量的类型的长度进行调整。例如若float类型指针变量p占4个字节，则p+1不会指向p的第二字节，而是会指向p所占的4个字节之后的那个字节 两个指针只有当都指向同一个数组中的元素时，才允许进行相减，并且减法的结果是两个元素在数组中的距离，而不是内存地址的差值，即在减法运算的同时会除掉变量类型的长度 6.13.2 关系运算 对于指向同一个数组中的元素的指针，可以用关系操作符(&gt; &lt; &gt;= &lt;=)来判断哪个指针指向数组中更前或更后的元素 Ch7 函数 7.2 函数声明 7.2.1 原型 原型总结了函数定义的起始部分的声明，向编译器提供有关函数应该如何调用的完整信息 函数原型的使用： 1234567// func_use.c#include &quot;func.h&quot;... // func.hint *func(int *value, int len);... 声明一个没有参数的函数原型： 1int *func(void); 7.2.2 函数的缺省认定 当程序调用一个无法见到原型的函数时，编译器会认为该函数返回一个整型 7.3 函数的参数 所有参数都是传值调用，函数不会修改实际传递的参数 当传递的参数是指针时，可以通过指针的间接访问修改指针所指的值，称为传址调用 7.4 ADT和黑盒 使用static关键字限制对非接口函数和数据的访问 7.5 递归 通过运行时堆栈支持递归函数的实现 通过一个简单的递归作为实例： 123456789101112// 接受一个整型值(无符号)，把它转换为字符并打印，前导零被删除#include &lt;stdio.h&gt;void binary_to_ascii(unsigned int value) &#123; unsigned int quotient; quotient = value / 10; if (quotient != 0) &#123; binary_to_ascii(quotient); &#125; putchar(value % 10 + &#x27;0&#x27;);&#125; 7.5.1 追踪递归函数 程序运行时堆栈的变化： ​ … 7.5.2 递归与迭代 如果一个递归函数内部所执行的最后一条语句就是调用自身时，被称为尾部递归，这样的递归很容易被改写为循环迭代的形式，而迭代的效率通常较高 7.6 可变参数列表 7.6.1 stdarg宏 定义于stdarg.h头文件 类型va_list：用于声明变量来访问参数列表的未确定部分 此时声明函数的方式为float average(int n, ...) 宏va_start：初始化va_list声明的变量，第1个参数是va_list变量名，第2个参数是省略号前的最后一个有名字的参数 宏va_arg：用于访问参数，第1个参数是va_list变量名，第2个参数是参数列表中下一个参数的类型，返回这个参数的值，并指向下一个可变参数 宏va_end：访问完最后一个可变参数后调用，参数为va_list变量名 7.6.2 可变参数的限制 这些宏无法判断实际存在的参数的数量 这些宏无法判断每个参数的类型 Ch8 数组 8.1 一维数组 8.1.1 数组名 1int b[10]; b[3]的类型是整型 b是一个指向b[0]的常量指针，因而不能修改数组名的值，即不能修改数组存储的内存地址 数组的赋值 12345678int a[10];int b[10];int *c;// 以下两个表达式作用相同，将c指向a[0]c = &amp;a[0];c = a; // 以下表达式非法，不能将数组复制给数组，数组间的复制只能通过循环逐个元素复制 b = a; // 以下表达式非法，a是常量，不能被修改 a = c; 123456789 #### 8.1.2 下标引用通过以下例子说明：​&#96;&#96;&#96;cint array[10];int *ap &#x3D; array + 2; 表达式 对等表达式 ap array+2, &amp;array[2] *ap array[2], *(array+2) ap[0] array[2] ap+6 array+8, &amp;array[8] *ap+6 array[2]+6 *(ap+6) array[8] ap[-1] array[1] ap[9] 非法 8.1.3 指针与下标 指针有时比下标更加高效 在数组中一次一步移动时，与固定数字相乘的运算在编译的时候完成，所以在运行时所需的指令就少 但这在实际中不常用，因为可能编译器对循环会有优化 8.1.5 数组和指针 12int a[5]; // 数组int *b; // 指针 a和b都具有指针值，都可以进行间接访问和下标引用操作 区别： 声明数组时，编译器会为数组保留内存空间，然后再创建数组名 声明指针变量时，编译器只为指针本身保留内存空间，而不为整型值分配内存空间 在上述声明后： *a是合法的，*b是非法的，因为*b将访问内存中某个不确定的位置 b是合法的，a是非法的，因为a是常量指针 8.1.7 声明数组参数 下面的函数原型是等价的： 12int strlen(char *string);int strlen(char string[]); 8.1.8 初始化 1int vector[5] = &#123;1, 2, 3, 4, 5&#125;; 静态初始化：静态变量存储在静态内存，只初始化一次 自动初始化：自动变量在缺省情况下是未初始化的，若给定初值，则每次进入代码块都会重新初始化 8.1.9 不完整的初始化 1int vector[5] = &#123;1, 2, 3, 4&#125;; vector[4]被初始化为0 8.1.10 自动计算数组长度 如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有初始值的长度 8.1.11 字符数组的初始化 12345// 初始化一个字符串数组char message1[] = &quot;Hello&quot;;// 初始化一个字符串常量char *message2 = &quot;Hello&quot;; 8.2 多维数组 8.2.1 存储顺序 定义一个数组： 1int array[3][6]; 其在内存中的存储形式为： 这18个元素的下标值依次是(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (1,0) … (2,4) (2,5) 8.2.2 数组名 如在int matrix[3][10]中，matrix是指向一个包含10个整型元素的数组的指针 那么matrix+1则指向： 而*(matrix + 1) + 5就等价于matrix[1] + 5，是一个指向整型的指针： 8.2.4 指向数组的指针 声明一个指向整型数组的指针，并令其指向matrix数组的第一行： 1int (*p)[10] = matrix; 8.2.5 作为函数参数的多维数组 可以使用以下两张形式的任何一种： 12void func(int (*mat)[10]);void func(int mat[][10]); 8.2.6 初始化 8.2.7 数组长度自动计算 在多维数组中，只有第1维才能根据初始化列表缺省地提供，剩余的几个维必须显式写出 8.3 指针数组 定义方式如下： 1234567char const *keyword[] = &#123; &quot;do&quot;, &quot;for&quot;, &quot;if&quot;, &quot;return&quot;, NULL&#125; 这样定义的好处在于如果要遍历这个表，只需要for (kwp=keyword; *kwp!=NULL; kwp++) Ch9 字符串、字符和字节 9.1 字符串基础 字符串的长度不包含最后的NUL字节 头文件string.h包含了使用字符串函数所需的原型和声明 9.2 字符串长度 1size_t strlen(char const *string); 返回类型为size_t，是一个无符号整数类型 不要在表达式中同时包含有符号数和无符号数，因此应该把strlen的返回值强制转换为int 9.3 不受限制的字符串函数 9.3.1 复制字符串 1char *strcpy(char *dst, char const *src); dst必须是一个字符数组或是一个指向动态分配内存的数组的指针 复制字符串前必须保证目标字符数组的空间足以容纳需要复制的字符串，不然会覆盖数组之后内存的内容 9.3.2 连接字符串 1char *strcat(char *dst, char const *src); 将src字符串的拷贝添加到dst字符串之后 9.3.4 字符串比较 1int strcmp(char const *s1, char const *s2); 若s1小于s2，返回一个小于0的值；若s1大于s2，返回一个大于0的值；若s1和s2相等，返回0 9.4 长度受限的字符串函数 字符串复制，将src的前len个字符(不够补NUL)复制给dst，但当src的长度大于len时，只能复制len个字符给dst，因此结果的dst最后是没有NUL的 1char *strncpy(char *dst, char const *src, size_t len); 字符串连接，将src的前len个字符(不够补NUL)连接到dst后面，会自动添加一个NUL在dst的最后 1char *strncat(char *dst, char const *src, size_t len); 字符串比较，比较两个字符串的前len位 1int strncmp(char const *s1, char const *s2, size_t len); 9.5 字符串查找基础 9.5.1 查找一个字符 12char *strchr(char const *str, int ch);char *strrchr(char const *str, int ch); 在字符串str中查找字符ch第一次出现的位置，返回一个指向该位置的指针，若没有找到返回NULL指针 strchr从左开始找，strrchr从右开始找 9.5.2 查找任何几个字符 1char *strpbrk(char const *str, char const *group); 返回一个指向str中第一个匹配group中任何一个字符的位置指针 9.5.3 查找一个子串 1char *strstr(char const *s1, char const *s2); 在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针 9.6 高级字符串查找 9.6.1 查找一个字符串前缀 12size_t strspn(char const *str, char const *group);size_t strcspn(char const *str, char const *group); strspn返回str起始部分匹配group中任意字符的字符数，而strcspn找的是非group中的字符 例如得到指向字符串中第一个非空白字符： 1prt = buffer + strspn(buffer, &quot;\\n\\t\\r\\f\\v&quot;); 9.6.2 查找标记 1char *strtok(char *str, char const *sep); 从字符串中隔离各个单独的称为标记的部分 sep定义了用作分隔符的字符集合 若strtok的第一个参数不是NULL，函数将找到字符串的第一个标记，同时保存它在字符串中的位置；若strtok的第一个参数是NULL，函数将在同一个字符串中从保存的位置开始查找下一个标记；若找不到下一个标记，则返回NULL 例子：查找被空白分隔的单词 123for (token=strtok(line, whitespace); token!=NULL; token=strtok(NULL, whitespace)) &#123; printf(&quot;%s\\n&quot;, token);&#125; 9.7 错误信息 1char *strerror(int error_number); 参数为错误代码，返回一个指向用于描述错误的字符串的指针 9.8 字符操作 头文件ctype.h 9.8.1 字符分类 9.8.2 字符大小写转换 12int tolower(int ch);int toupper(int ch); 9.9 内存操作 12345void *memcpy(void *dst, void const *src, size_t length);void *memmove(void *dst, void const *src, size_t length);void *memcmp(void const *a, void const *b, size_t length);void *memchr(void const *a, int ch, size_t length);void *memset(void *a, int ch, size_t length); 与strn带头的函数不同，这些函数遇到NUL字节时不会停止操作 Ch10 结构和联合 10.1 结构基础知识 当一个结构变量在表达式中使用时，并不被替换成一个指针，而是一个标量类型 10.1.1 结构声明 12345struct &#123; int a; char b; float c;&#125; x, y[20], *z; 声明了结构体x，包含20个结构体的数组y，指向结构体的指针z 1234567struct SIMPLE &#123; int a; char b; float c;&#125;;struct SIMPLE x, y[20], *z; 推荐使用以下声明方法： 1234567typedef struct &#123; int a; char b; float c;&#125; Simple;Simple x, y[20], *z; 10.1.2 结构成员 直接访问： 1234Simple simp;// 访问成员asimp.a 间接访问： 1234Simple *simp;// 访问成员asimp-&gt;a 10.1.5 结构的自引用 123456789101112131415161718192021222324252627// 错误struct SELF_REF &#123; int a; struct SELF_REF b; int c;&#125;;// 正确struct SELF_REF &#123; int a; struct SELF_REF *b; int c;&#125;;// 错误typedef struct &#123; int a; struct SELF_REF *b; int c;&#125; SELF_REF;// 正确typedef struct SELF_REF_TAG &#123; int a; struct SELF_REF_TAG *b; int c;&#125; SELF_REF; 10.1.6 不完整的声明 用于多个相互依赖的结构体之间的声明 123456789struct B;struct A &#123; struct B *partner;&#125;;struct B &#123; struct A *partner;&#125;; 10.2 结构、指针和成员 后面几节都以以下结构体为例： 1234567891011typedef struct &#123; int a; short b[2];&#125; Ex2;typedef struct Ex &#123; int a; char b[3]; Ex2 c; struct EX *d;&#125;; 若声明一个结构体： 12Ex x = &#123;10, &quot;Hi&quot;, &#123;5, &#123;-1, 25&#125;&#125;, 0&#125;;Ex *px = &amp;x; 10.2.1 访问指针 px的右值： px的左值： px+1是一个非法的左值 10.2.2 访问结构 *px的右值： *px的左值（接受一个新值）： *px+1是非法的，因为没办法将结构体和整型相加 *(px+1)也是非法的 10.2.3 访问结构成员 px-&gt;a的右值： 如果进行以下声明： 12int *pi;pi = &amp;px-&gt;a; 则pi为： ​ **注：**px的结果是整个结构，而pi的结果是一个整型数 px-&gt;b的右值为指针常量，所以没有合法左值： 对数组元素的访问采用px-&gt;b[1] 10.2.4 访问嵌套的结构 px-&gt;c的左值是整个结构，右值如下： px-&gt;c.a的右值： *px-&gt;c.b的右值： 10.2.5 访问指针成员 对px-&gt;d进行初始化，使其指向一个结构体： 12Ex y;px-&gt;d = &amp;y; px-&gt;d-&gt;c.b[1]的右值： 10.3 结构的存储分配 12345struct ALIGN &#123; char a; int b; char c;&#125;; 对于上述结构体，若整型长度为4字节，而且它的起始存储位置必须能被4整除，于是a存储为1字节，但是后面必须空出3字节才能存放b，其存储形式为： 一个结构体占了12个字节的存储空间，有效利用空间却只有6字节 如果声明改为如下形式，则只需要8个字节就能存储这个结构体： 12345struct ALIGN &#123; int b; char a; char c;&#125;; sizeof可以得出一个结构体的整体长度，包括跳过的字节 使用offset(type, member)能获得结构体中某成员的实际位置，如offset(struct ALIGN, b) 10.4 作为函数参数的结构 最好使用指针来传递参数，并声明为寄存器变量来提高效率 若结构体成员不能改变，则： 1void test(register ALIGN const *test); 若需要根据程序运行结果修改结构体中的值，则： 1void test(register ALIGN *test); 调用方式都为： 1test(&amp;align); 10.5 位段 注重可移植性的程序应该避免使用位段 10.6 联合 联合的所有成员引用的是内存中的相同位置 如果联合的各个成员具有不同的长度，联合的长度就是最长成员的长度 应用场景比如： 12345678struct VARIABLE &#123; enum &#123;INT, FLOAT, STRING&#125; type; union &#123; int i; float f; char *s; &#125; value;&#125;; 对于整型，type设为INT，存储于value.i中；对于浮点数，type设为FLOAT，存储于value.f中； 联合的初始化，初始值必须是联合第一个成员的类型，如 12345union &#123; int a; float b; char c[4];&#125; x = &#123;5&#125;; Ch11 动态内存分配 11.1 为什么使用动态分配内存 声明数组时，数组的长度往往在运行时才能知道，但是编译时需要指定数组的长度，因为需要提前开辟内存空间。 11.2 malloc和free 在头文件stdlib.h中声明 11.2.1 malloc 1void *malloc(size_t size); malloc从内存池中提取一块合适的内存，并返回一个指向这块内存起始位置的指针(如果内存池中的内存可以满足需求的话，否则返回NULL) 参数是需要分配的内存字节数 malloc分配的是一块连续的内存 分配的内存不会被初始化 11.2.2 free 1void free(void *pointer); 参数是NULL时不会产生任何效果 参数是先前从malloc、calloc或realloc返回的值时，将分配的内存归还给内存池 11.3 calloc和realloc 11.3.1 calloc 1void *calloc(size_t num_elements, size_t element_size); 参数包括所需元素的数量和每个元素的字节数 将分配的内存初始化为0 11.3.2 realloc 1void *realloc(void *ptr, size_t new_size); 用于修改一个原先已经分配的内存块的大小 扩大内存块时，在原先的内存块之后添加；缩小内存块时，从原先内存块的尾部删除 11.4 使用动态分配的内存 获得足够存储25个整型的内存 12int *pi;pi = malloc(25 * sizeof(int)); 11.5 常见的动态内存错误 对NULL指针进行解引用操作 对分配的内存进行操作时越界 释放并非动态分配的内存 试图释放一块动态分配的内存的一部分 一块动态内存被释放之后被继续使用 内存泄漏：在使用完毕动态内存后没有进行释放 Ch12 使用结构和指针 12.2 单链表 声明一个节点： 1234typedef struct NODE &#123; struct NODE *link; int value;&#125; Node; 链表结构如图所示： 12.2.1 插入一个有序单链表 1234567891011121314151617181920212223242526272829// 函数的参数是一个指向链表第一个节点的指针，以及一个需要插入的新值#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;sll_node.h&quot;#define FALSE 0#define TRUE 1int sll_insert(register Node **linkp, int new_value) &#123; register Node *current; register Node *new; // 寻找正确的插入位置 while ((current=*linkp) != NULL &amp;&amp; current-&gt;value &lt; new_value) &#123; linkp = &amp;current-&gt;link; &#125; // 为新节点分配内存 new = (Node *)malloc(sizeof(Node)); if (new == NULL) &#123; return FALSE; &#125; new-&gt;value = new_value; // 插入节点 new-&gt;link = current; *linkp = new; return TRUE;&#125; 12.3 双链表 声明一个双链表节点: 12345typedef struct NODE &#123; struct NODE *fwd; struct NODE *bwd; int value;&#125; Node; 双链表结构如图所示： Ch14 预处理器 14.1 预定义符号 符号 样例 含义 _FILE_ “name.c” 进行编译的文件名 _LINE_ 25 文件当前行的行号 _DATE_ “Jan 31 1997” 文件被编译的日期 _TIME_ “18:04:30” 文件被编译的时间 _STDC_ 1 如果编译器遵循ANSI C，值为1 14.2 #define 1#define name stuff 替换文本不仅限于数值字面值常量。 123#define reg register#define do_forever for(;;)#define CASE break;case 14.2.1 宏 #define允许把参数替换到文本中，如： 123#define SQUARE(x) (x)*(x)SQUARE(5) // 输出25 14.2.3 宏与函数 可以使用宏来实现简单的函数，如比较大小： 1#define MAX(a, b) ((a)&gt;(b) ? (a) : (b)) 14.2.6 #undef 移除一个宏定义 1#undef name 14.3 条件编译 1234567#if 常量表达式 statements#elif 常量表达式 statements#else statements#endif 如果常量表达式非零，则statements正常编译，否则不编译","categories":[{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"复习 - SQ1复形","slug":"复习-SQ1复形","date":"2020-11-04T10:51:12.000Z","updated":"2020-11-05T02:32:02.662Z","comments":true,"path":"2020/11/04/复习-SQ1复形/","link":"","permalink":"http://example.com/2020/11/04/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/","excerpt":"太久没练复形都忘光了。。。整理复习一下","text":"Overview CS Algs by Depth Depth 1 Shape Scramble Solve / / Depth 2 Shape Scramble Solve /-3-3/ /33/ /3/ /-3/ Depth 3 Shape Scramble Solve /3/1/ /-1/-3/ /-3/-2/ /2/3/ /3/3/ /-3/-3/ /3/12/ /-1-2/-3/ /33/-1-2/ /12/-3-3/ /33/-1/ /1/-3-3/ /-3-3/2/ /-2/33/ /3/1-4/ /-14/-3/ Depth 4 Shape Scramble Solve /33/-1-2/-2-4/ /24/12/-3-3/ /-3-3/01/-2-2/ -2/22/12/-3-3/ /3/1-4/42/ /24/1/-4/3/ /3/1-4/-2-4/ /-4-2/1/-4/3/ /33/-1-2/0-4/ /04/12/-3-3/ /33/12/02/ /0-2/21/33/ /33/-1-2/0-2/ /02/12/-3-3/ /-3-3/01/-2/ /2/0-1/33/ /3/1-4/4/ y2 /0-4/-41/3/ 1-1/0-3/5-2/04/ y2 /-4/1/-4/3/ /03/12/-32/ /-34/12/03/ 1-1/0-3/-1-2/3-2/ /-32/12/03/ /3/1-4/02/ /0-2/-14/-3/ /0-3/0-1/02/ /0-2/01/03/ /0-3/0-1/12/ /-1-2/01/03/ 1-1/3/21/-2/ /2/12/03/ /3/12/4/ /-4/-1-2/-3/ 1-1/0-3/-1-2/0-4/ /04/12/03/ 1-1/3/21/-2-3/ /23/-2-1/-3/ /3/12/23/ /-2-3/-1-2/-3/ /33/-1/4/ /-4/1/-3-3/ 1-1/3/21/0-3/ /03/-2-1/-3/ /0-3/0-1/1/ /-1/01/03/ /0-3/0-1/04/ /0-4/01/03/ Depth 5 Shape Scramble Solve Note /03/12/-3/02/ /0-2/3/-1-2/0-3/ /0-3/0-1/1/02/ /0-2/-1/01/03/ 1-1/03/01/-1/0-2/ /02/02/1/03/ /3/12/2-3/34/ /32/-34/12/03/ 1-1/0-3/-1-2/3-4/-3/ /3/-34/12/03/ 1-1/0-3/-1-2/3-2/3/ /-3/-32/12/03/ 1-1/0-3/-1-2/0-4/-3/ /3/04/12/03/ /03/12/04/3/ /-3/62/-12/03/ /33/1/-2/2/ /-2/2/-1/-3-3/ /33/-1-2/-2/1-2/ /-12/2/12/-3-3/ /33/-1-2/02/2-1/ /-21/0-2/12/-3-3/ 1-1/3/21/2-3/2-1/ /-21/-23/-2-1/-3/ 1-1/3/21/4-3/-21/ /2-1/-43/-2-1/-3/ /0-3/0-1/1/32/ /-3-2/-1/01/03/ 1-1/0-3/-1/0-2/-3-2/ /32/02/1/03/ /33/-1-2/-2-4/-3/ /3/24/12/-3-3/ 1-1/0-3/-1-2/0-4/-32/ /3-2/04/12/03/ 1-1/-3/-1-2/4/-2/ /2/-4/12/3/ /33/-1-2/0-4/02/ /0-2/04/12/-3-3/ 1-1/3/21/2/0-1/ /01/-2/-2-1/-3/ 1-1/0-3/-1-2/02/0-1/ /01/0-2/12/03/ /3/12/-2/01/ /0-1/2/-1-2/-3/ /03/12/02/3-2/ /-32/0-2/-1-2/0-3/ /3/1/-2/2/ /-2/2/-1/-3/ /3/1/-2-1/01/ /0-1/21/-1/-3/ 三小角换风筝尾 /3/1/-2/0-1/ /01/2/-1/-3/ 1-1/0-3/-1-2/3-4/32/ /-3-2/-34/12/03/ /3/12/-23/21/ /-2-1/2-3/-1-2/-3/ 1-1/0-3/-1-2/3-2/-3/ /3/-32/12/03/ /03/12/-32/3/ /-3/3-2/-1-2/0-3/ 1-1/0-3/-1-2/3-2/0-2/ /02/-32/12/03/ /3/1-4/02/-1/ /1/0-2/-14/-3/ 构造飞镖 /3/1-4/02/0-2/ /02/0-2/-14/-3/ 构造飞镖 1-1/3/21/2-3/0-1/ /01/-23/-2-1/-3/ /33/-1-2/2/0-1/ /01/-2/12/-3-3/ 三小角并一小角 /-3-3/01/-2-2/1-2/ \\ 合并六星 Depth 6 Shape Scramble Solve Note /0-3/-2-1/-32/-1-2/-4/ /4/12/3-2/21/03/ 1-1/-3/-1-2/2-3/-2-1/0-4/ /04/21/-23/12/3/ 待优化 1-1/0-3/-1-2/3-4/-1-2/-2/ /2/12/ -34/12/03/ 1-1/3/21/4-3/21/02/ /0-2/-2-1/-43/-2-1/-3/ /0-3/0-1/12/2/-1/ /1/-2/-1-2/01/03/ /3/1/-2-1/0-2/01/ /0-1/02/21/-1/-3/ /3/1/-2/2/03/ /0-3/-2/2/-1/-3/ /33/1/-2-2/21/-2-2/ \\ 两步变六星 /3/1/-2/0-1/2/ /-2/01/2/-1/-3/ 两步后23动1 /3/1/-2-1/01/-2/ /2/0-1/21/-1/-3/ /33/1/-2/2/-2-3/ /23/-2/2/-1/-3-3/ /3/12/-2/01/2/ /-2/0-1/2/-1-2/-3/ /3/12/-2/2-3/-2/ /21/2-1/21/-1/-3/ /3/1/-2/2/-23/ /2-3/-2/2/-1/-3/ /33/-1-2/-2/1/2/ /33/12/2/-1/-2/ 1-1/3/2-5/2/0-1/-4/ /4/01/-2/-25/-3/ 构造shield-paw /3/1/-2/2/-2/ /2/-2/2/-1/-3/ 构造shield-kite Depth 7 Shape Scramble Solve /3/1/-2/2/-2/1/ /-1/2/-2/2/-1/-3/ /0-3/0-1/02/0-2/02/0-1/ /01/0-2/02/0-2/01/03/","categories":[{"name":"Cube","slug":"Cube","permalink":"http://example.com/categories/Cube/"}],"tags":[{"name":"sq1","slug":"sq1","permalink":"http://example.com/tags/sq1/"},{"name":"cube","slug":"cube","permalink":"http://example.com/tags/cube/"}]},{"title":"Hexo+Volantis个人博客部署","slug":"Hexo-Volantis个人博客部署","date":"2020-11-03T09:46:42.000Z","updated":"2020-11-04T09:59:52.992Z","comments":true,"path":"2020/11/03/Hexo-Volantis个人博客部署/","link":"","permalink":"http://example.com/2020/11/03/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/","excerpt":"个人博客配置心得","text":"配置部署Hexo 配置流程 参考链接 安装npm 安装git 其中配置npm源 123456# 获取npm源npm get registry# 修改为淘宝源npm config set registry http://registry.npm.taobao.org/# 重置# npm config set registry https://registry.npmjs.org/ 常用命令 12345# 上传至githubhexo g &amp;&amp; hexo d# 本地运行hexo g &amp;&amp; hexo s Markdown公式显示问题 使用hexo-renderer-markdown-it插件 处理Markdown图片问题 在最开始的尝试中遇到以下问题： 直接将图片保存到github，在hexo编译生成的html网页中通过相对路径访问速度太慢 将博客部署到gitee上，由于服务器在国内，图片加载速度确实比github快很多，但是问题在于部署在gitee上的博客会有各种奇怪显示问题，所以也放弃 最终的解决办法： 先在github新建一个仓库Source，专门用来存放博客文章用到的图片 使用jsdelivr提供的cdn加速 在本地编写好markdown后，将图片文件夹复制到Source目录下并push到github仓库 在markdown文档中通过ctrl+f将所有图片的路径前缀改为https://cdn.jsdelivr.net/gh/&lt;github用户名&gt;/Source@latest/&lt;文件夹名&gt; Volantis主题配置 主题安装 修改./_config.yml 1theme: volantis 下载主题 1npm i hexo-theme-volantis volantis主题会安装在./node_modules/hexo-theme-volantis中 主题个性化 搜索工具安装 1npm i -S hexo-generator-search hexo-generator-json-content 字数统计工具安装 1npm i hexo-wordcount 主题配置文件 顶部导航栏 1234567891011121314151617181920212223navbar: logo: # choose [img] or [icon + title] img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/taiga.svg menu: - name: 主页 icon: fab fa-stack-overflow url: / - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: Search... # Search bar placeholder 封面 12345678910111213141516171819202122cover: layout_scheme: dock # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) background: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/interstellar.jpg logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;Schenk - Blog&#x27; subtitle: &#x27;SJTUer | Cuber&#x27; features: - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ 全局CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556custom_css: navbar: height: 44px width: auto # auto, max effect: [shadow, blur, floatable] # [shadow, floatable, blur] sidebar: effect: [shadow, floatable] # [shadow, floatable, blur] body: effect: [shadow, floatable] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true grayscale: false # Enable grayscale effect text_align: # left, right, justify, center h1: center h2: left h3: left h4: left p: justify gap: h2: 30px # Spacing above H2 (only px unit) h3: 18px # Spacing above H3 (only px unit) h4: 8px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... fontsize: root: 16px h1: 1.5rem # 不推荐用在文章中 h2: 1.5rem h3: 1.25rem h4: 1.125rem h5: 1rem h6: 1rem list: .9375rem meta: .875rem code: .875rem footnote: .78125rem fontfamily: logofont: fontfamily: &#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27; name: &#x27;Microsoft Yahei&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27; name: &#x27;Microsoft Yahei&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf weight: normal style: normal codefont: fontfamily: &#x27;UbuntuMono&#x27; name: &#x27;UbuntuMono&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/UbuntuMono-Regular.ttf weight: normal style: normal 页脚 1234567site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [copyright] # site copyright copyright: &#x27;[Copyright © 2020 Schenk](https://github.com/Schenk75/Schenk75.github.io)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; 文章布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: false # true, false # show readmore button readmore: always # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, wordcount, counter] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: data:image/png;base64,666 # ---------------- # 打赏组件 (for layout: post) donate: enable: false height: 128px images: - https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags] # meta library meta_library: # 默认文章作者（可在 front-matter 中覆盖） author: avatar: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg name: Schenk url: / # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag 侧边栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106sidebar: # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, webinfo] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg shape: circle # circle, rectangle url: /about/ title: Schenk subtitle: jinrishici: false # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/github-icon.svg size: 30px url: https://github.com/Schenk75 - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/struts.svg url: / - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/logos/WCAlogo.svg url: https://cubingchina.com/results/person/2018SHEN04 # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fas fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2020/11/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: service: busuanzi # busuanzi, leancloud siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; 统计工具 12analytics: busuanzi: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/tools/busuanzi.pure.mini.js 关闭评论 1234comments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: # valine, minivaline, disqus, gitalk, vssue, livere, isso, hashover 插件 1234567891011plugins: ######## Plugins to optimize the experience: # Codeblock Copy Button clipboard: enable: true js: https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js ######## Plugins for SEO: # npm i hexo-wordcount wordcount: enable: true 页面布局模板 参考链接 front-matter设置 参考链接","categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"cdn","slug":"cdn","permalink":"http://example.com/tags/cdn/"}]},{"title":"Internet安全协议与分析Notes","slug":"Internet安全协议Notes","date":"2020-11-02T06:54:20.991Z","updated":"2020-11-25T11:22:52.456Z","comments":true,"path":"2020/11/02/Internet安全协议Notes/","link":"","permalink":"http://example.com/2020/11/02/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/","excerpt":"Internet安全协议与分析期末复习","text":"IPSec 通信保护协议 AH 通信提供数据源认证、抗抵赖性、数据完整性和反重播保证，但不提供机密性保护 AH传输模式 源IP地址、目的IP地址是不能修改的，否则会被检测出来，因此AH在传输模式下和NAT冲突 AH隧道模式 AH验证的范围也是整个IP包，因此AH和NAT的冲突在隧道模式下也存在 ESP 为IP提供机密性、数据源认证、抗重播以及数据完整性等安全服务，但不提供抗抵赖性 对IP头部不进行认证，因此不会和NAT冲突 ESP传输模式 ESP隧道模式 密钥交换管理协议IKE 安全机制 前向安全性：一个密钥被破解不影响其他密钥的安全性 数据验证 DH交换和密钥分发 阶段1 主模式协商 野蛮模式协商 两种模式对比 阶段2 SSL 安全机制 数据机密性：对称加密 身份验证机制：基于证书的数字签名 消息完整性：MAC算法 SSL连接和会话 连接是点对点的、暂时的 会话是客户端和服务器之间持久的关联 SSL分层结构 上层协议 SSL握手协议：协商加密套件，交换密钥，身份认证 SSL password变化协议：修改新的加密套件和密钥 SSL警告协议：当其他过程中出现错误或发送异常时，向对方报告告警信息 下层协议 SSL记录协议：对上层数据分块、压缩、加密、传输 SSL握手协议 阶段1：建立安全能力 协商加密套件 阶段2：服务器鉴别与密钥交换 阶段3：客户端鉴别与密钥交换 服务器和客户端分别发送自己的证书并交换密钥信息以便进行身份认证 阶段4：完成 检验双方是否获得同样的安全参数 SSL记录协议 为每个SSL连接提供： 机密性 完整性 SSL协议安全性分析 鉴别机制：公开密钥机制和数字证书 加密机制：混合密码体制 完整性机制：定义了共享的、可以用来形成报文鉴别码MAC的密钥 抗重放攻击：序列号，用随机数标记握手 SSL脆弱性分析 客户端假冒 无法提供基于UDP的应用的安全保护 不能对抗通信流量分析：SSL只对数据进行保护，数据包的IP头和TCP头暴露在外 SSL进程存储空间中的主密钥泄露 SET 双重数字签名 订单信息OI：客户给商家 支付信息PI：客户给银行 SET电子支付流程 支付初始化：持卡人选择商品，下订单，选择银行卡 初始请求：持卡人发送请求指定交易环境 初始应答：商家回复交易环境信息，以及证书等，并附上签名 购物请求： 持卡人检查商家初始应答发送的签名信息，确保数据完整性 持卡人发送PReq 商家验证持卡人的身份和授权 商家将相关信息发送给支付网关 支付网关认证 网关将信息发送给银行 收单银行处理 确保PI和AuthReq的一致性 校验持卡人和商家对于订购行为的一致性 发送AuthRes给商家 支付完成 通过捕获令牌(Capture Token)完成支付 下单回复 SET核心技术 公开密钥加密 数字签名 数字信封：公钥算法加密对称密钥 电子安全证书 PGP 提供可用于电子邮件和文件存储应用的保密与鉴别服务 PGP数字签名与认证 PGP保密性 邮件的存储转发特性不适合用DH算法交换密钥 使用公钥算法对每个消息生成一次性会话密钥 PGP保密和认证结合 PGP压缩 使用ZIP算法 先签名后压缩 只需要存储原始报文和签名 易于更换压缩算法 PGP密钥环 每个结点都有存储密钥的结构 私钥环：存储该结点拥有的公/私钥对 公钥环：存储该结点拥有的其他所有用户的公钥 PGP信任网 PGP中没有认证机构，而是由用户互相对对方的公钥进行数字签名 确认是否信任 通过自己的数字签名 通过自己完全信任的人的数字签名 通过自己有限信任的多个人的数字签名 Kerberos 采用传统加密算法(非公钥算法) 基本概念 Principle：安全个体，有名字和口令 KDC：网络服务，提供ticket和临时会话密钥 Ticket：客户用来向服务器证明身份的票据 其大多数信息被服务器的密钥加密 Authenticator：包含最近产生的信息的记录，需要用到会话密钥 Credentials：一个Ticket加上秘密的会话密钥 AS：Authentication Server 通过long-term key认证用户 授予用户ticket granting ticket和short-term key 认证服务 TGS：Ticket Granting Server 通过ticket granting ticket和short-term key认证用户 发放service granting ticket给用户以访问其他服务器 授权和访问控制服务 Kerberos工作流程 1. 认证服务交换：获得票据许可票据(ticket granting ticket) 2. 票据许可服务交换：获得服务许可票据(service granting ticket) 3. 客户/服务器认证交换：获得服务 Kerberos跨域认证 获得本地TGS访问权 请求一张远程TGS的票据许可票据 向远程TGS请求其域内的服务 Kerberos优缺点 优点 密码不在网上传输，不易被窃听，难以猜测 单点登录机制，只用输入一次口令 票据被盗之后难以使用，因为需要配合认证头来使用 缺点 缺乏撤销机制 密钥管理复杂 跨域认证复杂 需要始终同步 需要始终在线的AS和TGS BAN 所用符号 A, B, S：泛指参与协议的主体 P, Q, R：主体变量 X, Y: 公式变量 K: 密钥变量 Kab, Kbs, Kas: 主体之间的共享密钥 Ka, Kb, Ks: 主体的公钥 Ka-1, Kb-1, Ks-1: 主体的私钥 Na, Nb, Ns：主体各自生成的用于确认新鲜性的随机数Nonce {X}k：用密钥k加密X的结果 &lt;X&gt;Y：X和Y的组合 P-&gt;Q:(X)：P发送消息X给Q bel(P,Q)：主体P相信X sees(P,X)：P接收到X said(P,X)：P发送X cont(P,X)：P拥有对X正确与否的判决权 fresh(X)：X是新鲜的 skey(P,K,Q)：K是P,Q的共享密钥 goodkey(P,K,Q)：K是P,Q共享的良好密钥 pubkey(P,K)：K是P的公钥 secret(P,X,Q)：X是P和Q的共享秘密 推理规则 消息意义规则 从加密消息所使用密钥以及消息中包含的秘密来推断消息发送者的身份 例如对于共享密钥：bel(P,goodkey(P,K,Q)) and sees(P,{X}k) =&gt; bel(P,said(Q,X)) 随机数验证规则 如果P相信X是新鲜的，并且P相信Q曾经发送过X，那么P相信Q相信X bel(P,fresh(X)) and bel(P,said(Q,X)) =&gt; bel(P,bel(Q,X)) 仲裁规则 如果P相信Q对X是有仲裁权的，并且P相信Q相信X，那么P相信X bel(P,cont(Q,X)) and bel(P,bel(Q,X)) =&gt; bel(P,X) 信仰规则 bel(P,X) and bel(P,Y) =&gt; bel(P,(X,Y)) bel(P,(X,Y)) =&gt; bel(P,X) or bel(P,Y) bel(P,bel(Q,(X,Y))) =&gt; bel(P,bel(Q,X)) or bel(P,bel(Q,Y)) 接收规则 如果P接收到一个消息，那么P也接收到这个消息的一部分 sees(P,(X,Y)) =&gt; sees(P,X) sees(P,&lt;X&gt;Y) =&gt; sees(P,X) 如果P收到加密消息，那么以下三种情况P可以读出消息原文 bel(P,goodkey(P,K,Q)) and sees(P,{X}K) =&gt; sees(P,X) bel(P,pubkey(P,K)) and sees(P,{X}K) =&gt; sees(P,X) bel(P,pubkey(Q,K)) and sees(P,{X}K-1) =&gt; sees(P,X) 新鲜规则 如果消息的一部分是新鲜的，则整个消息是新鲜的 bel(P,fresh(X)) =&gt; bel(P,fresh(X,Y)) 传递规则 如果P相信Q曾经发送过整个消息，那么P相信Q曾经发送过消息的部分 bel(P,said(Q,(X,Y))) =&gt; bel(P,said(Q,X))","categories":[{"name":"Course Notes","slug":"Course-Notes","permalink":"http://example.com/categories/Course-Notes/"}],"tags":[{"name":"安全协议","slug":"安全协议","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-01T13:16:05.384Z","updated":"2020-11-03T14:11:41.657Z","comments":true,"path":"2020/11/01/hello-world/","link":"","permalink":"http://example.com/2020/11/01/hello-world/","excerpt":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Git - Learn","slug":"Git学习","date":"2020-10-13T09:00:19.289Z","updated":"2021-10-14T15:19:50.269Z","comments":true,"path":"2020/10/13/Git学习/","link":"","permalink":"http://example.com/2020/10/13/Git%E5%AD%A6%E4%B9%A0/","excerpt":"Git学习记录","text":"版本控制 1. 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS 2. 集中版本控制 所有的版本数据都存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3. 分布式版本控制 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN的主要区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git环境配置 Git配置 查看配置 1git config -l 查看不同级别的配置文件： 1234567# 查看系统configgit config --system --list# Git\\etc\\gitconfig：Git安装目录下的gitconfig # 查看当前用户（global）配置git config --global --list# C:\\Users\\Administrator\\.gitconfig 只适用于当前登录用户的配置 设置用户名与邮箱（用户标识，必要） 12git config --global user.name &quot;&lt;名称&gt;&quot; # 名称git config --global user.email &lt;邮箱&gt; # 邮箱 Git基本理论 三个区域 Git本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下: Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本： Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) Git项目搭建 创建工作目录与常用指令 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 创建权限仓库 创建全新的仓库，需要用GIT管理的项目的根目录执行： 12# 在当前目录新建一个Git代码库$ git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 12# 克隆一个项目和它的整个代码历史(版本信息)$ git clone &lt;url&gt; Git文件操作 文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态 12345678# 查看指定文件状态git status &lt;filename&gt;#查看所有文件状态git statusgit add . 添加所有文件到暂存区git commit -m &quot;消息内容&quot; 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 12345*.txt # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt # 但lib.txt除外/temp # 仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ # 忽略build/目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt Git分支 git分支中常用指令： 123456789101112131415161718192021# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] Git子模块 git子模块中常用指令：参考https://blog.csdn.net/guotianqing/article/details/82391665 123# 遇到报错git submodule: already exists in the index# (path为子模块在本地项目中存储的目录)git rm -r --cached &lt;path&gt;","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Docker - Learn","slug":"Docker学习","date":"2020-10-12T11:59:23.847Z","updated":"2020-11-04T04:20:38.053Z","comments":true,"path":"2020/10/12/Docker学习/","link":"","permalink":"http://example.com/2020/10/12/Docker%E5%AD%A6%E4%B9%A0/","excerpt":"Docker学习记录","text":"底层原理 Docker是怎么工作的？ Docker是一个C-S结构的系统，Docker的守护进程运行在服务主机上，通过Socket从客户端访问。 DockerServer接收到DockerClient的指令就会执行这个命令。 Docker为什么比VM快？ Docker有着比虚拟机更少的抽象层 Docker利用的是宿主机的内核，VM需要有Guest OS。所以新建一个容器的时候，docker不需要像VM一样重新加载一个操作系统内核，避免引导 Docker常用命令 docker的默认工作路径 1/var/lib/docker 帮助命令 123docker version # 显示docker的版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker &lt;命令&gt; --help # 查看帮助命令 镜像命令 docker images 查看所有本地的主机上的镜像 1234567891011121314[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 9 months ago 13.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IDCREATED 镜像的创建时间SIZE 镜像的大小# 命令可选项-a, --all 列出所有镜像-q, --quiet 只显示镜像的id docker search 搜索镜像 1234567[root@localhost ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10046 [OK] mariadb MariaDB is a community-developed fork of MyS… 3680 [OK] # 可选项，通过收藏数过滤--filter=STAR=3000 搜索出来的镜像是STARS大于3000的 docker pull [:tag] 下载镜像 123456789101112131415161718192021222324252627282930313233343536[root@localhost ~]# docker pull mysqlUsing default tag: latest # 如果不写tag，默认是latestlatest: Pulling from library/mysqld121f8d1c412: Pull complete # 分层下载，docker镜像的核心 联合文件系统f3cebc0b4691: Pull complete 1862755a0b37: Pull complete 489b44f3dbb4: Pull complete 690874f836db: Pull complete baa8be383ffb: Pull complete 55356608b4ac: Pull complete dd35ceccb6eb: Pull complete 429b35712b19: Pull complete 162d8291095c: Pull complete 5e500ef7181b: Pull complete af7528e958b6: Pull complete Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 下载指定版本，共用的层会复用，不用重复下载[root@localhost ~]# docker pull mysql:5.75.7: Pulling from library/mysqld121f8d1c412: Already exists f3cebc0b4691: Already exists 1862755a0b37: Already exists 489b44f3dbb4: Already exists 690874f836db: Already exists baa8be383ffb: Already exists 55356608b4ac: Already exists 277d8f888368: Pull complete 21f2da6feb67: Pull complete 2c98f818bcb9: Pull complete 031b0a770162: Pull complete Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像 12docker rmi -f &lt;镜像id&gt; [&lt;镜像id&gt; &lt;镜像id&gt;] # 删除指定的镜像docker rmi -f $(docker images -aq) # 删除所有镜像 容器命令 **注：**有了镜像才可以创建容器，以centos镜像为例 1docker pull centos docker run [可选参数] 新建并启动容器 1234567891011121314151617# 参数说明--name=&quot;&lt;Name&gt;&quot; 容器名字，自定义，用来区分容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p 指定容器的端口，配置端口转发 -p ip:主机端口:容器端口 -p 主机端口:容器端口（常用） -p 容器端口-P 随机指定端口例：# 启动并进入容器[root@localhost ~]# docker run -it centos /bin/bash# 退出容器并关闭容器[root@bebbdced119e /]# exit# 退出容器但不关闭容器Ctrl + p + q docker ps [可选参数] 列出运行的容器 1234# 参数说明-a 列出所有运行过的容器-n=&lt;n&gt; 列出最近创建的n个容器-q 只显示容器编号 **docker rm 删除容器 123docker rm &lt;容器id&gt; 删除指定容器，不能删除正在运行的容器，若要强制删除加参数-fdocker rm -f $(docker ps -aq) 删除所有的容器docker ps -a -q|xargs docker rm 删除所有的容器 启动和停止容器 1234docker start &lt;容器id&gt; 启动容器docker restart &lt;容器id&gt; 重启容器docker stop &lt;容器id&gt; 停止容器docker kill &lt;容器id&gt; 强制停止容器 常用其他命令 后台启动容器 1234docker run -d centos# 问题：docker ps发现centos停止了# 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 查看日志 12docker logs -ft &lt;容器id&gt; # 查看所有日志docker logs -ft --tail &lt;n&gt; &lt;容器id&gt; # 查看最新的n条日志 **查看容器中的进程信息 ** 1docker top &lt;容器id&gt; 查看容器的元数据 1docker inspect &lt;容器id&gt; 进入正在后台运行的容器 1234567# 方法1docker exec -it &lt;容器id&gt; &lt;bashshell&gt;# 进入容器后开启一个新的终端，可以在里面操作（常用）# 方法2docker attach &lt;容器id&gt;# 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件 1docker cp &lt;容器id&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;","categories":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"Linux - Learn","slug":"Linux学习","date":"2020-09-11T11:47:26.625Z","updated":"2020-11-04T04:20:59.170Z","comments":true,"path":"2020/09/11/Linux学习/","link":"","permalink":"http://example.com/2020/09/11/Linux%E5%AD%A6%E4%B9%A0/","excerpt":"Linux学习记录","text":"了解系统信息 硬盘大小 123fdisk -l&#x2F;dev&#x2F;sda 操作系统中第一块硬盘的名称以及所在路径Linux操作系统一切皆文件 （文件名） sd (硬盘类型) a（第一块） 内存大小 1cat &#x2F;proc&#x2F;meminfo cpu大小 1cat &#x2F;proc&#x2F;cpuinfo 收集系统信息 1uname -a Linux文件系统 12345678910111213&#x2F;bin 普通用户和管理员都可以执行的命令&#x2F;sbin 只有管理员才能执行的命令 eg.关机重启&#x2F;boot 引导 主引导目录 独立的分区 启动菜单 内核&#x2F;dev device 设备文件存放目录&#x2F;etc 配置文件存放目录&#x2F;home 普通用户的家目录&#x2F;root 管理员的家&#x2F;media 光驱的挂载目录&#x2F;mnt 临时设备的挂载目录&#x2F;proc 里面的数据都在内存中，进程的所在目录&#x2F;tmp 临时文件存放目录&#x2F;usr 第三方软件的安装目录&#x2F;var 常变文件存放目录 eg.日志文件、邮件文件 挂载光驱 12弹出光驱：umount &#x2F;dev&#x2F;cdrom挂载光驱：mount &#x2F;dev&#x2F;cdrom &#x2F;media Linux文件类型的显示颜色 1234567蓝色 目录黑色 普通文件浅蓝色 符号链接（快捷方式）黑底黄字 设备文件 硬盘 sda红色 压缩包绿色 带有执行权限的文件紫色 图片 模块文件 压缩和解压缩 文件压缩和解压缩 12gzip bigfilegunzip bigfile.gz 12bzip2 bigfilebunzip2 bigfile.bz2 目录(文件夹)打包压缩 12tar -zcf &#x2F;tmp&#x2F;allfile.tar.gz &#x2F;tmp&#x2F;allfiletar -jcf &#x2F;tmp&#x2F;allfile.tar.bz2 &#x2F;tmp&#x2F;allfile 目录(文件夹)解压缩并解包 123tar -zxf &#x2F;tmp&#x2F;allfile.tar.gz -C &#x2F;tmptar -jxf &#x2F;tmp&#x2F;allfile.tar.bz2 -C &#x2F;tmp-C 指定解包位置 vim 模式切换 123命令模式 -&gt; 输入模式：i输入模式 -&gt; 命令模式：Esc命令模式 -&gt; 末行模式：: 末行模式命令 12345:wq 保存并退出:q! 不保存退出:set nu 显示行号:% s&#x2F;old&#x2F;new&#x2F;g 每一行中的old替换成new:50,56 d 删除50-56行的数据 命令模式命令 123456780 光标移动到当前行首$ 光标移动到当前行末yy 复制当前行2yy 复制当前行以及后一行，其他数字以此类推p 粘贴到当前行下一行dd 删除当前行gg 回到第一行G 回到最后一行 Linux软件安装——封装后的软件包 后缀名 123rpm red hat系统deb debian系统源码包 不考虑系统版本 有关软件包安装的命令 123456rpm -qa 列出所有已经安装的rpm包查询特定的rpm包使用管道符：rpm -qa | grep &quot;tree&quot;rpm -qpi 软件名 确认该软件的作用rpm -qpl 软件名 确认该软件的安装路径(无法修改)rpm -ivh 软件名 安装软件rpm -e 软件名 软件卸载 Linux软件安装——yum 12yum install 软件名yum remove 软件名 用户和组 三个重要文件 12345678910111213&#x2F;etc&#x2F;passwd 保存操作系统中所有的用户信息root : x : 0 : 0 : root : &#x2F;root : &#x2F;bin&#x2F;bash每一条目共7个字段，用冒号隔开字段1：用户名字段2：密码占位符字段3：用户的UID 0 表示超级用户 500-60000 普通用户 1-499 程序用户字段4：基本组的GID，先有组才有用户字段5：用户信息记录字段字段6：用户的家目录字段7：用户登录系统后使用的命令解释器 12345678910&#x2F;etc&#x2F;shadow 保存了用户密码信息root : $6$ME9wjPHAid5ds$PO&#x2F;GlBVEt1 : 18325 : 0 : 99999 : 7 :::字段1：用户名*字段2：用户的密码加盐并通过散列算法后的字符串（sha）字段3：距离1970&#x2F;1&#x2F;1密码最近一次修改的时间字段4：密码的最短有效期*字段5：密码的最长有效期（建议时间 90）字段6：密码过期前7天警告字段7：密码的不活跃期字段8：用户的失效时间 1&#x2F;etc&#x2F;group 记录了系统中所有组的信息 建立和调整用户属性 123456789101112131415161718192021222324252627282930313233343536371、建立一个名为class1的组ID为1000，class2的组ID为2000建立：groupadd class1groupadd -g 2000 class2修改gid：groupmod -g 1000 class1查看：vim &#x2F;etc&#x2F;group2、建立tom用户要求其基本组是class1,附加组为class2，tom用户的UID为600建立：useradd -g class1 -G class2 -u 600 tom修改：usermod查看：id tom3、建立一个程序用户UID为250,用户名为testuser，没有家目录（程序用户没有登录系统权限）useradd -u 250 -M -s &#x2F;sbin&#x2F;nologin testuser-M：没有家目录-s &#x2F;sbin&#x2F;nologin：不能登录4、为tom用户设定密码为123，并设定密码最长有效期为90天，将用户密码进行锁定使其无法登录passwd tom 设定密码chage -M 90 tom 设定密码最长有效期或者修改配置文件&#x2F;etc&#x2F;login.defspasswd -l tom 锁定passwd -u tom 解锁查看：passwd -S tomvim &#x2F;etc&#x2F;shadow5、删除tom用户和testuser用户，删除class1组和class2组userdel -r tom （-r 连同用户的家目录一起删除）userdel -r testusergroupdel class1groupdel class1 文件目录权限 列出文件信息 123456ls -a 列出所有文件，包括隐藏文件ls -l(ll) 列出文件详细信息文件：-rw-rw-r--.(权限) 1(链接数) centos(所属用户) centos(所属组) 12(文件大小，字节) Sep 12 10:07(最后修改时间) test.txt目录：drwxrwxr-x.(权限) 2(子目录数) centos(所属用户) centos(所属组) 6 Sep 12 10:06(最后修改时间) testdirls -ld 列出某一目录的详细信息ls -h 用人能看懂的方式显示文件大小 权限详细 1234567891011121314- rw- rw- r--.d rwx rwx r-x.共4个字段字段1：文件类型 -普通文件 d目录文件 l符号链接文件 b块设备字段2：文件所属者的权限 r w x 文件 读取 写入 可执行 目录 查看目录文件 增删文件 进入目录字段3：文件所属组的权限字段4：其他用户的权限 赋权限 12345方法1：chmod 对象 算术运算符 权限 文件 对象：u-所属者 g-所属组 o-其他用户 a-所有用户 算术运算符：- + &#x3D; 权限：r w x方法2：chmod 777 文件 改变文件的所属者和所属组 12chown 用户 文件chgrp 组 文件 粘滞位 sgid suid权限 12345678910粘滞位针对目录赋权，目录中创建的文件只有建立者可以删除 chmod o+t 文件 chmod o-t 文件sgid 针对目录建立的权限，在该目录中建立的文件所属组继承父目录的所属组 chmod g+s 文件 chmod g-s 文件suid 对可执行文件建立。谁运行该文件，就具有该文件所属者的权限 chmod u+s 文件 chmod u-s 文件 eg. chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim 查找有异常权限的文件 1234查找有suid权限的可执行文件find &#x2F;usr&#x2F;bin -perm 4755其中权限的第一个4表示suid权限，如果是2则表示sgid权限，如果是1则表示粘滞位权限的多一位也可以用于赋权限 不再允许添加新用户 123456789新建用户时会更改的文件 &#x2F;etc&#x2F;group &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow home&#x2F;xxxx锁定文件从而不能添加新用户 chattr +i &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow查看文件是否被锁定 lsattr &#x2F;etc&#x2F;passwd umask 1234567一般目录的最高权限是777一般文件的最高权限是666用户创建的文件通过umask来确定其权限root的umask是0022(第一位是特殊权限)普通用户并且uid&#x3D;sid的umask是0002umask的设置在&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc两个文件中 网络地址配置 12345678910111. 确认网卡信息：ip addr &#x2F; ifconfig2. 关闭NetworkManager服务：systemctl stop NetworkManager3. 网卡启用桥接模式，并配置网络地址： ip addr add IP&#x2F;掩码长度 dev ens334. 设置网关： ip route add default via IP dev ens335. 配置DNS： vim &#x2F;etc&#x2F;resolv.conf nameserver 202.120.2.1016. 关闭防火墙： systemctl stop firewalld.service 日志文件 123456789101112位置：&#x2F;var&#x2F;log日志记录的配置文件：&#x2F;etc&#x2F;rsyslog.conf 其中配置方式为 日志类型.日志级别 ，如authpriv.*表示记录所有级别的登录日志日志分类： 系统日志 &#x2F;var&#x2F;log&#x2F;messages 登录日志 &#x2F;var&#x2F;log&#x2F;secure 程序日志日志记录的日志级别：debug, info, notice, warning(warn), err(error), crit, alert, emerg(panic)最不严重 -&gt; 最严重配置日志备份服务器：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43252204&#x2F;article&#x2F;details&#x2F;105518163 WEB服务-apache 开启并使用apache 1234561. 启动服务 service httpd start2. 验证服务是否开启 ss -antpl | grep 803. 主页建立 vim &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html httpd配置文件 12345678910111213141516171819位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf默认会开启共享目录功能，这样会导致别人可以远程下载&#x2F;var&#x2F;www&#x2F;html中的内容，建议将其关闭： Options Indexes FollowSymLinks改为Options FollowSymLinks限制访问，将Require all granted修改为以下语句： &lt;RequireAll&gt; Require all granted Require not ip 192.168.1.10 192.168.2.0&#x2F;24 &#x2F;&#x2F;拒绝192.168.1.10和192.168.2.0网段客户机访问 &lt;&#x2F;RequireAll&gt;用户授权限制，只有通过指定的用户名密码才能访问网页： 设置用户名密码：htpasswd -c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser test (-c表示新建文件) 设置该文件只有apache用户可读： chown apache httpuser chmod 400 httpuser 修改配置文件： Authtype basic Authname &quot;Input username and password&quot; &#x2F;&#x2F; 提示信息 Authuserfile &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser Require valid-user lamp平台搭建 12345678910111213141. 安装apache2. 安装mysql yum install mysql-server &#x2F;&#x2F; 安装 service mysqld start &#x2F;&#x2F; 启动 mysqladmin -u root -p password &quot;123.sck&quot; &#x2F;&#x2F; 设置root密码 mysql -u root -p &#x2F;&#x2F; 登录数据库3. 安装php yum install php yum install php-mysqlnd yum install php-mbstring4. 配置php配置文件 vim &#x2F;etc&#x2F;php.ini 将short_open_tag从Off改为On5. 在&#x2F;var&#x2F;www&#x2F;html新建一个php文件 iptables防火墙 12345四个表： raw mangle nat 网络地址转换 filter 过滤","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]}],"categories":[{"name":"Install","slug":"Install","permalink":"http://example.com/categories/Install/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"},{"name":"Formal Model","slug":"Formal-Model","permalink":"http://example.com/categories/Formal-Model/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"Useful","slug":"Useful","permalink":"http://example.com/categories/Useful/"},{"name":"Translation","slug":"Translation","permalink":"http://example.com/categories/Translation/"},{"name":"Course Notes","slug":"Course-Notes","permalink":"http://example.com/categories/Course-Notes/"},{"name":"Cube","slug":"Cube","permalink":"http://example.com/categories/Cube/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"frp","slug":"frp","permalink":"http://example.com/tags/frp/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"},{"name":"substrate","slug":"substrate","permalink":"http://example.com/tags/substrate/"},{"name":"wasm","slug":"wasm","permalink":"http://example.com/tags/wasm/"},{"name":"eos","slug":"eos","permalink":"http://example.com/tags/eos/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"cargo","slug":"cargo","permalink":"http://example.com/tags/cargo/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"sq1","slug":"sq1","permalink":"http://example.com/tags/sq1/"},{"name":"cube","slug":"cube","permalink":"http://example.com/tags/cube/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"cdn","slug":"cdn","permalink":"http://example.com/tags/cdn/"},{"name":"安全协议","slug":"安全协议","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]}