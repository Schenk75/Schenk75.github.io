{"meta":{"title":"Schenk - Blog","subtitle":"","description":"","author":"schenk","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-06-20T09:27:15.668Z","updated":"2020-11-04T03:12:20.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-20T09:27:15.667Z","updated":"2020-11-04T03:04:04.000Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"友链 - Links","date":"2022-06-20T09:27:15.668Z","updated":"2020-11-04T03:11:20.000Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-20T09:27:15.668Z","updated":"2020-11-04T03:12:30.000Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-20T09:27:15.668Z","updated":"2020-11-04T03:12:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2022-06-20T09:27:15.668Z","updated":"2020-11-04T08:13:02.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"SJTUer Major in Cyber Security Cubing Since 2017 Biiiiiig Fan of Christopher Nolan &amp; One Piece &amp; Hua Chenyu"}],"posts":[{"title":"论文阅读-可搜索加密相关","slug":"paper-reading/searchable-encryption","date":"2022-12-11T16:00:00.000Z","updated":"2022-12-12T09:57:34.819Z","comments":true,"path":"2022/12/12/paper-reading/searchable-encryption/","link":"","permalink":"http://example.com/2022/12/12/paper-reading/searchable-encryption/","excerpt":"论文阅读-可搜索加密相关","text":"","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"db","slug":"db","permalink":"http://example.com/tags/db/"}]},{"title":"SGX Tools","slug":"instruction/sgx-tools","date":"2022-10-30T16:00:00.000Z","updated":"2022-10-31T09:12:02.968Z","comments":true,"path":"2022/10/31/instruction/sgx-tools/","link":"","permalink":"http://example.com/2022/10/31/instruction/sgx-tools/","excerpt":"整理使用过的SGX相关工具","text":"sgx_emmt 测量一个sgx程序运行过程中使用的最大enclave内存，根据 Developer Reference 中的相关章节进行测量，主要使用工具 sgx_gdb 在sdk安装目录的bin目录下 查看当前计算机的EPC大小 1234git clone git@github.com:ayeks/SGX-hardware.gitcd SGX-hardwaregcc test-sgx.c -o test-sgx./test-sgx","categories":[],"tags":[]},{"title":"WSL配置","slug":"instruction/wsl","date":"2022-06-21T16:00:00.000Z","updated":"2022-06-22T04:43:42.843Z","comments":true,"path":"2022/06/22/instruction/wsl/","link":"","permalink":"http://example.com/2022/06/22/instruction/wsl/","excerpt":"Windows11配置Linux子系统","text":"安装WSL 管理员权限打开powershell 1wsl --install 默认安装WSL 2 + Ubuntu 20.04，详见安装 WSL | Microsoft Docs 更新升级apt 1sudo apt update &amp;&amp; sudo apt upgrade 使用Windows文件管理器打开当前Ubuntu目录 1explorer.exe . 使用vscode打开当前当前Ubuntu目录 1code . 基本命令 WSL 的基本命令 | Microsoft Docs ==git等工具及语言的安装同双系统Ubuntu的安装== 配置WSL使用Windows代理 在Windows端Clash中开启 Allow LAN 在Ubuntu的 bashrc 中添加 123export hostip=$(cat /etc/resolv.conf |grep -oP &#x27;(?&lt;=nameserver\\ ).*&#x27;)export https_proxy=&quot;http://$&#123;hostip&#125;:7890&quot;export http_proxy=&quot;http://$&#123;hostip&#125;:7890&quot; 测试 1curl google.com","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"解决 cargo build 过程中无法更新基于git repo的crates","slug":"instruction/rust-cargo-git-block","date":"2022-05-15T16:00:00.000Z","updated":"2022-05-26T08:52:56.000Z","comments":true,"path":"2022/05/16/instruction/rust-cargo-git-block/","link":"","permalink":"http://example.com/2022/05/16/instruction/rust-cargo-git-block/","excerpt":"解决 cargo build 过程中无法更新基于git repo的crates","text":"经过 git clone 检查发现：https经常无法成功下载，而ssh下载稳定 修改 ~/.gitconfig ： 12[url &quot;ssh:&#x2F;&#x2F;git@github.com&#x2F;&quot;] insteadOf &#x3D; https:&#x2F;&#x2F;github.com 修改 ~/.cargo/config 12[net]git-fetch-with-cli &#x3D; true","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"论文阅读-ORAM相关","slug":"paper-reading/oram","date":"2022-05-06T16:00:00.000Z","updated":"2022-08-18T07:20:30.109Z","comments":true,"path":"2022/05/07/paper-reading/oram/","link":"","permalink":"http://example.com/2022/05/07/paper-reading/oram/","excerpt":"论文阅读-ORAM相关","text":"ORAM基础 使用场景 与不受信任的云存储交互，并在不泄露访问模式的情况下利用云存储 在安全Enclave中实现，从而&quot;ORAM控制器/client&quot;为enclave，而主内存为&quot;server&quot; 在编译器中实现，该编译器将任意代码转换为通过其内存访问模式不泄漏任何内容的代码，但运行速度更慢 constant-time/oblivious定义 对于一个函数，若对任意两个输入，代码和数据的访问模式是： 相同，或 同分布，或 服从计算不可区分的分布 不经意随机访问机研究综述 敌手： 通过用户的访问模式(access pattern)来推断存储数据的重要性 可以通过匹配前后两个连续的访问模式来推断数据查询之间的关联关系，甚至是加密数据的内容 ORAM：隐藏对真实数据块的访问，使得攻击者不能区分每一次访问是真实的还是随机的 ORAM 保证： 任意数据块不会永久驻留在某一个物理地址中，即确保任意两次访问不会产生关联 将每一次读写访问细化成一次读取加一次写回的原子操作 保护： 访问数据块的位置 数据块请求的顺序 对相同数据块的访问频率 具体的读写访问方式 定义：ORAM是客户端与服务器的交互协议 安全性：访问模式计算不可区分 正确性：使用ORAM和不使用的返回结果不同的概率是一个可忽略函数 设计重点： ORAM初始化 ORAM数据访问 特性： 低效性 安全性 用途广 模型： 简单模型 平方根模型 层次模型 分区模型 树状模型 ORAM性能优化 客户端与服务器平均带宽优化 基于布谷鸟哈希的优化策略 基于服务器计算的优化策略 基于映射表的优化策略 基于k 叉树的优化策略 客户端与服务器最坏情况带宽优化 基于de-amortization 的优化策略 基于树状模型的优化策略 基于改进混洗操作的优化策略（优化不经意排序算法） 基于改进驱逐操作的优化策略 客户端存储开销优化 基于迭代构造的优化策略 基于隐私信息检索的优化策略 基于布隆过滤器的优化策略 服务器存储开销优化 通过设计可变大小的数据块集合或者是增加(减少)部分数据块集合大小 客户端与服务器交互轮数优化 基于映射表的优化策略 基于混淆分支函数的设计 Path-ORAM An Introduction to Oblivious RAM (ORAM) – Kudelski Security Research 树的每个节点是一个bucket，其中包含固定个数的block，每个block使用 C 的对称密钥加密 position map初始化为随机值 开始执行data request 整个从根节点到叶子节点的branch返回给 C 每个block包含id和data，id在整棵树中唯一（但是dummy block的id都相同） shuffle： position map保证我们需要的block在这个branch中 若block是空的，不对其操作 非空block与当前branch中距离root最远的空block交换，使得它的leaf path与当前branch有交集 若在操作过程中发现目标block，position map中它的id替换成一个新的随机值 若没有发现空block，则需要shuffle的block会暂时保存在 C 本地的overflow stash，并在branch中替换为空block 所有block操作完成后，将暂存在overflow stash中的block分配到branch中新创建的空block中，然后清空stash 最后，将整个branch重新加密并上传到 S 具体过程如下：C 从root开始扫描 第二个block非空，需要shuffle C 从position map中找到对应的id 找到该block对应的leaf path，此时可以找到该leaf path与当前branch的最深公共节点，该节点一定在当前解密后的branch中，搜索该节点寻找一个空block 第一个block非空 第二个block也非空 第三个block为空 交换两个block，注意到此时空block被换到更接近root的位置 C 继续扫描和交换未被操作过的block 当 C 找到目标block，首先执行request中的op 然后 C 更新position map中对应block的leaf为新生成的随机leaf id 新的随机leaf id对应的branch会与当前branch有部分交集，同样，C 会查找最深公共节点，找寻空block来进行交换 此时，若找不到空block，C 会搜索其父节点，找寻空block来进行交换 在scan的过程中若碰到一个block，无法找到能与它交换的空block，则将其暂存在stash中 同时将该block覆写为空block stash中的block会周期性地写回到branch中空block的位置，并分配合适的leaf id；最后，branch重新加密并上传到 S Enclave-Based Oblivious RAM Using Intel’s SGX Computers &amp; Security 2020 Karolinska Institutet 卡罗林斯卡学院 Carnegie Mellon University in Qatar 卡内基·梅隆大学 Qatar University 卡塔尔大学 利用SGX构造了三种不同的oram：线性ORAM、平方根ORAM和路径ORAM","categories":[{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"},{"name":"ORAM","slug":"ORAM","permalink":"http://example.com/categories/ORAM/"}],"tags":[{"name":"oram","slug":"oram","permalink":"http://example.com/tags/oram/"}]},{"title":"在任意位置运行Python脚本","slug":"instruction/python-execute-anywhere","date":"2022-05-02T16:00:00.000Z","updated":"2022-05-16T11:25:42.000Z","comments":true,"path":"2022/05/03/instruction/python-execute-anywhere/","link":"","permalink":"http://example.com/2022/05/03/instruction/python-execute-anywhere/","excerpt":"在任意位置运行Python脚本","text":"在Ubuntu上任意位置运行某一个python脚本的方法： 首先在python文件开头加上： 1#!/usr/bin/env python3 说明该文件是python3脚本 为方便起见，可以将文件的.py后缀删去，并为文件添加可执行权限： 1chmod +x &lt;pythonFile&gt; 最后将python脚本所在的目录添加到 PATH 环境变量中，比如在 ~/.bashrc 中添加： 1export PATH=&lt;pathToPythonFile&gt;:$P","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"MIT 6.824 Distributed Systems 学习笔记","slug":"learning-notes/mit-6.824","date":"2022-04-27T16:00:00.000Z","updated":"2022-05-06T07:16:52.000Z","comments":true,"path":"2022/04/28/learning-notes/mit-6.824/","link":"","permalink":"http://example.com/2022/04/28/learning-notes/mit-6.824/","excerpt":"MIT6.824学习笔记","text":"Paper Reading MapReduce 一个编程模型，用于大规模并行计算，以及采用re-execution进行容错处理 $Map$：输入键值对，输出一系列中间键值对，并将相同的中间键排在一起传递到 $Reduce$ 函数 $Reduce$：输入中间键 $I$ 以及其对应的一系列中间值，对其进行合并，最后输出 实现 Master数据结构 Master存储： 每个map和reduce任务的状态（idle, in-progress, completed） 各个worker的标识 每个已完成的map任务的R个中间文件的位置和大小 容错 Worker Failure Master Failure Semantics in the Presence of Failures 本地优化 输入文件被划分为64MB的块，每个块会冗余存放在多个机器上 Master会将map任务尽可能分配到一个保存了对应副本的机器或其周围的机器上 任务粒度 M和R应该远大于worker机器的数量 备份任务 为了解决单点效率瓶颈，在MapReduce任务快完成时，master将剩余in-progress机器仍在执行的任务作为备份任务分配给其他机器 改进 Partitioning Function（如何分配R个输出文件） Ordering Guarantees Combiner Function（对重复的中间结果合并） Input and Output Types（自定义类型） Side-effects Skipping Bad Records（用户程序对特定的数据可能有bug） Local Execution（方便Debug） Status Information（日志） Counters Google File System Overview 假设 系统组件经常故障，因此需要持续监控，错误检测，容错处理，自动恢复 存储大量文件，有几百万100MB或以上的文件，多GB的文件很常见，需要高效管理，小文件不需要优化 存在两种读：大规模连续读和小规模随机读 有很多大规模连续写（添加内容），也需要支持小规模随机写但不要求其性能 高效处理多用户同时向同一个文件添加内容，保证原子性并减少开销 高持续带宽比低延迟更重要 架构 单个Master：必须最小化其参与的读和写，防止成为瓶颈 chunk大小：选择较大的64MB 优势： 减少client与master的交互 client更有可能在同一个chunk上进行大量操作，减少网络开销 减少master上存储的metadata 劣势：若很多client访问同一个文件，则这个chunk会成为hot spot Metadata：存放在master的内存中（前两个还会记录在operation log中进行持久化存储） 文件和chunk的命名空间 文件到chunk的映射 各个chunk副本的位置（通过启动时的轮询和之后的心跳消息获取） 一致性模型：保证文件命名空间的改变是原子性的 系统交互 尽可能减少master的参与 Leases 为了保证各副本的一致性改变，master通过将chunk lease给其中一个副本使其成为primary，然后primary选择一个改变的顺序，并同步给其他副本 数据流 原子性record append 快照snapshot Master操作 命名空间管理和读写锁 副本放置 最大化可靠性和可用性 最大化网络带宽利用率 chunk的create、re-replicate、rebalance 垃圾回收机制：周期性扫描 过期副本探测：master维护chunk版本号 容错和诊断 高可用性 快速恢复 Chunk复制 Master复制 数据完整性：chunk分为64KB的块，每个块对应32bit的checksum 诊断工具：诊断log记录重要的事件和所有RPC请求/回复 Fault-tolerant virtual machines 基本FT设计 确定性重播实现 写入log文件 挑战： 正确捕获所有输入和对确定执行必要的非确定因素 正确将输入和非确定因素应用到备份VM上 不造成性能损失 FT协议 **输出要求：**若备份VM接替了故障的主VM，则备份VM将继续与主VM完全一致地向外界输出 **输出规则：**在备份VM收到并确认与生成输出的操作相关的log之前，主VM不能向外部世界输出 检测和响应故障 FT的实际实现 启动和重启FT VM 关键是以相同状态启动备份VM的机制：FT VMotion 管理Logging Channel 其他重要实现 FT VM上的操作 Disk IO的实现 Network IO的实现 Course Notes FT VM 复制状态机 复制状态机基于这个事实：我们想复制的大部分的服务或者计算机软件都有一些确定的内部操作，不确定的部分是外部的输入 如果有两台计算机，如果它们从相同的状态开始，并且它们以相同的顺序，在相同的时间，看到了相同的输入，那么它们会一直互为副本，并且一直保持一致 VMware FT论文讨论的都是复制状态机，并且只涉及了单核CPU 在多核的机器中，两个核交互处理指令的行为是不确定的，所以就算Primary和Backup执行相同的指令，在多核的机器中，它们也不一定产生相同的结果 如果我们要创建一个新的副本，我们别无选择，只能使用状态转移，因为新的副本需要有完整状态的拷贝。所以创建一个新的副本代价会很高 非确定性事件 客户端输入： 当我们说输入的时候，我们实际上是指接收到了一个网络数据包 数据包中的数据 提示数据包送达了的中断 对于Primary和Backup，中断最好要在相同的时间，相同的位置触发，否则执行过程就是不一样的，进而会导致它们的状态产生偏差。所以，我们不仅关心网络数据包的内容，还关心中断的时间 怪异指令： 随机数生成器 获取当前时间的指令，在不同时间调用会得到不同的结果 获取计算机的唯一ID 多CPU并发： 当服务运行在多CPU上时，指令在不同的CPU上会交织在一起运行，进而产生的指令顺序是不可预期的 输出控制 Primary和Backup虚机都会生成回复报文，之后通过模拟的网卡送出，但是只有Primary虚机才会真正的将回复送出，而Backup虚机只是将回复简单的丢弃掉 控制输出规则：直到Backup虚机确认收到了相应的Log条目，Primary虚机不允许生成任何输出 Primary会等到Backup已经有了最新的数据，才会将回复返回给客户端。这几乎是所有的复制方案中对于性能产生伤害的地方，在某个时间点，Primary必须要停下来等待Backup Test-and-Set服务 Primary和Backup都在运行，但是它们之间的网络出现了问题，同时它们各自又能够与一些客户端通信，这样会产生Split Brain问题 Test-and-Set服务会在内存中保留一些标志位，当你向它发送一个Test-and-Set请求，它会设置标志位，并且返回旧的值，Primary和Backup都需要获取Test-and-Set标志位，类似锁 为了能够上线，Primary和Backup或许会同时发送一个Test-and-Set请求给Test-and-Set服务。当第一个请求送达时，Test-and-Set服务会说，这个标志位之前是0，现在是1。第二个请求送达时，Test-and-Set服务会说，标志位已经是1了，你不允许成为Primary Raft Majority Vote 在任何时候为了完成任何操作，你必须凑够过半的服务器来批准相应的操作 如果系统有 $2F+1$ 个服务器，那么系统最多可以接受 $F$ 个服务器出现故障，仍然可以正常工作 Raft初探 Raft会以库（Library）的形式存在于服务中：如果有一个基于Raft的多副本服务，那么每个服务的副本将会由两部分组成：应用程序代码和Raft库 日志 Log是Leader用来对操作排序的一种手段，Log是一些按照数字编号的槽位（类似一个数组），槽位的数字表示了Leader选择的顺序 在一个Follower收到了操作，但是还没有执行操作时，需要将这个操作存放在某处，直到收到了Leader发送的新的commit号才执行，对于Raft的Follower来说，Log是用来存放临时操作的地方 Leader需要在它的Log中记录操作，因为这些操作可能需要重传给Follower，即使对那些已经commit的请求，为了能够向丢失了相应操作的副本重传，也需要存储在Leader的Log中 可以帮助重启的服务器恢复状态，每个Raft节点都需要将Log写入到它的磁盘中，这样它故障重启之后，Log还能保留 **注：**从Log上无法直接观察出某一条日志是否已经commit 应用层接口 在Raft集群中，每一个副本上，这两层之间主要有两个接口 第一个接口是key-value层用来转发客户端请求的接口。如果客户端发送一个请求给key-value层，key-value层会将这个请求转发给Raft层，并说：请将这个请求存放在Log中的某处。这个接口实际上是个函数调用，称之为Start函数。这个函数只接收一个参数，就是客户端请求。key-value层说：我接到了这个请求，请把它存在Log中，并在committed之后告诉我 另一个接口是，随着时间的推移，Raft层会通知key-value层：你刚刚在Start函数中传给我的请求已经commit了。这个向上的接口以go channel中的一条消息的形式存在。Raft层会发出这个消息，key-value层要读取这个消息。所以这里有个叫做applyCh的channel，通过它你可以发送ApplyMsg消息 key-value层需要知道从applyCh中读取的消息，对应之前调用的哪个Start函数，所以Start函数需要返回这个请求将会存放在Log中的位置（index）以及当前的任期号（term number）和一些其它我们现在还不太关心的内容 在ApplyMsg中，将会包含请求（command）和对应的Log位置（index）。所有的副本都会收到这个ApplyMsg消息，它们都知道自己应该执行这个请求，弄清楚这个请求的具体含义，并将它应用在本地的状态中。所有的副本节点还会拿到Log的位置信息（index），但是这个位置信息只在Leader有用，因为Leader需要知道ApplyMsg中的请求究竟对应哪个客户端请求（进而响应客户端请求） Leader选举 Raft生命周期中可能会有不同的Leader，它使用任期号（term number）来区分不同的Leader Followers（非Leader副本节点）不需要知道Leader的ID，它们只需要知道当前的任期号 每个Raft节点都有一个选举定时器（Election Timer），如果在这个定时器时间耗尽之前，当前节点没有收到任何当前Leader的消息，这个节点会认为Leader已经下线，并开始一次选举，当前服务器会增加任期号（term number），因为它想成为一个新的Leader 之后，当前服务器会发出请求投票（RequestVote）RPC，这个消息会发给所有的Raft节点 如果有一场新的选举，有可能之前的Leader仍然在运行，并认为自己还是Leader。我们也需要关心，在不知道有新的选举时，旧的Leader会有什么样的行为？ 确保每个任期最多只有一个Leader：为了能够当选，Raft要求一个候选人从过半服务器中获得认可投票。每个Raft节点，只会在一个任期内投出一个认可选票 如果你赢得了选举，你需要立刻发送一条AppendEntries消息给其他所有的服务器。除非是当前任期的Leader，没人可以发出AppendEntries消息 选举定时器 任何一条AppendEntries消息都会重置所有Raft节点的选举定时器：每一次一个节点重置自己的选举定时器时，都需要重新选择一个随机的超时时间 Raft不能完全避免分割选票（Split Vote），但是可以使得这个场景出现的概率大大降低。Raft通过为选举定时器随机的选择超时时间来达到这一点 选举定时器的超时时间需要至少大于Leader的心跳间隔，实际上由于网络可能丢包，这里你或许希望将下限设置为多个心跳间隔 超时时间的上限： 最大超时时间影响了系统能多快从故障中恢复，这里的上限越大，系统的恢复时间也就越长 不同节点的选举定时器的超时时间差必须要足够长，使得第一个开始选举的节点能够完成一轮选举：至少需要大于发送一条RPC所需要的往返（Round-Trip）时间 日志恢复 Leader使用一种备份机制来探测Followers的Log中，第一个与Leader的Log相同的位置 在获得位置之后，Leader会给Follower发送从这个位置开始的，剩余的全部Log 选举约束 为了保证系统的正确性，并非任意节点都可以成为Leader 在处理别节点发来的RequestVote RPC时，需要做一些检查才能投出赞成票： 候选人最后一条Log条目的任期号大于本地最后一条Log条目的任期号 或者，候选人最后一条Log条目的任期号等于本地最后一条Log条目的任期号，且候选人的Log记录长度大于等于本地Log记录的长度 快速恢复 让Follower返回足够的信息给Leader，这样Leader可以以任期（Term）为单位来回退，而不用每次只回退一条Log条目 XTerm：Follower中与Leader冲突的Log对应的任期号。Leader会在prevLogTerm中带上本地Log记录中，前一条Log的任期号。如果Follower在对应位置的任期号不匹配，它会拒绝Leader的AppendEntries消息，并将自己的任期号放在XTerm中。如果Follower在对应位置没有Log，那么这里会返回 -1 XIndex：Follower中，对应任期号为XTerm的第一条Log条目的槽位号 XLen：如果Follower在对应位置没有Log，那么XTerm会返回-1，XLen表示空白的Log槽位数 case1： 12S1: 4 5 5S2: 4 6 6 6 Follower（S1）会返回XTerm=5，XIndex=2。Leader（S2）发现自己没有任期5的日志，它会将自己本地记录的，S1的nextIndex设置到XIndex，也就是S1中，任期5的第一条Log对应的槽位号。所以，如果Leader完全没有XTerm的任何Log，那么它应该回退到XIndex对应的位置（这样，Leader发出的下一条AppendEntries就可以一次覆盖S1中所有XTerm对应的Log） case2： 12S1: 4 4 4S2: 4 6 6 6 Follower（S1）会返回XTerm=4，XIndex=1。Leader（S2）发现自己其实有任期4的日志，它会将自己本地记录的S1的nextIndex设置到本地在XTerm位置的Log条目后面，也就是槽位2。下一次Leader发出下一条AppendEntries时，就可以一次覆盖S1中槽位2和槽位3对应的Log case3： 12S1: 4S2: 4 6 6 6 Follower（S1）会返回XTerm=-1，XLen=2。这表示S1中日志太短了，以至于在冲突的位置没有Log条目，Leader应该回退到Follower最后一条Log条目的下一条，也就是槽位2，并从这开始发送AppendEntries消息。槽位2可以从XLen中的数值计算得到 持久化 Log需要被持久化存储的原因是，这是唯一记录了应用程序状态的地方 currentTerm和votedFor都是用来确保每个任期只有最多一个Leader 如果一个服务器收到了一个RequestVote请求，并且为服务器1投票了，之后它故障。如果它没有存储它为哪个服务器投过票，当它故障重启之后，收到了来自服务器2的同一个任期的另一个RequestVote请求，那么它还是会投票给服务器2，因为它发现自己的votedFor是空的 存储currentTerm是为了防止任期回退 安全的做法是每次你添加一个Log条目，更新currentTerm或者更新votedFor。可以通过一些批量操作来提升性能。例如，只在服务器回复一个RPC或者发送一个RPC时，服务器才进行持久化存储 如果Leader收到了一个客户端请求，在发送AppendEntries RPC给Followers之前，必须要先持久化存储在本地；在回复AppendEntries 消息之前，Followers也需要持久化存储这些Log条目到本地 服务器重启时，commitIndex、lastApplied、nextIndex、matchIndex可以被丢弃，因为Leader可以通过检查自己的Log和发送给Followers的AppendEntries的结果，来发现哪些内容已经commit了 日志快照 快照背后的思想是，要求应用程序将其状态的拷贝作为一种特殊的Log条目存储下来 对于大多数的应用程序来说，应用程序的状态远小于Log的大小（如KV数据库） 如果Raft要求应用程序做一个快照，Raft会从Log中选取一个与快照对应的点，然后要求应用程序在那个点的位置做一个快照，然后我们可以安全的将那个点之前的Log丢弃；我们还需要为快照标注Log的槽位号 只要Raft持久化存储了快照，快照对应的Log槽位号，以及Log槽位号之后的所有Log，那么快照对应槽位号之前的这部分Log可以被丢弃 重启的时候，必须让Raft有方法知道磁盘中最近的快照和Log的组合，并将快照传递给应用程序。所以应用程序不仅需要有能力能生成一个快照，它还需要能够吸纳一个之前创建的快照，并通过它稳定的重建自己的内存 如果Leader发现有任何一个Follower的Log落后于Leader要做快照的点，Leader可以丢弃Follower需要的Log，但需要某种机制让AppendEntries能处理某些Follower Log的结尾到Leader Log开始之间丢失的这一段Log，即InstallSnapshot RPC 当Leader回退到了自己Log的起点，将不能再回退。这时，Leader会将自己的快照发给Follower，之后立即通过AppendEntries将后面的Log发给Follower 线性一致 一个服务是线性一致的，那么它表现的就像只有一个服务器，并且服务器没有故障，这个服务器每次执行一个客户端请求，并且没什么奇怪的事情发生 如果执行历史整体可以按照一个顺序排列，且排列顺序与客户端请求的实际时间相符合，那么它是线性一致的 一个线性一致的执行历史中的操作是非并发的，也就是时间上不重合的客户端请求与实际执行时间匹配 确定执行顺序： 如果一个操作在另一个操作开始前就结束了，那么这个操作必须在执行历史中出现在另一个操作前面 执行历史中，读操作，必须在相应的key的写操作之后 对于读请求，线性一致系统只能返回最近一次完成的写请求写入的值 Client交互 源自Raft作者博士论文Ch6 寻找Leader Client发送请求到随机节点，节点有两种处理方式： 节点可能通过Leader的AppendEntries RPC知道了LeaderId，从而可以将此信息传递给client； 节点作为代理，将请求转发给Leader。 Raft必须防止过期的Leadership信息 Leader：某个节点处于Leader的状态，但不是当前整个集群的Leader，若client将请求发送给此节点，将永远得不到回复，因为该节点不能得到大部分节点的同意。解决方案： 若Leader没有收到集群中大部分节点的心跳回复，则会自动退位，使得client能请求其他节点 Follower：当Follower开启一轮选举或任期改变时，不能回复client的请求，防止几个节点相互redirect Client：若client与节点失去连接，需要随机请求另一个节点 实现线性一致 Raft中，复制状态机可能会apply一条命令多次，为了实现线性一致，不能允许重复执行 节点保存client操作的结果，当client重发相同请求时，直接回复结果而不执行请求 给与每个client一个唯一标识，client为每条命令分配一个唯一序号 每个节点的状态机为每个client维护一个session，来跟踪client的最新命令序号以及响应的回复 当节点收到同一个client相同序号的命令时，直接回复session中的结果 在并发环境下，节点维护的session应该包含多个序号-回复pair，client在每个请求中包含其还未收到回复的最小的序号，节点根据此来丢弃更小的序号-回复pair 由于存储空间有限，在client session越来越多之后，节点必须丢弃一些client session 所有节点必须对丢弃的session达成共识，因此session丢弃必须是确定性的，可选方案： 设置session数量上限，根据LRU (Least Recently Used) 策略丢弃session 基于时间共识来丢弃session 处理在session过期后仍不断发送请求的client，可选方案： 为该client重新分配一个新的session，但这有命令重复执行的风险（在该client上一个session中可能已经执行过该命令） 节点区分新client和session过期的client：新client发送RegisterClient RPC来请求一个session，若节点收到的命令请求中包含过期的session，则返回error 更高效地执行只读请求 只读请求可以直接进行而不记录log (防止对磁盘的同步写) ，但是需要一些额外处理，否则可能回复过时数据 若Leader还没将自己任期的log条目标记为committed，则等待标记完成。由于Leader刚上任时不知道自己的哪些log已经commit了，所以他需要在自己任期开始时往自己的log中添加一条空的 no-op 条目，当该条目commit之后，Leader的 commitIndex 至少和其他节点一样大； Leader保存一个本地变量 readIndex 来记录当前的 commitIndex ，这将被用作是请求操作的状态的最低版本 Leader需要确保自己没有被更新的Leader取代，为此他发起一轮新的心跳消息，并等待大部分节点的确认，若得到大部分的确认，则Leader知道此时的 readIndex 是所有节点中最大的 commitIndex Leader等待其状态机执行到至少 readIndex ，至此所有操作都是线性一致的 最后，Leader直接查询状态机来获得client只读请求的结果，而不需要记录log 进一步优化：Leader可以积累一定数量的只读请求，然后通过一轮心跳消息来同时执行 进进一步优化：Follower也可以处理只读请求，首先向Leader发送请求来获取 readIndex ，然后Leader执行1-3步并回复Follower，最后Follower执行4-5步 Zookeeper 提高读性能 加入的服务器越多，读性能越高 Zookeeper并不要求返回最新的写入数据，即放弃线性一致性 从而client可以从Follower读取数据 一致保证 写请求线性一致 client请求会根据指定顺序执行，即FIFO client顺序 写请求一定会满足，因为写请求必须满足线性一致 读请求会发送到非Leader的副本，但是需要满足副本根据client读的顺序执行，即使是从不同的副本读也要满足顺序 每个Log条目都会被Leader打上zxid的标签，这些标签就是Log对应的条目号 任何时候一个副本回复一个客户端的读请求，首先这个读请求是在Log的某个特定点执行的，其次回复里面会带上zxid，对应的就是Log中执行点的前一条Log条目号 客户端会记住最高的zxid，当客户端发出一个请求到一个相同或者不同的副本时，它会在它的请求中带上这个最高的zxid 其他的副本就知道，应该至少在Log中这个点或者之后执行这个读请求 写请求和读请求并发时，读请求需要等到Leader执行完写操作后才能执行 如果一个客户端写了一份数据，例如向Leader发送了一个写请求，之后立即读同一份数据，并将读请求发送给了某一个副本，那么客户端需要看到自己刚刚写入的值 同步操作 Zookeeper有一个操作类型是sync，它本质上就是一个写请求 因为读请求必须至少要看到同一个客户端前一个写请求对应的状态 所以，如果我发送了一个sync请求之后，又发送了一个读请求 Zookeeper必须要向我返回至少是我发送的sync请求对应的状态 这是一个代价很高的操作，因为我们现在将一个廉价的读操作转换成了一个耗费Leader时间的sync操作 Ready文件 znode Zookeeper以文件目录的形式管理数据，所以每一个数据点也可以认为是一个file 假设有另外一个分布式系统，这个分布式有一个Master节点，而Master节点在Zookeeper中维护了一个配置，这个配置对应了一些file（也就是znode） Master节点对配置的更新需要是原子性的： 假设Master做了一系列写请求来更新配置，那么我们的分布式系统中的Master会以这种顺序执行写请求 假设有一些Ready file，如果Ready file存在，那么允许读这个配置；如果Ready file不存在，那么说明配置正在更新过程中，我们不应该读取配置 如果Master要更新配置，那么第一件事情是删除Ready file 之后它会更新各个保存了配置的Zookeeper file（也就是znode） 当所有组成配置的file都更新完成之后，Master会再次创建Ready file Worker节点对配置的读取 如果客户端看见了Ready file，那么副本接下来执行的读请求，会在Ready file重新创建的位置之后执行 Zookeeper可以保证这些读请求看到之前对于配置的全部更新 防止客户端读到不同版本的配置文件（Master更新配置，删除Ready file，客户端同时读到了一个Worker没来得及删除的Ready file，并读取了部分znode，然后等Master更新完，Worker重新创建Ready file后，客户端再读完剩下的znode）： 客户端会发送exists请求来查询Ready file是否存在，并建立一个针对这个Ready file的watch 如果Ready file有任何变更，例如被删除了，或者它之前不存在然后被创建了，副本会给客户端发送一个通知 当Ready file有变化时，副本会确保，合适的时机返回对于Ready file变化的通知 如果客户端向某个副本watch了某个Ready file，之后又发送了一些读请求，当这个副本执行了一些会触发watch通知的请求，那么Zookeeper可以确保副本将watch对应的通知，先发给客户端，再处理触发watch通知请求（也就是删除Ready file的请求），在Log中位置之后才执行的读请求 换句话说，客户端在完成读所有的配置之前，如果对配置有了新的更改，Zookeeper可以保证客户端在收到删除Ready file的通知之前，看到的都是配置更新前的数据（即，客户端读取配置读了一半，如果收到了Ready file删除的通知，就可以放弃这次读，再重试读） Zookeeper作用 Zookeeper的数据都存在内存，因此只适合于存储配置信息 它可以是一个VMware FT所需要的Test-and-Set服务的实现 用它来发布其他服务器使用的配置信息。例如，向某些Worker节点发布当前Master的IP地址 选举Master，当一个旧的Master节点故障时，我们需要让所有的节点都认可同一个新的Master节点 用Zookeeper来保存Master的状态，新的Master从Zookeeper读取状态，从而保证其状态是up-to-date的 类似MapReduce的系统： Worker节点可以通过在Zookeeper中创建小文件来注册自己 Master节点通过向Zookeeper写入具体的工作，之后Worker节点从Zookeeper中一个一个的取出工作、执行，完成之后再删除工作 Zookeeper API Zookeeper的API某种程度上来说像是一个文件系统：它有一个层级化的目录结构，有一个根目录（root），之后每个应用程序有自己的子目录。比如说应用程序1将自己的文件保存在APP1目录下，应用程序2将自己的文件保存在APP2目录下，这些目录又可以包含文件和其他的目录 Zookeeper被设计成要被许多可能完全不相关的服务共享使用，所以我们需要一个命名系统来区分不同服务的信息，这样这些信息才不会弄混 这里的文件和目录都被称为znodes，Zookeeper中包含了3种类型的znode Regular znodes：这种znode一旦创建，就永久存在，除非你删除了它 Ephemeral znodes：如果Zookeeper认为创建它的客户端挂了，它会删除这种类型的znodes Ephemeral znodes与客户端会话绑定在一起，所以客户端需要时不时的发送心跳给Zookeeper，告诉Zookeeper自己还活着，这样Zookeeper才不会删除客户端对应的Ephemeral znode Sequential znodes：当你想要以特定的名字创建一个文件，Zookeeper实际上创建的文件名是你指定的文件名再加上一个数字。当有多个客户端同时创建Sequential文件时，Zookeeper会确保这里的数字不重合，同时也会确保这里的数字总是递增的 Zookeeper以RPC的方式暴露以下API： CREATE(PATH，DATA，FLAG)：入参分别是文件的全路径名PATH，数据DATA，和表明znode类型的FLAG 如果我向Zookeeper请求创建一个文件，如果我得到了yes的返回，那么说明这个文件之前不存在，我是第一个创建这个文件的客户端 如果我得到了no或者一个错误的返回，那么说明这个文件之前已经存在了 DELETE(PATH，VERSION)：入参分别是文件的全路径名PATH，和版本号VERSION 每一个znode都有一个表示当前版本号的version，当znode有更新时，version也会随之增加 对于delete和一些其他的update操作，可以增加一个version参数，表明当且仅当znode的当前版本号与传入的version相同，才执行操作 EXIST(PATH，WATCH)：入参分别是文件的全路径名PATH，和一个有趣的额外参数WATCH 通过指定watch，你可以监听对应文件的变化，Zookeeper可以确保如果文件有任何变更，例如创建，删除，修改，都会通知到客户端 判断文件是否存在和watch文件的变化，在Zookeeper内是原子操作 所以，当调用exist并传入watch为true时，不可能在Zookeeper实际判断文件是否存在和建立watch通道之间，插入任何的创建文件的操作，这对于正确性来说非常重要 GETDATA(PATH，WATCH)：入参分别是文件的全路径名PATH，和WATCH标志位 这里的watch监听的是文件的内容的变化 SETDATA(PATH，DATA，VERSION)：入参分别是文件的全路径名PATH，数据DATA，和版本号VERSION Zookeeper当且仅当文件的版本号与传入的version一致时，才会更新文件 LIST(PATH)：入参是目录的路径名，返回的是路径下的所有文件 使用Zookeeper实现计数器 假设我们在Zookeeper中有一个文件，我们想要在那个文件存储一个统计数字，例如，统计客户端的请求次数 需要保证获取计数值和增加计数值的操作的原子性 1234WHILE TRUE: X, V &#x3D; GETDATA(&quot;F&quot;) IF SETDATA(&quot;f&quot;, X + 1, V): BREAK 第3行的意思是，只有当实际真实的版本号等于V的时候，才更新数据 使用Zookeeper实现非扩展锁 获得锁： 1234WHILE TRUE: IF CREATE(&quot;f&quot;, data, ephemeral&#x3D;TRUE): RETURN IF EXIST(&quot;f&quot;, watch&#x3D;TRUE): WAIT 在代码的第2行，是尝试创建锁文件，如果锁文件创建成功了，表明我们获得了锁，直接RETURN 如果锁文件创建失败了，那表明锁已经被别人占住了，所以我们需要等待锁释放。最终锁会以删除文件的形式释放，所以我们这里通过EXIST函数加上watch=TRUE，来监测文件的删除 在代码的第4行，等待文件删除对应的watch通知。收到通知之后，再回到循环的最开始，从代码的第2行开始执行 如果有1000个客户端同时要获得锁文件，为1000个客户端分发锁所需要的时间是 $O(n^2)$ （羊群效应） 因为每一次锁文件的释放，所有剩下的客户端都会收到WATCH的通知，并且回到循环的开始，再次尝试创建锁文件。所以CREATE对应的RPC总数与1000的平方成正比 使用Zookeeper实现可扩展锁 避免羊群效应，使得，即使有1000个客户端在等待锁释放，当锁释放时，另一个客户端获得锁的复杂度是 $O(1)$ 而不是 $O(n)$ 123456CREATE(&quot;f&quot;, data, sequential&#x3D;TRUE, ephemeral&#x3D;TRUE)WHILE TRUE: LIST(&quot;f*&quot;) IF NO LOWER #FILE: RETURN IF EXIST(NEXT LOWER #FILE, watch&#x3D;TRUE): WAIT 第1行调用CREATE，并指定sequential=TRUE，我们创建了一个Sequential文件，如果这是以“f”开头的第27个Sequential文件，这里实际会创建类似以“f27”为名字的文件 通过CREATE获得一个全局唯一序列号 Zookeeper生成的序号必然是递增的 第3行，通过LIST列出了所有以“f”开头的文件，也就是所有的Sequential文件 第4行，如果现存的Sequential文件的序列号都不小于我们在代码第1行得到的序列号，那么表明我们在并发竞争中赢了，我们获得了锁 当存在更低序列号的Sequential文件时，我们要做的是等待拥有更低序列号的客户端释放锁 在这个方案中，释放锁的方式是删除文件。所以接下来，我们需要做的是等待序列号更低的锁文件删除，之后我们才能获得锁 第5行，我们调用EXIST，并设置WATCH，等待比自己序列号更小的下一个锁文件删除 如果等到了，回到LIST开始执行，之所以要重新LIST，是因为比自己低的序号的客户端可能是释放锁才删除文件，也可能是挂了所以删除文件，例如，序号27等待26号释放锁，但如果26号客户端挂了，则需要等待25号释放锁，从而必须重新LIST Zookeeper中的锁不是原子性的，适合用于Soft Lock的场景，如运行MapReduce Job时，你可以用这样的锁来确保一个Task同时只被一个Work节点执行。例如，对于Task 37，执行它的Worker需要先获得相应的锁，再执行Task，并将Task标记成执行完成，之后释放锁。MapReduce本身可以容忍Worker节点崩溃，所以如果一个Worker节点获得了锁，然后执行了一半崩溃了，之后锁会被释放，下一个获得锁的Worker会发现任务并没有完成，并重新执行任务 CRAQ CRAQ是对于一个叫链复制（Chain Replication）的旧方案的改进，它在任意副本上执行读请求的前提下，还可以保证线性一致性 链复制 Chain Replication是这样一种方案，你有多个副本，你想确保它们都看到相同顺序的写请求（这样副本的状态才能保持一致） 在Chain Replication中，有一些服务器按照链排列，第一个服务器称为HEAD，最后一个被称为TAIL 当客户端想要发送一个写请求，写请求总是发送给HEAD HEAD根据写请求更新本地数据，我们假设现在是一个支持PUT/GET的key-value数据库，所有的服务器本地数据都从A开始 当HEAD收到了写请求，将本地数据更新成了B，之后会再将写请求通过链向下一个服务器传递 下一个服务器执行完写请求之后，再将写请求向下一个服务器传递，以此类推，所有的服务器都可以看到写请求 当写请求到达TAIL时，TAIL将回复发送给客户端，表明写请求已经完成了 对于读请求，如果一个客户端想要读数据，它将读请求发往TAIL TAIL直接根据自己的当前状态来回复读请求 故障恢复 如果HEAD出现故障，作为最接近的服务器，下一个节点可以接手成为新的HEAD，并不需要做任何其他的操作。对于还在处理中的请求，可以分为两种情况： 对于任何已经发送到了第二个节点的写请求，不会因为HEAD故障而停止转发，它会持续转发直到commit 如果HEAD在转发这个写请求之前就故障了，那么这个写请求必然没有commit，写请求必然没能送到TAIL，对于这些请求不必做任何事情。或许客户端会重发这个写请求，但是这并不是我们需要担心的问题 如果TAIL出现故障，TAIL的前一个节点可以接手成为新的TAIL。所有TAIL知道的信息，TAIL的前一个节点必然都知道 中间节点出现故障会稍微复杂一点，但是基本上来说，需要做的就是将故障节点从链中移除。或许有一些写请求被故障节点接收了，但是还没有被故障节点之后的节点接收，所以，当我们将其从链中移除时，故障节点的前一个节点或许需要重发最近的一些写请求给它的新后继节点 配置管理器 Chain Replication并不能抵御网络分区，也不能抵御脑裂。因此需要一个外部的权威（External Authority）来决定那些节点是活的，并确保所有参与者都认可由哪些节点组成一条链，这个外部的权威通常称为Configuration Manager Configuration Manager的工作就是监测节点存活性，一旦Configuration Manager认为一个节点挂了，它会生成并送出一个新的配置，在这个新的配置中，描述了链的新的定义，包含了链中所有的节点，HEAD和TAIL，所有节点都会遵从新的配置内容 Configuration Manager通常会基于Raft或者Paxos，在CRAQ的场景下，它会基于Zookeeper 对于一个数据中心，首先有一个基于Raft或者Paxos的Configuration Manager，它是容错的，也不会受脑裂的影响 之后，通过一系列的配置更新通知，Configuration Manager将数据中心内的服务器分成多个链 Configuration Manager通告给所有参与者整个链的信息，所以所有的客户端都知道HEAD在哪，TAIL在哪，所有的服务器也知道自己在链中的前一个节点和后一个节点是什么 Aurora 故障可恢复事务 通常来说，事务是通过对涉及到的每一份数据加锁来实现： 对于一个简单的数据库模型，数据库运行在单个服务器上，并且使用本地硬盘 在硬盘上存储了数据的记录，有一些data page用来存放数据库的数据，其中一个存放了X的记录，另一个存放了Y的记录。每一个data page通常会存储大量的记录，而X和Y的记录是page中的一些bit位 在硬盘中，除了有数据之外，还有一个预写式日志（Write-Ahead Log，简称为WAL） 在服务器内部，有数据库软件，通常数据库会对最近从磁盘读取的page有缓存 当你在执行一个事务内的各个操作时，例如执行 X=X+10 的操作时，数据库会从硬盘中读取持有X的记录，给数据加10 但是在事务提交之前，数据的修改还只在本地的缓存中，并没有写入到硬盘 为了让数据库在故障恢复之后，还能够提供同样的数据，在允许数据库软件修改硬盘中真实的data page之前，数据库软件需要先在WAL中添加Log条目来描述事务 假设，X的初始值是500，Y的初始值是750 在提交并写入硬盘的data page之前，数据库通常需要写入至少3条Log记录： 第一条表明，作为事务的一部分，我要修改X，它的旧数据是500，我要将它改成510 第二条表明，我要修改Y，它的旧数据是750，我要将它改成740 第三条记录是一个Commit日志，表明事务的结束 记录旧数据是为了对于一个非常长的事务，在事务结束之前，数据库可以提前将更新了的page写入硬盘；之后如果在事务提交之前故障了，恢复的软件可以发现，事务并没有完成，然后根据WAL中的日志撤回之前的操作 如果数据库成功的将事务对应的操作和commit日志写入到磁盘中，数据库可以回复给客户端说，事务已经提交了，接下来有两种情况： 如果数据库没有崩溃，那么在它的cache中，X，Y对应的数值分别是510和740。最终数据库会将cache中的数值写入到磁盘对应的位置。所以数据库写磁盘是一个lazy操作，它会对更新进行累积，每一次写磁盘可能包含了很多个更新操作 如果数据库在将cache中的数值写入到磁盘之前就崩溃了，这样磁盘中的page仍然是旧的数值。当数据库重启时，恢复软件会扫描WAL日志，发现对应事务的Log，并发现事务的commit记录，那么恢复软件会将新的数值写入到磁盘中。这被称为redo，它会重新执行事务中的写操作 Aurora 初探 在替代EBS的位置，有6个数据的副本，位于3个AZ，每个AZ有2个副本。所以现在有了超级容错性，并且每个写请求都需要以某种方式发送给这6个副本，这里通过网络传递的数据只有Log条目 这里的存储系统不再是通用（General-Purpose）存储，这是一个可以理解MySQL Log条目的存储系统 Aurora并不需要6个副本都确认了写入才能继续执行操作，只要Quorum形成了，也就是任意4个副本确认写入了，数据库就可以继续执行操作 Aurora存储服务器的容错目标 对于写操作，当只有一个AZ彻底挂了之后，写操作不受影响 对于读操作，当一个AZ和一个其他AZ的服务器挂了之后，读操作不受影响 AZ的下线时间可能很长，比如说数据中心被水淹了。人们可能需要几天甚至几周的时间来修复洪水造成的故障，在AZ下线的这段时间，我们只能依赖其他AZ的服务器。如果其他AZ中的一个服务器挂了，我们不想让整个系统都瘫痪。所以当一个AZ彻底下线了之后，对于读操作，Aurora还能容忍一个额外服务器的故障，并且仍然可以返回正确的数据 Aurora期望能够容忍暂时的慢副本 如果一个服务器看起来永久故障了，我们期望能够尽可能快的根据剩下的副本，生成一个新的副本 Quorum 复制机制 通常来说，Quorum系统就是简单的读写系统，支持Put/Get操作 假设有N个副本。为了能够执行写请求，必须要确保写操作被W个副本确认，W小于N。所以你需要将写请求发送到这W个副本。如果要执行读请求，那么至少需要从R个副本得到所读取的信息。这里的W对应的数字称为Write Quorum，R对应的数字称为Read Quorum。Quorum系统要求，任意你要发送写请求的W个服务器，必须与任意接收读请求的R个服务器有重叠。这意味着，R加上W必须大于N（ 至少满足R + W = N + 1 ），这样任意W个服务器至少与任意R个服务器有一个重合 可以轻易的剔除暂时故障、失联或者慢的服务器 可以调整读写的性能 Aurora读写存储服务器 Aurora中的写请求并不是像一个经典的Quorum系统一样直接更新数据。对于Aurora来说，它的写请求从来不会覆盖任何数据，它的写请求只会在当前Log中追加条目（Append Entries）。所以，Aurora使用Quorum只是在数据库执行事务并发出新的Log记录时，确保Log记录至少出现在4个存储服务器上，之后才能提交事务 但是存储服务器内存最终存储的还是数据库服务器磁盘中的page。在存储服务器的内存中，会有自身磁盘中page的cache，例如page1（P1），page2（P2），这些page其实就是数据库服务器对应磁盘的page 当一个新的写请求到达时，这个写请求只是一个Log条目，Log条目中的内容需要应用到相关的page中。但是我们不必立即执行这个更新，可以等到数据库服务器或者恢复软件想要查看那个page时才执行 对于每一个page，如果它最近被一个Log条目修改过，那么存储服务器会在内存中缓存一个旧版本的page和一系列来自于数据库服务器有关修改这个page的Log条目，所以对于一个新的Log条目，它会立即被追加到影响到的page的Log列表中（这里的Log列表从上次page更新过之后开始） 如果之后数据库服务器将自身缓存的page删除了，过了一会又需要为一个新的事务读取这个page，它会发出一个读请求到存储服务器，并要求存储服务器返回当前最新的page数据。这个时候，存储服务器才会将Log条目中的新数据更新到page，并将page写入到自己的磁盘中，之后再将更新了的page返回给数据库服务器，同时存储服务器在自身cache中会删除page对应的Log列表，并更新cache中的page 数据分片 为了能支持超过10TB数据的大型数据库。Amazon的做法是将数据库的数据，分割存储到多组存储服务器上，每一组都是6个副本，称为一个PG（Protection Group），分割出来的每一份数据是10GB 当Aurora需要发送一个Log条目时，它会查看Log所修改的数据，并找到存储了这个数据的PG，并把Log条目只发送给这个PG对应的6个存储服务器。所以，每个PG只存储了部分data page和所有与这些data page关联的Log条目 如果其中一个存储服务器挂了，我们期望尽可能快的用一个新的副本替代它。而一个存储服务器可能会存储10TB数据，也就是数百个PG，若它挂了，需要恢复整个服务器的数据，通过网络传输10TB消耗的时间太长了，因此需要一个更高效的恢复方案 Aurora实际使用的策略是，对于一个特定的存储服务器，它存储了许多Protection Group对应的10GB的数据块。对于Protection Group A，它的其他副本是5个服务器 或许这个存储服务器还为Protection Group B保存了数据，但是B的其他副本存在于与A没有交集的其他5个服务器中 这种模式下，如果一个存储服务器挂了，假设上面有100个数据块，现在的替换策略是：找到100个不同的存储服务器，其中的每一个会被分配一个数据块，也就是说这100个存储服务器，每一个都会加入到一个新的Protection Group中（相当于每一个存储服务器只需要负责恢复10GB的数据，并且可以并行恢复） Frangipani Frangipani 挑战 假设工作站W1创建了一个文件 /A。最初，这个文件只会在本地缓存中创建。首先，Frangipani需要从Petal获得 / 目录下的内容，之后当创建文件时，工作站只是修改缓存的拷贝，并不会将修改立即返回给Petal。直接的问题是：假设工作站W2上的用户想要获取 / 目录下的文件列表，我们希望这个用户可以看到新创建的文件。这称为缓存一致性问题（Cache Coherence） 因为所有的文件和目录都是共享的，非常容易会有两个工作站在同一个时间修改同一个目录，我们期望看到的是两个工作站的修改都可以生效，且互不干扰。这称为原子性（Atomicity） 假设我的工作站修改了大量的内容，由于Write-Back缓存，可能会在本地的缓存中堆积了大量的修改。如果我的工作站崩溃了，但是这时这些修改只有部分同步到了Petal，还有部分仍然只存在于本地。同时，其他的工作站还在使用文件系统。那么，我的工作站在执行操作的过程中的崩溃，最好不要损坏其他人同样会使用的文件系统。因此我们需要的是单个服务器的故障恢复 锁服务器 Frangipani的缓存一致性核心是由锁保证的，用锁来帮助工作站确定当它们缓存了数据时，它们缓存的是最新的数据 在锁服务器里面，有一个表单，就叫做locks。我们假设每一个锁以文件名来命名，所以对于每一个文件，我们都有一个锁，而这个锁，可能会被某个工作站所持有 在每个工作站，会记录跟踪它所持有的锁，和锁对应的文件内容。所以在每个工作站中，Frangipani模块也会有一个lock表单，表单会记录文件名、对应的锁的状态和文件的缓存内容 当一个Frangipani服务器决定要读取文件，首先它会向一个锁服务器请求文件对应的锁，之后才会向Petal服务器请求文件或者目录的数据 收到数据之后，工作站会记住，本地有一个文件X的拷贝，对应的锁的状态，和相应的文件内容 在工作站完成了一些操作之后，比如创建文件，或者读取文件，它会随着相应的系统调用（例如rename，write，create，read）释放锁（在做操作期间，锁的状态是Busy） 但是从锁服务器的角度来看，工作站仍然持有锁。工作站内部会标明，这是锁时Idle状态，它不再使用这个锁 Frangipani对锁应用了很多的规则： 工作站不允许持有缓存的数据，除非同时也持有了与数据相关的锁 如果你在释放锁之前，修改了锁保护的数据，那你必须将修改了的数据写回到Petal，只有在Petal确认收到了数据，你才可以释放锁 最后才能从工作站的lock表单中删除关文件的锁的记录和缓存的数据 缓存一致性 工作站和锁服务器之间的缓存一致协议协议包含了4种不同的消息： Request消息：从工作站发给锁服务器。Request消息会说：hey锁服务器，我想获取这个锁 Grant消息：一旦工作站Request的锁被释放了，锁服务器会回复一个Grant消息给工作站 Revoke消息：通常来说，当工作站使用完锁之后，不会向锁服务器释放锁。如果锁服务器收到了一个加锁的请求，它查看自己的lock表单可以发现，这个锁现在正被工作站WS1所持有，锁服务器会发送一个Revoke消息给当前持有锁的工作站WS1，并说：现在别人要使用这个文件，请释放锁吧 Release消息：当一个工作站收到了一个Revoke请求，如果锁时在Idle状态，并且缓存的数据脏了，工作站会首先将修改过的缓存写回到Petal存储服务器中，然后发送一条Release消息来释放锁 如果工作站收到Revoke消息时，它还在使用锁，直到它完成了相应的文件系统操作，它都不会放弃锁；完成了操作之后，工作站中的锁的状态才会从Busy变成Idle，之后工作站才能注意到Revoke请求，在向Petal写完数据之后最终释放锁 一个主要的优化是，Frangipani有共享的读锁（Shared Read Lock）和排他的写锁（Exclusive Write Lock） 原子性 为了实现原子性，Frangipani在内部实现了一个数据库风格的事务系统，并且是以锁为核心。同时，这是一个分布式事务系统 Frangipani是这样实现分布式事务的：在我完全完成操作之前，Frangipani确保其他的工作站看不到我的修改 首先我的工作站需要获取所有我需要读写数据的锁，在完成操作之前，我的工作站不会释放任何一个锁 将所有修改了的数据写回到Petal之后，我的工作站才会释放所有的锁 Frangipani Log 需要能正确应对这种场景：一个工作站持有锁，并且在一个复杂操作的过程中崩溃了。比如说一个工作站在创建文件，或者删除文件时，它首先获取了大量了锁，然后会更新大量的数据，在其向Petal回写数据的过程中，一部分数据写入到了Petal，还有一部分还没写入，这时工作站崩溃了，并且锁也没有释放 Frangipani与其他的系统一样，需要通过预写式日志（Write-Ahead Log，WAL）实现故障可恢复的事务（Crash Recoverable Transaction） 当一个工作站需要完成涉及到多个数据的复杂操作时，在工作站向Petal写入任何数据之前，工作站会在Petal中自己的Log列表中追加一个Log条目，这个Log条目会描述整个的需要完成的操作 只有当这个描述了完整操作的Log条目安全的存在于Petal之后，工作站才会开始向Petal发送数据 Frangipani在实现WAL时，有一些不同的地方： 在大部分的事务系统中，只有一个Log，系统中的所有事务都存在于这个Log中；但是Frangipani不是这么保存Log的，它对于每个工作站都保存了一份独立的Log 几乎在所有使用了Log的系统中，Log与运行了事务的计算机紧紧关联在一起，并且几乎总是保存在本地磁盘中；但是Frangipani工作站的Log存储在Petal，而不是本地磁盘中，这样的话如果工作站崩溃了，它的Log可以被其他工作站从Petal中获取到 我们需要大概知道Log条目的内容是什么： 每个Log条目都包含了Log序列号，这个序列号是个自增的数字。因为如果工作站崩溃了，Frangipani需要根据序列号探测工作站Log的结尾 每个Log条目还有一个用来描述一个特定操作中所涉及到的所有数据修改的数组 数组中的每一个元素会有一个Petal中的块号（Block Number），一个版本号和写入的数据 Log只包含了对于元数据的修改，不会包含需要写入文件的数据，所以它并不包含用户的数据 所以写入Petal的完整过程是：当工作站从锁服务器收到了一个Revoke消息，要自己释放某个锁，它需要执行： 首先，工作站需要将内存中还没有写入到Petal的Log条目写入到Petal中 之后，再将被Revoke的Lock所保护的数据写入到Petal 最后，向锁服务器发送Release消息 故障恢复 这里的场景是，当工作站需要重命名文件或者创建一个文件时，首先它会获得所有需要修改数据的锁，之后修改自身的缓存来体现改动。但是后来工作站在向Petal写入数据的过程中故障了。发生故障时可能会有这几种场景： 要么工作站正在向Petal写入Log，所以这个时候工作站必然还没有向Petal写入任何文件或者目录 要么工作站正在向Petal写入修改的文件，所以这个时候工作站必然已经写入了完整的Log 当持有锁的工作站崩溃了之后，发生的第一件事情是锁服务器向工作站发送一个Revoke消息，但是锁服务器得不到任何响应，之后才会触发故障恢复。Frangipani出于一些原因对锁使用了租约，当租约到期了，锁服务器会认定工作站已经崩溃了，之后它会初始化恢复过程 锁服务器会通知另一个还活着的工作站说：看，工作站1看起来崩溃了，请读取它的Log，重新执行它最近的操作并确保这些操作完成了，在你完成之后通知我，在收到这里的通知之后，锁服务器才会释放锁 Frangipani对每一份存储在Petal文件系统数据增加一个版本号，同时将版本号与Log中描述的更新关联起来。当工作站需要修改Petal中的元数据时，它会向从Petal中读取元数据，并查看当前的版本号，之后在创建Log条目来描述更新时，它会在Log条目中对应的版本号填入元数据已有的版本号加1 之后，如果工作站执行到了写数据到Petal的步骤，它也会将新的增加了的版本号写回到Petal。所以，如果一个工作站没有故障，并且成功的将数据写回到了Petal。这样元数据的版本号会大于等于Log条目中的版本号。如果有其他的工作站之后修改了同一份元数据，版本号会更高 分布式事务 分布式事务主要有两部分组成。第一个是并发控制（Concurrency Control）第二个是原子提交（Atomic Commit） 并发控制 在并发控制中，主要有两种策略 悲观并发控制（Pessimistic Concurrency Control）：在悲观系统中，如果有锁冲突，比如其他事务持有了锁，就会造成延时等待。所以这里需要为正确性而牺牲性能 乐观并发控制（Optimistic Concurrency Control）：你不用担心其他的事务是否正在读写你要使用的数据，你直接继续执行你的读写操作，通常来说这些执行会在一些临时区域，只有在事务最后的时候，你再检查是不是有一些其他的事务干扰了你 如果没有这样的其他事务，那么你的事务就完成了，并且你也不需要承受锁带来的性能损耗 如果有一些其他的事务在同一时间修改了你关心的数据，并造成了冲突，那么你必须要Abort当前事务，并重试 讨论悲观并发控制，这里涉及到的基本上就是锁机制。这里的锁是两阶段锁（Two-Phase Locking）： 当事务需要使用一些数据记录时，第一个规则是在使用任何数据之前，在执行任何数据的读写之前，先获取锁 第二个对于事务的规则是，事务必须持有任何已经获得的锁，直到事务提交或者Abort，你不允许在事务的中间过程释放锁 这就是两阶段锁的两个阶段，第一个阶段获取锁，第二个阶段是在事务结束前一直持有锁 缺点是非常容易产生死锁，实际上事务有各种各样的策略，包括了判断循环，超时来判断它们是不是陷入到这样一个场景中。如果是的话，数据库会Abort其中一个事务，撤回它所有的操作，并表现的像这个事务从来没有发生一样 两阶段提交 原子性是指，事务的每一个部分都执行，或者任何一个部分都不执行。两阶段提交（Two-Phase Commit）是一种解决方案 实际上是数据被分割在不同的服务器上，所以相应的任务也被分包在不同的服务器上。假设有一个计算机会用来管理事务，它被称为事务协调者（Transaction Coordinator），事务协调者以某种形式运行事务的代码，例如Put/Get/Add，它向持有了不同数据的其他计算机发送消息，其他计算机再执行事务的不同部分 在一个完整的系统中，或许会有很多不同的并发运行事务，也会有许多个事务协调者在执行它们各自的事务。在这个架构里的各个组成部分，都需要知道消息对应的是哪个事务，所以对于事务，需要有事务ID（Transaction ID），简称为TID 除了TC之外，其他的服务器执行部分的事务，这些服务器被称为参与者（Participants） 我们将Two-Phase Commit简称为2PC。参与者有：事务协调者（TC），我们假设只有两个参与者（A，B），两个参与者就是持有数据的两个不同的服务器 在事务的最开始，TC会向参与者A发送Get请求并得到回复，之后再向参与者B发送一个Put请求并得到回复 之后，当TC到达了事务的结束并想要提交事务，这样才能： 释放所有的锁 使得事务的结果对于外部是可见的 再向客户端回复 在开始执行事务时，TC需要确保，所有的事务参与者能够完成它们在事务中的那部分工作，TC为了确保这一点，会向所有的参与者发送Prepare消息 当A或者B收到了Prepare消息，它们就知道事务要执行但是还没执行的内容，它们会查看自身的状态并决定它们实际上能不能完成事务，并回复Yes/No TC会等待来自于每一个参与者的这些Yes/No投票。如果所有的参与者都回复Yes，那么事务可以提交，不会发生错误；之后TC会发出一个Commit消息，给每一个事务的参与者；之后，事务参与者通常会回复ACK说，我们知道了要commit 如果任何一个参与者回复了No，表明自己不能完成这个事务，那么事务协调者不会发送commit消息，它会发送一轮Abort消息给所有的参与者说，请撤回这个事务 在事务Commit之后，会发生两件事情 事务协调者会向客户端发送代表了事务输出的内容，表明事务结束了，事务没有被Abort并且被持久化保存起来了 为了遵守两阶段锁规则，事务参与者会释放锁（这里不论Commit还是Abort都会释放锁） 每个事务参与者在参与事务时，会对任何涉及到的数据加锁 故障恢复 事务参与者故障 参与者B可能在回复事务协调者的Prepare消息之前的崩溃了：如果B发现自己不可能发送Yes，比如说在发送Yes之前自己就故障了，那么B被授权可以单方面的Abort事务 B也可能在回复了Yes给事务协调者的Prepare消息之后崩溃的：在B故障的时候，不知道事务是否能Commit，因为它还没有收到Commit消息。但是B还是需要做好Commit的准备。这意味着，在故障重启的时候，B不能丢失对于事务的状态记录 在B回复Prepare之前，它必须确保记住当前事务的中间状态，记住所有要做的修改，记住事务持有的所有的锁，这些信息必须在磁盘上持久化存储 之后如果B在发送完Yes之后崩溃了，当它重启恢复时，通过查看自己的Log，它可以发现自己正在一个事务的中间，并且对一个事务的Prepare消息回复了Yes B可能在收到Commit之后崩溃了：但是这样的话，B就完成了修改，并将数据持久化存储在磁盘上了。这样的话，故障重启就不需要做任何事情，因为事务已经完成 因为没有收到ACK，事务协调者会再次发送Commit消息。当B重启之后，收到了Commit消息时，它可能已经将Log中的修改写入到自己的持久化存储中、释放了锁、并删除了有关事务的Log。因此对于一个它不知道事务的Commit消息，B会简单的ACK这条消息 事务协调者故障 如果事务的任何一个参与者可能已经提交了，或者事务协调者可能已经回复给客户端了，那么我们不能忽略事务。例如如果事务协调者已经向A发送了Commit消息，但是还没来得及向B发送Commit消息就崩溃了，那么事务协调者必须在重启的时候准备好向B重发Commit消息，以确保两个参与者都知道事务已经提交了 如果事务协调者在发送Commit消息之前就崩溃了，那就无所谓了，因为没有一个参与者会Commit事务，它可以直接Abort事务 如果事务协调者在发送完一个或者多个Commit消息之后崩溃，那么就不允许它忘记相关的事务 在崩溃的时间点，也就是事务协调者决定要Commit而不是Abort事务，并且在发送任何Commit消息之前，它必须先将事务的信息写入到自己的Log，并存放在例如磁盘的持久化存储中 事务协调者在收到所有对于Prepare消息的Yes/No投票后，会将结果和事务ID写入存在磁盘中的Log，之后才会开始发送Commit消息 作为恢复流程的一部分，对于执行了一半的事务，事务协调者会向所有的参与者重发Commit消息或者Abort消息，以防在崩溃前没有向参与者发送这些消息 在事务协调者没有收到Yes/No回复一段时间之后，它可以单方面的Abort事务。因为它知道它没有得到完整的Yes/No消息，当然它也不可能发送Commit消息 类似的，如果参与者等待Prepare消息超时了，那意味着它必然还没有回复Yes消息，进而意味着事务协调者必然还没有发送Commit消息。所以如果一个参与者在这个位置因为等待Prepare消息而超时，那么它也可以决定Abort事务 假设B收到了Prepare消息，并回复了Yes，这个时候参与者没有收到Commit消息，它接下来怎么也等不到Commit消息。这段时间里，B一直持有事务涉及到数据的锁，这意味着，其他事务可能也在等待这些锁的释放。但是这时候我们不能单方面Abort事务或Commit事务，并释放锁，必须等待事务协调者上线 因为B对Prepare消息回复了Yes，这意味着事务协调者可能收到了来自于所有参与者的Yes，并且可能已经向部分参与者发送Commit消息 这意味着A可能已经看到了Commit消息，Commit事务，持久化存储事务的结果并释放锁","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"distributed system","slug":"distributed-system","permalink":"http://example.com/tags/distributed-system/"}]},{"title":"论文阅读-Oblivious Database相关","slug":"paper-reading/oblivious-db","date":"2022-04-12T16:00:00.000Z","updated":"2022-12-02T06:33:24.788Z","comments":true,"path":"2022/04/13/paper-reading/oblivious-db/","link":"","permalink":"http://example.com/2022/04/13/paper-reading/oblivious-db/","excerpt":"论文阅读-Oblivious Database相关","text":"不经意数据库相关研究 抵抗inference attack 关键是隐藏访问模式：隐藏访问内容+访问时间/访问次数/访问顺序等 ObliDB:star2: Proceedings of the VLDB Endowment，Volume 13，Issue 2，October 2019 Stanford University 威胁模型： 读取并篡改不可信内存 暂停和恢复Enclave执行 观察到对不可信内存的访问模式 监听网络通信 了解存储的数据的辅助信息 无法突破SGX远程认证 假设：不经意内存有限 安全保证： 探测到任何篡改数据的恶意行为 只泄露查询选择率（select行的比例），表的大小（包括输出表和中间表）和查询方案 可选的padding模式，可以隐藏表的大小和查询选择率 在enclave外的数据经过加密和MAC计算，仅泄露大小 数据库中表的数量 &amp; 查询了哪张表不作隐藏 Overview： 不经意数据库引擎支持小规模查询和分析查询（需要遍历整张表） 表加密存储在不可信内存但是访问模式被隐藏 两种存储方案：线性表、不经意索引（用于单点查询） Enclave用于存储密钥、元数据，不经意算子在Enclave中执行 存储方案 扁平化存储 数据存储在相邻的块中，每次读/写都需要访问所有块（整张表），用于存储： 小的表 操作后返回表的大部分区域的表 涉及读取全部或大部分表的分析 数据的插入、更新、删除需遍历整张表，对未受影响的块进行虚拟写（重新写一遍所有数据并重新加密） 索引存储 对B+树的插入/删除操作会泄露树的结构信息 =&gt; 使用虚拟ORAM访问，填充所有插入/删除操作，使其访问次数与最坏情况匹配 优化： 懒写回：只在必要的时候写入ORAM，否则将节点保留在enclave中 移除指向父节点的指针 Opaque 14th USENIX Symposium on Networked Systems Design and Implementation (NSDI 17) UC Berkeley Opaque relies on oblivious sorts over the entire dataset. These systems are not efficient for more general workloads that may also include point queries.【ObliDB】(单点查询效率低) 仅达到了Level 1的不经意性，因为使用不经意内存池进行优化【O-Join】 不经意分布式数据分析平台： 引入一系列新的分布式关系运算符 新的查询规划技术，rule-based和cost-based 三种运行模式：加密模式、不经意模式、不经意填充模式 威胁模型 观察和修改网络通信 获取操作系统的root权限 观察enclave对不可信内存的访问模式 可以进行回滚攻击，将密封的数据恢复到之前的状态 不能破坏可信硬件 对Opaque源码的访问是不经意的 安全保证 加密模式 数据加密和身份认证 self-verifying integrity 不经意模式 隐藏访问模式，但不隐藏访问的数据大小，以及Catalyst选择的查询方案 不经意填充模式 在不经意模式的基础上，进一步隐藏数据大小和查询方案 Overview 不经意执行 不经意排序（单机 &amp; 分布式） 不经意过滤（filter） 不经意聚合（group） 不经意连接（join） 查询规划 成本模型：主要考虑不经意排序的次数 查询优化 混合敏感性：使用second path analysis来推断敏感表 OCQ Proceedings of the Fifteenth European Conference on Computer Systems 2020 UC Berkeley OCQ[33]是一个不经意的协同竞争分析的通用框架，它建立在Opaque[87]的基础上，以分散的方式执行协同竞争查询。【Practical O-Join】 多方不经意竞争分析的解决方案，而不是设计一个数据库 主要贡献： 不经意查询算法 schema-aware填充机制：防止两种数据泄露——enclave中的数据泄露和enclave外网络通信中的模式泄露 不经意规划器：决定在哪执行操作以及如何执行 不经意算法： Single-machine oblivious sorting can be done using sorting networks that perform a fixed sequence of compare-exchange operations. Asymptotically more compare-exchange operations are needed for oblivious sorting than for traditional sorting. An oblivious compare-exchange can be implemented via a comparison followed by a conditional swap of two equal-length buffers depending on the result of the comparison. For data partitioned across multiple machines, oblivious sorting can be accomplished using a two-level sorting algorithm in which each partition is individually sorted using a sorting network, and records are sorted across partitions using an algorithm called column sort. Column sort consists of a fixed sequence of data exchange and intra-machine sorting that uses only 4 shuffles, compared to O(nlog2n) shuffles for a sorting-network-based distributed sort. Overview Oblivious join:star2: Proceedings of the VLDB Endowment 2020 University of Waterloo 滑铁卢大学 提出时间复杂度为 $O(nlog^2n+mlogm)$ 的不经意equi-join算法，其中 $n$ 是输入表大小之和， $m$ 是输出表大小 equi-join是指根据相等的条件来join两张表 该算法只依赖于能够在加密数据上支持sorting network的计算模型 不隐藏输出大小和运行时间 在加密数据上进行计算 Outsourced External Memory Secure Cryptographic Coprocessors TEE Secure Multiparty Computation Fully Homomorphic Encryption 不经意性划分 Level 1：对公共内存的访问是不经意的，但需要非常数量的本地内存来执行non-oblivious计算 Level 2：对公共内存的访问是不经意的，且需要的本地内存大小是一个常数 访问程序的数据是不经意的，但是基于控制流访问的字节码没有隐藏。例如分支语句，条件本身是不经意的，但是跳转到的分支的字节码位置没有隐藏 Level 3：程序的控制流，甚至处理器执行的指令，都与输入无关 将Level 2的程序转变为Level 3的程序需另外满足3条限制： 循环次数必须是常数（因为若根据变量来定循环次数，会很难隐藏执行循环的时间） 任何变量执行的最大分支数是一个常数 若一个程序暴露输出长度 $m$ ，则这一定在分配了 $m_0\\in\\Omega(m)$ 的内存之后 Overview 输入两张未排序的表 $T_1$ 和 $T_2$ ，分别包含 $n_1$ 和 $n_2$ 对 $(j,d)$ ，其中 $j$ 表示参与join条件判断的属性， $d$ 是其他属性。输出记为 $T_1\\bowtie T_2={(d_1,d_2)|(j,d_1)\\in T_1, (j,d_2)\\in T_2}$ 使用固定大小的本地内存来实现Level 2的不经意性 算法 ProDB Information Systems 2021 The Hong Kong Polytechnic University 香港理工大学 使用enclave+ORAM的方案来优化硬件资源不足的问题 提出SaP ORAM协议，用来实现enclave到不可信区的通信 不支持并发控制，回滚机制，数据库日志 Overview 安全模型：Memory-secure DBMS two-tier设计： core（部署在TEE中） SQL Decryptor：在TEE中解密SQL query Secure Query Processor (SQP)：与传统处理query的组件相同，除了I/O access ORAM Analyzer (OA)：利用SQL query历史信息的meta-data来规划最优的分配数据块到ORAM树path的方案 ORAM Clients：每个client对应一个server，SQP通过client获取不可信内存中的数据 shield（部署在不可信内存） DBMS Main Process：主程序 ORAM Servers：树形结构，以ORAM-to-Disk机制将数据安全地写入磁盘 work-flow SaP ORAM probabilistic lazy persistence Tagged position map：tag-address-path映射 Update list：存储被SQL query更新的块（而不是被ORAM重加密更新的），不能被敌手知道哪些块在Update list中 probabilistic dirty-block-generation procedure SQL-aware path sharing 目的：减少查询内和查询间的ORAM轮数 核心思想：在一轮ORAM中从树的path中获取多个块（ORAM Analyzer跟踪那些经常一起访问的块，并尽可能多地将它们放在同一ORAM树路径中） 具体方案：没细看 Obladi Proceedings of the 13th USENIX Symposium on Operating Systems Design and Implementation (OSDI’18) Cornell University Obladi [28] considers concurrent ACID transactions but does not support indexes and only processes operations in batches over discrete time epochs.【ObliDB】 Obladi[32]是第一个在隐藏访问模式的同时提供ACID事务的系统。它批量处理操作，但不支持索引【Practical O-Join】 【主要是事务和并发的实现】 第一个提供ACID事务的kv数据库 容错机制 并发控制 Practical Oblivious Join SIGMOD '22: Proceedings of the 2022 International Conference on Management of Data 西安电子科技大学，阿里巴巴 :star2:【参考文献整理】 对以往的不经意Join算法进行整理比较 提出了两种用于一般二元equi-join的不经意算法 oblivious sort-merge join oblivious index nested-loop join 通过扩展index nested-loop join来支持一些band join（如&quot;&lt;“和”&gt;&quot;） 使用index nested-loop join来支持多个表上的非循环equi-join Oblivious Query Processing Microsoft Research Contributions 对安全查询处理的形式化定义 设计占用较小TM（Trusted Module）的不经意算法 定理1（Informal）：$O(log,n)$ TM空间占用的不经意算法的存在性 定理2（Informal）：I/O复杂度 实现时间复杂度 $O(nlog,n)$ ，TM空间占用 $O(log,n)$ 的不经意算法 ORAM-based算法时间复杂度的下界为 $\\Omega(nlog^2n)$ 除了不经意排序，所有算法都基于磁盘扫描；不经意排序基于磁盘搜索， 搜索次数 $O(log_{M/B}(n/B))\\cdot o(n/B)$ 【M为TM内存，B为block大小】 ORAM-based算法磁盘搜索次数 $\\Omega(\\frac{n}{BlogM}log^2{\\frac{n}{B}})$ 对比 数据库类型 支持 特点 实现 ObliDB 关系型 索引 TEE+ORAM Opaque Spark SQL 分布式 TEE OCQ Opaque 分布式 TEE ProDB DBMS(关系型) SaP ORAM协议 TEE+ORAM Obladi kv数据库 事务 并发ORAM ORAM CODBS 关系型(PostgresSQL) 索引 形式化证明:star2: TEE+ORAM O-Join 关系型 二元equi-join TEE Practical O-Join 关系型 综合Join ORAM O-Query 关系型 形式化证明:star2: 算法 不经意可搜索加密 CODBS 40th International Symposium on Reliable Distributed Systems (SRDS) 2021 University of Porto 葡萄牙波尔图大学 提出一种新的不经意搜索方案CODBS来存储数据库索引，将搜索树拆分为L个较小的ORAM实例，而不是一个较大的ORAM 提出了Forest ORAM，这是一种用于存储数据库表的优化ORAM结构 提出了一种优化的不经意数据库体系结构，并在PostgreSQL之上实现了一个完整的解决方案 形式化证明 POSUP Proceedings on Privacy Enhancing Technologies; Journal Volume: 2019 Oregon State University 俄勒冈州立大学 POSUP [41] and Oblix [50] explore oblivious indexes over encrypted data using specialized ORAM constructions as building blocks, but do not support general queries.【ObliDB】 使用Intel SGX开发不经意数据结构，在大数据集上提供实用的不经意搜索/更新操作 Oblix 2018 IEEE Symposium on Security and Privacy (SP) UC Berkeley POSUP [41] and Oblix [50] explore oblivious indexes over encrypted data using specialized ORAM constructions as building blocks, but do not support general queries.【ObliDB】 不泄露访问模式，并且能够隐藏搜索结果的大小；支持更新（插入和删除），以及多个（可能是恶意的）用户 Preserving Access Pattern Privacy in SGX-Assisted Encrypted Search 27th International Conference on Computer Communication and Networks (ICCCN) 2018 The University of Auckland 奥克兰大学 提出了一种SGX辅助的对加密数据进行搜索的方案 保护访问模式免受侧通道攻击，同时确保搜索效率（使用了B+树结构来保证搜索效率） 处理大型数据库，而不需要在SGX上长期存储（分批加载和处理树索引） 与基于oram的解决方案(如obildb)相比，我们的方案要快11倍以上 不经意性证明/分析 Memory trace oblivious program execution KV数据库TEE EdgelessDB 开源项目，无相关论文，兼容MySQL Authenticated key-value stores with hardware enclaves【相关性不大】 Syracuse University 雪城大学 支持查询认证的kv数据库，从而保护数据完整性 实现认证LSM树：eLSM（with small query proofs at selective tree levels），将内存数据存放在enclave外部 提出基于LSM树的新摘要结构：eLSM摘要，以append方式更新摘要 基于Google LevelDB和Facebook RocksDB实现eLSM LSM树 适用于写密集型workload 基本增删改查：深入浅出分析LSM树（日志结构合并树） - 知乎 (zhihu.com) LSM树详解 - 知乎 (zhihu.com) 安全定义 Query integrity：读出的数据是否是之前合法的写请求写入的 Query completeness：读出的数据是否完整 Query freshness：读出的数据的时间戳是否最大 Aria 2021 IEEE 37th International Conference on Data Engineering (ICDE) 清华 现实世界的工作负载通常表现出高度倾斜的访问模式：一小部分hot KV pair收到的请求比其他多得多 引入基于软件的EPC空间管理器 Secure Cache ，为KV存储提供安全保障和高性能 深入研究了命中和未命中惩罚，从而优化了缓存策略 基于 Secure Cache 实现Aria，一个不依赖特定index structure的kv数据库 KV存储 index structure：通过key找到一个KV pair hash-based：简单而快速的点查询 tree-based：支持范围查询（有序存放key） storage manager：保存KV pair 通常的设计是：将KV存储直接放在不受信任的内存中，并在EPC中构建安全元数据，以保护KV pair的完整性和机密性。这样的设计基于这样的事实：对不受信任内存中的KV pair或MAC的任何攻击都会导致从其相应计数器计算的MAC与存储在不受信任内存中的MAC之间的KV pair不匹配 Secure Cache Secure Cache 用于缓存最经常访问的MT节点，从而在访问这些节点时可以直接从 Secure Cache 里验证，消除了MT验证的开销（叶节点若是要验证，只需要沿着到根节点的路径，找到第一个在缓存中的节点即可） 语义优化： 消除metadata从enclave内部到外部的加密 避免clean缓存项的写回 缓存命中优化： 将深层的节点固定在 Secure Cache 中（因为验证时用到的概率高） 采用FIFO策略来驱逐 Secure Cache 中的节点 若命中率小于一个阈值，停止swap 实现 连续Merkle树 用户空间堆分配器 解耦合设计 计数器管理 Put和Get实例 每次get需要解密多个kv pair才能得到想要的结果，是否有优化空间？ SPEICHER 17th USENIX Conference on File and Storage Technologies (FAST 19) 2019 The University of Edinburgh 爱丁堡大学 基于LSM树的三个设计更改：【Tweezer】 必须调整MemTable以减少EPC的使用。Speicher重新设计了MemTable，使它的大部分(叶上的值)显式地存储在EPC外部，并具有加密保护 I/O调用必须由另一个线程在用户级别上处理，以避免在每次调用时都离开enclave上下文。Speicher使用基于Intel SPDK[1]的直接I/O库运行，这减少了额外上下文切换的成本 KVS应该有适当的时间戳，以击败回滚和分叉攻击。Speicher使用自己的异步单调计数器包装同步SGX单调计数器 用于屏蔽执行的I/O库：I/O库在不退出enclave的情况下执行I/O操作 SPEICHER基于屏蔽执行框架SCONE实现 异步可信单调计数器：确保数据新鲜度，利用KV存储中同步操作的延迟来异步更新计数器 安全LSM数据结构：部署在enclave外部，并保证完整性，机密性和新鲜性 算法：设计和实现持久化KV数据库的操作：get, put, range queries, iterators, compaction, restore 威胁模型 敌手可以控制整个系统软件堆栈，包括操作系统或虚拟机监控程序，并能够发起物理攻击，例如执行内存探测 防止回滚攻击和分叉攻击 无法抵御侧信道攻击 设计挑战 有限EPC大小：EPC分页切换开销大，因此需要将MemTable放在enclave外部，同时保证安全 不可信的存储介质：存储引擎持久化三种文件：SSTable，WAL，Manifest，需要保证这三种文件的安全（SGX本身不提供对有状态计算的安全保证），因此重新设计LSM数据结构 昂贵的I/O系统调用：SCONE提供异步系统调用接口，但不适合需要支持频繁I/O系统调用的存储系统，因此设计了一种新的I/O机制 可信计数器：用于保护存储在不可信存储介质中的数据的新鲜性，SGX可信计数器十分慢，因此设计了异步可信单调计数器 Overview SPEICHER controller：基于SCONE实现，提供可信执行环境、远程认证、enclave内部用户级多线程和内存管理的运行时支持 屏蔽I/O库：从enclave内部直接访问磁盘，而不需要昂贵的exit操作，通过SPDK实现 可信计数器：防止回滚攻击，设计异步单调计数器AMC MemTable：key存放在enclave中的跳表里，value加密存放在不可信内存【存在线性增长导致EPC页切换的问题】 SSTable：KV按序排列并经过加密，每个block的hash存放在footer，footer的hash记录在enclave中的Manifest中从而确保新鲜性 Log文件：append-only - WAL：存放插入的KV pair直到top-level compaction，用于restore WAL - Manifest：跟踪实时文件 算法 Put：将KV pair添加到WAL，然后写到MemTable Get：需要生成存在证明或不存在证明 Range queries：根据start key构建Iterator进行遍历，对于每个key，找到最顶层的value Iterators Restore：收集所有属于KV存储的文件（通过读取Manifest），然后重放所有变化到MemTable Compaction EnclaveCache Proceedings of the 20th International Middleware Conference 2019 SJTU 对多租户云环境的KV数据库进行用户隔离等保护【不相关】 ShieldStore:star2: Proceedings of the Fourteenth EuroSys Conference 2019 School of Computing, KAIST 韩国科学技术院 随着密钥空间的增长，ShieldStore由于bucket变长而承受着巨大的验证开销【Aria】 Baseline kv存储 【不是直接用业界成熟的kv数据库，而是自己实现一个简单版本的内存kv存储】 基于哈希的索引结构：高效点查询，范围查询困难 为相同的哈希值创建链表，来抗碰撞 server-side加密和计算数据 Overview 只将主要的密钥和meta-data存放在enclave中，主哈希表经过加密后存放在非可信区 设计 key-value加密 通过对hash索引使用keyed-hash函数，可以将hashed键分布中的信息泄漏降至最低【进一步优化？】 通过key hint来在一个bucket中快速找到对应的value 若一个key更新，IV/counter会增加；若创建新的kv pair，会插入到bucket的头部 完整性校验 对每个bucket set维护一个Merkle root，而不是对所有kv pair维护一个Merkle tree【时间、空间复杂度分析？】 持久化 周期性snapshot parent进程密封enclave内的meta-data，child进程直接存储不可信内存中的哈希表 在snapshot的同时处理新的请求，使用临时表 使用SGX提供的单调计时器防止回滚攻击【使用效率更高的安全计时器?】 优化 额外的堆分配器：在enclave内运行，分配外部不可信内存（为了减少OCALL） MAC bucket：每个hash bucket维护一个，用来存放每个条目的MAC，从而快速计算merkle proof 而不用遍历整个chain 多线程：不同的线程处理不同的hash key，从而避免同步，但线程数量只能固定，不能动态变化【使用Occlum改进？】 搜索加密的key：使用1字节明文key的hash作为hint，从而减少需要解密的次数（只对匹配hint的key进行解密来判断是否是target key） ZeroTrace:star2: NDSS 2018 University of Waterloo 滑铁卢大学 ZeroTrace[66]在set/dictionary/list接口上提供了一个新的不经意的get/put/insert操作库【Practical O-Join】 设计和实现了一个不经意内存管理器 设计和实现 ZeroTrace，一个用来不经意处理数据结构的库 安全威胁 enclave内对外部内存的访问是完全暴露于server的 enclave内部的执行不能保证不经意性 server可以随时终止enclave从而造成某些攻击 不抵抗硬件攻击、硬件制造的漏洞、拒绝服务攻击 定义 enclave执行的不经意性（计算不可区分） SGX的安全挑战 软件侧信道 不能对超出EPC范围的存储提供隐私/完整性保护 没有直接的IO/系统调用 SGX的性能挑战 EPC大小限制 可信区和不可信区切换 ORAM正确性和安全性定义（可忽略函数/计算不可区分） ZeroTrace内存控制器 client接口：read(addr) 和 write(addr, data) server处理： FetchPath(leaf) 和 StorePath(tpath, leaf) 内存管理器enclave程序: 初始化：将程序加载到enclave中 构筑块： 不经意函数：根据汇编级别的函数库构建ORAM控制器 加密和哈希：使用AES-NI和SHA-256 ORAM控制器：处理client请求 (op, id, data*) 不经意leaf-label检索 不经意block检索 不经意path重建 Fetch/Store path优化 使用多个磁盘扩展带宽 缓存ORAM树的顶层 安全性分析（informal） 持久化的完整性 定义fault tolerance的enclave协议 functionality和security 抵抗mix-and-match攻击 抵抗重放攻击 Precursor Proceedings of the 22nd International Middleware Conference 2021 TU Braunschweig 布伦瑞克工业大学 德国 利用TEE来提供保密性和完整性，同时依赖于RDMA进行低延迟和高带宽通信 将加密操作放在客户端，以防止服务器端CPU瓶颈 尽可能避免昂贵的TEE上下文切换，即安全区和非安全区的切换 TEE-KV Proceedings of the ACM Symposium on Cloud Computing 2018 Tokyo University of Agriculture and Technology 东京农工大 &amp; 蚂蚁 &amp; Microsoft Research Asia 微软亚洲研究院 【只有一个Abstract，这是个啥？】 Oblivious key-value stores and amplification for private set intersection Annual International Cryptology Conference 2021 Oregon State University 俄勒冈州立大学 【形式化证明，没有用到SGX】 引入了无关键值存储(OKVS)的抽象，确定并形式化了允许OKVS接入不同协议的重要属性 描述了放大技术，可以用来将较弱的OKVS引导为强OKVS Tweezer 20th USENIX Conference on File and Storage Technologies (fast22) UNIST 韩国蔚山科学技术学院 在Speicher基础上修改 根据Speicher论文自己实现了一个Speicher版本 TWEEZER比Speicher性能高出1.94 ~ 6.23×，使得由于机密计算导致的性能开销从16 ~ 30×减少到4 ~ 9× 不同于Speicher的三个关键设计 无需构建横跨SSTable的Merkle树来确保LSM树的新鲜度，而是对不同的SSTable采用不同的key进行身份认证，使得攻击者无法在当前SSTable以外的任何地方找到其他数据块来执行重放攻击 Tweezer为每个SSTable创建并关联一个唯一的MAC key，基于LSM树的三个属性：每个SSTable的不可变性、每个Level的键的唯一性和每个数据块中的排序键 每个数据块中键的顺序都是唯一且不变的，这使得Tweezer可以检测到任何对新鲜度的攻击，而无需为每个SSTable生成Merkle树 将MAC与每个键值对相关联，而不是与SSTable中的每个数据块相关联。Tweezer通过分别对每个键值对进行加密和身份验证，减少了EPC使用中的读放大。 使用哈希链来对日志文件（WAL和Manifest）进行身份认证，而不使用计数器，Tweezer要求用户放置一个心跳事务来作为时间戳记录KVS版本，并在以后使用它来验证Tweezer的快照是否是最新的","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"db","slug":"db","permalink":"http://example.com/tags/db/"}]},{"title":"Introduction To Modern Cryptography笔记","slug":"learning-notes/cryptography","date":"2022-03-19T16:00:00.000Z","updated":"2022-04-28T07:28:14.000Z","comments":true,"path":"2022/03/20/learning-notes/cryptography/","link":"","permalink":"http://example.com/2022/03/20/learning-notes/cryptography/","excerpt":"正式的密码学证明","text":"Chapter 1: Introduction 1.2 对称加密Setting Kerckhoffs’ principle：要求加密算法的安全性只依赖于密钥的安全性，而加解密算法都应当可以公开 1.3 古典加密算法 恺撒加密、移位加密、单字母替换、多字母移位 密钥空间充分性原则：任何安全的加密方案必须拥有一个能够抵御穷举搜索的密钥空间 1.4 现代密码学原则 原则1 Formal Defination 安全性定义包含： security guarantee regardless of any information an attacker already has, a ciphertext should leak no additional information about the underlying plaintext threat model 敌手的目标是要解密密文，得到明文 Ciphertext-only attack 唯密文攻击：敌手只能得到密文【被动攻击】 Known-plaintext attack 已知明文攻击：敌手能获得一个或多个明文-密文对【被动攻击】 Chosen-plaintext attack 选择明文攻击：敌手可以选择明文，并获得加密后的密文【主动攻击】 Chosen-ciphertext attack 选择密文攻击：敌手可以选择密文，并获得解密后的明文【主动攻击】 原则2 Precise Assumption 原则3 Proofs of Security Chapter 2: Perfectly Secret Encryption 2.1 符号定义 加密方案的元素： $\\mathcal{M}$ ——有限消息空间，$|\\mathcal{M}|&gt;1$ 令 $M$ 是一个随机的消息 ，对于任意 $m\\in\\mathcal{M}$ ，$Pr[M=m]$ 表示 $M$ 与 $m$ 一致的概率 $\\mathcal{K}$ ——有限密钥空间 令 $K$ 是 $\\mathsf{Gen}$ 随机生成的密钥，对于任意 $k\\in\\mathcal{K}$ ，$Pr[K=k]$ 表示 $\\mathsf{Gen}$ 生成的密钥为 $k$ 的概率 注：$K$ 和 $M$ 是独立的 $\\mathcal{C}$ ——密文空间 令 $C$ 是一个随机变量，对于任意 $c\\in\\mathcal{C}$ ，$Pr[C=c]$ 表示 $\\mathsf{Enc}$ 加密得到的密文为 $c$ 的概率 给定 $\\mathsf{Enc}$ ，$\\mathcal{C}$ 的分布完全取决于 $\\mathcal{M}$ 和 $\\mathcal{K}$ 的分布 加密方案包含三个算法： $\\mathsf{Gen}$ ——密钥生成 密钥生成算法从 $\\mathcal{K}$ 中均匀地选择一个密钥 $k$ $\\mathsf{Enc}$ ——加密 输入 $k\\in\\mathcal{K}, m\\in\\mathcal{M}$ ，输出密文 $c\\in\\mathcal{C}$ 对于概率性加密算法，记作 $c\\leftarrow \\mathsf{Enc}_{k}(m)$ 对于确定性加密算法，记作 $c:=\\mathsf{Enc}_{k}(m)$ $\\mathsf{Dec}$ ——解密 输入 $k\\in\\mathcal{K},c\\in\\mathcal{C}$ ，输出消息 $m\\in\\mathcal{M}$ 一般假设解密算法是确定性的，记作 $m:=\\mathsf{Dec}_{k}©$ Perfect Secrecy 定义2.3：加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是perfectly secret，如果对 $\\mathcal{M}$ 上任意概率分布，任意明文 $m\\in\\mathcal{M}$ ，任意密文 $c\\in\\mathcal{C}$ 且 $Pr[C=c]&gt;0$ 有：$Pr[M=m|C=c]=Pr[M=m]$ 等价定义：$Pr[C=c|M=m]=Pr[C=c]$ 引理2.4：加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是perfectly secret，当且仅当对所有 $m, m’\\in\\mathcal{M}$ 和所有 $c\\in\\mathcal{C}$ 有：$Pr[\\mathsf{Enc}{k}(m)=c]=Pr[\\mathsf{Enc}{k}(m’)=c]$ 说明密文不包含任何关于明文的信息，且不可能区分加密后的 $m$ 和 $m’$ Perfect (adversarial) indistinguishability 定义敌手不可区分实验 $\\mathsf{PrivK}^{eav}_{\\mathcal{A},\\Pi}$ (其中 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ )： 敌手 $\\mathcal{A}$ 输出一对消息 $m_0,m_1\\in\\mathcal{M}$ 选择一个比特 $b\\in{0,1}$ ，计算 $c\\leftarrow \\mathsf{Enc}_k(m_b)$ 并发送给 $\\mathcal{A}$ 。称 $c$ 为挑战密文 $\\mathcal{A}$ 输出一个比特 $b’$ 若 $b=b’$ 则实验输出1，记作 $\\mathsf{PrivK}^{eav}_{\\mathcal{A},\\Pi}=1$ ，此时 $\\mathcal{A}$ 获胜；反之输出0 定义2.5：加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是perfectly indistinguishable，如果对所有 $\\mathcal{A}$ 有： $Pr[\\mathsf{PrivK}^{eav}_{\\mathcal{A},\\Pi}=1]=\\frac{1}{2}$ 引理2.6：加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是perfectly secret，当且仅当它是perfectly indistinguishable 2.2 一次一密 定义：取定整数 $l&gt;0$ ， $\\mathcal{M},\\mathcal{C},\\mathcal{K}$ 都是长度为 $l$ 的二进制串，即 ${0,1}^l$ $\\mathsf{Gen}$ ：根据均匀分布从 $\\mathcal{K}={0,1}^l$ 中选择一个密钥 $\\mathsf{Enc}$ ：给定密钥 $k\\in{0,1}^l$ 和消息 $m\\in{0,1}^l$ ，输出密文 $c:=k\\oplus m$ $\\mathsf{Dec}$ ：给定密钥 $k\\in{0,1}^l$ 和密文 $c\\in{0,1}^l$ ，输出消息 $m:=k\\oplus c$ 定理2.9：一次一密方案是perfectly secret 局限性： 密钥必须和消息等长 只有每次加密使用不同的密钥才安全 2.3 Perfect Secrecy的局限性 定理2.10： $(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是perfectly secret加密方案，则 $|\\mathcal{K}|&gt;|\\mathcal{M}|$ 【反证】 Perfectly secret的加密方案中密钥空间必须大于消息空间 2.4 香农定理 定理2.11(香农定理)：对于 $|\\mathcal{M}|=|\\mathcal{K}|=|\\mathcal{C}|$ 的加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是perfectly secret，当且仅当： 每个密钥 $k\\in\\mathcal{K}$ 被 $\\mathsf{Gen}$ 选择的概率为 $1/|\\mathcal{K}|$ 对每个 $m\\in\\mathcal{M}$ 和 $c\\in\\mathcal{C}$ ，存在唯一的密钥 $k\\in\\mathcal{K}$ 使得 $\\mathsf{Enc}_k(m)$ 输出 $c$ Chapter 3: Private-Key Encryption 3.1 计算安全 放松perfect secrecy的限制： 仅对可行时间内的敌手保证安全（敌手可能在足够多的时间内可以破解） 敌手有很小的概率破解 形式化定义 具体定义 一个方案是 $(t,\\varepsilon)$-安全 的，如果任何敌手在时间 $t$ 内破解该方案的概率最大为 $\\varepsilon$ 渐进定义 诚实各方使用一个共享的安全参数 $n$ (或记为 $1^n$ ) 来初始化加密方案，从而敌手的攻击时间和攻击成功的概率都是 $n$ 的函数： 敌手攻击时间：多项式时间，即存在多项式 $p$ ，对所有输入 $x\\in{0,1}^*$ ，算法最多执行 $p(|x|)$ 步 敌手的攻击成功概率可忽略 定义3.4：从自然数映射到非负实数的函数 $f$ 是可忽略(negligible)的，如果对所有正多项式 $p$ ，存在 $N$ ，使得对所有 $n&gt;N$ ，有 $f(n)&lt;\\frac{1}{p(n)}$ 【将任意可忽略函数记作 $\\mathsf{negl}$】 命题3.6：令 $\\mathsf{negl_1}$ 和 $\\mathsf{negl_2}$ 为可忽略函数，则 $\\mathsf{negl_3}(n)=\\mathsf{negl_1}(n)+\\mathsf{negl_2}(n)$ 是可忽略的 对任意正多项式 $p$ ，$\\mathsf{negl_4}(n)=p(n)\\cdot \\mathsf{negl_1}(n)$ 是可忽略的 一个方案是安全的，如果任何PPT (probabilistic polynomial-time概率多项式时间) 敌手破解该方案的概率可忽略 3.2 定义计算安全的加密 定义3.7：一个对称加密方案是一个PPT算法元组 $(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ ，满足： $\\mathsf{Gen}$ 的输入为 $1^n$ ，输出密钥 $k$ ，记作 $k\\leftarrow \\mathsf{Gen}(1^n)$ ，并假设任何 $k$ 满足 $|k|&gt;n$ $\\mathsf{Enc}$ 的输入为 $k$ 和 $m\\in{0,1}^*$ ，输出密文 $c$ ，记作 $c\\leftarrow \\mathsf{Enc}_k(m)$ $\\mathsf{Dec}$ 的输入为 $k$ 和 $c$ ，输出消息 $m$ 或错误 $\\bot$ (当输入为无效密文)，记作 $m:=\\mathsf{Dec}_k©$ 算法满足 $\\mathsf{Dec}_k(\\mathsf{Enc}_k(m))=m$ 安全的基本定义 关于敌手能力的假设： 仅窃听信道（唯密文攻击） 多项式时间 定义敌手不可区分实验 $\\mathsf{PrivK}^\\mathsf{eav}_{\\mathcal{A},\\Pi}(n)$ (其中 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ )： 敌手 $\\mathcal{A}$ 根据输入 $1^n$ 输出一对消息 $m_0,m_1$ ，且 $|m_0|=|m_1|$ 计算 $k\\leftarrow \\mathsf{Gen}(1^n)$ ，选择一个比特 $b\\in{0,1}$ ，计算 $c\\leftarrow \\mathsf{Enc}_k(m_b)$ 并发送给 $\\mathcal{A}$ 。称 $c$ 为挑战密文 $\\mathcal{A}$ 输出一个比特 $b’$ 若 $b=b’$ 则实验输出1，记作 $\\mathsf{PrivK}^\\mathsf{eav}_{\\mathcal{A},\\Pi}(n)=1$ ，此时 $\\mathcal{A}$ 获胜；反之输出0 定义3.8(3.9)：对称加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是EAV-安全的（对窃听敌手不可区分），如果对所有PPT敌手 $\\mathcal{A}$ 有一个可忽略函数 $\\mathsf{negl}$ ，使得对所有n： $Pr[\\mathsf{PrivK}^\\mathsf{eav}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\frac{1}{2}+\\mathsf{negl}(n)$ 该式说明 $\\mathcal{A}$ 正确判断加密的消息是 $m_0$ 还是 $m_1$ 的概率小于等于 $\\frac{1}{2}+\\mathsf{negl}(n)$ $Pr[out_{\\mathcal{A}}(\\mathsf{PrivK}\\mathsf{eav}_{\\mathcal{A},\\Pi}(n,0))=1]-Pr[out_{\\mathcal{A}}(\\mathsf{PrivK}\\mathsf{eav}_{\\mathcal{A},\\Pi}(n,1))=1]\\leq \\mathsf{negl}(n)$ 其中 $\\mathsf{PrivK}^\\mathsf{eav}{\\mathcal{A},\\Pi}(n,b)$ 表示实验选择了 $m_b$ 进行加密； $out{\\mathcal{A}}(\\mathsf{PrivK}^\\mathsf{eav}_{\\mathcal{A},\\Pi}(n,b))$ 表示 $\\mathcal{A}$ 在实验中的输出，即 $b’$ 该式说明 $\\mathcal{A}$ 不能判断进行的实验是 $\\mathsf{PrivK}^\\mathsf{eav}{\\mathcal{A},\\Pi}(n,0)$ 还是 $\\mathsf{PrivK}^\\mathsf{eav}{\\mathcal{A},\\Pi}(n,1)$ 语义安全 不可区分意味着密文不会泄露任何一比特的明文 定理3.10： $\\Pi=(\\mathsf{Enc},\\mathsf{Dec})$ 是一个对长度为 $l$ 的消息的对称加密方案，并且是EAV-安全的。则对所有PPT敌手 $\\mathcal{A}$ 和任何 $i\\in{1,…,l}$ ，存在一个可忽略函数 $\\mathsf{negl}$ 使得：【其中 $m^i$ 表示消息的第 $i$ 比特；$\\mathcal{A}(1^n,\\mathsf{Enc}_k(m))$ 表示 $\\mathcal{A}$ 收到挑战密文后的输出 $b’$ 】 $$Pr[\\mathcal{A}(1n,\\mathsf{Enc}_k(m))=mi]\\leq\\frac{1}{2}+\\mathsf{negl}(n)$$ 不可区分意味着没有敌手能从密文中学习到任何明文的函数 定理3.11：$\\Pi=(\\mathsf{Enc},\\mathsf{Dec})$ 是一个对长度为 $l$ 的消息的对称加密方案，并且是EAV-安全的。则对所有PPT敌手 $\\mathcal{A}$ 存在一个PPT算法 $\\mathcal{A’}$ ，使得对任何 $S\\subseteq {0,1}^l$ 和任何函数 $f: {0,1}^l\\rightarrow{0,1}$ ，存在一个可忽略函数 $negl$ 使得： $$ |Pr[\\mathcal{A}(1n,\\mathsf{Enc}_k(m))=f(m)]-Pr[\\mathcal{A’}(1n)=f(m)]|\\leq \\mathsf{negl}(n) $$ 3.3 构建安全加密方案 伪随机生成器 伪随机生成器 $G$ 是一个高效、确定性的算法，用于将一个短的、均匀的字符串 (seed) 转变为一个长的、伪随机的字符串 定义3.14：令 $l$ 为一个多项式，$G$ 为一个确定性多项式时间算法，使得对任何 $n$ 和输入 $s\\in{0,1}^n$ ，输出 $G(s)$ 是一个长度为 $l(n)$ 的字符串。称 $G$ 是一个伪随机生成器，如果满足： 扩展性：对任意 $n$ 满足 $l(n)&gt;n$ 伪随机性：对任意PPT算法 $D$ ，存在一个可忽略函数使得：【其中 $r\\in {0,1}^{l(n)}$】 $$ |Pr[D(G(s))=1]-Pr[D®=1]|\\leq \\mathsf{negl}(n) $$ 称 $l$ 为 $G$ 的扩展系数 之所以生成的字符串是伪随机而不是均匀的，举例说明：$l(n)=2n$ 时，长度为 $2n$ 的字符串空间为 $2^{2n}$ ，选择任意一个 $r\\in {0,1}^{2n}$ 的概率为 $1/2^{2n}$ ，是均匀的；但是由于 $s$ 的长度为 $n$ ，所以 $G(s)$ 的字符串空间为 $2^n$ ，选择到的概率为 $1/2^n$ ，不是均匀的 流密码 流密码是一对确定性算法 $(\\mathsf{Init}, \\mathsf{GetBits})$ $\\mathsf{Init}$ 输入seed $s$ 和可选的初始化向量 $IV$ ，输出初始状态 $st_0$ $\\mathsf{GetBits}$ 输入状态信息 $st_i$ ，输出一个比特 $y$ 并更新状态到 $st_{i+1}$ 算法3.16： 规约证明 将证明一个敌手 $\\mathcal{A}$ 成功破解一个方案 转换为 证明一个算法 $\\mathcal{A’}$ 解决一个难题，具体步骤如下： 选定一个敌手 $\\mathcal{A}$ 攻击 $\\Pi$ ，攻击成功的概率为 $\\varepsilon(n)$ ； 构建一个算法 $\\mathcal{A’}$ ，它使用敌手 $\\mathcal{A}$ 作为子程序来尝试解决问题 $X$ 。注意： $\\mathcal{A’}$ 不知道 $\\mathcal{A}$ 是如何工作的，它只知道 $\\mathcal{A}$ 要攻击 $\\Pi$ 。当输入一个问题 $X$ 的实例 $x$ 时， $\\mathcal{A’}$ 为 $\\mathcal{A}$ 模拟一个 $\\Pi$ 的实例，使得： $\\mathcal{A}$ 无法区分自己是作为 $\\mathcal{A’}$ 的子程序在运行还是其本身在攻击 $\\Pi$ ； 如果 $\\mathcal{A}$ 成功破解 $\\mathcal{A’}$ 模拟的 $\\Pi$ ，则 $\\mathcal{A’}$ 能解决问题 $x$ ，其概率至少为 $1/p(n)$ ； 根据上一点， $\\mathcal{A’}$ 解决 $X$ 的概率为 $\\varepsilon(n)/p(n)$ 。若 $\\varepsilon(n)$ 不是可忽略的，则 $\\varepsilon(n)/p(n)$ 也不是可忽略的，从而得到一个算法 $\\mathcal{A’}$ 以不可忽略的概率解决 $X$ ，与假设（ $X$ 是一个计算难题，无法在多项式时间内解决）矛盾； 综上，如果 $X$ 确实是计算难题，则没有 $\\mathcal{A}$ 能以不可忽略的概率破解 $\\Pi$ 。换言之， $\\Pi$ 是计算安全的。 安全的定长加密方案 用生成器对密钥进行扩充，以达到一次一密的效果 具体构造3.17如下： 定理3.18：如果 $G$ 是伪随机生成器，则上述构造的加密方案是EAV-安全的 规约证明3.18： 使用 $\\mathcal{A}$ 来构造一个判别器 $D$ ，将 $\\mathcal{A}$ 正确选择 $\\Pi$ 加密的消息的能力规约到 $D$ 分辨 $G$ 的输出和均匀字符串的能力，从而由 $G$ 的安全性能推导出 $\\Pi$ 的安全性。 $D$ 的构造如下，$D$ 的目标是分辨输入 $w$ 是随机串还是由伪随机生成器生成的： 定义 $\\widetilde{\\Pi}=(\\widetilde{\\mathsf{Gen}},\\widetilde{\\mathsf{Enc}},\\widetilde{\\mathsf{Dec}})$ 为一次一密方案： $\\widetilde{\\mathsf{Gen}}(1^n)$ 输出长度为 $l(n)$ 的密钥 $k$ ； $\\widetilde{\\mathsf{Enc}}$ 使用 $k$ 加密长度为 $l(n)$ 的消息：$c:=k\\oplus m$ ； 根据一次一密的perfect secrecy： $$ Pr[\\mathsf{PrivK}^{eav}_{\\mathcal{A},\\widetilde{\\Pi}}(n)=1]=\\frac{1}{2} \\tag{3.3} $$ 对 $D$ 进行分析： 若 $w$ 是从 ${0,1}^{l(n)}$ 中均匀选出的，则 $\\mathcal{A}$ 作为 $D$ 的子程序运行的视图和在实验 $\\mathsf{PrivK}^{eav}{\\mathcal{A},\\widetilde{\\Pi}}(n)$ 中的视图完全一致，即： $$ Pr{w\\leftarrow {0,1}{l(n)}}[D(w)=1]=Pr[\\mathsf{PrivK}{eav}_{\\mathcal{A},\\widetilde{\\Pi}}(n)=1]=\\frac{1}{2} \\tag{3.4} $$ 若 $w$ 是通过 $w=G(k),,k\\in {0,1}^n$ 生成的，则 $\\mathcal{A}$ 作为 $D$ 的子程序运行的视图和在实验 $\\mathsf{PrivK}^{eav}{\\mathcal{A},\\Pi}(n)$ 中的视图完全一致，即 $$ Pr{k\\leftarrow {0,1}n}[D(G(k))=1]=Pr[\\mathsf{PrivK}{eav}_{\\mathcal{A},\\Pi}(n)=1] \\tag{3.5} $$ 由于 $G$ 是伪随机生成器，所以存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ |Pr_{w\\leftarrow {0,1}^{l(n)}}[D(w)=1]-Pr_{k\\leftarrow {0,1}^n}[D(G(k))=1]|\\leq \\mathsf{negl}(n) $$ 根据公式 $(3.4),,(3.5)$ 得： $$ |\\frac{1}{2}-Pr[\\mathsf{PrivK}^{eav}_{\\mathcal{A},\\Pi}(n)=1]|\\leq \\mathsf{negl}(n) $$ 即 $Pr[\\mathsf{PrivK}^{eav}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\frac{1}{2}+\\mathsf{negl}(n)$ ，从而方案 $\\Pi$ 是EAV-安全的。 3.4 更强的安全概念 多消息加密——修改安全目标 多消息窃听实验 $\\mathsf{PrivK}^\\mathsf{mult}_{\\mathcal{A},\\Pi}(n)$ ： 敌手 $\\mathcal{A}$ 得到输入 $1^n$ ，并输出一对相同长度的消息列表： $\\vec{M_0}=(m_{0,1},…,m_{0,t})$ 和 $\\vec{M_1}=(m_{1,1},…,m_{1,t})$ ，其中 $|m_{0,i}|=|m_{1,i}|$ ； $k\\leftarrow \\mathsf{Gen(1^n)}$ ，并随机选择 $b\\in{0,1}$ 。对所有 $i$ ，计算 $c_i\\leftarrow \\mathsf{Enc}k(m{b,i})$ ，将 $\\vec{C}=(c_1,…,c_t)$ 发送给 $\\mathcal{A}$ ； $\\mathcal{A}$ 输出一比特 $b’$ ； 若 $b=b’$ 则实验输出1，$\\mathcal{A}$ 获胜，反之输出0。 定义3.19：一个对称加密方案 $\\Pi=(\\mathsf{Gen,Enc,Dec})$ 是多消息EAV-安全的，如果对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{PrivK}^\\mathsf{mult}_{\\mathcal{A},\\Pi}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 命题3.20：存在一个对称加密算法是EAV-安全的，但不是多消息EAV-安全的。【eg. 一次一密】 定理3.21：如果 $\\Pi$ 是一个无状态的加密方案且 $\\mathsf{Enc}$ 是确定性算法，则 $\\Pi$ 不可能是多消息EAV-安全的。 CPA-安全（选择明文攻击）——增强威胁模型 CPA不可区分实验 $\\mathsf{PrivK}^\\mathsf{cpa}_{\\mathcal{A},\\Pi}(n)$ ： $k\\leftarrow \\mathsf{Gen(1^n)}$ ； 敌手 $\\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\\mathsf{Enc}_k(\\cdot)$，输出一对相同长度的消息 $m_0$ 和 $m_1$ ； 随机选择 $b\\in{0,1}$ ，计算 $c\\leftarrow \\mathsf{Enc}k(m{b})$ ，并发送给 $\\mathcal{A}$ ； $\\mathcal{A}$ 输出一比特 $b’$ ； 若 $b=b’$ 则实验输出1，$\\mathcal{A}$ 获胜，反之输出0。 定义3.22：对称加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是CPA-安全的（对选择明文攻击不可区分），如果对所有PPT敌手 $\\mathcal{A}$ 有一个可忽略函数 $\\mathsf{negl}$ ，使得对所有n： $$Pr[\\mathsf{PrivK}^\\mathsf{cpa}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\frac{1}{2}+\\mathsf{negl}(n)$$ 多消息加密的CPA-安全 定义oracle $\\mathsf{LR}_{k,b}(\\cdot,\\cdot)$ ：输入两个等长的消息 $m_0$ ，$m_1$ ，若 $b=0$ 输出 $c\\leftarrow \\mathsf{Enc}_k(m_0)$ ；若 $b=1$ 输出 $c\\leftarrow \\mathsf{Enc}_k(m_1)$ LR-oracle实验 $\\mathsf{PrivK}^\\mathsf{LR-cpa}_{\\mathcal{A},\\Pi}(n)$ ： $k\\leftarrow \\mathsf{Gen(1^n)}$ ； 随机选择 $b\\in{0,1}$ ； 敌手 $\\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\\mathsf{LR}{k,b}(\\cdot,\\cdot)$ 【 $\\mathcal{A}$ 能通过请求 $\\mathsf{LR}{k,b}(m_{0,1},m_{1,1})$,…,$\\mathsf{LR}{k,b}(m{0,t},m_{1,t})$ 来获取消息列表的加密结果，同时也可以通过请求 $\\mathsf{LR}_{k,b}(m,m)$ 来获得 $\\mathsf{Enc}_k(m)$ 】，输出一对相同长度的消息 $m_0$ 和 $m_1$ ； 计算 $c\\leftarrow \\mathsf{Enc}k(m{b})$ ，并发送给 $\\mathcal{A}$ ； $\\mathcal{A}$ 输出一比特 $b’$ ； 若 $b=b’$ 则实验输出1，$\\mathcal{A}$ 获胜，反之输出0。 定义3.23：对称加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是多消息CPA-安全的，如果对所有PPT敌手 $\\mathcal{A}$ 有一个可忽略函数 $\\mathsf{negl}$ ，使得对所有n： $$Pr[\\mathsf{PrivK}^\\mathsf{LR-cpa}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\frac{1}{2}+\\mathsf{negl}(n)$$ 定理3.24：任何CPA-安全的对称加密方案都是多消息CPA-安全的 3.5 构造CPA-安全的加密方案 伪随机函数 定义keyed函数 $F(k,x):{0,1}^\\times {0,1}^\\rightarrow {0,1}^$ ，一般而言可以固定密钥 $k$ ，记作 $F_k(x)=F(k,x)$ ，而 $F_k(x):{0,1}^\\rightarrow {0,1}^*$ 。安全参数 $n$ 规定了密钥、输入、输出的长度，从而 $F_k(x)$ 是条件 $k\\in{0,1}^n$ 下的一个将长度为 $n$ 的输入映射到长度为 $n$ 的输出的函数。 称函数 $F$ 是伪随机的，如果 $F_k(x)$ 与 $f:{0,1}^n\\rightarrow {0,1}^n$ 不可区分【所有 $f$ 的集合记作 $\\mathsf{Func}_n$】 可以将 $f$ 看作一个表，根据长度 $n$ 的输入查表得到长度 $n$ 的输出，输入可以固定顺序为 $0^n$ 到 $1^n$ ，则该表有 $2^n$ 行，每个输入对应的输出长度为 $n$ ，即每行长度为 $n$ ，因此函数 $f$ 可以看作一个长度为 $2^n\\cdot n$ 的序列，从而 $f$ 的取值空间大小为 $2{2n\\cdot n}$ 【$F_k$ 的取值空间为 $2^n$】 定义3.25：令 $F:{0,1}^\\times {0,1}^\\rightarrow {0,1}^*$ 为一个keyed函数。$F$ 是一个伪随机函数，如果对所有PPT判别器 $D$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ |Pr[D{F_k(\\cdot)}(1n)=1]-Pr[D{f(\\cdot)}(1n)=1]|\\leq\\mathsf{negl}(n) $$ 注：$D$ 并不知道具体的 $k$ 伪随机排列 令 $\\mathsf{Perm}_n$ 是 ${0,1}^n$ 的全排列，大小为 $(2^n)!$ 若函数 $f\\in\\mathsf{Perm}_n$ ，说明不同输入映射到的输出是不同的 $F$ 是一个keyed排列，如果 $F_k$ 的值是全排列； $F$ 是efficient的，如果可以在多项式时间内计算 $F_k(x)$ 和 $F_k^{-1}(y)$ $F$ 是伪随机排列，如果 $F_k(x)$ 与 $f\\in\\mathsf{Perm}_n$ 不可区分 命题3.27：如果 $F$ 是一个伪随机排列且 $l_{in}(n)\\geq n$ ，则 $F$ 也是一个伪随机函数 定义3.28：令 $F:{0,1}^\\times {0,1}^\\rightarrow {0,1}^*$ 为一个keyed排列。$F$ 是一个强伪随机排列，如果对所有PPT判别器 $D$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ |Pr[D{F_k(\\cdot),F_k{-1}(\\cdot)}(1n)=1]-Pr[D{f(\\cdot),f{-1}(\\cdot)}(1n)=1]|\\leq\\mathsf{negl}(n) $$ 伪随机函数与伪随机生成器的关系 伪随机生成器 $G$ 可以由伪随机函数 $F$ 得到：$G(s)=F_s(1)||F_s(2)||…||F_s(l)$ 根据伪随机函数构造流密码3.29： 伪随机函数构造的CPA-安全加密 证明基于伪随机函数的构造的安全性：首先假设构造中的伪随机函数被以一个随机函数替换，再通过规约证明来说明这个改变不会影响敌手成功的概率，最后再证明修改后的构造是安全的 构造3.30： 缺点在于生成的密文长度是明文的两倍 定理3.31：如果 $F$ 是一个伪随机函数，则上述构造是CPA-安全的【证明on P83】 3.6 工作模式 流密码的工作模式 同步模式：有状态，需要通信双方同步，基于算法3.16和构造3.17 令发送方为A，接收方为B，双方计算 $\\mathsf{st}_0:=\\mathsf{Init}(k)$ 发送第一条长度为 $l_1$ 的消息 $m_1$ ，A根据 $\\mathsf{st}0$ 运行 $l_1$ 次 $\\mathsf{GetBits}$ ，得到 $\\mathsf{pad}1\\overset{def}{=}y_1,…,y{l_1}$ 并更新状态到 $\\mathsf{st}{l_1}$ ，然后发送 $c_1:=\\mathsf{pad}_1 \\oplus m_1$ ；而B解密通过 $m_1:=\\mathsf{pad}_1 \\oplus c_1$ 发送第二条长度为 $l_2$ 的消息 $m_2$ ，A根据 $\\mathsf{st}{l_1}$ 运行 $l_2$ 次 $\\mathsf{GetBits}$ ，得到 $\\mathsf{pad}2\\overset{def}{=}y{l_1+1},…,y{l_1+l_2}$ 并更新状态到 $\\mathsf{st}_{l_1+l_2}$ ，然后发送 $c_2:=\\mathsf{pad}_2 \\oplus m_2$ ；而B解密通过 $m_2:=\\mathsf{pad}_2 \\oplus c_2$ ，以此类推 自同步模式：无状态CPA-安全，基于构造3.30，其中的 $F_k(IV)\\overset{def}{=}G_\\infty(k,IV,1^l)$ 分组密码的工作模式 使用分组密码构造CPA-安全的加密方案，改进构造3.30，使得密文长度减小。令 $F$ 为分组长度为 $n$ 的分组密码，需要加密的消息记为 $m=m_1,m_2,…,m_l$ 且 $m_i\\in{0,1}^n$ ECB模式（Electronic Code Book）：$c:=\\langle F_k(m_1),…,F_k(m_l)\\rangle$ ，它是确定性算法，因此不是CPA-安全的，同时它也不是EAV-安全的，因为每一个分组的block都相同 CBC模式（Cipher Block Chaining）：概率性算法，若 $F$ 是一个伪随机排列，则CBC-模式加密是CPA-安全的 缺点：加解密只能串行，不能并行，因为后面的block依赖于前面block的输出 链式CBC：对一种选择明文攻击不安全，构造攻击如下： 假设敌手知道 $m_1\\in{m_10,m_11}$ ，并且得到了密文 $IV,c_1,c_2,c_3$ ，接着构造 $m_4=IV\\oplus m_1^0\\oplus c_3$ ，得到输出 $c_4$ 。从而可以得出 $m_1=m_1^0$ 当且仅当 $c_4=c_1$ ，因此敌手可以从 ${m_10,m_11}$ 中选出正确的 $m_1$ OFB模式（Output Feedback）：可以看作是自同步流密码，$F$ 不需要是一个伪随机排列，消息长度不需要进行填充，且每一步的状态都是保密的。若 $F$ 是一个伪随机函数，则OFB模式是CPA-安全的。虽然加解密都只能串行执行，但是加解密用的伪随机串可以提前计算 CTR模式（Counter）：也可以看作自同步流密码，具体构造如下： 选择一个随机值 $\\mathsf{ctr}\\in{0,1}^n$ ，计算伪随机串 $y_i:=F_k(\\mathsf{ctr}+i)$ 【其中 $\\mathsf{ctr}+i$ 是整数模 $2^n$ 相加】，从而第 $i$ 个密文块为 $c_i:=y_i\\oplus m_i$ $F$ 不需要是一个伪随机排列，消息长度不需要进行填充，且每一步的状态都是保密的，加解密可以并行执行，且伪随机串可以提前计算 定理3.32：若 $F$ 是一个伪随机函数，则CRT模式是CPA-安全的。【证明on P93】 3.7 选择密文攻击 CCA-安全 CCA不可区分实验 $\\mathsf{PrivK}^\\mathsf{cca}_{\\mathcal{A},\\Pi}(n)$ ： $k\\leftarrow \\mathsf{Gen(1^n)}$ ； 敌手 $\\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\\mathsf{Enc}_k(\\cdot)$ 和 $\\mathsf{Dec}_k(\\cdot)$ ，输出一对相同长度的消息 $m_0$ 和 $m_1$ ； 随机选择 $b\\in{0,1}$ ，计算 $c\\leftarrow \\mathsf{Enc}k(m{b})$ ，并发送给 $\\mathcal{A}$ ； $\\mathcal{A}$ 可以继续使用 $\\mathsf{Enc}_k(\\cdot)$ 和 $\\mathsf{Dec}_k(\\cdot)$ ，但不能对挑战密文使用 $\\mathsf{Dec}_k(\\cdot)$。最终 $\\mathcal{A}$ 输出一比特 $b’$ ； 若 $b=b’$ 则实验输出1，$\\mathcal{A}$ 获胜，反之输出0。 定义3.33：对称加密方案 $\\Pi=(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})$ 是CCA-安全的（对选择密文攻击不可区分），如果对所有PPT敌手 $\\mathcal{A}$ 有一个可忽略函数 $\\mathsf{negl}$ ，使得对所有n： $$Pr[\\mathsf{PrivK}^\\mathsf{cca}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\frac{1}{2}+\\mathsf{negl}(n)$$ 注：任何CCA-安全的对称加密方案都是多消息CCA-安全的 之前所讨论的所有加密方案都不是CCA安全的，例如对于构造3.30：敌手选择 $m_0=0n,,m_1=1n$ ，在收到密文 $c=\\langle r,s\\rangle$ 之后，敌手反转 $s$ 的第一位，并将新的密文 $c’=\\langle r,s’\\rangle$ 发送到 $\\mathsf{Dec}_k(\\cdot)$ 进行解密，若结果是 $10^{n-1}$ 说明 $b=0$ ，若结果是 $01^{n-1}$ 说明 $b=1$ CCA-安全的一个重要性质是non-malleability，即对于一个密文，若对其做一些修改，则解密要么无效要么结果与原本的结果毫无关系 Padding-Oracle Attacks 攻击者只需要知道修改后的密文是否能够有效解密，具体攻击方法见P98 Chapter 4: Message Authentication Codes 4.2 MAC（消息认证码）定义 定义4.1：一个MAC包含三个PPT算法 $(\\mathsf{Gen},\\mathsf{Mac},\\mathsf{Vrfy})$ ：满足 $\\mathsf{Vrfy}_k(m,\\mathsf{Mac}_k(m))=1$ $\\mathsf{Gen}$ 根据输入安全参数 $1^n$ ，输出密钥 $k,,|k|\\geq n$ $\\mathsf{Mac}$ 根据输入密钥 $k$ 和消息 $m\\in{0,1}^*$ ，输出一个标签 $t$ ，即 $t\\leftarrow \\mathsf{Mac}_k(m)$ $\\mathsf{Vrfy}$ 是确定性算法，根据输入密钥 $k$ 、消息 $m$ 和标签 $t$ ，输出一比特 $b$ ，即 $b:=\\mathsf{Vrfy}_k(m,t)$ 。若 $b=1$ 说明验证通过 消息认证实验 $\\mathsf{Mac{-}forge}_{\\mathcal{A},\\Pi}(n)$ ： $k\\leftarrow \\mathsf{Gen}(1^n)$ 敌手 $\\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\\mathsf{Mac}_k(\\cdot)$ 。敌手最终输出 $(m,t)$ 。令 $\\mathcal{Q}$ 表示 $\\mathcal{A}$ 对oracle的所有请求集合 $\\mathcal{A}$ 成功当且仅当(1). $\\mathsf{Vrfy}_k(m,t)=1$ 和(2). $m\\notin \\mathcal{Q}$ ，此时实验输出1 定义4.2：MAC算法 $\\Pi=(\\mathsf{Gen},\\mathsf{Mac},\\mathsf{Vrfy})$ 是安全的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{Mac{-}forge}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\mathsf{negl}(n) $$ 以上定义的安全的MAC算法不能抵抗重放攻击，因为它不对消息的状态进行验证，只要 $(m,t)$ 是有效的就可以通过验证 消息认证增强实验 $\\mathsf{Mac{-}sforge}_{\\mathcal{A},\\Pi}(n)$ ： $k\\leftarrow \\mathsf{Gen}(1^n)$ 敌手 $\\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\\mathsf{Mac}_k(\\cdot)$ 。敌手最终输出 $(m,t)$ 。令 $\\mathcal{Q}$ 表示所有的请求过的 $(m,t)$ 集合 $\\mathcal{A}$ 成功当且仅当(1). $\\mathsf{Vrfy}_k(m,t)=1$ 和(2). $(m,t)\\notin \\mathcal{Q}$ ，此时实验输出1 定义4.3：MAC算法 $\\Pi=(\\mathsf{Gen},\\mathsf{Mac},\\mathsf{Vrfy})$ 是强安全的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{Mac{-}sforge}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\mathsf{negl}(n) $$ 命题4.4：令 $\\Pi=(\\mathsf{Gen},\\mathsf{Mac},\\mathsf{Vrfy})$ 是一个安全的MAC算法，则它也是强安全的 4.3 构造安全MAC 固定长度MAC 构造4.5： 定理4.6：若 $F$ 是一个伪随机函数，则构造4.5对于长度为 $n$ 的消息是安全的MAC【证明on P117】 任意长度MAC 构造4.7： 定理4.8：如果 $\\Pi’$ 是安全的定长MAC，则构造4.7也是安全MAC【证明on P120】 4.4 CBC-MAC 基本构造4.11（定长CBC-MAC）： 定理4.12：令 $\\ell$ 为多项式，若 $F$ 是伪随机函数，则构造4.11是对长度为 $\\ell(n)\\cdot n$ 的消息的安全MAC 构造任意长度的CBC-MAC *安全性证明on P125，包括： 定理4.13 断言4.14 断言4.15 4.5 认证加密 定义 不可伪造加密实验 $\\mathsf{Enc{-}Forge}_{\\mathcal{A},\\Pi}(n)$ ： $k\\leftarrow \\mathsf{Gen}(1^n)$ 敌手 $\\mathcal{A}$ 得到输入 $1^n$ 并能够使用加密oracle $\\mathsf{Enc}_k(\\cdot)$ 。敌手最终输出密文 $c$ 令 $m:=\\mathsf{Dec}_k©$ ，令 $\\mathcal{Q}$ 表示 $\\mathcal{A}$ 对加密oracle的所有请求集合。实验输出1当且仅当(1) $m\\neq\\perp$ 和(2) $m\\notin \\mathcal{Q}$ 若敌手可以伪造一个密文，使其能够成功解密，则敌手获胜 定义4.16：一个对称加密方案 $\\Pi$ 是不可伪造的，如果对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{Enc{-}Forge}_{\\mathcal{A},\\Pi}(n)=1]\\leq\\mathsf{negl}(n) $$ 定义4.17：一个对称加密方案是一个认证加密方案，如果它既是CCA-安全的又是不可伪造的 一般构造 Encrypt-and-authenticate： $$ c\\leftarrow\\mathsf{Enc}{k_E}(m),,and,,t\\leftarrow\\mathsf{Mac}{k_E}(m) $$ 不能保证基本的安全性，因为MAC并没有机密性要求，从而可能泄露关于 $m$ 的信息 Authenticate-then-encrypt： $$ t\\leftarrow\\mathsf{Mac}{k_E}(m),,and,,c\\leftarrow\\mathsf{Enc}{k_E}(m||t) $$ 不能保证一定是认证加密方案，例如对于CBC模式加密，将 $t$ 看作是对消息 $m$ 的填充，则对于解密失败存在两种情况：填充错误或MAC验证失败，但只要攻击者能分辨两种错误，就可以正确解密，如3.7节最后的Padding-Oracle Attacks所示 Encrypt-then-authenticate： $$ c\\leftarrow\\mathsf{Enc}{k_E}(m),,and,,t\\leftarrow\\mathsf{Mac}{k_E}© $$ 正式构造4.18如下： 定理4.19：令 $\\Pi_E$ 是CPA-安全的对称加密方案， $\\Pi_M$ 是强安全的MAC，则构造4.18是认证加密方案【证明on P136】 Chapter 5: Hash Functions and Applications 5.1 定义 抗碰撞 定义5.1：哈希函数是一对PPT算法 $(\\mathsf{Gen},H)$ ，满足： $\\mathsf{Gen}$ 是一个概率算法，输入安全参数 $1^n$ ，输出密钥 $s$ 。假设 $1^n$ 隐含在 $s$ 中 $H$ 根据输入密钥 $s$ 和字符串 $x\\in{0,1}^*$ ，输出字符串 $Hs(x)\\in{0,1}{\\ell(n)}$ collision-finding实验 $\\mathsf{Hash{-}coll}_{\\mathcal{A},\\Pi}(n)$ ： $s\\leftarrow\\mathsf{Gen}(1^n)$ 敌手 $\\mathcal{A}$ 根据输入 $s$ 输出 $x,x’$ 实验输出1当且仅当 $x\\neq x’$ 且 $Hs(x)=Hs(x’)$ ，此时称 $\\mathcal{A}$ 找到了碰撞 定义5.2：哈希函数 $\\Pi=(\\mathsf{Gen},H)$ 是抗碰撞的，如果对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{Hash{-}coll}_{\\mathcal{A},\\Pi}(n)=1]\\leq \\mathsf{negl}(n) $$ 在实际应用中，哈希函数通常是unkeyed的，即 $H: {0,1}*\\rightarrow{0,1}\\ell$ ，从理论的角度这是不安全的，因为所有哈希函数在生成的时候就硬编码了碰撞对 $(x,x’)$ ，但是实践中找到这样的碰撞对是困难的，因此unkeyed哈希函数还是计算安全的 较弱的安全概念 弱抗碰撞性（抗第一原像）：给定 $s,x$ ，PPT敌手找到 $x’\\neq x$ 使得 $Hs(x’)=Hs(x)$ 是不可行的 单向性（抗第二原像）：给定 $s,y$ ，PPT敌手找到 $x$ 使得 $H^s(x)=y$ 是不可行的 抗碰撞 =&gt; 弱抗碰撞 =&gt; 单向 5.2 域扩张：Merkle-Damgard变换 用于将压缩函数扩展为完整的哈希函数，同时保持前者的抗碰撞性 将定长输入的哈希函数通过Merkle-Damgard变换转换为任意长度输入的哈希函数，构造5.3： 定理5.4：如果 $(\\mathsf{Gen},h)$ 是抗碰撞的，则 $(\\mathsf{Gen},H)$ 也是抗碰撞的【证明on P157】【形式化证明on 练习5.4】 5.3 使用哈希函数实现消息认证 Hash-and-MAC 构造5.5： 定理5.6：若 $\\Pi$ 是对长 $\\ell$ 的消息安全的MAC，且 $\\Pi_H$ 是抗碰撞的，则构造5.5是对任意长消息安全的MAC【证明on P160】 HMAC 构造5.7： 5.5 Random-Oracle模型 向oracle查询 $x$ 并得到输出 $y$ ，$x$ 是保密的，甚至查询oracle这个事件本身也是保密的 一致性：若对特定的输入 $x$ ，oracle输出 $y$ ，则之后再输入相同的 $x$ ，oracle仍然输出 $y$ 一些性质： 若 $x$ 没有发送到 $H$ 进行查询，则 $H(x)$ 的值是均匀随机的 即使 $x$ 不是随机的，甚至 $x$ 是已知的， $H(x)$ 的值也是均匀随机的 若 $\\mathcal{A}$ 向 $H$ 请求 $x$ ，则规约过程可以看到这个请求，也能知道 $x$ 规约过程可以设置 $H(x)$ 的值，只要这个值是均匀随机分布的 Random-Oracle实例 假设Random-Oracle将 $\\ell_{in}$ 比特输入映射为 $\\ell_{out}$ 比特输出，且 $\\ell_{in},\\ell_{out}&gt;n$ Random-Oracle作伪随机生成器（$\\ell_{in}&lt;\\ell_{out}$） $|Pr[\\mathcal{A}{H(\\cdot)}(y)=1]-Pr[\\mathcal{A}{H(\\cdot)}(H(x))=1]|\\leq \\mathsf{negl}(n)$ ，其中 $x\\in{0,1}{\\ell_{in}(n)},,y\\in{0,1}{\\ell{out}(n)}$ Random-Oracle作抗碰撞哈希函数（$\\ell_{in}&gt;\\ell_{out}$） 任何PPT敌手 $\\mathcal{A}$ 成功进行如下实验的概率可忽略： 选择随机函数 $F$ $\\mathcal{A}$ 获胜，当他输出不同的 $x,x’$ 使得 $H(x)=H(x’)$ Chapter 7: Theoretical Constructions of Symmetric-Key Primitives 7.1 单向函数 定义 逆转实验 $\\mathsf{Invert}_{\\mathcal{A},f}(n)$ ： 随机均匀选择 $x\\in{0,1}^n$ ，计算 $y:=f(x)$ $\\mathcal{A}$ 根据输入 $1^n$ 和 $y$ ，得到输出 $x’$ 当 $f(x’)=y$ 时，实验的输出为1，否则输出0 定义7.1：函数 $f:{0,1}*\\rightarrow{0,1}*$ 是单向函数，若满足： （计算简单）存在一个多项式时间算法 $M_f$ 来计算 $f$ ，即对所有 $x$ 有 $M_f(x)=f(x)$ （求逆困难）对所有PPT算法 $\\mathcal{A}$ 存在一个可忽略函数使得： $$ Pr[\\mathsf{Invert}_{\\mathcal{A},f}(n)=1]\\leq\\mathsf{negl}(n) $$ 对于2，可以将其简记为： $$ \\underset{x\\leftarrow{0,1}n}{Pr}[\\mathcal{A}(1n,f(x))\\in f^{-1}(f(x))]\\leq\\mathsf{negl}(n) $$ 定义7.2：PPT算法组成的元组 $\\Pi=(\\mathsf{Gen},\\mathsf{Samp},f)$ 是一个函数族，若满足： 参数生成算法 $\\mathsf{Gen}$ 根据输入 $1^n$ ，输出参数 $I,,|I|\\geq n$ 。$I$ 中的每一个值定义了函数 $f_I$ 的定义域 $\\mathcal{D}_I$ 和值域 $\\mathcal{R}_I$ 采样算法 $\\mathsf{Samp}$ 根据输入 $1^n$ ，输出 $\\mathcal{D}_I$ 的一个均匀分布的元素 评估算法（确定性）$f$ 根据输入 $I$ 和 $x\\in\\mathcal{D}_I$ ，输出 $y\\in\\mathcal{R}_I$ ，记作 $y:=f_I(x)$ $\\Pi$ 是一个排列族，若对所有 $\\mathsf{Gen}(1^n)$ 输出的 $I$ 的值，满足 $\\mathcal{D}_I=\\mathcal{R}_I$ 且函数 $f_I:\\mathcal{D}_I\\rightarrow\\mathcal{D}_I$ 是双射（单射且满射） 对函数族定义逆转实验 $\\mathsf{Invert}_{\\mathcal{A},\\Pi}(n)$ ： 运行 $\\mathsf{Gen}(1^n)$ 来获取 $I$ ，运行 $\\mathsf{Samp}(I)$ 来获取随机均匀 $x\\in\\mathcal{D}_I$ ，最后计算 $y:=f_I(x)$ $\\mathcal{A}$ 根据输入 $I,,y$，输出 $x’$ 当 $f(x’)=y$ 时，实验的输出为1，否则输出0 定义7.3：函数族/排列族 $\\Pi=(\\mathsf{Gen},\\mathsf{Samp},f)$ 是单向的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{Invert}_{\\mathcal{A},\\Pi}(n)=1]\\leq\\mathsf{negl}(n) $$ 硬核谓词 定义7.4：函数 $\\mathsf{hc}:{0,1}^*\\rightarrow{0,1}$ 是函数 $f$ 的硬核谓词，若 $\\mathsf{hc}$ 可以在多项式时间内计算，并且对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ \\underset{x\\leftarrow{0,1}n}{Pr}[\\mathcal{A}(1n,f(x))=\\mathsf{hc}(x)]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ $\\mathsf{hc}(x)$ 可以根据 $x$ 很容易算出，但很难根据 $f(x)$ 算出 7.2 单向函数构造伪随机 Step1：说明任何单向函数都存在硬核谓词 定理7.5（Goldreich–Levin定理）：假设单向函数存在，则存在一个单向函数 $g$ 和一个 $g$ 硬核谓词 $\\mathsf{hc}$ 具体来说，令 $f$ 是一个单向函数，可以构造 $g(x,r)\\overset{def}{=}(f(x),r),,|x|=|r|$ ，并定义： $$ \\mathsf{hc}(x,r)\\overset{def}{=}\\oplus^n_{i=1}x_i\\cdot r_i $$ Step2：说明单向排列的硬核谓词可以构造伪随机生成器 定理7.6：令 $f$ 是一个单向排列，$\\mathcal{hc}$ 是 $f$ 的硬核谓词，则 $G(s)\\overset{def}{=}f(s)||\\mathsf{hc}(s)$ 是扩张因子 $\\ell(n)=n+1$ 的伪随机生成器 定理7.7：如果存在一个扩张因子 $\\ell(n)=n+1$ 的伪随机生成器，则对任何多项式 $\\mathsf{poly}$ 存在一个扩张因子为 $\\mathsf{poly}(n)$ 伪随机生成器 Step3：根据伪随机生成器构造伪随机函数 定理7.8：如果存在一个扩张因子 $\\ell(n)=2n$ 的伪随机生成器，则存在一个伪随机函数 定理7.9：如果存在一个伪随机函数，则存在一个强伪随机排列 推论7.10：假设存在单向函数，则存在任何扩张因子的伪随机生成器，伪随机函数，强伪随机排列 推论7.11：如果存在单向函数，则存在CCA-安全的对称加密方案以及安全的MAC 7.8 计算不可区分性 定义7.30：两个概率集合 $\\mathcal{X}={X_n}{n\\in\\mathbb{N}}$ 和 $\\mathcal{Y}={Y_n}{n\\in\\mathbb{N}}$ 是计算不可区分的，记作 $\\mathcal{X}\\overset{c}{\\equiv}\\mathcal{Y}$ ，若对所有PPT判别器 $D$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ |\\underset{x\\leftarrow X_n}{Pr}[D(1^n,x)=1]-\\underset{y\\leftarrow Y_n}{Pr}[D(1^n,y)=1]|\\leq\\mathsf{negl}(n) $$ 概率集合是无穷多概率分布的序列 通常也会把 $\\underset{x\\leftarrow X_n}{Pr}[D(1^n,x)=1]$ 记作 $Pr[D(1^n,X_n)=1]$ 计算不可区分具有传递性，即：若 $\\mathcal{X}\\overset{c}{\\equiv}\\mathcal{Y},,\\mathcal{Y}\\overset{c}{\\equiv}\\mathcal{Z}$ ，则 $\\mathcal{X}\\overset{c}{\\equiv}\\mathcal{Z}$ 使用计算不可区分定义伪随机生成器——定义7.31：令 $\\ell(\\cdot)$ 是一个多项式，令 $G$ 是一个确定性多项式时间算法，且对所有 $s$ 满足 $|G(s)|=\\ell(|s|)$ 。$G$ 是伪随机生成器若满足： （扩张）对所有 $n$ 满足 $\\ell(n)&gt;n$ （伪随机）集合 ${G(U_n)}{n\\in\\mathbb{N}}$ 与 ${U{\\ell(n)}}_{n\\in\\mathbb{N}}$ 在计算上不可区分 其中 $U_n$ 代表在 ${0,1}^n$ 上的均匀分布 令 $\\mathcal{X}$ 和 $\\mathcal{Y}$ 是计算不可区分的可采样概率集合，则对所有多项式 $p$ ，集合 $\\overline{\\mathcal{X}}={(X_n{(1)},…,X_n{p(n)})}{n\\in\\mathbb{N}}$ 和 $\\overline{\\mathcal{Y}}={(Y_n{(1)},…,Y_n{p(n)})}{n\\in\\mathbb{N}}$ 计算不可区分 Chapter 10: Key Management and the Public-Key Revolution 10.3 密钥交换和Diffie-Hellman协议 密钥交换实验 $\\mathsf{KE}_{\\mathcal{A},\\Pi}^{\\mathsf{eav}}(n)$ ： 两个参与方使用 $1^n$ 来执行协议 $\\Pi$ 。协议执行完会产生一个记录 $\\mathsf{trans}$ ，包含双方交流的所有信息以及双方最终输出的密钥 $k$ 随机均匀选择 $b\\in{0,1}$ 。若 $b=0$ 则令 $\\hat{k}:=k$ ，否则随机均匀选择 $\\hat{k}\\in{0,1}^n$ $\\mathcal{A}$ 根据收到的 $\\mathsf{trans}$ 和 $\\hat{k}$ ，输出一比特 $b’$ 若 $b=b’$ 则实验输出1，否则输出0 定义10.1：密钥交换协议 $\\Pi$ 对窃听者安全，若对所有PPT敌手存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{KE}_{\\mathcal{A},\\Pi}^{\\mathsf{eav}}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 构造10.2：（Diffie-Hellman协议） 其中 $\\mathbb{G}$ 是一个循环群，$q$ 是 $\\mathbb{G}$ 的阶，$g$ 是 $\\mathbb{G}$ 的生成元 定理10.3：若 $\\mathcal{G}$ 的决策Diffie-Hellman问题是困难的，则Diffie-Hellman协议对于窃听者是安全的【证明on P368】 其中决策Diffie-Hellman问题指：任何敌手给定 $g,gx,gy$ 都不能将共享密钥 $g^{xy}$ 与随机均匀的值区分 Chapter 11: Public-Key Encryption 11.2 定义 定义11.1：公钥加密方案是一个PPT算法的三元组 $(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})$ ： $\\mathsf{Gen}$ 根据输入的安全参数 $1^n$ ，输出一对密钥 $(pk,sk)$ $\\mathsf{Enc}$ 根据输入的公钥 $pk$ 和消息 $m$ ，输出密文 $c$ ，记作 $c\\leftarrow\\mathsf{Enc}_{pk}(m)$ $\\mathsf{Dec}$ 根据输入的私钥 $sk$ 和密文 $c$ ，输出消息 $m$ 或者失败 $\\bot$ ，记作 $m:=\\mathsf{Dec}_{sk}©$ 抵抗选择明文攻击 窃听不可区分实验 $\\mathsf{PubK}^{\\mathsf{eav}}_{\\mathcal{A},\\Pi}(n)$ ： $(pk,sk)\\leftarrow\\mathsf{Gen}(1^n)$ 敌手 $\\mathcal{A}$ 获得公钥 $pk$ ，并输出一对等长的消息 $m_0,,m_1$ 随机均匀选择 $b\\in{0,1}$ ，计算 $c\\leftarrow\\mathsf{Enc}_{pk}(m_b)$ ，然后将挑战密文 $c$ 发送给 $\\mathcal{A}$ $\\mathcal{A}$ 输出 $b’$ ，若 $b=b’$ 则实验输出1（敌手成功），否则输出0 定义11.2：一个公钥加密方案 $\\Pi=(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})$ 对窃听攻击者不可区分，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{PubK}_{\\mathcal{A},\\Pi}^{\\mathsf{eav}}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 命题11.3：若一个公钥加密方案对窃听攻击者不可区分，则它也是CPA-安全的 对于公钥加密而言，任何窃听敌手都可以获得公钥来加密明文 定理11.4：确定性公钥加密方案都不是CPA安全的 多消息加密 LR-oracle实验 $\\mathsf{PubK}^{\\mathsf{LR-cpa}}_{\\mathcal{A},\\Pi}(n)$ ： $(pk,sk)\\leftarrow\\mathsf{Gen}(1^n)$ 随机均匀选择 $b\\in{0,1}$ 敌手 $\\mathcal{A}$ 获得输入 $pk$ ，并且可以访问oracle $\\mathsf{LR}_{pk,b}(\\cdot,\\cdot)$ 敌手 $\\mathcal{A}$ 输出一比特 $b’$ 若 $b=b’$ 则实验输出1（敌手成功），否则输出0 其中oracle $\\mathsf{LR}{pk,b}(\\cdot,\\cdot)$ ：输入两个等长的消息 $m_0$ ，$m_1$ ，若 $b=0$ 输出 $c\\leftarrow \\mathsf{Enc}{pk}(m_0)$ ；若 $b=1$ 输出 $c\\leftarrow \\mathsf{Enc}_{pk}(m_1)$ 定义11.5：一个公钥加密方案 $\\Pi=(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})$ 对窃听攻击者是多消息不可区分的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{PubK}_{\\mathcal{A},\\Pi}^{\\mathsf{LR-cpa}}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 定理11.6：若一个公钥加密方案是CPA-安全的，则它也是多消息不可区分的【*证明on P383】 断言11.7：$\\Pi=(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})$ 是对一比特消息进行加密的公钥加密方案，$\\Pi’=(\\mathsf{Gen’},\\mathsf{Enc’},\\mathsf{Dec’})$ 是对任意长消息进行加密的公钥加密方案，构造如下：$\\mathsf{Enc’}{pk}(m)=\\mathsf{Enc}{pk}(m_1),…,\\mathsf{Enc}{pk}(m{\\ell})$ ，其中 $m=m_1\\cdot\\cdot\\cdot m_{\\ell}$ 。则如果 $\\Pi$ 是CPA-安全的，$\\Pi’$ 也是 抵抗选择密文攻击 CCA不可区分实验 $\\mathsf{PubK}^{\\mathsf{cca}}_{\\mathcal{A},\\Pi}(n)$ ： $(pk,sk)\\leftarrow\\mathsf{Gen}(1^n)$ 敌手 $\\mathcal{A}$ 获得 $pk$ ，并且可以访问解密oracle $\\mathsf{Dec}_{sk}(\\cdot)$ 。$\\mathcal{A}$ 输出一对等长消息 $m_0,m_1$ 随机均匀选择 $b\\in{0,1}$ ，计算 $c\\leftarrow\\mathsf{Enc}_{pk}(m_b)$ 并发送给 $\\mathcal{A}$ $\\mathcal{A}$ 可以继续与解密oracle交互，但不能解密 $c$ 。最终 $\\mathcal{A}$ 输出一比特 $b’$ 若 $b=b’$ 则实验输出1（敌手成功），否则输出0 定义11.8：一个公钥加密方案 $\\Pi=(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})$ 是CCA-安全的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{PubK}_{\\mathcal{A},\\Pi}^{\\mathsf{cca}}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 若一个公钥加密方案是CCA-安全的，则它也是多消息CCA-安全的 11.3 混合加密和KEM/DEM范式 定义11.9：一个密钥封装机制（KEM）是PPT算法的三元组 $(\\mathsf{Gen},\\mathsf{Encaps},\\mathsf{Decaps})$ 使得： 密钥生成算法 $\\mathsf{Gen}$ 根据输入的安全参数 $1^n$ ，输出公私钥对 $(pk,sk)$ 密封算法 $\\mathsf{Encaps}$ 根据输入的安全参数 $1^n$ 和公钥 $pk$ ，输出密文 $c$ 和密钥 $k\\in{0,1}^{\\ell(n)}$ ，其中 $\\ell$ 是密钥长度。记作 $(c,k)\\leftarrow\\mathsf{Encaps}_{pk}(1^n)$ 确定性的解封算法 $\\mathsf{Decaps}$ 根据输入的私钥 $sk$ 和密文 $c$ ，输出密钥 $k$ 或者一个特殊符号 $\\bot$ 来表示解封失败。记作 $k:=\\mathsf{Decaps}_{sk}©$ 构造11.10： CPA-安全 令 $\\Pi=(\\mathsf{Gen},\\mathsf{Encaps},\\mathsf{Decaps})$ 是KEM，定义CPA不可区分实验 $\\mathsf{KEM}^{\\mathsf{cpa}}_{\\mathcal{A},\\Pi}(n)$ ： $(pk,sk)\\leftarrow\\mathsf{Gen}(1^n)$ ，然后 $(c,k)\\leftarrow\\mathsf{Encaps}_{pk}(1^n)$ ，其中 $k\\in{0,1}^n$ 随机均匀选择 $b\\in{0,1}$ 。若 $b=0$ 则令 $\\hat{k}:=k$ ，若 $b=1$ ，则随机均匀选择 $\\hat{k}\\in{0,1}^n$ $\\mathcal{A}$ 获得 $(pk,c,\\hat{k})$ ，并输出 $b’$ 。若 $b=b’$ 则实验输出1（敌手成功），否则输出0 定义11.11：一个KEM $\\Pi$ 是CPA-安全的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{KEM}_{\\mathcal{A},\\Pi}^{\\mathsf{cpa}}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 定理11.12：若 $\\Pi$ 是一个CPA-安全的KEM，$\\Pi’$ 是一个对窃听攻击不可区分的对称加密方案，则构造11.10中的 $\\Pi^{\\mathsf{hy}}$ 是CPA-安全的公钥加密方案【证明on P394】 CCA-安全 令 $\\Pi=(\\mathsf{Gen},\\mathsf{Encaps},\\mathsf{Decaps})$ 是KEM，定义CCA不可区分实验 $\\mathsf{KEM}^{\\mathsf{cca}}_{\\mathcal{A},\\Pi}(n)$ ： $(pk,sk)\\leftarrow\\mathsf{Gen}(1^n)$ ，然后 $(c,k)\\leftarrow\\mathsf{Encaps}_{pk}(1^n)$ ，其中 $k\\in{0,1}^n$ 随机均匀选择 $b\\in{0,1}$ 。若 $b=0$ 则令 $\\hat{k}:=k$ ，若 $b=1$ ，则随机均匀选择 $\\hat{k}\\in{0,1}^n$ $\\mathcal{A}$ 获得 $(pk,c,\\hat{k})$ 以及可以访问oracle $\\mathsf{Decaps}_{sk}(\\cdot)$ ，但不能请求解封挑战密文 $c$ $\\mathcal{A}$ 输出 $b’$ 。若 $b=b’$ 则实验输出1（敌手成功），否则输出0 定义11.13：一个KEM $\\Pi$ 是CCA-安全的，若对所有PPT敌手 $\\mathcal{A}$ 存在一个可忽略函数 $\\mathsf{negl}$ 使得： $$ Pr[\\mathsf{KEM}_{\\mathcal{A},\\Pi}^{\\mathsf{cca}}(n)=1]\\leq\\frac{1}{2}+\\mathsf{negl}(n) $$ 定理11.14：若 $\\Pi$ 是一个CCA-安全的KEM，$\\Pi’$ 是一个CCA-安全的对称加密方案，则构造11.10中的 $\\Pi^{\\mathsf{hy}}$ 是CCA-安全的公钥加密方案","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/tags/cryptography/"}]},{"title":"Markdown数学符号补充","slug":"lookup/markdown-math","date":"2022-03-18T16:00:00.000Z","updated":"2022-04-28T07:39:54.000Z","comments":true,"path":"2022/03/19/lookup/markdown-math/","link":"","permalink":"http://example.com/2022/03/19/lookup/markdown-math/","excerpt":"Markdown数学符号补充","text":"对typora-数学符号进行补充 \\overset{def}{=} $\\overset{def}{=}$ \\underset{x\\leftarrow{0,1}^n}{Pr} $ \\underset{x\\leftarrow{0,1}^n}{Pr}$","categories":[{"name":"Lookup","slug":"Lookup","permalink":"http://example.com/categories/Lookup/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]},{"title":"Linux常用命令","slug":"lookup/linux-notes","date":"2022-02-18T16:00:00.000Z","updated":"2022-11-03T06:09:18.167Z","comments":true,"path":"2022/02/19/lookup/linux-notes/","link":"","permalink":"http://example.com/2022/02/19/lookup/linux-notes/","excerpt":"Linux常用命令汇总","text":"Debug命令 查找文件位置 1sudo find / -name &lt;file_name&gt; 查看程序依赖的动态链接库 1ldd &lt;file_name&gt; Setup命令 命令行工具 使命令行工具在任意目录下都能直接使用 1sudo ln -s ~/chainmaker/chainmaker-go/tools/cmc/cmc /usr/ 测试命令 查看进程的内存占用 1234# 首先使用top命令找到指定进程的pid（top命令只显示了进程占用内存的百分比，没有具体数值）top# 根据pid打印进程所占内存，每2秒打印一次while true; do pmap -d &lt;pid&gt; | tail -1; sleep 2; done 查看当前目录下所有文件大小 1du -lh --max-depth=1 | sort -n","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Lookup","slug":"Lookup","permalink":"http://example.com/categories/Lookup/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"rust实践经验","slug":"instruction/rust-notes","date":"2022-01-31T16:00:00.000Z","updated":"2022-09-07T05:50:39.380Z","comments":true,"path":"2022/02/01/instruction/rust-notes/","link":"","permalink":"http://example.com/2022/02/01/instruction/rust-notes/","excerpt":"开发rust程序过程中遇到的问题以及解决方法","text":"开发rust程序过程中遇到的问题以及解决方法 错误处理 对于 Result、Option等类型，如果使用 unwrap、expect等方法，会直接导致panic 对于 Result 类型，如果遇到错误只需要返回 None，那么可以使用如下简单的语法来替代 match : 1let some_var = something_that_returns_result().ok()?; 其中，Result::ok() 函数将 Result 转换为 Option： 对于 Ok(val)，返回 Some(val)； 对于 Err(some_error)，返回 None ? 提取 Option 中的内容，如果为 None，则返回 None slice复制 使用copy_from_slice将一个slice的内容复制到另外一个slice时，要求两个slice的长度相同，因此对于要将[u8]转为[u8; usize]的场景，需要使用以下代码： 1234let v: Vec&lt;u8&gt; = vec![1,2,3];let vs: &amp;[u8] = v.as_slice();let mut vs2: [u8; 32] = [0; 32];vs2[..3].copy_from_slice(vs); 关于所有权 定长的变量存放在栈中，默认实现 Copy 特征，拷贝时直接在栈上复制一个副本，为浅拷贝 不定长或可变的变量存放在堆中，并将其对应的指针压入栈中，拷贝时会转移所有权，若需要原变量也保持所有权，需要进行深拷贝，即将堆中存放的数据也拷贝一份 循环 使用方法 等价使用方式 所有权 for item in collection for item in IntoIterator::into_iter(collection) 转移所有权 for item in &amp;collection for item in collection.iter() 不可变借用 for item in &amp;mut collection for item in collection.iter_mut() 可变借用 Trait 孤儿规则：如果你想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的 eg：无法在当前作用域中，为 String 类型实现 Display 特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域 调用方法需要引入特征： 12345678910111213use std::convert::TryInto;fn main() &#123; let a: i32 = 10; let b: u16 = 100; let b_ = b.try_into() .unwrap(); if a &lt; b_ &#123; println!(&quot;Ten is less than one hundred.&quot;); &#125;&#125; 特征对象： Box&lt;dyn Trait&gt; 或 &amp;dyn Trait Box::leak 需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久 eg. 可以把一个 String 类型，变成一个 'static 生命周期的 &amp;str 类型： 1234567891011fn main() &#123; let s = gen_static_str(); println!(&quot;&#123;&#125;&quot;, s);&#125;fn gen_static_str() -&gt; &amp;&#x27;static str&#123; let mut s = String::new(); s.push_str(&quot;hello, world&quot;); Box::leak(s.into_boxed_str())&#125; Stack overflow 例如定义一个跳表节点 123456struct Node &#123; skips: Vec&lt;Option&lt;*mut Node&gt;&gt;, next: Option&lt;Box&lt;Node&gt;&gt;, key: Vec&lt;u8&gt;, value: Vec&lt;u8&gt;,&#125; 若跳表中节点很多，则在drop头节点时，默认会采用递归的方式来清除，这样会导致爆栈，因此需要自定义迭代方式的drop 123456789impl Drop for Node &#123; fn drop(&amp;mut self) &#123; if let Some(mut next) = self.next.take() &#123; while let Some(n) = next.next.take() &#123; next = n; &#125; &#125; &#125;&#125;","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"go实践经验","slug":"instruction/go-notes","date":"2022-01-31T16:00:00.000Z","updated":"2022-05-02T06:35:08.000Z","comments":true,"path":"2022/02/01/instruction/go-notes/","link":"","permalink":"http://example.com/2022/02/01/instruction/go-notes/","excerpt":"开发go程序过程中遇到的问题以及解决方法","text":"开发go程序过程中遇到的问题以及解决方法 hash 使用 crypto.sha256 可以获得文件哈希： 12345678910111213fileName := &quot;main.go&quot;file, err := os.Open(fileName)if err != nil &#123; log.Fatal(err)&#125;defer file.Close()hash := sha256.New()if _, err = io.Copy(hash, file); err != nil &#123; log.Fatal(err)&#125;sum := hash.Sum(nil)fmt.Printf(&quot;Sum: %x\\n&quot;, sum) 最终得到的哈希值 sum 的类型是 []byte ，若想要得到 string 类型的哈希值不能通过 string(sum) 的方式强制转换，而需要使用以下方法转换： 1hash := hex.EncodeToString(sum) json 使用 json.Marshal 方法可以将 struct 转换为字符串，但其中的特殊html字符会被转义成unicode，例如 &amp; 会被转义为 \\u0026 ，若不想被转义，则需要通过以下方法转换： 123456bf := bytes.NewBuffer([]byte&#123;&#125;)jsonEncoder := json.NewEncoder(bf)jsonEncoder.SetEscapeHTML(false)jsonEncoder.Encode(fdata.Data)fileData := bf.String()fmt.Println(f) slice 拷贝 切片是底层数组的视图，实际指向一段地址 eg. 在将arr放入res，底层是将指向arr切片地址的指针放入res中。若不改变arr大小，仅改变arr中元素的值，会导致之前放入res中的arr产生变化（在递归中会碰到这样的问题） 123456789101112arr := []int&#123;1,2,3&#125;res := [][]int&#123;&#125;res = append(res, arr)// 改变arr中的值，不做扩容arr[2] = 4res = append(res, arr)// arr扩容arr = append(arr, 5)res = append(res, arr)fmt.Println(res)// 输出：[[1 2 4] [1 2 4] [1 2 4 5]] 正确的做法是进行深拷贝： 123456789101112131415161718arr := []int&#123;1,2,3&#125;res := [][]int&#123;&#125;tmp := make([]int, len(arr))copy(tmp, arr)res = append(res, tmp)// 改变arr中的值，不做扩容arr[2] = 4tmp = make([]int, len(arr))copy(tmp, arr)res = append(res, tmp)// arr扩容arr = append(arr, 5)tmp = make([]int, len(arr))copy(tmp, arr)res = append(res, tmp)fmt.Println(res)// 输出：[[1 2 3] [1 2 4] [1 2 4 5]] 垃圾回收 底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个slice的小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收 例如假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）： 12var a []*int&#123; ... &#125;a = a[:len(a)-1] // 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍 修复如下： 123var a []*int&#123; ... &#125;a[len(a)-1] = nil // GC回收最后一个元素内存a = a[:len(a)-1] // 从切片删除最后一个元素 另外，若对于一个很大的临时数组，只需要读取其中的一小部分，读取后整个数组不再需要放在var内存中，则应该传值到一个新的数组，而不是直接使用slice引用： 123var bigArr []int&#123; ... &#125;a := append([]int&#123;&#125;, bigArr[1:3]...) map 拷贝 与slice类似，map也是一个指针，若要进行深拷贝，需要对逐个键值对进行拷贝： 1234567891011m := map[int]string&#123;1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;&#125;mCopy := map[int]string&#123;&#125;for k, v := range m &#123; mCopy[k] = v&#125;m[4] = &quot;d&quot;fmt.Println(m)fmt.Println(mCopy)// 输出：map[1:a 2:b 3:c 4:d]// map[1:a 2:b 3:c] package 同一目录下的同级文件属于一个包，main.go可以直接调用其他文件中的函数，但是在运行的时候需要使用 go run .","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Go","slug":"Go","permalink":"http://example.com/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"}]},{"title":"Chainmaker相关命令","slug":"lookup/chainmaker-commands","date":"2021-12-02T16:00:00.000Z","updated":"2022-04-28T07:37:24.000Z","comments":true,"path":"2021/12/03/lookup/chainmaker-commands/","link":"","permalink":"http://example.com/2021/12/03/lookup/chainmaker-commands/","excerpt":"Chainmaker相关命令","text":"启动、关闭链 启动链 12cd ~/chainmaker/chainmaker-go/scripts./cluster_quick_start.sh normal 各节点的初始状态文件保存在 ~/chainmaker/chainmaker-go/buid/release 中的压缩文件，启动脚本会将其解压，为了保证链的状态不被覆盖，将压缩文件备份： 12mkdir -p ../build/bakmv ../build/release/*.tar.gz ../build/bak 若要重新初始化链，只用将备份的文件重新放回release目录，再启动链： 1234rm -rf ../build/release/*cp ../build/bak/* ../build/release./cluster_quick_start.sh normalrm ../build/release/*.tar.gz 关闭链 1./cluster_quick_stop.sh 查看节点启动使用正常 查看进程是否存在 1ps -ef|grep chainmaker | grep -v grep 看端口是否监听 1netstat -lptn | grep &quot;1230\\|1130&quot; 检查节点是否有ERROR日志 12345cat $HOME/chainmaker/chainmaker-go/build/release/chainmaker-v2.0.0-wx-org1.chainmaker.org/bin/panic.logtail -f $HOME/chainmaker/chainmaker-go/build/release/chainmaker-v2.0.0-wx-org1.chainmaker.org/log/system.logtail -f $HOME/chainmaker/chainmaker-go/build/release/chainmaker-v2.0.0-wx-org1.chainmaker.org/log/system.log|grep &quot;ERROR\\|put block\\|all necessary&quot; 使用Docker镜像进行合约开发 后台启动docker镜像并进入容器内部 1docker run -it --name chainmaker-rust-contract -v $HOME/chainmaker/contract:/home chainmakerofficial/chainmaker-rust-contract:2.1.0 bash 关闭容器后再次进入 123456# 启动容器docker start chainmaker-rust-contract# 进入容器命令行docker exec -it chainmaker-rust-contract bash# 关闭容器docker stop chainmaker-rust-contract 命令行创建wasm合约 12345678910cmc client contract user create \\--contract-name=fact \\--runtime-type=WASMER \\--byte-code-path=./testdata/contract/chainmaker_contract.wasm \\--version=1.0 \\--sdk-conf-path=./testdata/sdk_config.yml \\--admin-key-file-paths=./testdata/crypto-config/wx-org1.chainmaker.org/user/admin1/admin1.tls.key,./testdata/crypto-config/wx-org2.chainmaker.org/user/admin1/admin1.tls.key,./testdata/crypto-config/wx-org3.chainmaker.org/user/admin1/admin1.tls.key \\--admin-crt-file-paths=./testdata/crypto-config/wx-org1.chainmaker.org/user/admin1/admin1.tls.crt,./testdata/crypto-config/wx-org2.chainmaker.org/user/admin1/admin1.tls.crt,./testdata/crypto-config/wx-org3.chainmaker.org/user/admin1/admin1.tls.crt \\--sync-result=true \\--params=&quot;&#123;&#125;&quot; 命令行调用wasm合约 123456cmc client contract user invoke \\--contract-name=fact \\--method=save \\--sdk-conf-path=./testdata/sdk_config.yml \\--params=&quot;&#123;\\&quot;file_name\\&quot;:\\&quot;name007\\&quot;,\\&quot;file_hash\\&quot;:\\&quot;ab3456df5799b87c77e7f88\\&quot;,\\&quot;time\\&quot;:\\&quot;6543234\\&quot;&#125;&quot; \\--sync-result=true","categories":[{"name":"Lookup","slug":"Lookup","permalink":"http://example.com/categories/Lookup/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"frp配置","slug":"instruction/frp-setup","date":"2021-11-03T16:00:00.000Z","updated":"2022-12-19T03:40:23.711Z","comments":true,"path":"2021/11/04/instruction/frp-setup/","link":"","permalink":"http://example.com/2021/11/04/instruction/frp-setup/","excerpt":"frp配置","text":"frp安装 下载：https://github.com/fatedier/frp/releases frp配置 服务端 frps.ini 1234567[common]bind_port = 7000token = 12345678# 可在本地通过 ServerIP:7500 查看服务端情况dashboard_user = rootdashboard_pwd = rootdashboard_port = 7500 提供服务的内网机器 frpc.ini 12345678910[common]server_addr = ServerIPserver_port = 7000token = 12345678[secret_ssh]type = stcpsk = 自定义密钥，与下面一致local_ip = 127.0.0.1local_port = 22 注：需要开启22端口，检测方式： 1ssh root@127.0.0.1 访问服务的机器 frpc.ini 123456789101112[common]server_addr = ServerIPserver_port = 7000token = 12345678[secret_ssh_visitor]type = stcprole = visitorserver_name = secret_sshsk = 自定义密钥，与上面一致bind_addr = 127.0.0.1bind_port = 6000 访问内网机器 服务端 Debian (后台运行) 1nohup ./frps -c frps.ini &amp; 内网机器 Ubuntu 1./frpc -c frpc.ini 若要开机自启则需要使用 systemd，参考使用 systemd | frp (gofrp.org) 访问Ubuntu的机器 Windows (写个bat文件方便直接启动) 1frpc.exe -c frpc.ini 在Windows上使用ssh连接 1ssh -oPort=6000 schenk@127.0.0.1 注：连接后需要手动使.bashrc生效 1source ~/.bashrc","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"v2ray配置","slug":"discard/v2ray","date":"2021-10-29T16:00:00.000Z","updated":"2022-04-28T07:09:40.000Z","comments":true,"path":"2021/10/30/discard/v2ray/","link":"","permalink":"http://example.com/2021/10/30/discard/v2ray/","excerpt":"v2ray配置","text":"Debian 9服务端配置 安装v2ray 1234apt install ntp -yapt-get update -y &amp;&amp; apt-get install curl -ybash &lt;(curl -s -L https://git.io/v2ray.sh)v2ray url # generate vmess url 放行端口 iptables 12345iptables -I INPUT -p tcp --dport &lt;port&gt; -j ACCEPTiptables-saveapt-get install iptables-persistentnetfilter-persistent savenetfilter-persistent reload ufw 123ufw statusufw allow &lt;port&gt;ufw reload Windows客户端 https://github.com/2dust/v2rayN/releases/latest Android客户端 https://github.com/2dust/v2rayNG/releases Linux客户端 https://github.com/jiangxufeng/v2rayL","categories":[],"tags":[]},{"title":"SGX移植crate","slug":"instruction/sgx移植","date":"2021-10-24T16:00:00.000Z","updated":"2022-04-28T07:21:52.000Z","comments":true,"path":"2021/10/25/instruction/sgx移植/","link":"","permalink":"http://example.com/2021/10/25/instruction/sgx%E7%A7%BB%E6%A4%8D/","excerpt":"将Rust Crate移植到SGX中","text":"总流程 12345678910111213141516def 移植(self): if self支持 no_std then 不用修改，直接在依赖处配置好 no_std 的 features return # 移植依赖项 (忽略dev-dependencies） for each dep of self.dependencies 移植 dep # 移植自身 (1) wget 库代码 &amp;&amp; tar xzf (2) 编辑 Cargo.toml 修改每个依赖项为移植后的依赖项 (3) 编辑 src&#x2F;lib.rs 添加特定header（见后文） (4) 编辑每个源文件 添加 use std::prelude::v1::*; (5) 仔细review每个使用 fs&#x2F;path&#x2F;net&#x2F;time&#x2F;env 等不可信输入的地方，修正那里的逻辑 (6) 检查每个 platform dependent 的 feature，将其固定为只适用于 linux-x86_64 的逻辑（因为 linux-SGX 就只有这个环境） (7) 测试 &#96;cargo build&#96; 是否通过 return 下载crate 123456https://crates.io/api/v1/crates/&lt;库名&gt;/&lt;版本号&gt;/downloadhttps://crates.io/api/v1/crates/iter-enum/1.0.1/downloadhttps://crates.io/api/v1/crates/pin-project/1.0.8/downloadhttps://crates.io/api/v1/crates/strum_macros/0.21.1/downloadhttps://crates.io/api/v1/crates/thiserror/1.0.30/download 查看依赖 1cargo tree 检查依赖关系 1grep -R &lt;lib&gt; cargo.toml 12345[target.&#x27;cfg(not(target_env = &quot;sgx&quot;))&#x27;.dependencies]sgx_tstd = &#123; rev = &quot;v1.1.3&quot;, git = &quot;https://github.com/apache/teaclave-sgx-sdk.git&quot; &#125;# 引用已移植的cratebyteorder = &#123; git = &quot;https://github.com/mesalock-linux/byteorder-sgx&quot; &#125; lib.rs 123456#![cfg_attr(all(feature = &quot;mesalock_sgx&quot;, not(target_env = &quot;sgx&quot;)), no_std)]#![cfg_attr(all(target_env = &quot;sgx&quot;, target_vendor = &quot;mesalock&quot;), feature(rustc_private))]#[cfg(all(feature = &quot;mesalock_sgx&quot;, not(target_env = &quot;sgx&quot;)))]#[macro_use]extern crate sgx_tstd as std; 每一个.rs文件添加 (包括lib.rs)，若编译时报Warning再对照着删除 1use std::prelude::v1::*; 常见错误 编译时出现： 1234567error[E0432]: unresolved import `core::alloc::AllocRef` --&gt; /home/schenk/.cargo/git/checkouts/teaclave-sgx-sdk-be25c2ad2f03718d/a6a172e/sgx_alloc/src/system.rs:26:17 |26 | AllocError, AllocRef, GlobalAlloc, Layout, | ^^^^^^^^ no `AllocRef` in `alloc`error: aborting due to previous error 说明rustup toolchain选择有问题，使用命令修改toolchain能通过编译: 1rustup override set nightly-2020-10-25-x86_64-unknown-linux-gnu 编译时出现： 12345error: duplicate lang item in crate `std`: `f32_runtime`. | = note: the lang item is first defined in crate `sgx_tstd` (which `helloworldsampleenclave` depends on) = note: first definition in `sgx_tstd` loaded from /home/schenk/sgx/workspace/sgx-test/enclave/target/release/deps/libsgx_tstd-c10171ffd7c558b5.rlib = note: second definition in `std` loaded from /home/schenk/.rustup/toolchains/nightly-2020-10-25-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-3010daceac92f8fa.so, /home/schenk/.rustup/toolchains/nightly-2020-10-25-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-3010daceac92f8fa.rlib 很有可能是因为在这个错误之前出现了其他错误，例如变量未定义等： 123456error[E0425]: cannot find value `sealed_log` in this scope --&gt; src/lib.rs:143:14 |143 | &amp;sealed_log, | ^^^^^^^^^^ not found in this scope 应当先修复其他的错误 notes cfg 12// 条件编译，如果同时满足feature是&quot;mesalock_sgx&quot; 和 target_env不是&quot;sgx&quot;，则编译#[cfg(all(feature = &quot;mesalock_sgx&quot;, not(target_env = &quot;sgx&quot;)))] cfg_attr 12// 如果满足all(feature = &quot;mesalock_sgx&quot;, not(target_env = &quot;sgx&quot;))，则相当于 ![cfg(no_std)]#![cfg_attr(all(feature = &quot;mesalock_sgx&quot;, not(target_env = &quot;sgx&quot;)), no_std)] .toml features 123456# crate本来就没有features的话不用改# 否则在default中加入&quot;mesalock_sgx&quot;，并添加feature mesalock_sgx，在其中加入在crate中引入的&quot;sgx_*&quot;[features]default = [&quot;linkage&quot;, &quot;mesalock_sgx&quot;]linkage = [&quot;sqlite3-src&quot;]mesalock_sgx = [&quot;sgx_tstd&quot;, &quot;sgx_libc&quot;] target.xxx.dependencies：满足xxx条件时的依赖","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Ubuntu连接PEAP网络","slug":"instruction/ubuntu-peap","date":"2021-10-21T16:00:00.000Z","updated":"2022-04-28T07:22:14.000Z","comments":true,"path":"2021/10/22/instruction/ubuntu-peap/","link":"","permalink":"http://example.com/2021/10/22/instruction/ubuntu-peap/","excerpt":"Ubuntu连接PEAP网络,以SJTU校园网为例","text":"创建配置文件： 12cd /etc/NetworkManager/system-connectionssudo gedit SJTU 在SJTU配置文件中添加内容： 1234567891011121314151617181920212223242526[connection]id&#x3D;SJTUuuid&#x3D;9e123fbc-0123-46e3-97b5-f3214e123456 # uniquetype&#x3D;802-11-wireless[802-11-wireless-security]key-mgmt&#x3D;wpa-eapauth-alg&#x3D;open[802-11-wireless]ssid&#x3D;SJTUmode&#x3D;infrastructuremac-address&#x3D;&lt;MAC address&gt;security&#x3D;802-11-wireless-security[802-1x]eap&#x3D;peap;identity&#x3D;&lt;username&gt;phase2-auth&#x3D;mschapv2password&#x3D;&lt;password&gt;[ipv6]method&#x3D;auto[ipv4]method&#x3D;auto 连接SJTU网络：","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"论文阅读-Secure Multiparty Computation from SGX","slug":"paper-reading/paper-secure-mpc","date":"2021-08-15T16:00:00.000Z","updated":"2022-07-20T03:52:52.905Z","comments":true,"path":"2021/08/16/paper-reading/paper-secure-mpc/","link":"","permalink":"http://example.com/2021/08/16/paper-reading/paper-secure-mpc/","excerpt":"论文Secure Multiparty Computation from SGX阅读笔记","text":"1.Introduction 使用可信硬件实现MPC协议需要克服： 用户和远程机器之间缺乏专用通道 在异步通信以及仅有TEE介入的条件下对计算进行身份验证/达成一致 确保“正确”的各方参与计算 处理共存于同一TEE、共享内存空间的代码之间的交互，每段代码可能对应不同的用户 确保TEE内部运行的代码不会向外部泄露敏感信息 1.1 贡献 通用安全多方计算 一个高效的安全多方计算协议（非交互式） 加载进TEE的代码先执行密钥交换，再通过秘密信道执行任意函数 $F$ 标记验证计算LAC 经过验证的输出为计算序列提供完整性保护，输出的完整性可以进行公开验证 为输入添加标签，并将对应于特定标签的输入和输出绑定 对LAC进行正式建模，通过LAC原语将任意程序部署到TEE LAC可用于更多的依赖TEE的安全协议的模块化分析 实现和实验 两个实现： sgx-mpc-mbed ：依赖TLS库，使用RSA进行密钥交换 sgx-mpc-nacl ：依赖NaCl密码学库，使用椭圆曲线密码进行密钥交换和数字签名 3.TEE程序与机器 TEE程序 抽象为编程语言 $L$ ，包含TEE系统调用 TEE中的系统调用结果只能依赖于: 程序加载时定义的初始共享状态 显式传递的输入 新鲜的随机硬币","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"论文阅读-TZ4Fabric. Executing Smart Contracts with ARM TrustZone","slug":"paper-reading/paper-TZ4Fabric","date":"2021-06-12T16:00:00.000Z","updated":"2022-04-28T07:43:26.000Z","comments":true,"path":"2021/06/13/paper-reading/paper-TZ4Fabric/","link":"","permalink":"http://example.com/2021/06/13/paper-reading/paper-TZ4Fabric/","excerpt":"论文TZ4Fabric. Executing Smart Contracts with ARM TrustZone阅读笔记","text":"1.引入 Hyperledger Fabric私有链码（FPC）是一个开源项目，它使通道上的节点（区块链网络中节点的子集）在TEE内执行智能合约，特别是在Intel SGX Enclave内。由于物联网设备大多体积小，可能由电池供电，并嵌入低功耗处理器，FPC不容易在这种情况下部署，这极大地阻碍了其在论文的目标部署场景中的适用性。 Fig1描述了论文预想的部署场景：一个异构的、可能分布的节点集合加入了区块链；智能合约必须跨通道执行，只有少数节点受到保护，免受攻击。例如，攻击者可以破坏一个通道，获得对其节点的访问权并收集敏感信息。为了遏制攻击并防止攻击传播到其他通道，某些通道的智能合约可以在TEE内执行。受到TEE保护的节点可以免受恶意攻击，特别是作为物联网设备部署在“野外”的节点更容易受到此类攻击。 本论文提出了结合ARM TZ的Hyperledger Fabric链码执行的原型系统TZ4Fabric。TZ4Fabric体系结构受到FPC的启发，但它隔离了TEE组件。该设计不仅可以利用ARM TZ，还可以TZ4Fabric扩展到未来的TEE。 2.背景 区块链和智能合约 在许可的区块链中(如Ripple和Hyperledger Fabric)，网络的访问是受限制的，实体是已知的。 Hyperledger Fabric (HF)是一个支持智能合约的许可区块链，在HF中，智能合约称为链码。Fig2给出了HF的高层架构和工作流程，在链码函数被调用之前，它必须被安装(存储在文件系统上)并在对等端实例化。 1、2：客户端应用向对等端发送请求（交易提出），来调用链码函数；对等端执行链码函数 3：对等端向客户端发送交易响应，交易响应由对等端签名，并包含执行响应消息以及读集合和写集合，读集合代表对等端在执行期间通过 GetState 从账本中查询到的所有键值，写集合包含对等端通过 PutState 生成的所有键值对更新 4：当客户端收集了由认可策略定义的足够多的交易响应时，将它们发送给排序端，排序端将交易响应放入区块，并将它们分发给所有对等端，这是排序阶段。之后在验证阶段，每个对等端检查是否满足认可策略以及不同交易的读和写是否由冲突，然后就把交易写在账本上，账本包含两个促成部分：一个区块链和一个世界状态，世界状态是一个可插拔的数据库，用于存储和有效检索区块链中的键的当前值 ARM TrustZone 提供硬件组件，用于在ARM处理器上启用TEE。OP-TEE是一个流行的开源运行时，支持ARM TZ。ARM TZ的安全世界和正常世界的切换是通过安全监控呼叫(SMC)进行的。系统资源是严格隔离的：正常世界不能访问安全世界的资源(如内存、外设等)。在安全世界的引导过程中，将建立信任链，并对安全世界的软件映像进行完整性检查——这个过程称为安全引导。 3.威胁模型 考虑一个强大的攻击者，他拥有管理权限，并且可以物理访问所有支持ARM TZ的节点。进一步假设操作系统和用户空间在正常情况下是不可信的。但是假定TEE(包括引导加载程序、固件、OP-TEE和安全监视器)是可信的。 由于ARM TZ本身并不支持远程认证机制，因此攻击者可能会在协议执行之前试图破坏它。链码在正常情况下作为可信应用程序(TA)存储，并使用构建密钥进行签名。ARM TZ在运行时不提供完整性保护。本论文不考虑侧信道攻击。 4.TZ4Fabric架构 支持ARM TZ的设备通常是低功耗嵌入式设备，其中许多都是由电池供电的，它们资源（存储和内存）有限。TZ4Fabric依赖于Go编程语言环境、HF、OP-TEE以及gRPC等包，这些包不仅需要几百兆的持久存储，而且在运行时也需要几百兆的内存，因此论文提出通过代理将大型系统组件(如HF和Docker)与轻量级安全相关组件(如链码)解耦。 在设计中，链码操作及其响应中可以包含敏感信息，必须保护这些信息免受恶意攻击。因此，将链码存放到一个支持TEE的嵌入式设备。将TZ4Fabric分为三大组件：作为链码驻留在对等端上的包装器、代理、链码本身。包装器通过gRPC和代理通信，代理和链码运行在基于ARM的环境中，并使用TrustZone，其中代理在正常世界，链码在安全世界。论文的设计利用OP-TEE框架来进行代理和链码之间的交互。 包装器被安装和实例化为链码，并被用作对等端和账本的接口。它将来自客户端的输入调用转发到安全世界中的链码，处理与账本的通信，并将交易响应发送回对等端。 代理充当中介，在包装器和链码之间转发调用。它负责从正常世界到安全世界的上下文切换。 链码实现了区块链应用程序逻辑，并由客户端通过包装器调用。在执行过程中，链码可以使用代理通过 getState 和 putState 命令访问账本。 论文的设计允许在一个单一的安全世界中实例化和运行多个链码。 论文的原型侧重于在HF中包含ARM TZ，而没有实现一个机制在网络中复制链码。链码在原型中作为OP-TEE中的TAs执行，链码使用与机器上运行的OP-TEE相同的构建系统进行编译，TA使用原始的构建密钥进行签名，并可选地加密。因此，在调用链码之前，必须将每个链码编译到TA并在目标机器上安装，然后，链码可以在目标机器上复制并直接调用，而不必经过生成TA的过程。在原型中，为链码生成了一个TA，并将其部署在所有启用ARM TZ的代理上。","categories":[{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"论文阅读-Ekiden. A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts","slug":"paper-reading/paper-Ekiden","date":"2021-06-12T16:00:00.000Z","updated":"2022-07-20T03:49:41.282Z","comments":true,"path":"2021/06/13/paper-reading/paper-Ekiden/","link":"","permalink":"http://example.com/2021/06/13/paper-reading/paper-Ekiden/","excerpt":"论文Ekiden. A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts阅读笔记","text":"1.引入 现有的智能合约系统因此缺乏保密性和隐私性，它们不能安全地存储或计算敏感数据；区块链共识需求也使得智能合约在计算能力、存储容量和事务吞吐量方面的性能低下。 区块链和TEE有互补特性： 区块链可以保证强可用性和持久性，而TEE不能保证可用性（因为宿主可以自行决定终止TEE），也不能可靠地访问网络或持久性存储 区块链的计算能力非常有限，必须公开其整个状态以供公共验证，而TEE与本地计算相比产生的开销很小，并通过远程认证提供具有机密性的可验证计算 区块链和TEE结合会产生新的安全问题：由于TEE的基本限制是恶意主机可以任意操纵它的调度和I/O，TEE可能在任意时间中止，导致区块链上丢失和冲突的状态。TEE缺少可信时钟，因此很难更新到区块链的最新状态。可能存在的攻击例如针对区块链的完整性攻击危及TEE保护内容的机密性（如，攻击者可以通过提供一个伪造的区块链来绕过TEE强制执行的隐私计算，以退回到执行前并向其请求任意多个查询） Ekiden采用计算与共识分离的架构。Ekiden在链下的TEE中使用计算节点执行私有数据的智能合约计算（避免了链上计算负担），然后验证它们在链上的正确执行，而区块链上的共识节点不需要使用TEE。Ekiden与共识机制无关，只需要一个能够验证来自计算节点的远程认证的区块链。 为了解决TEE的可用性和网络安全限制，Ekiden支持链上检查和合约状态存储。 主要贡献 正式安全建模：使用一个理想的功能$F_{Ekiden}$来表达Ekiden的全部安全需求，在通用可组合性(UC)框架中概述安全性证明，表明Ekiden协议在并发组合下与$F_{Ekiden}$匹配； TEE-区块链结合方案：系统地列举了区块链和TEE融合产生的基本缺陷，并提供了克服这些缺陷的通用技术； 性能：区块链可能是TEE-区块链混合系统的性能瓶颈。论文提供了优化，在不降低安全性的情况下最小化区块链的使用。 2.背景 智能合约 智能合约系统的限制： 对每个节点都完全复制的智能合约进行链上计算很昂贵 传统的智能合约系统不提供隐私保护，用户由假名区别，但是假名只提供很弱的隐私保护 合约状态和用户输入必须是公开的，以便矿工验证正确的计算，缺乏隐私 可信硬件 SGX生成的认证是不可伪造的 单单SGX不能保证可用性（恶意主机可以任意终止Enclave或丢弃消息） SGX容易遭受侧信道攻击 3.TEE-区块链系统的技术挑战 容忍TEE故障 可用性故障 在SGX中，恶意主机可以终止Enclave，即使是诚实主机也可能在电源循环中丢失Enclave。TEE-区块链系统必须能够容忍这样的主机故障，确保崩溃的TEE可以延迟执行。 论文将TEE视为可消耗和可互换的，依赖区块链来解决并发性导致的任何冲突。为了确保任何特定的TEE很容易被替换，TEE是无状态的，并且任何持久状态都由区块链存储。 侧信道 为了对付SGX的侧信道攻击，论文采用的方法是在空间和时间上进行划分，针对强敌手模型设计Ekiden中的关键组件，如密钥管理器，允许攻击者打破一小部分TEE的机密性，并限制其他组件对密钥管理器的访问。另外还采用了主动密钥旋转来限制泄漏密钥的权限。 时钟故障 SGX的时钟不可信，一个TEE-区块链混合协议必须尽量减少对TEE时钟的依赖。 在论文的设计中，不需要TEE拥有当前区块链的状态。具体来说，不需要TEE来区分陈旧状态和当前状态，而依赖于区块链主动拒绝任何陈旧输入状态的更新。 PoW区块链的发布证明 为了利用区块链作为持久存储，TEE必须能够有效地验证一个项目已经存储在区块链中，同时TEE也需要能够验证新块。这就需要一个可信时钟来防止敌手隔离Enclave而提供一个无效的子链。 论文利用了TEE的保密性，这样延迟时钟响应的攻击者就不能阻止Enclave成功验证区块链内容。 TEE中的密钥管理 使用区块链持久化TEE状态的一个基本限制是缺乏保密性。通常可以通过在多个TEE中保存相同的密钥副本来实现密钥存储，虽然这种方法能很好地抵抗状态丢失，但是会造成更大的攻击面，在可用性和暴露风险之间需要权衡。 论文针对强敌手模型设计密钥管理器，允许攻击者打破一小部分TEE的机密性，并限制其他组件对密钥管理器的访问。 执行结果的原子性交付 通常，对于有状态的TEE-区块链协议，TEE的执行产生两个消息： $m_1$：向调用者发送输出结果 $m_2$：向区块链发送状态更新 这两个消息必须原子性交付，要么都交付成功，有一个交付失败则系统不可用：$m_1$ 在调用者收到时交付成功，$m_2$ 在区块链接受时交付成功，被拒绝的状态更新不是交付成功。 若不要求两个消息的原子性交付，可能产生的攻击有： 如果只有 $m_1$ 被交付，可能会产生倒回攻击，由于TEE不能判断输入状态是否为新状态，因此攻击者可以提供旧状态以从旧状态恢复TEE的执行，直到获得想要的结果（公平性）； 如果只有 $m_2$ 被交付，用户可能永久丢失输出，因为一般不可能根据更新后的状态来重新产生相同的输出 4.Ekiden概述 为了支持像信用评分这样的大规模隐私敏感应用程序，智能合约系统满足数据机密性保护以及高性能的同时要保持区块链提供的完整性和可用性。 Ekiden概述 Ekiden实现了用户自定义智能合约的安全执行环境，Ekiden合约是一个确定性的有状态程序。将合约程序的形式定义为 $(outp,st_{new}):=Contract(st_{old},inp)$ ，其中合约的输入是 $st_{old}$（前一个状态）和 $inp$（用户输入），生成输出 $outp$ 和新状态 $st_{new}$。 一旦部署在Ekiden上，智能合约就有了强大的保密性、完整性和可用性保证。在Ekiden中，有三种实体： 客户是智能合约的用户，在Ekiden中，客户可以通过秘密输入创建合同或执行现有的合同。无论哪种情况，客户机都将计算委托给计算节点； 计算节点在合约TEE中执行合约并且生成用于证明状态更新正确性的证明，从而处理客户的请求。一组计算节点组成一个密钥管理委员会，并运行一个分布式协议来管理合约TEE使用的密钥，合约TEE通过密钥管理委员会来创建或恢复密钥； 共识节点构成区块链，合约状态和认证都保存在这个区块链上。共识节点负责使用TEE检查状态更新的有效性。 工作流程 简单起见，假设客户拥有使用的计算节点的优先级列表，客户记为 $P$ ，计算节点记为 $Comp$。 合约创建 创建合约时，$P$ 将合约代码 $contract$ 发送给 $Comp$，$Comp$ 将 $Contract$ 加载到合约TEE中，合约TEE创建一个新鲜的合约id $cid$，从密钥管理委员会获取新鲜的 $(pk{in}_{cid},sk{in}{cid})$ 对和 $k{cid}^{state}$ 并生成加密的初始状态 $Enc(k^{state}{cid},\\vec{0})$ 和一个证明 $\\sigma{TEE}$（用于证明TEE初始化的正确性以及 $pk_{cid}^{in}$ 是对应于合约 $cid$ 的公钥）。 最后，$Comp$ 从认证服务获取 $\\sigma_{TEE}$ 的正确性证明，该证明和 $\\sigma_{TEE}$ 绑定到一个“certified”证明 $\\pi$ 中。$Comp$ 接着发送 $(Contract,pk{in}_{cid},Enc(k{state}_{cid},\\vec{0}),\\pi)$ 到共识节点。 合约创建的完整协议由Fig2的 $Prot_{Ekiden}$ 中的 create 表示。 请求执行 描述Fig1的过程： (1) 为了使用输入 $inp$ 来执行合约 $cid$ ，$P$ 首先从区块链获取与合约 $cid$ 相关联的 $pk_{cid}^{in}$ ，计算 $inp_{ct}=Enc(pk^{in}{cid},inp)$ ，并将消息 $(cid,inp{ct})$ 发送给 $Comp$ 。如 $Prot_{Ekiden}$ 的Line8-11所示。 (2) $Comp$ 从区块链取出合约代码，以及合约 $cid$ 的加密过去状态 $st_{ct}=Enc(k^{state}{cid},st{old})$ ，并将 $st_{ct}$ 和 $inp_{ct}$ 加载到TEE中执行。 如 $Prot_{Ekiden}$ 的Line30-33所示。 (3-4) 合约TEE从密钥管理委员会获取 $k_{cid}^{state}$ 和 $sk^{in}{cid}$ ，并使用它们解密 $st{ct}$ 和 $inp_{ct}$ 。从而生成输出 $outp$ ，一个新的加密状态 $st{'}_{ct}=Enc(k_{cid}{state},st_{new})$ 和一个用于证明计算正确的签名 $\\pi$ 。如 $Prot_{Ekiden}$ 的Line7-13所示。 (5a, 5b) 最后，$Comp$ 和 $P$ 执行一个原子交付协议，将 $outp$ 交付给 $P$ ，并将 $(st^{'}{ct},\\pi)$ 交付给共识节点。共识节点先验证 $\\pi$ 再接受新状态 $st^{'}{ct}$ 并将其存放在区块链上，只有在这之后，$P$ 才能接收到 $outp$ 。 Ekiden将请求执行与共识解耦。在以太坊中，请求执行被网络中的所有节点复制以达成共识，使得整个网络的速度和单个节点一样慢。而在Ekiden中，请求只被K个计算节点执行，K通常比较小，共识节点只需要验证K个正确执行的证明。 论文的实现中，使用签名 $\\pi$ 来作为TEE正确执行的证明。一个计算节点 $Comp$ 通过如下方式获得签名 $\\pi$ 。假设 $Comp$ 执行结果为一个输出 $st^{‘}{ct}$ 和一个证明 $\\sigma{TEE}$（对合约代码和 $st^{’}{ct}$ 的签名），$Comp$ 将 $\\sigma{TEE}$ 发送到IAS，IAS验证 $\\sigma_{TEE}$ 并回复 $\\pi=(b,\\sigma_{TEE},\\sigma_{IAS})$ ，其中 $b\\in{0,1}$ 表明 $\\sigma_{TEE}$ 的有效性，$\\sigma_{IAS}$ 是IAS对 $b$ 和 $\\sigma_{TEE}$ 的签名。然后 $\\pi$ 被提交到共识节点作为 $st^{'}_{ct}$ 正确性的证明。 Ekiden安全目标 正确执行：合约状态转换反映了合约代码在给定状态和输入上的正确执行； 一致性：在任何时候，区块链都存储与每个计算节点一致的单一状态转换序列； 保密：Ekiden保证合约状态和来自诚实客户的输入对所有其他各方保密，另外Ekiden也能抵御一些密钥管理TEE的背叛； 优雅的机密性降级：如果有计算节点违反机密性，Ekiden提供前向保密，并与受影响的TEE进行合理隔离。假设机密性违反发生在 $t$ ，攻击者最多能够获取 $t-\\Delta$ 的历史。 Ekiden不对合约级别的隐私泄露进行防御，如合约中的隐蔽信道、bug或侧信道。 假设和威胁模型 TEE 假设SGX是正确实现和安全制造的，但由于SGX存在侧信道攻击，假设敌手可以危及一小部分TEE的机密性。 区块链 Ekiden对底层共识协议不可知。假设区块链正确执行规定的计算，并且总是可用的。Ekiden依赖共识节点来进行认证，进一步假设区块链提供发布证明，可以证明区块链上包含一些内容。 威胁模型 系统中的各方都必须信任Ekiden和TEE 假设敌手可以控制除了一个计算节点之外的所有操作系统和网络堆栈，在受控节点上，敌手可以任意排序消息和调度进程 敌手可以操控任意数量的客户 客户不需要自己执行合约，也不需要可信硬件 诚实用户信任自己的代码和平台，但不相信其他客户 每个合约都有一个明确的策略来规定如何处理数据和服务请求 Ekiden不能防止合约有意或无意地通过软件漏洞泄露机密 5.Ekiden重要模块 发布证明 为permissionless的区块链提出发布证明协议： 发布证明是一种在验证者 $\\varepsilon$ 、合约TEE和不可信证明提供者 $P$ 之间的交互式证明。总的来说，只给 $P$ 有限的时间在足够困难的子链的块上发布消息，从而敌手很难伪造。 $\\varepsilon$ 存储最近的一个checkpoint块 $CB$，可以通过 $CB$ 计算难度系数 $\\delta(CB)$ ， $\\varepsilon$ 向任何请求客户发出 $CB$ 版本，使客户能够验证 $CB$ 的新鲜度。给定一个有效的最近的 $CB$ ， $\\varepsilon$ 可以通过 $\\delta(CB)$ 来验证新的块。为了方便分析，论文中的难度系数是恒定的。 为了初始化 $m$ 的发布，$\\varepsilon$ 获取时间戳 $t_1$ ， $\\varepsilon$ 可能需要经过一段延时才能收到 $t_1$ 。收到 $t_1$ 之后，$\\varepsilon$ 生成一个随机数 $r$ 并要求 $P$ 发布 $(m,r)$ 。$\\varepsilon$ 收到 $P$ 发送的证明 $\\pi_{(m,r)}$ 之后，获取时间戳 $t_2$ 。令 $n_c$ 为发布 $(m,r)$ 所需要的确认次数，$\\tau$ 为期望的块间隔时间（区块链中的定值），$\\epsilon$ 为一个乘法松弛因子，代表块产生的时间变化。例如，$\\epsilon=1.5$ 表示 $\\pi_{(m,r)}$ 的产生可以比预期在主链上的速度慢1.5倍。$\\varepsilon$ 只有当 $t_2-t_1&lt;n_c\\times\\tau\\times\\epsilon$ 时才接受 $\\pi_{(m,r)}$。 将 $\\epsilon$ 设置为一个大的值可以降低错误拒绝的概率（拒绝诚实用户 $P$ 的证明会导致区块链增长速度减慢），然而大的 $\\epsilon$ 值也会导致错误接受的概率增大。对于 $\\epsilon&gt;1$ ，需要一个足够大的 $n_c$ 来使成功攻击的概率可忽略，然而大的 $n_c$ 意味着诚实用户 $P$ 需要等待很长时间才能获得输出，影响用户体验。 例如，假设攻击者有25%的算力，设置 $n_c=80$ 以及 $\\epsilon=1.6$ 意味着攻击者需要预期2112次哈希才能伪造一个发布证明，而诚实的证明只有2-19的几率被拒绝。攻击者的伪造时间只有 $t_2-t_1$ ，而若 $\\varepsilon$ 经过一段延时才收到 $t_1$ ，则 $t_2-t_1$ 就更短，对攻击者不利。 一旦一条消息在一个TEE中发布，其他TEE可以通过经认证的安全信道获取该消息及其证明，从而节省重复协议的成本。 密钥管理 每个Ekiden合约都和一系列密钥相关联，包括一个用于状态加密的对称密钥和用于加密客户输入的密钥对。 敌手模型 假设敌手可以打破一定比例（$f%$）的TEE的机密性 假设参与主体有抵御女巫攻击的身份（交押金才能参与协议） 假设随时有足够多（$2f%$）的用户在线，从而密钥的可用性得到保证（通过经济奖惩来激励参与） 所需属性 由于解密密钥最终会暴露给合约TEE，而合约TEE本身也可能受到威胁，因此采用的密钥必须是短期的，来自暴露机会更低的的长期主密钥。密钥管理协议应满足的属性： 机密性：敌手无法窃取长期主密钥 可用性：诚实的合约TEE能获取解密密钥 前向保密：如果一个短期密钥被窃取，它不能用于解密早于 $t-\\Delta$ 时间的加密消息 初步准备 分布式密钥生成（DKG）：DKG协议允许N个团体生成随机密钥，DKG协议允许的结果是一个秘密，通过秘密共享方案在各方之间共享； 分布式伪随机函数（PRF）：PRF是函数 $F={f_s}{s\\in{S}}$ 的集合，并且对于随机索引 $s\\leftarrow$S$，$f_s(·)$ 于一个随机函数不能区分。 令 $G$ 是一个Schnorr group，$g$ 是一个生成器，$H:{0,1}^*\\rightarrow G$ 是一个哈希函数，则 $f_s(x)=H(x)^s$ 是PRF族。 假设 $s$ 被多方采用 $(k,n)$-秘密分享方案分享，为了评估 $f_s(x)$ ，团体 $i$ 计算并输出 $y_i=H(x)^{s_i}$ ，在收集了至少 $k+1$ 的 ${y_i}$ 之后，可以通过多项式插值得到 $f_s(x)$：$f(x)=H(x)S=H(x){\\sum_{i\\in A}{S_i\\lambda_i}}=\\prod_{i\\in A}{y_i^{\\lambda_i}}$ ，其中 $\\lambda_i$ 是拉格朗日系数 $\\lambda_i=\\prod_{j\\neq i}{\\frac{-i}{i-j}}$ 。 协议 密钥管理委员会和长期密钥：对于抵抗女巫攻击的身份，可以抽取N 个节点来形成密钥管理委员会（KMC），其中N是系统参数。初始化一个合约 $c$ 时，KMC运行DKG协议来生成一个长期密钥 $k_c$ ，从而 $k_c$ 通过 $(\\lceil fN\\rceil,N)$-秘密分享方案在KMC成员之间秘密分享。 生成短期密钥：假设短期密钥在每一轮都过期，为了在第 $t$ 轮获得合约 $c$ 的短期密钥，一个计算节点 $Comp$ 首先建立安全信道并与KMC成员认证身份。一旦验证了 $Comp$ 确实在执行 $c$ ，每个KMC成员 $i$ 计算 $k_{c,t,i}=H(t){k_ci}$ ，并将 $k_{c,t,i}$ 发送给 $Comp$ 。在从 $A\\subseteq$ KMC 收集了 $f+1$ 个结果之后，$Comp$ 可以生成第 $t$ 轮的短期密钥 $k_{c,t}=\\prod_{i\\in A}{k_{c,t,i}^{\\lambda_i}}$ ，其中 $\\lambda_i$ 是拉格朗日系数 。 违规隔离：通过为每个计算节点强制执行隐私预算，主动隔离违反机密性的行为。为此，假设每个合约TEE有不可伪造的身份，密钥管理节点为每个计算节点 $Comp$ 维护一个计数器 $K_{Comp}$ 来记录请求次数。计数器会随着轮次增加而清零。只有当 $K_{Comp}&lt;K$ 时密钥管理节点才满足计算节点的请求，其中 $K$ 是一个系统参数。这样，无论一个被破坏的计算节点产生多少个TEE，它最多只能获得 $K$ 个密钥。 原子性交付 假设TEE和调用客户 $P$ 之间有一个安全信道，通过以下协议实现 $m_1$ 和 $m_2$ 的原子交付： TEE从密钥管理器获取新鲜的密钥 $k$ ，并将加密的认证消息 $m_1^c=Enc(k,m_1)$ 发送给 $P$ ; 一旦 $P$ 确认收到 $m_1^c$ ，TEE将 $m_2$ 发送给区块链； TEE得到 $m_2$ 的发布证明 $\\pi_{m_2}$ 之后，将 $k$ 发送给 $P$。 6.协议细节和安全证明 $Prot_{Ekiden}$ 的目的是实现一个通用可组合性(UC)理想功能 $F_{Ekiden}$ 。 初步准备和符号说明 认证执行 使用 $G_{att}$ 正式定义可信硬件上经过验证的执行。一个party首先将程序 $prog$ 通过 install 消息加载进TEE中，通过 resume 调用，程序根据给定输入运行，生成输出 $outp$ 以及一个硬件密钥 $sk_{TEE}$ 下的签名认证 $\\sigma_{TEE}=\\sum_{TEE}.Sig(sk_{TEE},(prog,outp))$ ，其中 $sk_{TEE}$ 可以通过 $G_{att}.getpk()$ 获取。 如果一个TEE程序产生一对输出 $(outp_1,outp_2)$ ，认证只对 $outp_1$ 签名，即 $\\sigma_{TEE}=\\sum_{TEE}.Sig(sk_{TEE},(prog,outp_1))$ ，在 $outp_1$ 中包含 $outp_2$ 的哈希。 使用合约包装器来抽象例行常用功能，如状态加密，密钥管理等。被包装器扩充的合约 $c$ 称为 $\\widehat{c}$ 。 区块链 $F_{blockchain}[succ]$ 定义了区块链，参数 $succ$ 指定添加到存储中的新item的条件，对交易有效性的概念进行建模。 除了读写接口，$F_{blockchain}$ 提供了一个接口使得客户可以确定一个item是否包含在区块链内，这个接口避免了提前下载整个区块链。 参数化 $F_{blockchain}$ 在Ekiden中，存储的内容被解析为状态转换的有序数组，定义为 $trans_i=(H(st_{i-1}),st_i,\\sigma_i)$ ，包含之前状态的哈希，新状态和对状态转换的正确性的TEE证明。存储可以被解释为一种特殊的初始状态，随后是一系列状态转换：$Storage=((Contract,st_0,\\sigma_0),{trans_i}_{i\\geq1})$ 。 状态转换必须扩展最新的状态，并且认证经过验证，它才是有效的。有效性验证是通过使用函数 $succ(·,·)$ 参数化 $F_{blockchain}$ 来实现的：当且仅当 $h=H(st_{old})$ 其中 $st_{old}$ 是 $Storage$ 中的最新状态，同时满足 $\\sum_{TEE}.Vf(pk_{TEE},\\sigma_{TEE},(h,st_{new}))$ 时，$succ(Storage,(h,st_{new},\\sigma_{TEE}))=true$ 。这保证了状态转换链不会分叉。 协议的正式规范 $Prot_{Ekiden}$ 是Ekiden协议的正式规范，依赖 $G_{att}$ 和 $F_{blockchain}$ 作为认证执行和区块链的理想功能。$Prot_{Ekiden}$ 使用电子签名方案 $\\sum(KGen,Sig,Vf)$ ，对称加密方案 $S\\varepsilon(KGen,Enc,Dec)$ 以及非对称加密方案 $A\\varepsilon(KGen,Enc,Dec)$。 状态密钥分享 每个合约都和一系列密钥绑定，合约TEE将管理密钥的工作委托给密钥管理TEE。在 $Prot_{Ekiden}$ 中，密钥管理的通信由 $keyManager$ 函数进行抽象。 合约创建 创建Ekiden中的合约时，客户 $P_i$ 输入合约代码 $Contract$ ，并调用计算节点 $Comp$ 的 create 子程序。$Comp$ 将 $\\widehat{Contract}$ 加载进TEE中，并调用 create 进行初始化。如Fig9所示，合约TEE创建一个新鲜的合约 $cid$ ，从密钥管理器获得新鲜的 $(pk_{cid}{in},sk{in}{cid})$ 和 $k{cid}^{state}$ ，并生成加密初始状态 $st_0$ 和一个证明 $\\sigma_{TEE}$ ，$\\sigma_{TEE}$ 证明了 $st_0$ 被正确初始化以及 $pk_{cid}^{in}$ 是合约 $cid$ 的对应公钥。计算节点 $Comp$ 将 $(Contract,cid,st_0,pk_{cid}^{in},\\sigma_{TEE})$ 发送到 $F_{blockchain}$ 并等待回复。$Comp$ 将合约 $cid$ 返回给 $P_i$ ，然后 $P_i$ 验证合约 $cid$ 确实存储在 $F_{blockchain}$ 上。 请求执行 为了执行合约 $cid$ ，客户 $P_i$ 首先从 $F_{blockchain}$ 获得输入加密密钥 $pk_{cid}^{in}$ 。然后 $P_i$ 输入 $(cid,inp_{ct})$ 其中 $inp_{ct}$ 是经过 $pk^{in}{cid}$ 加密和经过 $spk_i$ 认证的 $P_i$ 的输入，并调用 $Comp$ 的 request 子程序。$Comp$ 从 $F{blockchain}$ 获取加密的之前状态 $st_{ct}$ ，并使用 $\\widehat{Contract}$ 代码和输入 $(cid,inp_{ct},st_{ct})$ 启动一个合约TEE。 如Fig9所示，如果 $\\sigma_{P_i}$ 验证通过，合约TEE使用从密钥管理器获得的密钥解密 $st_{ct}$ 和 $inp_{ct}$ ，并且执行合约 $Contract$ 得到结果 $(st_{new},outp)$ 。为了确保新状态和输出的原子性交付，$Comp$ 和 $P_i$ 执行第5章中描述的原子交付协议： 首先合约TEE计算 $outp_{ct}=Enc(k^{out}{cid},outp)$ 以及 $st{ct}{'}=Enc(k{state}{cid},st{new})$ ，并且通过 $epk_i$ 建立的安全信道发送两个结果的认证给 $P_i$ ； $P_i$ 通过调用 $Comp$ 的 claim-output 子程序来确认接收，该子程序使得合约TEE发送 $m_1=(st_{ct}^{'},outp_{ct},\\sigma)$ 到 $F_{blockchain}$ 。$\\sigma$ 保护 $m_1$ 的完整性，并以加密方式将新状态和输出绑定到以前的状态和输入，从而恶意的 $Comp$ 无法篡改它； 一旦 $m_1$ 被 $F_{blockchain}$ 接受，合约TEE通过安全信道将解密后的 $outp_{ct}$ 发送给 $P_i$ 。 $Prot_{Ekiden}$ 的安全 定理1的证明在附录B 定理1（$Prot_{Ekiden}$ 的安全性）： 假设 $G_{att}$ 的认证方案 $\\sum_{TEE}$ 和数字签名 $\\sum$ 在选择消息攻击（EU-CMA）下不可伪造，$H$ 是弱抗碰撞性的，$A\\varepsilon$ 和 $S\\varepsilon$ 是IND-CPA安全的。则 $Prot_{Ekiden}$ 在 $(G_{att}, F_{blockchain})$-结合模型中安全地实现了对静态敌手的 $F_{Ediden}$ 。 减轻应用程序级别泄露 Ekiden通过启用持久化的应用程序状态来减少应用程序级的隐私泄露（由于智能合约编写的问题导致的隐私泄露等）。 7.实现 使用Rust SGX SDK实现了一个编译器，它可以自动将合约构建为可执行文件，并加载到计算节点中。 Ekiden与许多现有的区块链兼容。 应用 机器学习合约 为了演示对秘密数据的共享学习，论文实现了两个示例合约： 基于财务记录的信用评分 根据医疗记录预测心脏病的可能性 提供给这些示例合约的训练数据被视为敏感数据，不会在合约外作为明文公开。 智能建筑热力学模型 论文移植了一个非线性最小二乘的实现，用于基于智能建筑提供的时间序列热力学数据来预测温度。Ekiden允许合约运行其模型，同时对传感器数据和模型保密，这表明Ekiden对高度交互的工作负载具有足够的响应能力。 代币 最流行的以太坊合约是ERC20代币标准。论文实现了一个直接用Rust编写的代币合约，Ekiden会自动提供隐私和匿名性，而这是智能合约在以太坊主网上无法实现的。代币中每个用户的帐户余额是保密的。 扑克 论文实现了一个扑克合约，其中用户轮流向合约提交他们的行动，智能合约包含了洗牌和(有选择地)显示牌的所有游戏逻辑。扑克是区块链系统和安全多方计算的通用基准测试应用程序。Ekiden在每次行动后都将保存状态到区块链，并且可以从任何Enclave访问，所以如果玩家中止行动，秘密纸牌仍然能够被显示出来。 加密猫 加密猫是一款以太坊游戏，允许用户繁殖虚拟猫，虚拟猫以ERC721代币的形式存储在链上。每只猫都有一组独特的基因，这些基因决定了它的外观和价值。后代的特征是由一个混合了父母基因的智能合约决定的。基因混合合约的源代码并不公开：游戏开发者的目标是让繁殖过程变得不可预测。 论文从以太坊区块链获取了基因混合合约的字节码，并使用Ekiden EVM端口执行。论文通过从以太坊网络复制真实交易来验证正确性。这个例子展示了Ekiden可以执行以太坊合约，即使源代码不可用。 加密猫的基因混合算法经过了逆向工程，这使得玩家能够优化自己繁殖出具有罕见特征的猫的机会，从而破坏游戏的生态系统。相比之下，Ekiden合约可以访问硬件中的随机性来源，并允许加密存储游戏算法。 Origin Origin是一个在以太坊之上建立在线市场平台，论文移植了一个demo，允许用户使用Ether列出和购买道具。该应用进一步证明了以太坊的开发框架可以很容易地被Ekiden使用：在demo中使用的智能合约无需修改。基于Ekiden，区块链中的用户交易历史保持隐私，交易确认速度比以太坊更快。 8.评估 与以太坊主网上的ERC20合约相比，Ekiden-BT可以支持吞吐量提高600倍、延迟降低400倍、货币成本降低1000倍的代币合约。虽然论文预计在使用更大规模区块链部署时，会出现一些轻微的性能下降，但性能优化显著降低了区块链速度的影响。 此外，论文证明Ekiden可以有效地支持计算密集型工作，如机器学习应用程序，这在以太坊上是成本高昂的。 端到端延迟 吞吐量 共识对吞吐量的影响 to be continued","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"论文阅读-Hawk.The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts","slug":"paper-reading/paper-hawk","date":"2021-06-05T16:00:00.000Z","updated":"2022-07-20T03:52:41.182Z","comments":true,"path":"2021/06/06/paper-reading/paper-hawk/","link":"","permalink":"http://example.com/2021/06/06/paper-reading/paper-hawk/","excerpt":"论文 Hawk.The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts阅读笔记","text":"1.引入 区块链上的可信时钟的存在对于协议中实现公平交易至关重要：恶意用户可能会过早地中止协议以避免资金支付，但是有了可信时钟，过早地中止协议会被判定为超时，这样区块链就可以将恶意用户的抵押存款重新分配给诚实用户，以此来惩罚恶意用户。 尽管区块链和智能合约具有表现力和强大功能，但这些技术目前缺乏交易隐私：尽管各方可以创建匿名公钥以增加其匿名性，但每个匿名公钥的所有交易和余额都是公开可见的。缺乏隐私是去中心化智能合约广泛应用的主要障碍，因为一些金融交易，如保险合同或股票交易，被许多个人和组织视为高度机密。 Hawk概览 Hawk编译器负责将程序编译成区块链和用户之间的加密协议，一个Hawk程序包括两个部分： 隐私部分 $\\phi_{priv}$ ： 用于接收各方的输入数据和货币等，并执行计算来分配收益。$\\phi_{priv}$用于保护参与者的数据和资金交换； 公开部分 $\\phi_{pub}$ ：不涉及隐私数据和资金的部分。 Hawk编译器把Hawk程序编译成以下几个部分，这些部分共同定义了用户、管理员和区块链之间的加密协议： 被所有共识节点执行的区块链程序 由用户执行的程序 由管理员（一个特别协助方）执行的程序 安全保证 链上隐私：只有合约双方自愿公开信息，区块链才会将交易隐私向公众公布，$\\phi_{priv}$以加密形式展现在公众眼前。非正式地讲，链上隐私的实现通过向区块链发送“加密”信息，并依靠零知识证明来确保合同执行和资金保存的正确性。 合约安全：保护同一合约协议中的各方互不侵犯，不仅包括机密性和真实性等密码学概念，还包括存在欺骗和中止行为时的公平交易 最低限度信任管理员 Hawk合约的执行由管理员推动，管理员可以看到用户的输入，并被信任不会泄露用户的隐私数据。 管理员不是可信第三方：即使管理员可以任意偏离协议或与当事人串通，管理员也不能影响合约的正确执行，如果管理员中止了协议，就会受到经济上的惩罚，而用户则会得到相应的补偿； 管理人员不需要被信任来维护基础货币的安全性或隐私，如防止双花攻击等； 如果多个合约实例同时运行，则每个合约可以指定不同的管理员，而恶意管理员只会影响该实例； 可以用可信计算硬件实例化管理员，或使用用户自己之间的多方计算代替。 实例：密封拍卖 该实例用于实现一个密封的、第二价格的拍卖，其中出价最高的竞标者获胜，但支付第二高的价格，且竞标者在不知道其他人的出价的情况下提交出价。 该实例中$\\phi_{priv}$决定中标者和支付金额；$\\phi_{pub}$使用公共存款来防止管理员通过中止协议来损害竞标者利益。 合约的安全需求 前提： Hawk的安全建立在区块链本身的安全特性上：假设区块链的共识协议在对手不拥有大量计算能力的情况下是安全的； 在Hawk中，为了减少链上执行代码产生的费用，设计的协议在链下执行大部分计算 安全需求： 独立隐私输入：各用户在提交自己的投注资金之前无法查看其他用户的投注金额，即使与恶意管理员串通也无法查看； 交易后隐私保护：只要管理员不公布信息，即使在拍卖之后各用户的出价也不会公布； 公平交易：拍卖参与者可能试图提早退出协议，以避免付款或影响资金再分配。如果一方中止或拍卖管理员中止，中止方将受到经济惩罚，而其余方则获得补偿。Hawk在特定超时后强制执行退款； 防范不诚实管理员：除了中止协议外，不诚实的管理员不能影响拍卖结果和资金再分配。对于中止协议的管理员，对其进行罚款。 中止和超时 该实例定义了三种超时 $T_1&lt;T_2&lt;T_3$： $T_1$：Hawk合约在$T_1$之后停止招标； $T_2$：所有用户都需要在$T_2$内向管理员公布自己的出价，否则将视作0； $T_3$：如果管理员中止协议，用户可以在$T_3$后收回投标资金。 $\\phi_{pub}$实现额外的激励机制，本实例中如果管理员提前中止拍卖，将重新分配管理员的公共存款。 本文贡献 Hawk是第一个在去中心化加密货币系统中同时提供隐私交易和可编程性的系统： 去中心化智能合约的正式模型：针对密码学的区块链模型，提出了一种形式化的通用可组合性(UC)模型，这种形式模型是独立的，并且在区块链模型中定义协议的安全性时通常是有用的； 新的加密套件：实现了一个新的加密套件，它将私有事务与可编程逻辑绑定在一起，包含三个基本原语 freeze，compute 和 finalize ： freeze原语允许各方提交正常数据以及货币，提交的货币在合约中冻结，支付分配在之后由$\\phi_{priv}$确定； compute的过程中，各方将提交的数据和货币向管理员公开，以便管理员计算$\\phi_{priv}$函数，根据$\\phi_{priv}$的结果，管理员构造新的私有货币支付给各用户。然后，管理员向区块链提交新的私有货币以及它们的零知识证明。此时之前冻结的货币在用户中重新分配。 实现和评估：创建Hawk原型，实现一些应用来评估性能。提出协议优化，得到10倍性能。在约有100个参与方时，管理员使用四核进行密码计算（协议中最昂贵的部分），时间在2.85分钟内；所有的链上计算（由矿工执行）都十分便宜，都在20毫秒以内。 2.密码学的区块链模型 区块链模型 区块链在正确性和可用性方面受到信任，但在隐私方面不受信任。区块链不仅维护一个存储每个假名账户余额的全局账本，而且还执行用户定义的程序。论文给出了区块链的通用模型，可以运行任意图灵完备程序： 区块链的时钟是离散的，每一轮用 round 或 epoch 表示 所有链上用户都可以观察到区块链的状态，包括公共账本和任何用户定义的程序 发送到区块链的消息将在下一轮开始时到达。在同一轮中，敌手可以任意重新排序发送到区块链的消息，但不能丢弃消息，然而敌手可以在链下丢弃各方之间传递的消息。这意味着敌手可能会尝试抢先攻击（例如当观察到一个诚实用户正在交易一只股票时，对手会通过发送交易同一只股票的竞争交易来抢占先机） 用户在区块链上可以创建任意多的假名账户 假设区块链将正确执行任何规定好的计算 区块链正式建模 论文提供了正式的、精确的功能规范和安全性规范，并且设计的协议在通用可组合性(UC)框架下正式证明是安全的。 建模的程序分为理想程序（记为$IdealP$）、区块链程序（记为$B$）和用户/管理员程序（记为$UserP$）。同时论文定义包装器来将伪代码程序转换为UC框架下的程序： 理想包装器$F(·)$将理想程序$IdealP$转换为理想函数$F(IdealP)$ 区块链包装器$G(·)$将区块链程序$B$转换为区块链函数$G(B)$，可以延迟区块链上的消息在下一轮开始到达 协议包装器$\\Pi(·)$将用户/管理员程序$UserP$转换为用户端或管理员端的协议$\\Pi(UserP)$ 包装器还实现了智能合约应用的一些共同特征，包括时间、公共账本、假名和敌手对消息重新排序，这样就不需要为每个区块链应用重复这些符号。 正式UC建模及证明 附录B 编程约定 Timer激活点：理想函数包装器$F(·)$和区块链包装器$G(·)$实现了逐轮递增的时钟，并且每次时钟增加，包装器就会调用Timer激活点。因此理想程序和区块链程序可以定义Timer激活点来实现超时操作； 理想程序中的延迟处理：在灰色背景中编写的程序指令表示的是不会立即进行的计算，而是推迟到下一轮开始时执行。这是一种简写，因为在实际协议中，区块链函数完成的任何计算都将被延迟； 假名：在理想程序、区块链程序和用户端程序中出现的所有表示用户的标识符默认情况下都指假名； 账本和转账：$符号仅用于可读性（用于区分与货币相关的变量和其他变量），并没有特殊含义。 3.密码学抽象 论文使用理想程序的形式来描述密码学抽象。Hawk实现了以下规范： 私人账本和转账：定义理想程序$IdealP_{cash}$来描述私人账本的需求； Hawk-specific原语：定义 freeze、compute 和 finalize 三种Hawk-specific原语来同时满足交易隐私性和可编程性。 隐私资金规范$IdealP_{cash}$ Mint mint 操作允许用户 $P$ 将资金从他的公共总账 $ledger[P]$ 转移到私有货币池 $Coins[P]$ ，每次转账后用户 $P$ 的私有货币被创建，并与一个值 $val$ 关联。 为保证安全性，$IdealP_{cash}$ 在用户 $P$ 创建私有货币之前检查他的公共总账 $ledger[P]$ 中的余额是否足够。 Pour pour 操作允许用户 $P$ 私下在其私人货币池花钱。简单起见，采用两种输入货币和两种输出货币来模拟货币交换。 为保证安全性，$IdealP_{cash}$ 会检查： 对于两种输入货币，用户 $P$ 确实拥有其声明的量那么多的私有货币 两种输入货币的总价值和两种输出货币的总价值相等 隐私 当诚实用户 $P$ 执行 mint 操作时，敌手 $A$ 能获得 $(P, val)$。对于公共货币池的任何操作都会被敌手 $A$ 获得。 当诚实用户 $P$ 执行 pour 操作时，敌手 $A$ 只能获得动态生成的输出假名 $P_1$ 和 $P_2$ ，而不知道哪种在私人池的货币被花了，也不知道花钱的人是谁。如果恶意用户是 pour 操作的接收方，那他会额外获得货币的金额。 额外的微妙之处 诚实用户会跟踪一个装有不同货币的钱包，每当诚实用户执行 pour 操作时，首先会检查本地钱包中是否有相同的货币，如果有，会立即将货币从钱包中取出，通过这种方式，如果诚实用户在一轮中进行了多次 pour 操作，将为每次 pour 操作选择不同的货币； 诚实用户在下一轮之前是不能花掉同一轮中自己获得的货币的，但是恶意用户可以（因为任何消息都立即被敌手获得，敌手也可以为区块链在同一轮中收到的所有消息选择排序方式） 诚实用户总会 pour 给存在的假名，但敌手可以 pour 给不存在的假名 $\\bot$ ，这种情况下私人货币实际上进入了一个黑洞，并且无法取回。 Hawk规范$IdealP_{Hawk}$ Freeze 用户 $P$ 从私有货币池 $Coins$ 中移除一种货币，并将其添加到 $FrozenCoins$ 中进行冻结，用户的私有输入 $in$ 也会记录在 $FrozenCoins$ 中。$IdealP_{Hawk}$ 检查 $P$ 之前没有调用过 freeze，并且货币 $(P, val)$ 存在在 $Coins$ 中。 Compute 用户 $P$ 调用 compute​ 时，其私有输入 $in$ 和冻结的货币 $val$ 将公开给管理员 $P_M$ Finalize 管理员 $P_M$ 提交一个公共输入 $in_M$ 到 $IdealP_{Hawk}$ ，$IdealP_{Hawk}$ 根据所有用户的输入和冻结的货币价值计算 $\\phi_{priv}$ 的结果，并根据这个结果重新分配 $FrozenCoins$ 。为了保证安全，$IdealP_{Hawk}$ 检查冻结货币的总价值等于输出货币的总价值。 与公共合约交互 $IdealP_{Hawk}$ 的功能由公共Hawk合约 $\\phi_{pub}$ 参数化，在 finalize 过程中，$IdealP_{Hawk}$ 调用 $\\phi_{pub}.check$ 。$\\phi_{pub}$ 的作用如下： 检查管理员的输入 $in_M$ 的格式是否正确 重新分配公共存款：如果用户或管理员提前中止协议，或者用户提供了无效的资金投入（例如少于最低赌注），$\\phi_{pub}$ 可以重新分配用户的公开存款 安全和隐私需求 当诚实用户 $P$ freeze 冻结一笔金额时，敌手不能看到该金额，但能看到诚实用户的假名 $P$ 。这不会损害诚实用户的隐私，因为他可以随时创建新的假名； 当诚实用户调用 compute 时，只有管理员 $P_M$ 能看到用户的输入 和冻结的金额，其他用户不能看到； 在 finalize 操作期间，输出 $out$ 会公开该所有用户，如果不希望公开，$out$ 可以为空。 时间和中止 freeze 操作在 $T_1$ 内完成，$compute$ 操作在 $T_2$ 内完成，如果用户冻结了货币但是在 $T_2$ 内没有公布，则这些冻结的货币会丢失，即 $(in_i, val_i):=(0, \\bot)$ 简化的假设 论文实现的协议不支持管理员中止协议时冻结货币的退款 假设参与合约的假名集和超时 $T_1, T_2$ 硬编码在程序中 4.加密协议 协议分为两部分： 隐私资金转移 区块链程序 $Blockchain_{cash}$ 维护一系列私有货币 $Coins$ ，每一种货币的形式为 $(P, coin:=Comm_s($val))$ ，其中 $P$ 是用户假名，$coin$ 是根据随机数 $s$ 生成的货币值 $$val$ 的承诺。 在 pour 操作期间，用户 $P$ 选择两种 $Coins$ 中的货币来花费，分别为 $(P, coin_1)$ 和 $(P, coin_2)$ 。pour 操作将 $val^{‘}_1$ 和 $val^{’}_2$ 分别付给两个输出假名 $P_1$ 和 $P_2$ ，并且保证 $val_1+val_2=val{'}_1+val{‘}2$ 。支付用户选择新的随机数 $s_i^{'}(i\\in{1,2})$ 并计算输出货币 $(P_i,coin_i:=Comm{s{'}_i}($val_i{’}))$ ，支付用户将 $s_i^{‘}$ 和 $val_i^{’}$ 发送给收款用户 $P_i$ 。发送者计算一个零知识证明来证明输出的货币是适当构造的，其中正确性涉及以下方面： 货币的存在性：$(P, coin_1)$ 和 $(P, coin_2)$ 确实是私有货币池 $Coins$ 的一部分，这里使用零知识证明可以确保支付用户隐藏其花费的货币种类。为了提高效率，$Blockchain_{cash}$ 维护一个 $Coins$ 的Merkle树 $MT$ 来证明货币的存在性； 不会双重支付：每一个货币 $(P, coin)$ 都有一个唯一的序列号 $sn$ ，在 pour 货币时，必须提供货币的 $sn$ 以及其零知识证明来证明 $sn$ 的正确性，$Blockchain_{cash}$ 确保 $sn$ 不会被用两次； 保护金额：零知识证明确保输入的货币和输出的货币的总价值相等。 当诚实用户向诚实用户 pour 时，敌手 $A$ 不会知道承诺方案 $Comm$ 隐藏的输出货币的值，敌手 $A$ 可以看到接收两种输出货币的用户假名； 当不诚实用户 $P^$ 向诚实用户 $P$ pour 时，尽管敌手知道 $coin$ 公开，然而一旦交易在$Blockchain_{cash}$生效，敌手就不能使用 $(P,coin)$，因为 $P^$ 不知道 $P$ 的密钥。 PRF：伪随机函数 ENC：加密 DEC：解密 同时实现隐私和可编程逻辑 Freeze freeze 操作不直接向用户支出，而是将资金以及附带的隐私输入提交给智能合约，这是使用类似pour​的协议完成的： 用户 $P$ 选择一个私有货币 $(P,coin)\\in Coins$，其中 $coin:=Comm_s($val)$。$P$使用自己的密钥计算 $coin$ 的序列号 $sn$ 并公开，用于防止双重支付； 用户 $P$ 计算承诺 $(val||in||k)$ ，其中 $in$ 是用户输入，$k$ 是一个对称加密密钥（用于实际优化）； 用户 $P$ 进行零知识证明，类似 pour 操作。 Compute compute 操作在链下计算 ${val_i^{‘}}_{i\\in[n]}$以及进行正确性证明。Hawk依赖管理员 $P_M$ 来进行计算，所有用户将自己的输入经过管理员的公钥加密后发送给管理员：$ct:=ENC(P_M.epk,r,($val||in||k||s^{’}))$ ，其中 $ct$ 是密文， $P_M.epk$ 是管理员的公钥。 在获取用户的公开信息后，管理员通过私有合约 $\\phi_{priv}$ 计算 ${val_i^{'}}_{i\\in[n]}$ 以及公开输出 $out$。管理员同时也会构建一个零知识证明来证明结果。 Finalize 管理员提交$\\phi_{priv}$的结果以及零知识证明到$Blockchain_{cash}$之后，$Blockchain_{cash}$验证证明并重新分配冻结的资金，与此同时还将管理员的公开输入 $in_M$ 和公开输出 $out$ 发送给公开Hawk合约 $\\phi_{pub}$。 定理1 假设Merkle树使用的哈希算法是抗碰撞的，承诺方案 $Comm$ 是 perfectly binding 和计算隐藏的，零知识证明的NIZK方案满足零知识需求，加密方案ENC和SENC是正确并且安全的，PRF方案是安全的，则协议 $UserP_{cash}$ 和 $UserP_{hawk}$ 安全地模拟了静态模型中抵抗恶意对手的理想功能$F(IdealP_{hawk})$ 。 证明在文献[37]: A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. http://ia.cr/2015/675. 扩展和讨论 使用可信硬件实例化管理员 使用可信硬件SGX实例化管理员从而在安全秘密地进行链下计算。但是任何不与区块链交互的链下协议都不能在中止的情况下提供公平交易——即使使用了可信硬件。 5.在UC协议中采用SNARKS以及实际优化 在UC协议中采用SNARKS 简洁非交互式知识论证（Succinct Non-interactive ARguments of Knowledge）对一般计算任务进行了简洁的证明，并已在多个系统中实现。 论文的UC协议实现采用高效的SNARK-lifting转换。 实际考虑 高效SNARK电路 一个SNARK证明器的性能主要取决于代数电路中乘法门的数量，为了更高效，论文通过两种方式设计优化电路： 使用SNARK友好的密码原语 构建定制的电路生成器来友好地实现SNARK，而不是依赖编译器来编译更高级别的实现 Hawk中在主要的密码学构造块包括：针对Merkle树的抗碰撞哈希函数、伪随机函数、承诺和加密。在实现中，模数q被设置为底层SNARK实现的254位素数，维数d在80位的安全级别下设置为3，在112位的安全级别下设置为4。 更多性能优化略。。。 6.实现和评估 略","categories":[{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"Substrate入门","slug":"learning-notes/substrate入门","date":"2021-04-14T16:00:00.000Z","updated":"2022-04-28T07:47:50.000Z","comments":true,"path":"2021/04/15/learning-notes/substrate入门/","link":"","permalink":"http://example.com/2021/04/15/learning-notes/substrate%E5%85%A5%E9%97%A8/","excerpt":"Substrate框架入门","text":"Start 架构 substrate客户端的基本构成： 存储(storage)：存储区块链的状态，使用简单而高效的键值对存储机制 运行时(Runtime)：定义处理块的逻辑，包括状态转换逻辑。运行时代码的编译方式有两种： 编译为wasm并且存储在区块链上（使得forkless运行时升级成为可能） 使用本机运行时编译为客户端的本机代码 点对点网络(peer-to-peer network)：使用rust的 libp2p 实现 共识(consensus)：substrate可以定制共识引擎，也提供一些建立在Web3 Foundation研究之上的共识机制 RPC(remote procedure call)：使区块链用户可以与网络交互，substrate提供HTTP和WebSocket RPC服务器 Telemetry：由嵌入式Prometheus服务器公开的客户端度量 基本概念 Extrinsics extrinsic指来自链外的信息，并且会被纳入区块中。分为三类： inherents 签名交易 无签名交易 注： 执行函数时触发的事件不属于extrinsic 区块结构 substrate的每一个区块都是由一个区块头和一组extrinsic组成的，区块头包含区块高度、父区块哈希值、extrinsic根哈希值、链上状态根哈希值，以及摘要等信息。 Extrinsics 被打包到当前区块中并会被执行，每个extrinsic都在runtime进行了定义。 Extrinsic根哈希值主要有两个用途： 它可以在区块头构建和分发完成之后，防止任何人对该区块头中所含extrinsic内容进行篡改 它提供了一种方法，在只有区块头信息的条件下，可以帮助轻客户端快速地验证某一区块中存在某笔交易 Inherents Inherent指的是那些仅能由区块创建者插入到区块当中的无签名信息，他们不会在网络上传播或存储在交易队列中 只要足够多的区块验证人认可该Inherent的合理性，那么这条Inherent就是有效的 签名交易 签名交易包含了签发该交易的账户私钥签名，这意味着此账户同意承担相应的区块打包费用 由于签名交易打包上链的费用在交易执行前就可以被识别，所以在网络节点中传播此类交易造成信息泛滥的风险很小 无签名交易 无签名交易意味着无人支付交易费用，这使得交易队列无法用有效的手段来防止其被滥用 无签名交易里缺失nonce字段来辅助识别交易执行顺序，从而难以防止重放攻击 少数交易能够安全使用不具签名的形式，前提是它们需要提供 SignedExtension 的自定义实现，来防止垃圾交易 Signed Extension SignedExtension 是一个trait ，通过它可以使用额外的数据或逻辑来扩展交易 在交易执行之前，任何时候需要获取某笔特定交易信息时，都可以使用 SignedExtension 来实现。 因此SignedExtension 在交易队列中被大量使用 Runtime会使用 SignedExtension 提供的一些数据，比如用来计算可调用函数Call的交易费用 SignedExtension 还包含一个名为AdditionalSigned的字段，这个字段可存放任意可编码数据，因而能够在打包或者发送交易之前，被用来执行自定义逻辑 为了避免将可能失败的交易打包进区块中，交易队列还会定期调用 SignedExtension 的函数来验证即将进入区块的交易 SignedExtension 也可以用于验证无签名交易：通过实现*_unsigned 的一系列方法，来封装信息核验、防垃圾信息和重放保护等逻辑，供交易池使用 交易池 交易池包含所有在网络广播的，已被本地节点接收和验证的交易（签名和未签名的） 有效性 交易池检查交易是否有效（由Runtime决定）： 检查交易索引 (nonce) 是否正确 检查帐户是否有足够的资金来支付相关费用 检查签名是否有效 交易池还定期检查池内现有交易的有效性： 如果发现无效或过期的普通交易，该交易将被交易池删除 排序 如果交易是有效的，交易队列会将交易分为两组： 就绪队列：包含所有可放到新的待处理区块中的交易。 对于随 FRAME 构建的 Runtime，所有交易必须严格遵循就绪队列中的顺序 未来队列：包含所有可能在未来变成有效的交易。例如，一个交易可能有一个对其账户来说过高的 nonce 值，此交易将在未来队列中等待，直到之前的交易上传至区块链上 交易依赖关系 ValidTransaction 结构体定义了 requires 、 provides 和 priority 参数来构建交易的依赖关系。 这个依赖关系允许交易池产生有效线性顺序的交易 对于用 FRAME 构建的 Runtime，节点基于不同账户对交易进行排序。 所有签名交易都需要包含一个交易索引 (nonce)，该索引值在每次进行新的交易时都会递增1 FRAME 交易包括一个 provides 标签（值为 encode(sender ++ nonce) ），和 requires 标签（值为 encode(sender ++ (nonce -1)) if nonce &gt; 1 ）。来自单一发送人的所有交易将形成一个序列。 交易优先级 ValidTransaction 结构体中的 priority 决定了就绪队列中的交易顺序，priority 定义了当一个交易可解锁多个依赖交易时，所应有的线性排序 当某个节点成为下一个区块生成者时，它将在下一个区块把交易按优先级别从高到低排序，直到达到区块的长度限制 对于用 FRAME 构建的 Runtime，priority 定义为交易要支付的 fee (费用)。 例如： 如果我们从不同的发送者那里收到 2 个交易（而且 nonce=0 时），我们通过 priority 来确定哪个交易更为重要，并优先把它打包进区块中 如果我们从同一个发送方收到 2 个相同 nonce 的交易，那么只会有一个交易会被打包到链上。 我们使用 priority 来选择 fee 较高的交易，并把它储存到交易池中。 注意：交易池并不知道费用、账户、或签名，它只处理交易的有效性和 priority、requires 和 provides 参数这些抽象概念。 所有其他详细信息都是由 Runtime 通过 validate_transaction 函数定义的。 交易的流程 交易可以遵循两条路径： 我们的节点生成的区块 我们的节点会监听网络上的交易 每一笔交易都要经过验证，而有效的交易会被放入交易池 交易池负责对交易进行排序，并返回可被纳入区块的交易。在就绪队列中的交易将被用来打包到区块内 交易会被执行，而状态变化会存在本地内存中。来自就绪队列的交易也会在网络上传播给其他节点 构建好的区块会被发布到网络上，而网络上其他所有节点都会接收并执行该区块 注意：交易在区块生成时不会从就绪队列中被删除，只有在区块导入时才被删除，这是因为最新生成的区块有可能进不了规范链里 从网络接收的区块 该区块被执行后，整个区块要么成功，要么失败 交易有效性 validate_transaction 是在 Runtime 里被调用的，检查有效的签名和 nonce 并返回一个 Result validate_transaction 只会个别地检查交易，所以它不会捡测到类似同一输出被使用两次的错误。 validate_transaction 并不会检查对模块的调用是否成功 validate_transaction 函数应专注于为交易池提供必要的信息，以便对交易进行排序和优先处理，并快速拒绝所有无效或过时的交易 账户 substrate用公私钥对来表示网络参与者 账户密钥 密钥对代表一个账户，并可以控制资金 账户密钥是通过泛型定义的，在 Runtime 中进行实例化 Stash密钥 Stash 账户的公私钥对，这个账户就像一个 “储蓄账户”，不应该用它进行频繁的交易。因此，应以最安全的方式来保存其私钥 Controller密钥 Controller 帐户的公私钥对，在 Substrate 的 NPOS 模型中，Controller 密钥会代表某个账户进行验证或提名 Controller 账户只需要支付交易费用，所以它只需要最少量的资金 会话密钥 会话密钥是验证者用来签署和共识相关消息的 “热密钥” 更改会话密钥的方式：通过Controller账户对会话公钥签名并创建一个证书，再将证书通过 extrinsic 广播 会话密钥是通过泛型定义的，在 Runtime 中进行实例化 交易权重 链可用的资源是有限的，包括内存、存储 I/O、算力、交易/区块大小和状态数据库的大小 权重用于管理验证一个区块所用的时间，常用于限制存储I/O和算力 区块中可包含的权重总量是有限的，并且可用的权重消耗通常也会受到交易费的限制 最大区块权重应等于目标区块时间的三分之一，为区块构造分配、网络传播、导入和验证各分配三分之一 权重基础 对权重的计算应该满足： 在被调用之前可计算。区块创建者在实际决定是否接受某个交易之前应该能够检查其权重 本身消耗很少的资源。 如果计算交易的权重会消耗与执行交易消耗相似的资源，那这样就没有意义了。因此，权重计算应该比执行交易更轻量级 无需访问链上状态即可确定使用的资源。权重有利于表示固定的度量或仅基于少量 I/O 的可调用函数参数的测量 如果权重十分依赖于链上状态，则可以： 强制使用可调用函数可能消耗的权重上限。 如果可调用函数使用的强制权重上限与其下限差别只是很少，则可直接使用其权重上限而无需访问链上状态。 但是如果两者差别巨大，那么即使进行很少的交易，其经济成本也可能很大，这将破坏激励措施，并降低链上吞吐量 要求有效权重作为参数传递到可调用函数中。 消耗的权量应基于这些参数，同时也应包含在调用时验证它们所花费的时间。 必须经过这一验证过程以确保权重参数准确对应于链上状态，如果对应不上，则报错 链下功能 使用预言机(Oracle)先对链下的数据作查询或处理，然后才将其提交到链上 预言机是一种外部服务，通常用于监听区块链事件，并根据条件触发任务。 当这些任务执行完毕，执行结果会以交易的形式提交至区块链上。 虽然这种方法可行，但在安全性、可扩展性，和效率方面仍然存在一些缺陷 因此substrate提供一些链下特性： Off-Chain Worker (OCW) 执行长时间运行的和可能不确定的任务（如web请求、加解密、数据签名、随机数生成、cpu密集型计算、链上数据枚举/聚合等） Off-Chain Storage 为substrate节点提供本地存储 Off-Chain Indexing 允许Runtime独立于OCW直接写入链下存储 Runtime Runtime 用于定义区块链的业务逻辑 在 Runtime 中定义了用于表示区块链状态的存储项，同时也定义了允许区块链用户对该状态进行更改的函数 为了能够提供无须分叉的升级功能，Substrate采用了可编译成 WebAssembly (Wasm)字节码的 Runtime 形式 FRAME 是Parity 的 Substrate runtime 开发系统， FRAME 定义了额外的 runtime 基础类型，并提供了一个框架，使得通过编写模块 (称为 “pallets”) 来构建 runtime 变得十分容易，每个 pallet 用于封装特定于该域的逻辑，这些逻辑可表示为一组存储项、事件、错误和可调用函数的集合 Runtime基本类型 核心原语 runtime必须提供给substrate其他层的最小化内容： Hash：数据摘要， 通常是一个256位的数值 DigestItem Digest：一系列 DigestItem 的组合， 它对当前区块中轻客户端所需知晓的所有信息进行了编码 Extrinsic：这种类型代表着一段来自链外、且被区块链认可的数据。 它通常包括一个或多个签名，以及某种编码指令(例如转移资金所有权或调用智能合约) Header：包含了单个区块所有信息 (以加密或其它形式) 的类型。 它包括父区块哈希、存储根哈希和 extrinsic 根哈希、区块摘要及区块号 Block：基本上就是 Header 和一系列 Extrinsics 的组合，以及所使用的哈希算法说明 BlockNumber：一种类型，代表一个有效区块的祖先区块的总数量。 通常是32字节数值 FRAME原语 如果是通过Substrate FRAME搭建的runtime，还可以使用如下的FRAME原语： Call: 通过extrinsic调用的可调用函数类型 Origin: 代表着函数调用方，例如可以是签名消息(交易)、无签名消息(区块链内生数据)，或者runtime本身(根调用) Index: 帐户的交易索引 (nonce) 类型， 存储交易发送方账户曾经发出的交易总数 Hashing：在runtime中使用的哈希系统 (算法) AccountId： 用于在runtime中识别用户账户的类型 Event：代表runtime发出的事件类型 Version：代表runtime版本的类型 FRAME Framework for Runtime Aggregation of Modularized Entities (FRAME) 是一组可简化 runtime 开发的模块（pallet）和支持库 FRAME 提供了一些与 Substrate Primitives 交互的帮助模块，而 Substrate Primitives 则提供了与核心客户端的交互接口 Pallet Pallets是一种可组合成为Substrate runtime的特殊Rust模块。每个pallet都拥有独立的逻辑，可修改相应区块链状态转换函数的特征和功能 Pallet架构 123456789101112131415161718192021// 1. 导入库和依赖项// 此pallet支持使用任何带有`no_std`标志编译的Rust库。use support::&#123;decl_module, decl_event, decl_storage, ...&#125;// 2. Runtime配置Trait // 所有runtime类型和常量都放在这里。// 如果此pallet依赖于其他特定的pallet，则应将依赖pallet的配置trait添加到继承的trait列表中pub trait Config: system::Config &#123; ... &#125;// 3. Runtime事件// 事件是一种用于报告特定条件和情况发生的简单手段，用户、Dapp和区块链浏览器都可能对事件的感兴趣。没有它就很难发现。decl_event!&#123; ... &#125;// 4. Runtime存储// Runtime存储允许在保证“类型安全“前提下使用Substrate存储数据库，因而可在块与块之间留存内容。decl_storage!&#123; ... &#125;// 5. Pallet声明 // 此模块定义了最终从此pallet导出的&quot;Module&quot;结构体// 它定义了该pallet公开的可调用函数，并在区块执行时协调该pallet行为decl_module! &#123; ... &#125; Substrate内置模块 汇总链接 Runtime宏 decl_storage! 在 pallet 中定义一个存储项目，存储项目的定义包括： 数据类型，为下列其中一种： StorageValue类型: rust-type StorageMap类型: map hasher($hasher) rust_type =&gt; rust_type StorageDoubleMap类型: doublemap hasher($hasher) rust_type, hasher($hasher) rust_type =&gt; rust_type getter函数 键类型及其哈希函数 (如果是map或double-map类型) 存储的名称 默认值 这些存储值可通过其后的add_extra_genesis模块在其创世区块中进行初始化 12345678910decl_storage! &#123; trait Storage for Module&lt;T: Config&gt; as MyModule &#123; // ... &#125; add_extra_genesis &#123; build (|config| &#123; //... &#125;); &#125;&#125; API文档 decl_event! 通过实现 Event枚举类型来定义pallet事件，而宏中的每个事件类型都是Event枚举类型内的一个成员 API 文档 decl_error! 定义 pallet 在可调用函数中可能返回的错误类型 DispatchError 。宏自动为DispatchError 实现了 From&lt;Error&lt;T&gt;&gt; trait， 因此，DispatchError 能为特定的错误类型返回正确的模块索引、错误代码、错误字符串 API 文档 decl_module! 定义pallet中的可调用函数，在此宏中，pallet声明了一个名为 Module的结构体，以及一个名为 Call 的枚举类型。除了为 Module 和 Call实现了各种辅助trait，如 Copy、StructuralEq、 Debug以外，该宏还为Module实现了生命周期trait，如 frame_support::traits::OnInitialize， frame_support::traits::OnFinalize， frame_support::traits::OnRuntimeUpgrade，和frame_support::traits::OffchainWorker API 文档 construct_runtime! 用于构造Substrate runtime，将各个pallets集成到runtime。该宏声明及实现了各种不同的结构体和枚举类型，如Runtime、Event、Origin、 Call、GenesisConfig 等，同时也为这些结构体类型实现了不同的辅助trait API 文档 Runtime 结构类型是为Substrate runtime而定义的 Event 枚举类型的成员变量是所有可发出事件的pallets，并且实现了辅助trait和编码/解码trait。Event 实现了TryInto&lt;pallets::Event&lt;Runtime&gt;&gt; trait，以从枚举类型中提取事件 Origin枚举类型是通过实现辅助traits来定义的，如 PartialEq、Clone、 Debug等trait。 此枚举类型定义了是谁调用了extrinsic：NONE、 ROOT还是由特定帐户签名调用 Call枚举类型由所有的集成pallet作为成员变量来定义的。 它包含每个集成pallet的数据和元数据，并通过实现frame_support::traits::UnfilteredDispatchable trait将调用重定向到特定pallet 该宏定义了GenesisConfig 结构类型，并实现了sp_runtime:: BuildStorage trait以建立存储的创世配置 该宏收集每一个pallet对 frame_support::unsigned::ValidateUnsigned 这个trait的实现， 如果没有任何一个pallet实现了 ValidateUnsigned trait，则所有的无签名交易都将被拒绝 parameter_types! 用于在构造runtime时声明参数类型，这些参数类型将赋值给各pallet的可配置trait关联类型。该宏使用get()函数返回的具体值，来替换掉结构体中指定的类型。 每个参数的结构体类型还实现了 frame_support::traits::Get&lt;I&gt; 这个trait，以将类型转换为其指定的值 API 文档 impl_runtime_apis! 通过RuntimeApi和RuntimeApiImpl这两个结构体类型为客户端实现API API 文档 add_crypto! 指定交给pallet管理的密钥对及其签名算法。该宏声明了三种结构体类型: Public、Signature和Pair Public 类型用于生成密钥对、签名和验证签名 Signature 类型用于在确定了签名加密方法情况下保存签名属性 Pair 类型用于使用种子生成一个公私密钥对 API 文档 impl_outer_origin! 用于为runtime构造一个 Origin结构体类型，它通常由construct_runtime!自动调用 API 文档 impl_outer_event! 用于在runtime时构造一个 Event 结构体类型， 它通常由 construct_runtime!宏自动调用 API 文档 impl_outer_dispatch! 用于实现一个元调用模块，以把调用分派给其它调用者，它通常是由 construct_runtime!自动调用的 API 文档 Runtime元数据 建立在 Substrate 上的区块链会暴露出元数据，以便能轻松与其交互。 元数据根据不同的 pallets来源被分隔成不同模块，对于每个模块，元数据都提供该模块对外暴露的 存储项、extrinsic 调用、事件、常量和错误的相关信息。 Substrate 会自动生成这些元数据，并通过 RPC 函数使它可被调用 可使用特定语言库或者与语言无关的HTTP和WebSocket API这两种渠道，来从Substrate节点中获取元数据 具体参考 Runtime执行流程 Substrate runtime的执行由Executive模块来协调，它负责调用区块链中包含的各种runtime模块 Executive模块对外暴露了 execute_block 函数，以实现如下功能： 初始化区块 执行extrinsics 完结区块 验证交易 在区块开始执行前，检查签名交易的有效性 执行区块 只要有效交易的队列不为空，Executive模块就开始执行区块 初始化区块 区块初始化时，System模块和其他runtime模块都会首先调用其on_initialize 函数，把由模块定义的、需要前置的业务逻辑在交易执行前全部处理掉。 除System模块总是优先处理外，其余模块均按照在construct_runtime!宏里定义的顺序来执行 接下来是初始检查，该步骤将验证区块头中的父哈希是否正确，以及extrinsics trie的根是否囊括了所有的extrinsics 执行Extrinsics 按照交易优先级顺序执行每一个有效的extrinsic。 Extrinsics一定不能在rutnime逻辑中引起程序崩溃，否则系统将很容易受到用户攻击，而通过这种攻击，用户可不受任何惩罚地消耗计算资源 当extrinsic执行时，原有存储状态不会提前被缓存下来，修改将直接应用到存储上。 因此，在更改存储状态之前，runtime开发人员应进行所有必要检查，以确保extrinsic能执行成功。 一旦extrinsic在执行过程中失败了，存储更改将不能回滚 extrinsic执行时触发的事件也会写入存储。 因此，在完成所有待执行动作之前，不应该触发相关事件。 否则，倘若extrinsic在事件触发后才执行失败的话，该事件将不能回滚 完结区块 执行完所有队列中的extrinsic之后，Executive模块调用各模块的 on_idle 和 on_finalize 函数来执行区块的最后业务逻辑 智能合约 概述 智能合约与Runtime开发的关系 Substrate Runtime 开发和 Substrate 智能合约是使用 Substrate 框架来构建 “去中心化应用” 的两种不同途径 智能合约 传统的智能合约平台允许用户在核心区块链逻辑之上发布额外的逻辑，为保证安全性，智能合约平台内建了一些安全防护手段，包括： Fees：确保合约开发者在使用了区块链的计算和存储资源来执行智能合约之后付费，这样出块节点的资源就不会被他们滥用 沙箱：一个合约无法直接修改核心区块链存储或其他合约的存储 状态租赁：合约会因为占用了区块链的空间而需要为其付费 回滚：合约可能有导致逻辑错误的情况，我们对合约开发者开发能力的期望很低，因此增加了额外的开销，以支持在交易失败时回滚整个交易 Runtime开发 Runtime 开发不向开发者提供智能合约所提供的那些保护或安全措施，相反，可以完全控制网络上每个节点运行的基本逻辑，也拥有修改和控制所有模块的每一个存储条目的完整权限 Substrate Runtime 开发的目的是为区块链提供精炼、高性能、和快速的节点。 它不提供任何保护，不提供交易回退的开销， 也不隐式地引入区块链上节点运行的收费系统 两者对比 智能合约 Runtime 对网络来说是天生安全 提供对整个区块链的底层访问权限 通过经济激励来防止滥用 没有任何原生的经济激励机制来抵御作恶 通过额外的计算开销来支持错误处理 没有内置安全措施带来的性能开销 开发门槛更低 开发者需要逾越一定的门槛 ink!智能合约 Substrate使用ink!作为其智能合约的语言，ink!是一个基于 Rust 的嵌入式领域专用语言（eDSL），专用于编写Contracts模块的 Wasm 智能合约，其设计宗旨是正确性、简洁性、高效性 ink! 设计上尽可能接近 Rust 编程语言，使用属性宏将标准的 Rust 结构标记为可理解的合约组件 1#[ink(...)] ink!的合约开发组件包括： 事件 (Events) 事件主题 (Event Topics) 存储 (Storage) 构造函数 (Constructor Functions) 消息函数 (Message Functions) 因为是采用 Rust 编写，ink! 可以提供编译时的溢出/下溢安全保护 ink!语言基础 合约(Contracts)模块 合约模块为 Runtime 提供部署和执行wasm智能合约的能力 Wasm引擎 合约模块依赖于 Wasm 的沙盒接口，它定义了 Runtime 内可用的 Wasm 执行引擎（wasmi） 功能 合约模块在智能合约的部署和执行上有许多合约开发者熟悉的功能以及一些新功能 合约账户 对 Substrate Runtime 来说，合约账户就像普通的用户账户一样；但是，除了普通账户所拥有的 AccountID 和 Balance 之外，合约账户还有相关的合约代码和一些持久的合约存储 部署合约 用 Contracts 模块部署合约需要两个步骤： 在区块链上存储 Wasm 合约 开启一个由新存储空间的新账户，与该智能合约挂勾 这意味着可以使用同一个 Wasm 代码初始化多个具有不同的构造参数的合约实例，从而减少区块链上 Contracts 模块所需的存储空间 合约调用 调用合约可以改变合约内的储存、创建新合约，或调用其他合约。 由于可以编写自定义 Runtime 模块，Contracts 模块也可以用合约账户直接异步调用那些 Runtime 函数 沙箱保护 Contracts 模块旨在供公共网络上的所有用户使， 这意味着合约只能直接修改他们自己所拥有的存储。 为了给底层区块链状态提供安全保障，合约模块实现了可逆交易，可回滚那些对存储进行改动而没有成功完成的合约调用 手续费 为了限制一次交易可使用的计算资源，合约调用需要收取手续费 (gas fee)，在构造合约交易时，需要指定 gas 限额。随着合约的执行，gas 根据计算的复杂性逐步被消耗。如果在合约执行完成前达到 gas 限额，则交易失败，合约存储被还原，gas 费用 并不会 退还给用户；如果合约执行完成时还有剩余 gas，则在交易结束时退还给用户 存储租金 与 gas 限制了交易的计算资源类似，存储租金限制了合约在区块链存储中的占用率，合约账户按其使用的存储量所占的比例支付租金。 当合约可用余额低于某个限额时，合约账户会变成一个 “墓碑”，其存储被清空。 墓碑合约可通过提供能激活它的最少资金和被清除的数据，来重新激活合约","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"}]},{"title":"论文阅读-TWINE An Embedded Trusted Runtime","slug":"paper-reading/paper-twine","date":"2021-04-11T16:00:00.000Z","updated":"2021-04-12T12:54:08.000Z","comments":true,"path":"2021/04/12/paper-reading/paper-twine/","link":"","permalink":"http://example.com/2021/04/12/paper-reading/paper-twine/","excerpt":"论文TWINE：An Embedded Trusted Runtime阅读笔记","text":"1.Introduction TWINE（Trusted Wasm in Enclave） 使用标准Intel工具链实现 允许本地执行遗留Wasm应用程序，而无需重新编译 动态地将WASI操作转换为系统调用或安全库函数 将文件操作映射到英特尔的受保护文件系统，持久的数据是透明加密的，并且永远不会以明文的形式从enclave之外访问 实现了完整的安全SQLite嵌入 Contributions 通用的Enclave内wasm运行时环境，支持文件系统加密 广泛评估性能和瓶颈 改进英特尔受保护文件系统的建议 3.Background LLVM 不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR) 如果需要支持一种新的编程语言，那么只需要实现一个新的前端 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改 WASI 让 WebAssembly 也可以运行在非浏览器环境中 需要实现可移植的二进制文件（.wasm）和一个跨平台的运行时（runtime） 实现细粒度的权限控制： 先定义一套标准的系统调用接口：wasi-core 各个平台（windows、unix）对标准接口进行平台实现 对于一个具体的 wasm 程序，需要把其允许调用的接口在运行的时候传入，比如对于一个 wasm 模块，我只传入“__wasi_path_open”这样一个接口，因此 wasm 中就只能用这样一个接口 同样的，对于文件路径也是，只允许对传入的文件路径进行操作，例如只传入 /tmp 路径，wasm 模块就没有办法对 /usr 路径下的文件进行操作 wasm代表抽象的虚拟机，wasi代表其抽象的OS WASM运行时 使用WAMR作为底层运行时： 支持两种解释执行模式，一种慢但内存占用少，另一种快但内存占用多 支持两种二进制执行模式，AoT和JIT，都使用LLVM 使用C语言实现，外部依赖很少 4.Trusted Runtime for WebAssembly TWINE由两大模块组成：Wasm运行时和WASI接口 Wasm运行时完全在TEE中运行，而WASI作为可信环境和不可信环境之间的桥梁与OS通信（相当于OCALL） WASI的优势在于提供三种抽象： 开发者可以自由选择开发语言，只要能够被LLVM等编译器编译为WASI TEE从应用程序中抽象出来：只要TEE能够解释或执行Wasm(由WASI支持)，应用程序就可以安全执行 WASI与系统无耦合，只要OS提供WASI需要的API就可以使用 安全性 WASI可以通过沙箱的方式控制安全性（权限控制） SGX和WASI组成双向沙箱 系统（Enclave认为untrusted）不能损害enclave代码的完整性或是内存中的数据的机密性 Wasm应用（OS认为untrusted）不能直接与OS交互，除非WASI给与权限 威胁模型 没有物理攻击，且TEE提供了指定的保护级别，并且标准加密不能被破坏 对于SGX Enclave：enclave内的代码和数据是可信的，而来自外部的任何东西都是不可信的 外部只能读取经过加密的enclave内存 侧信道攻击和拒绝服务攻击可能存在，需要enclave中的应用程序解决 对于OS：遵循honest-but-curious模型 WASI WASI是Wasm应用程序与外部世界通信的接口 WAMR的工具包提供了一个预先编译器，能够在Wasm应用程序到达TWINE的enclave之前，使用LLVM将其编译为本地代码（native code）。因此，TWINE不包含Wasm解释器，只能执行预先编译的应用程序（执行本地代码比代码编译更快） Wasm运行时比代码解释器占用的内存更小 WASI实现细节 大部分WASI调用被直接转换为OCALL TWINE为WAMR实现了一个不同的WASI接口，更适合SGX使用： 保留其沙箱实现 将剩下部分分为两层：一层用于特定功能实现，一层用于一般调用 一般调用通过在enclave外调用类POSIX库来处理，同时提供额外的安全措施和健全性检查；一般调用只有某个功能没有可信实现时才会使用 TWINE包含一个编译标志，可以全局禁用enclave中的不受信任的POSIX实现（接口可能泄漏主机调用中的敏感数据，例如使用模式和参数） IPFS（Intel Protected File System） IPFS分为两部分： 1.可信库，在enclave中运行，为文件管理提供了类似POSIX的API 2.不可信库，与enclave之外的POSIX函数交互，这些函数进行实际文件读写 写操作：先由可信库对内容加密，再由不可信库写到存储介质（加密后的文件以Merkle树的结构存在） 读操作：由可信库进行完整性校验 IPFS实现细节 IPFS自动创建用于加密文件的密钥，这些密钥由enclave签名和处理器的密钥导出 TWINE持久化的文件在enclave之外被视为密文，而在Wasm应用程序处理之前会透明地解密并进行完整性检查","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"wasm","slug":"wasm","permalink":"http://example.com/tags/wasm/"}]},{"title":"EOS入门","slug":"learning-notes/eos入门","date":"2021-04-08T16:00:00.000Z","updated":"2022-04-28T07:47:46.000Z","comments":true,"path":"2021/04/09/learning-notes/eos入门/","link":"","permalink":"http://example.com/2021/04/09/learning-notes/eos%E5%85%A5%E9%97%A8/","excerpt":"EOS开发入门","text":"简介 平台和工具链 Nodeos EOSIO节点守护进程的核心 处理区块链数据持久层、点对点网络和智能合约调度 在开发环境中，可以使用nodeos建立单节点区块链网络 Cleos 命令行工具，调用nodeos暴露的接口API 部署和测试EOSIO智能合约 Keosd 密钥管理器守护进程，用于存储私钥和对消息签名 keosd为要在相关钱包文件中加密的密钥提供安全密钥存储介质 keosd守护进程还定义了一个安全的enclave，用于对cleos或第三方库创建的交易进行签名 EOSIO.CDT WASM工具链 对EOSIO智能合约的编译进行EOSIO-specfic优化 EOSJS JavaScript API SDK，集成基于EOSIO的区块链 核心概念 账户 存储在区块链上的人类可读的名字 用于转移或提交有效的交易到区块链上 钱包 存储密钥的客户端 理想情况下，钱包有一个加密状态和一个解密状态 授权和权限 定义交易的需求，通过linking authorization或linkauth来为特殊合约分配权限 智能合约 在链上执行，一旦执行就永久留存在链上且不可变 DPOS共识 Delegated Proof of Stake 委托权益证明 若在链上持有token，可以通过投票系统选择block producer 任何人都可以参与block producer的竞选 RAM 被视为永久存储，用于存放账户名、权限、代币余额等需要快速访问的链上数据 RAM需要购买，并且不是基于权益分配，因为RAM是一个有限的持久性资源 CPU 代表区块链上一个动作的执行时间 在cleos的 get account 命令的输出中，CPU被称为 cpu bandwidth，代表一个账户在将动作提交到合约时可以支配的处理时间 CPU是一个瞬态系统资源，属于EOSIO的权益机制 NET NET是交易的网络带宽，单位为byte 在cleos的 get account 命令的输出中，NET被称为 net bandwidth NET是一个瞬态系统资源，属于EOSIO的权益机制 技术特征 WebAssembly C++编译 EOSIO使用C++编写智能合约 在EOSIO核心层的顶端是一个Wasm虚拟机：EOS VM ，用于执行智能合约（它是为区块链应用的高要求而设计的，对WebAssembly引擎的要求远远高于为web浏览器标准开发而设计的引擎） 使用Wasm标准有利于将其他语言移植到EOSIO平台 高吞吐量、更快的确认、低延迟 通过智能合约分配和管理资源 权益机制 通过权益机制来获取系统资源（CPU和NET） 用户使用权益token换取CPU和NET的使用，按照占所有用户的token比例分配 商业模型灵活性 综合的权限架构 可升级 高效能源消耗 环境配置 安装EOSIO和CDT 根据官网指示安装EOSIO和CDT，在Ubuntu20.04上，下载github上对应的Pre-release包 创建开发钱包 创建钱包 注意保存密码 1cleos wallet create --to-console 打开钱包 1cleos wallet open 查看钱包列表 1cleos wallet list 解锁钱包 1cleos wallet unlock 向钱包导入密钥 1cleos wallet create_key 导入开发密钥 1cleos wallet import 输入如下私钥（所有新的EOSIO链都有相同的开发密钥） 15KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 对应的开发公钥为： 1EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 开启keosd和nodeos 开启keosd 1keosd &amp; 若遇到报错： 1&quot;3120000 wallet_exception: Wallet exception Failed to lock access to wallet directory; is another keosd running?&quot; 先使用命令 pkill keosd 再重新开启 开启nodeos 运行Nodeos，加载所有基本插件，设置服务器地址，开启CORS，添加合约debug和日志 123456789101112nodeos -e -p eosio \\--plugin eosio::producer_plugin \\--plugin eosio::producer_api_plugin \\--plugin eosio::chain_api_plugin \\--plugin eosio::http_plugin \\--plugin eosio::history_plugin \\--plugin eosio::history_api_plugin \\--filter-on=&quot;*&quot; \\--access-control-allow-origin=&#x27;*&#x27; \\--contracts-console \\--http-validate-host=false \\--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp; 查看日志 查看Nodeos是否正在出块 1tail -f nodeos.log 如果报错 Database dirty flag set (likely due to unclean shutdown): replay required ，先使用命令 pkill nodeos 安全关闭nodeos，再重新开启 确保RPC API正常运行 1curl http://localhost:8888/v1/chain/get_info 创建开发账户 账户是授权的集合，保存在区块链上 账户可以标识一个用户，也可以标识智能合约（一个账户只能有一个智能合约） 账户可以由一个用户或一组用户控制 创建测试账户 每个EOSIO账户都和一个公钥绑定 123cleos create account eosio bob EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CVcleos create account eosio alice EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 查看账户信息 1cleos get account alice 得到如下结果： 12345678910111213141516permissions: owner 1: 1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV active 1: 1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CVmemory: quota: unlimited used: 2.66 KiB net bandwidth: used: unlimited available: unlimited limit: unlimitedcpu bandwidth: used: unlimited available: unlimited limit: unlimited 用户可以暴露active公钥，自己保存owner公钥，这样，如果active公钥被泄露，用户可以使用owner公钥取回账户控制权（所以建议使用不同的active公钥和owner公钥） 智能合约编写 Hello World 创建hello目录并编写hello.cpp 12345678#include &lt;eosio/eosio.hpp&gt;class [[eosio::contract]] hello : public eosio::contract &#123;public: using eosio::contract::contract; [[eosio::action]] void hi(eosio::name user) &#123; print(&quot;Hello, &quot;, user); &#125;&#125;; 编译cpp，会产生两个文件：hello.wasm和hello.abi 1eosio-cpp -abigen -o hello.wasm hello.cpp 部署智能合约 首先创建一个新的hello账户，在hello目录下生成hello账户的公私钥 1cleos create key --file hello_key 使用生成的公钥创建hello账户 1cleos create account eosio hello &lt;public key&gt; 向钱包导入hello私钥 1cleos wallet import 部署hello智能合约到hello账户（先cd到contracts目录） 1cleos set contract hello ./hello -p hello@active 调用智能合约 1cleos push action hello hi &#x27;[&quot;bob&quot;]&#x27; -p bob@active 设置智能合约调用权限 修改hello.cpp并重新编译以及部署 123456789#include &lt;eosio/eosio.hpp&gt;class [[eosio::contract]] hello : public eosio::contract &#123;public: using eosio::contract::contract; [[eosio::action]] void hi(eosio::name user) &#123; require_auth(user); print(&quot;Hello, &quot;, eosio::name&#123; user &#125;); &#125;&#125;; 测试：bob说hi，但交易由alice签名（失败） 1234cleos push action hello hi &#x27;[&quot;bob&quot;]&#x27; -p alice@activeError 3090004: Missing required authorityEnsure that you have the related authority inside your transaction!; 测试：bob说hi，交易由bob签名（成功） 12345cleos push action hello hi &#x27;[&quot;bob&quot;]&#x27; -p bob@activeexecuted transaction: 033b54bd4a79a9bc868910087bd769e108ffe6f0db29b2b51c61007b03880f51 104 bytes 116 us# hello &lt;= hello::hi &#123;&quot;user&quot;:&quot;bob&quot;&#125;&gt;&gt; Hello, bob Tokens 获取源代码，在contracts目录下： 123git clone https://github.com/EOSIO/eosio.contracts --branch v1.7.0 --single-branchcd eosio.contracts/contracts/eosio.token 创建一个账户来部署token合约（公钥是EOSIO开发公钥） 1cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 编译智能合约 1eosio-cpp -I include -o eosio.token.wasm src/eosio.token.cpp --abigen 部署智能合约（cd到 eosio.token/…/ 目录下） 1cleos set contract eosio.token ./eosio.token --abi eosio.token.abi -p eosio.token@active 创建token：需要指定一个颁发者和token名称以及最大供应量；同时为了创建token，需要eosio.token账户的权限 1cleos push action eosio.token create &#x27;[ &quot;alice&quot;, &quot;1000000000.0000 SYS&quot;]&#x27; -p eosio.token@active 颁发token：拥有颁发权的alice颁发100个token（可以加上 -d -j 参数来debug） 1cleos push action eosio.token issue &#x27;[ &quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot; ]&#x27; -p alice@active 交易token：alice转了25个token给bob 1cleos push action eosio.token transfer &#x27;[ &quot;alice&quot;, &quot;bob&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot; ]&#x27; -p alice@active 查看bob以及alice的账户余额 123cleos get currency balance eosio.token bob SYScleos get currency balance eosio.token alice SYS ABI文件 Application Binary Interface（ABI）用来描述如何将用户操作在JSON格式和二进制格式之间转换 ABI文件结构 12345678910&#123; &quot;version&quot;: &quot;eosio::abi/1.0&quot;, &quot;types&quot;: [], &quot;structs&quot;: [], &quot;actions&quot;: [], &quot;tables&quot;: [], &quot;ricardian_clauses&quot;: [], &quot;abi_extensions&quot;: [], &quot;___comment&quot; : &quot;&quot;&#125; types 自定义数据类型需要在ABI文件中进行描述，但是对于EOS.IO的内建类型，无需在ABI文件中说明，之前的hello和eos.token合约的ABI文件中，types都是[]，因为没有自定义类型 如下，给account_name建立一个笔名，在ABI文件里用name可以代替account_name 1234&quot;types&quot;: [&#123; &quot;new_type_name&quot;: &quot;account_name&quot;, &quot;type&quot;: &quot;name&quot;&#125;] structs 声明各个action需要传入的参数，系统根据actions部分中声明的type，在structs部分寻找对应的数据结构，也就是说，函数声明部分并没包含具体内容，具体数据需要到structs中寻找 1234567&#123; &quot;name&quot;: &quot;issue&quot;, // 数据结构名 &quot;base&quot;: &quot;&quot;, // 继承的父结构名 &quot;fields&quot;: [ // 参数数组，包含参数名和类型 &#123;&quot;name&quot;:&quot;&quot;, &quot;type&quot;:&quot;&quot;&#125;, ] &#125; 例子： 1234567891011121314151617181920212223242526272829&quot;structs&quot;: [&#123; &quot;name&quot;: &quot;transfer&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: [ &#123;&quot;name&quot;:&quot;from&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;to&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;quantity&quot;, &quot;type&quot;:&quot;asset&quot;&#125;, &#123;&quot;name&quot;:&quot;memo&quot;, &quot;type&quot;:&quot;string&quot;&#125; ] &#125;,&#123; &quot;name&quot;: &quot;create&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: [ &#123;&quot;name&quot;:&quot;issuer&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;maximum_supply&quot;, &quot;type&quot;:&quot;asset&quot;&#125;, &#123;&quot;name&quot;:&quot;can_freeze&quot;, &quot;type&quot;:&quot;uint8&quot;&#125;, &#123;&quot;name&quot;:&quot;can_recall&quot;, &quot;type&quot;:&quot;uint8&quot;&#125;, &#123;&quot;name&quot;:&quot;can_whitelist&quot;, &quot;type&quot;:&quot;uint8&quot;&#125; ] &#125;,&#123; &quot;name&quot;: &quot;issue&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: [ &#123;&quot;name&quot;:&quot;to&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;, &#123;&quot;name&quot;:&quot;quantity&quot;, &quot;type&quot;:&quot;asset&quot;&#125;, &#123;&quot;name&quot;:&quot;memo&quot;, &quot;type&quot;:&quot;string&quot;&#125; ] &#125;] actions 用于声明智能合约有哪些可以调用的action 12345&#123; &quot;name&quot;: &quot;transfer&quot;, // 在智能合约中定义的函数名 &quot;type&quot;: &quot;transfer&quot;, // 在structs中声明的数据结构名 &quot;ricardian_contract&quot;: &quot;&quot; // 可选参数，开发中&#125; tables 列出智能合约需要建立的数据表的名称以及数据表中存储的结构体名称 1234567&#123; &quot;name&quot;: &quot;&quot;, // 数据表的名称 &quot;type&quot;: &quot;&quot;, // 数据表对应的struct &quot;index_type&quot;: &quot;&quot;, // 主键类型 &quot;key_names&quot; : [], // 键名列表，长度与key_types相同 &quot;key_types&quot; : [] // 键的类型列表，长度与key_names相同&#125; 例子： 1234567&#123; &quot;name&quot;: &quot;accounts&quot;, &quot;type&quot;: &quot;account&quot;, &quot;index_type&quot;: &quot;i64&quot;, &quot;key_names&quot; : [&quot;primary_key&quot;], &quot;key_types&quot; : [&quot;uint64&quot;]&#125;","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"},{"name":"eos","slug":"eos","permalink":"http://example.com/tags/eos/"}]},{"title":"论文阅读-SGX容器相关","slug":"paper-reading/SGX-Container-LibOS","date":"2021-03-23T16:00:00.000Z","updated":"2022-12-05T06:29:03.935Z","comments":true,"path":"2021/03/24/paper-reading/SGX-Container-LibOS/","link":"","permalink":"http://example.com/2021/03/24/paper-reading/SGX-Container-LibOS/","excerpt":"论文阅读-SGX容器相关","text":"LibOS概念 库操作系统 (Library OS) 的思想是，将应用程序所依赖的操作系统个性（操作系统个性是操作系统的应用程序编程接口(api)和应用程序可见语义的实现，用于构建应用程序的OS服务）作为库在应用程序的地址空间中运行。一个小的、固定的抽象集将库OS连接到主机OS内核，提供了更好的系统安全性和更快速的OS组件独立演化的可能性。 SCONE: Secure Linux Containers with Intel SGX SCONE是一个屏蔽的执行框架，它使未经修改的应用程序能够利用SGX提供的隔离。使用SCONE，程序会根据修改后的标准C库(SCONE libc)重新编译，这有助于系统调用的执行。应用程序的地址空间仅被限定为enclave内存，而不受信任的内存只能通过系统调用接口访问。特殊的包装器复制enclave内部和外部的系统调用参数，并提供以透明的加密方式保护任何数据的功能，否则这些数据可能会以明文形式离开enclave边界(所谓的shield)。 SCONE是一种Docker的安全容器机制，它使用Intel CPU的SGX可信执行支持来保护容器进程免受外部攻击。 SCONE的特征： 支持安全策略和透明认证 原生应用程序支持：不过仍然建议将已有的应用进行重新编译再放入SCONE 不仅支持静态链接，也支持动态链接：共享库可以在应用程序开始运行后被加载，共享库被SCONE文件系统shield保护 支持fork 威胁模型 我们假设有一个强大而活跃的对手，他拥有对系统和物理硬件的超级用户访问权。它们可以控制整个软件栈，包括特权代码，如容器引擎、操作系统内核和其他系统软件。这使对手能够重播、记录、修改和删除任何网络数据包或文件系统访问。 设计权衡 为了在容器中安全执行Linux进程，应该在enclave中放置怎么样的系统支持? 不同的设计方案会影响： 容器的安全属性，包括TCB的大小和对外公开的接口 SGX固有限制对性能的影响 可选设计方案 外部容器接口 要在安全容器中执行未修改的进程，容器必须支持C标准库(libc)接口，从而必须使用系统调用，这不能在enclave内部执行，因此安全容器必须向主机OS公开外部接口。关键的决策变成了(a)外部接口和(b)在enclave中实现接口所需的TCB的大小。 图1a显示了一个先前的设计方案，它通过在enclave中放置一个完整的Windows library OS来最小化外部接口。这种方法的一个好处是，它只公开一个包含22个调用的小外部接口，因为一个进程的大部分系统支持可以由库操作系统提供。然而，库OS增加了enclave内部的TCB大小。此外，由于库OS引入了额外的抽象(例如，执行I/O时)，它可能会增加性能开销。 图1b的设计是外部接口用于执行应用程序发出的所有libc库调用。这对接口的安全性要求很高。这种方法的一个好处是，它在enclave内部产生了最小的TCB—只有一个很小的shim C库需要将libc调用中继到enclave外部的宿主libc库。 图1c的设计是前两者取中值，在libc实现执行的系统调用级别上定义了外部接口 系统调用的开销 有效的系统调用支持是安全容器的关键需求。因此，安全容器设计不能仅仅简单的使用线程转换来支持系统调用。 内存访问开销 出于性能原因，安全容器设计应该减少对enclave内存的访问。理想情况下，它应该尽可能多地使用不可信的非enclave内存，而不损害提供的安全保证。 SCONE设计 SCONE将一个基于系统调用的外部接口暴露给OS，在将参数传递给应用程序之前，执行完整性检查并将所有基于内存的返回值复制到enclave内部 SCONE支持M:N线程来避免不必要的enclave转换，当应用程序线程发出系统调用时，SCONE检查是否有另一个应用程序线程可以唤醒并执行，直到系统调用的结果可用为止 SCONE为容器提供了一个到主机OS的异步系统调用接口，使用共享内存来传递系统调用的参数和返回值，并发出执行系统调用的信号，系统调用由SCONE内核模块中运行的独立线程执行，因此在执行系统调用时，enclave中的线程不需要退出 SCONE集成了现有的Docker容器环境，并确保安全的容器与标准Linux容器兼容 外部接口防护 文件系统防护 保护文件的完整性和机密性。容器映像创建者定义三组不相交的文件路径前缀： 未受保护的文件的前缀 加密和经过身份验证的文件的前缀 经过身份验证的文件的前缀 当文件被打开时，防护层确定文件名的最长匹配前缀。根据匹配情况，对文件进行身份验证、加密或直接传递给主机操作系统。 SCONE还通过其文件系统防护支持专用的安全临时文件系统。防护层保证了临时文件的完整性和机密性：临时文件系统维护非enclave内存中被修改的文件的状态。 网络防护 使用TLS为容器服务建立安全通道，封装了所有的套接字操作，并将它们重定向到一个网络防护层。在建立新连接时，网络防护层将执行TLS握手并对通过套接字传输的任何数据进行加/解密。 这种方法不需要客户端或服务端更改，私钥和证书是从容器的文件系统中读取的，因此，它们受到文件系统防护层的保护。 控制台防护 容器环境允许授权的进程附加到stdin、stdout和stderr控制台流。为了确保发送到这些流的应用程序数据的机密性，SCONE支持对它们进行透明加密。控制台流是单向的，这意味着它们无法受到网络防护层的保护，因为网络防护层的底层TLS实现需要双向流。控制台防护通过基于刷新模式将流分割成可变大小的块来加密流。通过为每个块分配一个唯一的标识符（由授权的SCONE客户端检查)，可以保护流免受重播和重新排序攻击。 异步系统调用 同步系统调用的缺点：由于SGX不允许系统调用从一个enclave内部发出，必须通过对enclave之外的函数的调用来实现。这意味着执行线程必须将基于内存的参数复制到非enclave内存，退出enclave并执行外部函数来发出系统调用。当系统调用返回时，线程必须重新进入enclave，并将基于内存的结果复制回enclave。效率很低 因此，SCONE提供了一个异步系统调用接口。该接口由两个无锁的、多生产者-多消费者队列组成：一个请求队列和一个响应队列。系统调用是通过将请求放入请求队列来发出的。SCONE内核模块中的一个操作系统线程接收并处理这些请求。当系统调用返回时，操作系统线程将结果放入响应队列。 Ryoan: A Distributed Sandbox for Untrusted Computation on Secret Data Ryoan提供了一个安全的分布式沙箱，利用SGX来保护沙箱实例免受潜在恶意计算平台的攻击，受保护的沙箱实例限制了不可信的数据处理模块，允许用户在数据处理服务中对数据保密，而不需要信任提供服务的第三方平台 Graphene-SGX: A Practical Library OS for Unmodified Applications on SGX Graphene-SGX为SGX提供一个端口来增强SGX的功能，如对动态加载库的完整性支持和安全多线程的支持 将LibOS进程实现为Enclave-Isolated进程（EIP），每个EIP由一个Enclave内的一个LibOS实例托管，即n个EIP需要n个LibOS实例和n个Enclave。 不足（Occlum中提出）： 由于Enclave创建的成本很高，进程创建非常昂贵 EIP之间的进程间通信（IPC）很昂贵，因为EIP完全被Enclave边界隔离，必须通过不可信内存来传输加密的消息来彼此通信 在多个LibOS实例之间同步时困难的，因为多个LibOS会存在于多个Enclave中 设计考量 功能性 在一个极端，像Haven这样的LibOS将操作系统的大多数应用程序支持代码拖到enclave中。在另一个极端，只有薄薄一层shim，如SCONE和Panoply封装了一个API层(系统调用表)。在enclave中添加更多代码会增加TCB的大小，但可以减少enclave和不受信任的OS之间的接口和攻击面的大小和复杂性。 在设计时需要考虑： 进出enclave十分消耗资源 EPC的大小有限 防护层的复杂性 SGX硬件可以将应用程序与不受信任的操作系统隔离，但SGX本身无法保护需要从操作系统获得功能的应用程序。Iago攻击是来自不受信任的操作系统对应用程序的语义攻击，通过未经检查的系统调用返回值损害SGX应用程序。 因此，任何SGX框架都必须提供一些防护支持，以验证或拒绝来自不受信任的操作系统的输入。防护层的复杂性与接口的复杂性直接相关：由于一个LibOS或shim可以减少enclave API的大小或复杂性，Iago攻击成功的概率就降低了。 应用程序代码的复杂性 将应用程序运行在Enclave中，可以有以下方法： 修改应用程序，以减少运行时所需的时间 对不受信任的操作系统开放和屏蔽更多接口 将更多的功能引入到shim或LibOS中 设计大纲 威胁模型 不可信的组件包括： 英特尔CPU之外的硬件 操作系统、hypervisor和其他系统软件 在同一主机上执行的其他应用程序，包括不相关的enclave 驻留在应用程序进程中但enclave之外的用户空间组件 可信组件包括： 英特尔CPU Enclave中的代码，包括LibOS、未经修改的应用程序及其支持库 Intel SGX SDK提供的enclave：aesmd。它用来验证enclave签名中的属性并批准enclave创建。除了aesmd和驱动，不信任Intel SGX SDK 多进程应用 在每个进程中运行一个单独的LibOS实例来支持多进程应用程序。每个LibOS实例通过消息传递来协调状态。例如，通过fork创建第二个enclave，并通过消息传递复制父enclave的内容 屏蔽Linux抽象 动态加载 为了运行未经修改的Linux二进制文件，Graphene-SGX实现了动态加载和运行时链接。在Linux系统中二进制文件大都是动态链接的，但静态链接在SGX框架中很流行，因为它很简单，便于使用硬件enclave度量。动态链接需要动态加载器中的根信任，然后动态加载器必须度量库。对于Haven，enclave度量仅验证Haven本身的完整性，并且同样的度量适用于在相同的Haven二进制文件上运行的任何应用程序。 Graphene-SGX扩展了Haven模型，为任何可执行库和动态链接库的组合生成唯一签名。下图显示了一个enclave的结构和动态加载过程。Graphene-SGX从一个不受信任的平台适配层(pal-sgx)开始，该层调用SGX驱动程序来初始化enclave。enclave的初始状态决定了CPU随后验证的度量结果，它包括一个屏蔽库(libshield.so)、要运行的可执行文件和一个清单文件（指定了enclave中的属性和可加载二进制文件）。然后屏蔽库加载一个Linux LibOS (libLinux.so)和标准C库(ld-linux-x86-64.so和libc.so)。在enclave初始化之后，加载程序继续加载其他库，这些库由屏蔽库检查。如果SHA-256哈希值与清单不匹配，屏蔽层将拒绝打开库。 清单包括所有组件的完整性度量以及签名，这个清单对于每个应用程序都是唯一的，并作为enclave初始化的一部分进行度量。这种策略需要信任Graphene-SGX(in-enclave)引导加载程序和屏蔽模块，从而能够根据清单正确加载二进制文件，并拒绝OS提供的任何错误二进制文件。这并不比放置在Haven的动态加载器中的信任级别差，但不同点在于Graphene能区分不同的应用程序，甚至相同应用程序的使用不同库的实例。 存储权限 默认情况下，Linux链接器格式(ELF)经常将代码和链接数据(例如跳转目标)放在同一个页面中。库在链接期间将可执行页面临时标记为可写，然后将该页面保护为仅执行页面。这种行为在当前的Linux共享库中普遍存在，但是可以在编译时更改，将可写的部分填充到单独的页面上。 SGX1不能在enclave初始化之后更改页面权限。为了支持这种ELF行为，我们目前将所有enclave页面映射为可读、可写和可执行。这可能会导致一些安全风险，例如enclave中的代码注入攻击。在一些情况下，这也会损害功能，例如，一些JVM实现使用页面错误来同步线程。 依赖位置的可执行文件 SGX要求所有的enclave大小都是2的幂，并且起始地址从与enclave大小对齐的虚拟地址开始。大多数Linux可执行文件被编译成依赖于位置的，通常从地址0x400000开始。挑战在于，要创建包含此地址且大于4MB的enclave将必须包含地址0。 我们认为在enclave中包含地址0是一个正面的结果，但并不是严格必要的，因为我们不愿意在空指针后面的代码中进行强声明。Graphene-SGX仍然可以在enclave中将该地址标记为未映射。因此，空指针仍然会导致页面错误。另一方面，如果地址0在enclave之外，则存在不受信任的OS将该地址映射到危险数据的风险，从而破坏enclave的完整性。 Occlum: Secure and Efficient Multitasking Inside a Single Enclave of Intel SGX Occlum设计了一种新的软件故障隔离技术（SFI Software Fault Isolation）用于沙箱不可信模块的软件检测，通过SFI隔离流程（SIP）实现LibOS，从而能够安全共享Enclave的单个地址空间，并且实现既安全又高效的多任务处理 在SGX中添加LibOS的目的在于： SGX开发人员需要将SGX保护的应用程序分成enclave和非enclave两部分，这导致了需要大量的工作来重构SGX的遗留代码。最近的工作试图通过在enclave中引入库操作系统(LibOSes)来尽量减少工作量。通过LibOS提供系统调用，遗留代码可以在enclave中运行，而不需要修改。 AccTEE: A WebAssembly-based Two-way Sandbox for Trusted Resource Accounting 远程计算通常在沙箱环境中进行： 隔离执行以保护主机环境免受未经授权的访问 控制和限制资源使用 数据所有者和计算提供者存在相互的不信任，因为： 数据所有者会失去对代码和数据的控制权 不能确定代码执行环境的完整性 资源使用审计缺少双方信任 AccTEE结合SGX和WebAssembly实现一个双向沙箱，在保证代码和数据的机密性和完整性的同时，进行细粒度地资源核算（通过计算WebAssembly指令，内存分配以及I/O操作）。 SGX：保护代码和数据不被计算提供者未经授权访问 WebAssembly：防止数据所有者未经授权访问计算提供者的机器 背景 使用场景 志愿计算 缺点： 通过计量捐赠的CPU时间来决定贡献，而不考虑内存、IO或CPU性能 多次执行每个任务来保证结果的完整性，浪费资源 志愿者可以获得数据和代码 通过AccTEE可以保护结果的完整性，避免多次执行浪费资源；也可以跟踪资源使用情况，防止有作弊行为。 补偿计算：参与者提供他们私有机器的空闲资源，并以此获得奖励，例如加密货币。但计算资源提供者和基础设施提供者相互不信任，可能存在基础设施提供者恶意修改计算资源提供者的贡献值。 通过AccTEE，计算资源提供者可以保护自己的贡献不被恶意修改。 无服务计算：由功能即服务（Function-as-a-Service FaaS）驱动，开发人员不需要管理服务器，只需要编写和提交函数代码，由云提供商来设置函数的执行上下文，衡量并行函数实例的数量，连接函数的输入输出。但会存在代码所有者和计算提供者间的不信任。 Pay-by-Computation：网络内容提供者主要依靠在线广告获得运营资金，但是用户想方设法删除广告，浏览器也有了拦截广告的技术，因此需要一种替代的，侵入性较小的机制来补充网络内容提供者。 通过AccTEE，用户通过使用空闲资源在后台运行短期任务来换取网站的访问权，由双向沙箱来保护任务的机密性和完整性。 WebAssembly WASM是一种新型的、平台无关的二进制指令格式，其目标是一种安全、快速和可移植的低级代码格式。 在技术层面，WebAssembly代表了一个基于软件故障隔离的单向沙箱，WebAssembly模块通过不相邻的内存空间相互隔离：代码的内存空间、执行栈、执行环境数据结构和堆是分开的，从而防止任意代码执行以及WebAssembly模块自身数据之外的数据损坏。 除了内存隔离之外WASM还提供一个受保护的调用堆栈，它只包含固定大小的变量，更复杂的结构存放在线性存储器的栈中，以防止缓冲区溢出。 WASM提供人类可读的格式WAT，等同于二进制格式。 AccTEE构建在WASM的内置软件故障隔离之上，以防止程序干扰核算系统。 威胁模型 假设代码数据所有者和计算提供者都是强大的攻击者，可以进行任意行为，所有参与的执行平台都是不可信的。但是信任Intel和SGX。 AccTEE设计 系统需求 系统支持各种高级编程语言 平台独立性：核算的结果独立于平台，平台只需要将workload代码转换为可执行指令 双向隔离：workload隔离于平台环境，平台提供者不能干涉代码执行 可信资源核算：双方都不能干预核算机制 代码和数据的完整性和机密性 低性能开销 资源核算方法 AccTEE使用中间代码来获得平台独立性，具体来说，使用WebAssembly来支持更多的语言：对于相同的(确定性的)任务和输入参数，在不同的硬件平台，甚至不同的WebAssembly运行时，执行的WebAssembly指令的数量是相同的。 execution sandbox防止不可信的数据和代码访问主机或干预资源核算 accounting enclave(AE)防止不可信主机窃听数据代码或操控资源核算 accounting enclave基于WASM提供的基于语言的隔离实现 instrumentation enclave(IE)和AE通过Enclave度量来确保代码正确执行 总体工作流程： 将应用程序编译为WebAssembly 度量WebAssembly代码（在IE中），并输出度量后的WebAssembly代码和一个认证（确保输出是由该IE生成） IE的输出作为AE的输入，AE在认证通过后执行代码，并生成资源核算日志 I/O操作 wasm没有为I/O操作指定接口，因此wasm代码被嵌入到运行时系统中，该系统将必要的原语暴露为wasm代码可以调用的函数。 SGX Enclave中不允许系统调用，必须退出Enclave后才能执行不可信的I/O操作。AccTEE依赖SGX-LKL来执行遗留二进制文件，SGX-LKL处理Enclave内部的系统调用，但是直接访问外部资源的系统调用（如I/O）是不受信任的。 Accounting Enclave AccTEE跟踪三种资源类型，其衡量方式如下： CPU使用：执行的WASM指令的数量 内存 I/O使用：各种I/O通道发送和接收的字节数 CPU 通过维护一个计数器（指令计数器）来跟踪CPU的使用情况，每执行一条wasm指令就递增。 AccTEE将一个全局计数器变量添加到原始wasm代码中，初始化为0，同时也在每个代码块的最后添加wasm指令来增加计数器的值。 wasm指令有不同的复杂度，在计数时需要加权。指令访问内存的成本取决于内存访问模式和访问范围：线性访问便宜而随机访问昂贵，但由于访问内存的指令的成本是无法预测的，所以AccTEE采用峰值内存来估计内存访问的成本。 指令计数器的优化： flow-based（基于数据流）：不用每个代码块都进行计数，当一个代码块有多个父节点时，可以在这个代码块加上所有父节点计数的最小值，在父节点上只要加上差值即可，如下图所示 loop-based（基于循环）：将指令计数器的增量移出循环，不要在每个循环中都增加，而是退出循环之后增加一次。 内存 每个wasm模块都可以访问一块线性内存（连续的一段内存，使用模块定义的大小初始化，但可以动态增长到某个最大值，并且只能增长不能减小），因此AccTEE使用线性内存的大小来计算workload消耗的内存，包含两个策略： 在代码执行结束时将所有线性内存相加得到内存使用峰值 将指令计数器和线性内存大小相结合，实现细粒度的内存计算 I/O 在AccTEE上下文中，wasm运行时时受信任的部分，因此可以通过检测运行时的I/O函数流入和流出wasm模块的字节数来测定。 AccTEE实现 使用SGX-LKL来在Enclave中运行未修改的二进制文件。【创新点：可以进行修改？】 关于wasm的执行环境，采用Node.js JavaScript运行时，底层使用Chrome的JavaScript引擎V8来执行JavaScript和WebAssembly。【可替代方案：WAVM、wasmi】 V8引擎需要“粘合代码”来在JavaScript和wasm执行上下文之间架起桥梁，粘合代码通常是专门为相应的WebAssembly代码定制的，并与之一起生成 基于Emscripten提供的主模块和副模块的分离。main模块提供了一个接口，包含了它导入的所有标准库函数，并生成所有必要的JavaScript粘合代码。每个附加模块(也称为side模块)只从main模块中导入所需的标准库函数。加载side模块时不需要额外的粘合代码。在我们的框架中，我们只是静态地包含了一个提供所有标准库函数及其粘合代码的main模块，而每个动态加载的模块都是一个从main模块中导入所需功能的side模块。编译和实例化每个side模块的代码直接集成到框架中 AccTEE评估 SGX HW模式开销比SIM模式和SGX-LKL模式下大得多？（是由于EPC页切换带来的开销？） 表现为当workload超过可用的EPC内存（93MB）时，性能显著下降。 A Practical Intel SGX Setting for Linux Containers in the Cloud 将SGX部署到云环境应该满足： 对远程认证的有限支持：SGX的一个非常重要的特性是能够向第三方(如云用户)证明SGX应用程序的身份和完整性，但原生的Haven和SCONE都没有提供对CPU远程认证的支持； SGX的应用安全：将整个应用包含在一个安全的enclave中的那些解决方案 (Haven, Graphene-SGX, SCONE) 都不一定保证安全，因为它们都扩大TCB，并且可能包含现存的应用或库中的漏洞； 限制EPC内存：当前最大的EPC大小是128MB，用户可用的大约是93MB。虽然Linux上支持EPC页面交换，但这会导致相当大的性能损失。EPC限制还意味着云提供商需要保护EPC免受(恶意的)过度使用，这是现有解决方案没有考虑到的一个因素。SGX2甚至允许在enclave运行时期间动态地分配EPC页面，从而加剧了EPC内存消耗； 对应用程序的支持：为了减小enclave内部的TCB(可信计算基), Intel强制要求对程序进行分区，这使得SGX的编程变得困难。 提出lxcsgx： 为容器化应用程序启用SGX远程认证 在Linux内核中强制每个容器的EPC内存使用进行控制，以防止(恶意的)资源过度使用 实现一个GCC插件来帮助程序分区，以减少enclave中的TCB，并更好地支持可伸缩性 使用SGX实现软件TPM，为遗留应用程序提供快速的硬件TPM替换以及套接字api 基于lxcsgx改进并评估Nginx/OpenSSL和Memcached Motivation Haven、Graphene-SGX、SCONE等提供一种方案来使用户不需要仔细划分SGX程序，但代价是增加了PCB和Enclave大小，忽视远程认证、EPC大小的硬件限制。 非官方SDK的不足 不提供远程认证，就不能像远程用户提供保证（应用程序是否确实在Enclave中运行以及Enclave是否具有正确的度量） Enclave中的运行时存在安全问题：Enclave内部使用的传统加密库（如OpenSSL）会受到侧信道攻击，Graphene-SGX和SCONE直接将glibc和musl放入Enclave中，存在包含不安全的函数的问题；相比而言，所有危险的函数都从Intel的可信C库中移除，对于敏感的函数则使用硬件指令完成 程序分区 程序分区要求开发人员找出代码中最安全敏感的部分，放入SGX的可信区域，从而减小TCB。由于系统调用不允许在Enclave内部进行，所以任何不需要分区的方案都依赖于额外的中间层（如LibOS）来模拟系统调用，然而这样会增大TCB。 程序分区的另一个好处是在加载时和运行时都可以减少EPC内存的消耗。 EPC内存控制 在一台云服务器上只能使用128MB的EPC内存来支持多用户，可能存在的内存泄露会导致SGX内核驱动程序交换其他用户的Enclave，并且也有可能存在恶意用户对EPC内存发起DoS攻击。 lxcsgx强制对每个容器的EPC内存使用进行控制以防止以上问题。 软件TPM Enclave不能由不同的进程共享从而减少EPC内存消耗，每个进程都需要分配一个新的虚拟地址区域来加载相同的Enclave，会映射到不同的EPC页面，即EPC页面是不能共享的。 SGX所需的功能（加密、随机数生成、安全存储等）通常在多个应用之间共享，因此可以在通用平台服务上创建一个单一的Enclave，同时为不同的应用程序服务。 lxcsgx使用了tpmsgx将SGX通用加密服务实例化为软件tpm，提供给开发者套接字api。 设计实现 威胁模型 我们并不一定信任云提供商，它可能对破坏其客户的托管容器的机密性感兴趣。恶意的云提供商还可能主动尝试破坏托管容器的机密性和完整性； Linux内核和运行在云服务器上的LXC程序都不受信任； 我们不认为DoS攻击是由ring 0攻击者发起的(例如，防止用户使用Intel SGX) 不考虑来自ring 0攻击者的控制通道攻击或来自ring 3攻击者的侧通道攻击 LXC应用的远程认证 由于LXC/Docker无法挂载非filebackend的套接字，所以容器化应用程序无法直接使用SGX提供的使用QE的远程认证。 解决方案： 为Linux内核添加一个新特性以支持容器的抽象UNIX套接字传递 为了使LXC能够使用内核提供的抽象UNIX套接字直通特性，我们向LXC添加了一个名为lxcsgx.sgx.sock的新配置 控制EPC内存使用 计算每个容器分配的EPC页面数量，如果请求超过EPC额度的页面，则拒绝分配。然而，找到负责每个EPC分配请求的相应容器并非易事，因为容器对底层Linux内核是透明的，内核只看到进程。 我们使用网络名称空间作为容器的唯一标识符，因为它由在容器内运行的所有应用程序共享。在大多数情况下，容器配置了不同的虚拟网卡(LXC中的veth)，因此具有不同的网络名称空间。当一个网络名称空间被多个容器共享时，EPC控制将应用于名称空间中的每个容器。 SGX内核驱动程序实现：SGX内核驱动程序负责EPC内存管理，包括分配、交换和回收。在每次尝试EPC页面分配(EADD)时，我们使用SGX驱动程序维护的enclave所有者信息找到请求进程的PID。给定PID，我们找到相应的网络名称空间并检索EPC控制记录。如果激活了记录，并且请求的EPC使用在限制内，则允许分配，并增加使用计数。类似地，对于EPC页回收，我们减少相应EPC控制记录的当前使用计数。 LXC实现：为了利用EPC控制机制，将另外两个新配置(lxyz .sgx. EPC . limitandlxyz .sgx. EPC .control)添加到LXC中 tpmsgx：软件TPM MPTEE: Bringing Flexible and Efficient Memory Protection to Intel SGX 内存保护扩展（MPX）现在在Linux上已失效。如果使用GCC 9.1及更高版本，它实际上已经无效，因为去年删除了编译器端支持，而现在在Linux 5.6中取消了内核支持。 内存保护扩展是英特尔设计的，用于在运行时检查指针引用，以避免缓冲区溢出以及Skylake和更新的处理器的其他潜在相关漏洞。但是，英特尔一直没有保持对MPX软件的支持，他们表示，未来的英特尔CPU可能会删除MPX功能。 MPX从未真正与基于编译器的消毒器一起真正起飞，它更优雅地解决了相同领域的问题，不需要专门的硬件支持。 Understanding TEE Containers, Easy to Use? Hard to Trust - 安全性分析 提出TECUZZER来对各个SGX容器（Tcon）进行模糊测试，包括Graphene-SGX, SCONE, Occlum, SGX-LKL, Chancel, Deflection 和 Ratel 不完整的OCALL接口保护 基于系统调用的隐蔽通道 使用系统调用参数来开启隐蔽通道，应用程序可以将飞地内数据转移到不受信任的操作系统 只有Occlum提供防御 Tcon应该只允许必要的系统调用（如网络I/O和文件I/O）以及用于安全控制的包装器（如应用加密和限制系统调用参数的范围） 被动系统调用窥探攻击 大多数Tcons不能处理I/O请求，特别是磁盘I/O。因此，他们不得不求助于不受信任的内核来处理请求。然而，这会向操作系统暴露大量信息。以文件操作为例，内核知道哪个文件被打开并被处理，甚至知道发生读或写操作的偏移量。 Occlum和SGX-LKL各自运行一个内嵌文件系统，不将文件的操作暴露给不受信任的操作系统；Ryoan使用内存中的POSIX api来访问预加载的文件，这对操作系统是不可观察的；Graphene保护一部分文件，其他文件保存在Enclave外，通过I/O访问时会暴露访问模式；其他Tcon不提供防御 使用in-enclave文件系统，或采用ORAM 缺乏返回值校验 除了传出参数之外，Tcon还应该控制系统调用的返回值，以减少Iago攻击等漏洞的风险 Graphene-SGX和SCONE可以很好地实现对返回值的安全检查；SGX-LKL、Ryoan和Occlum对某些系统调用的返回值进行校验；一些Tcons实际上由不受信任的组件来检查Enclave外的系统调用的返回值 对Enclave内所有公开的系统调用强制执行返回值检查 软件隔离的缺陷（只针对安全威胁中Enclave内代码不可信的场景UAM） 缺乏直接的分支检查 需要对所有分支指令进行控制，这样程序就不会跳过保护跳转到指令化代码和关键指令之间的位置 错误的内存边界检查 当前的Tcon设计执行内存边界检查，以确保应用程序只能写入自己的数据段 在Deflection和Chancel中，没有进行很好地内存边界检查；Occlum AE所以来的MPX已经被Intel废弃了 Tcon应该强制执行细粒度的内存边界检查，这要求加载器拥有关于应用程序内存布局的详细信息 库缺少工具 注入飞地的未受控恶意库可以完全打破Tcon保护 受限的侧信道保护 基于故障的侧通道攻击 页面错误攻击（更改页表项上的标志，以诱导页面错误，以观察访问模式）和AC错误攻击（更改对齐检查标志，以诱导缓存线内秘密数据访问） 没有Tcon可以抵御页面错误攻击；Graphene-SGX可以减缓AC错误攻击 将已有的解决方案集成到Tcon中，如T-SGX、地址随机化、ORAM、HyperRace等，目前尚不清楚这种保护会不会影响其性能 认证和秘密配置问题 Ratel根本没有认证支持；Deflection和Chancel只提供远程认证接口，而没有完全实现；SCONE包含完整的远程认证实现，但不支持秘密配置 在实际部署之前，应该包括这些关键功能 对执行环境配置的保护不完全 除了在enclave中运行的应用程序外，还应该评估其参数、环境变量和必要的配置文件，以确保它们的完整性得到保护，并且它们不会破坏enclave中的安全保护 Occlum提供了最好的保护；Chancel, Deflection 和 Ratel没有提供任何保护 所有这些元数据都应该具有完整性和机密性，对于在加载到Enclave之前无法确定其正确内容的环境变量，Tcons应该对其执行安全校验","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Rust高级特性","slug":"learning-notes/rust-advance","date":"2021-03-23T16:00:00.000Z","updated":"2022-04-28T07:17:08.000Z","comments":true,"path":"2021/03/24/learning-notes/rust-advance/","link":"","permalink":"http://example.com/2021/03/24/learning-notes/rust-advance/","excerpt":"Rust高级特性","text":"闭包 在函数中返回闭包： 为了从函数返回一些东西，Rust 需要知道返回类型的大小，而不能直接返回一个trait，因此可以返回一个Box指针 在函数中定义的变量放入闭包中返回，会因为移出作用域而失效，因此采用move关键字使得闭包获得它环境的所有权 1234567891011fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; &#123; let num = 5; Box::new(move |x| x + num)&#125;fn main() &#123; let f = factory(); let answer = f(1); assert_eq!(6, answer);&#125; 通用函数调用 不同的trait中有同名函数： 12345678910111213141516171819202122trait Foo &#123; fn f(&amp;self);&#125;trait Bar &#123; fn f(&amp;self);&#125;struct Baz;impl Foo for Baz &#123; fn f(&amp;self) &#123; println!(&quot;Baz’s impl of Foo&quot;); &#125;&#125;impl Bar for Baz &#123; fn f(&amp;self) &#123; println!(&quot;Baz’s impl of Bar&quot;); &#125;&#125;let b = Baz;// b.f(); // 产生歧义，不能执行Foo::f(&amp;b);Bar::f(&amp;b); 结构体本身和trait中有同名函数，使用 &lt;Type as Trait&gt; 指明用的是哪个trait中的函数： 12345678910111213141516171819202122trait Foo &#123; fn foo() -&gt; i32;&#125;struct Bar;impl Bar &#123; fn foo() -&gt; i32 &#123; 20 &#125;&#125;impl Foo for Bar &#123; fn foo() -&gt; i32 &#123; 10 &#125;&#125;fn main() &#123; assert_eq!(10, &lt;Bar as Foo&gt;::foo()); assert_eq!(20, Bar::foo());&#125; 包(crate)和模块(module) 基本调用： 结构： 12345foo├── Cargo.toml└── src └── aaa.rs └── main.rs aaa.rs： 123pub fn print_aaa() &#123; println!(&quot;&#123;&#125;&quot;, 25);&#125; main.rs： 1234567mod aaa;use self::aaa::print_aaa;fn main () &#123; print_aaa();&#125; 多层模块 优先查找 xxx.rs 文件 main.rs、lib.rs、mod.rs中的mod xxx ： 默认优先查找同级目录下的 xxx.rs 文件； 其他文件yyy.rs中的mod xxx ：默认优先查找同级目录的yyy目录下的 xxx.rs 文件； 如果 xxx.rs 不存在，则查找 xxx/mod.rs 文件，即 xxx 目录下的 mod.rs 文件。 例子： 结构： 123456789src├── a│ ├── b│ │ ├── c│ │ │ ├── d.rs│ │ │ └── mod.rs│ │ └── mod.rs│ └── mod.rs└── main.rs a/b/c/d.rs： 123pub fn print_ddd() &#123; println!(&quot;i am ddd.&quot;);&#125; a/b/c/mod.rs: 1pub mod d; a/b/mod.rs: 1pub mod c; a/mod.rs: 1pub mod b; main.rs: 1234567mod a;use self::a::b::c::d;fn main() &#123; d::print_ddd();&#125; **注：**若在 a/mod.rs 中进行重导出(Re-exporting)，即： 12pub mod b;pub use b::c::d; 则可以直接在 main.rs 中使用 use a::d; 来调用 路径 self 的含义： use self::xxx 表示，加载当前模块中的 xxx。此时 self 可省略； use xxx::&#123;self, yyy&#125;，表示，加载当前路径下模块 xxx 本身，以及模块 xxx 下的 yyy； super 表示父模块：use super::xxx; 表示引用父模块中的 xxx 数组转基本类型 将包含4个u8的数组转换为u32类型 123456use std::mem;unsafe &#123; let a = [0u8, 0u8, 0u8, 0u8]; let b = mem::transmute::&lt;[u8; 4], u32&gt;(a);&#125; 关联类型 将多个类型归为一类，如下，构建一个图(Graph)，需要的类型包括点(Node)和边(Edge) 1234567891011121314151617181920212223242526272829trait Graph &#123; type N; type E; fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool; fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;&#125;struct Node;struct Edge;struct MyGraph;impl Graph for MyGraph &#123; type N = Node; type E = Edge; fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool &#123; true &#125; fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; &#123; Vec::new() &#125;&#125;let graph = MyGraph;let obj = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;; 宏 $开头的变量是语法元素，指示符用于限定愈发元素的类型，包括： ident: 标识符，用来表示函数或变量名 expr: 表达式 block: 代码块，用花括号包起来的多个语句 pat: 模式，普通模式匹配（非宏本身的模式）中的模式，例如 Some(t), (3, 'a', _) path: 路径，注意这里不是操作系统中的文件路径，而是用双冒号分隔的限定名(qualified name)，如 std::cmp::PartialOrd tt: 单个语法树 ty: 类型，语义层面的类型，如 i32, char item: 条目， meta: 元条目 stmt: 单条语句，如 let a = 42; 重复 1234567891011121314macro_rules! vector &#123; ($($x:expr),*) =&gt; &#123; &#123; let mut temp_vec = Vec::new(); $(temp_vec.push($x);)* temp_vec &#125; &#125;;&#125;fn main() &#123; let a = vector![1, 2, 4, 8]; println!(&quot;&#123;:?&#125;&quot;, a);&#125; 递归 123456789101112macro_rules! find_min &#123; ($x:expr) =&gt; ($x); ($x:expr, $($y:expr),+) =&gt; ( std::cmp::min($x, find_min!($($y),+)) )&#125;fn main() &#123; println!(&quot;&#123;&#125;&quot;, find_min!(1u32)); println!(&quot;&#123;&#125;&quot;, find_min!(1u32 + 2 , 2u32)); println!(&quot;&#123;&#125;&quot;, find_min!(5u32, 2u32 * 3, 4u32));&#125; 导入和导出 宏导入导出用 #[macro_use] 和 #[macro_export]。父模块中定义的宏对其下的子模块是可见的，要想子模块中定义的宏在其后面的父模块中可用，需要使用 #[macro_use]。 1234567891011121314151617181920212223242526272829macro_rules! m1 &#123; () =&gt; (()) &#125;// 宏 m1 在这里可用mod foo &#123; // 宏 m1 在这里可用 #[macro_export] macro_rules! m2 &#123; () =&gt; (()) &#125; // 宏 m1 和 m2 在这里可用&#125;// 宏 m1 在这里可用#[macro_export]macro_rules! m3 &#123; () =&gt; (()) &#125;// 宏 m1 和 m3 在这里可用#[macro_use]mod bar &#123; // 宏 m1 和 m3 在这里可用 macro_rules! m4 &#123; () =&gt; (()) &#125; // 宏 m1, m3, m4 在这里均可用&#125;// 宏 m1, m3, m4 均可用 crate 之间只有被标为 #[macro_export] 的宏可以被其它 crate 导入。假设上面例子是 foo crate 中的部分代码，则只有 m2 和 m3 可以被其它 crate 导入。导入方式是在 extern crate foo; 前面加上 #[macro_use] 123#[macro_use]extern crate foo;// foo 中 m2, m3 都被导入 如果只想导入 foo crate 中某个宏，比如 m3，就给 #[macro_use] 加上参数 123#[macro_use(m3)]extern crate foo;// foo 中只有 m3 被导入 unsafe 解引用一个裸指针*const T和*mut T 1234let x = 5;let raw = &amp;x as *const i32;let points_at = unsafe &#123; *raw &#125;;println!(&quot;raw points at &#123;&#125;&quot;, points_at); 读写一个可变的静态变量static mut 12345static mut N: i32 = 5;unsafe &#123; N += 1; println!(&quot;N: &#123;&#125;&quot;, N);&#125; 调用一个不安全函数 12345678unsafe fn foo() &#123; //实现&#125;fn main() &#123; unsafe &#123; foo(); &#125;&#125; 迭代器 消费者 collect() 1let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;(); find() 1let greater_than_forty_two = (0..100).find(|x| *x &gt; 42); fold() 12// 计算从迭代器的第0个元素开始，所有元素的累加let sum = (1..4).fold(0, |sum, x| sum + x); 迭代适配器 map 1(1..100).map(|x| println!(&quot;&#123;&#125;&quot;, x)); take 123for i in (1..).take(5) &#123; println!(&quot;&#123;&#125;&quot;, i);&#125; filter 123for i in (1..100).filter(|&amp;x| x % 2 == 0) &#123; println!(&quot;&#123;&#125;&quot;, i);&#125; FFI 调用ffi函数 引入libc库 Cargo.toml: 12[dependencies]libc = &quot;0.2.86&quot; rs文件： 1extern crate libc 声明ffi函数 12345678910use libc::c_int;use libc::c_void;use libc::size_t;#[link(name = &quot;yourlib&quot;)]extern &#123; fn your_func(arg1: c_int, arg2: *mut c_void) -&gt; size_t; // 声明ffi函数 fn your_func2(arg1: c_int, arg2: *mut c_void) -&gt; size_t; static ffi_global: c_int; // 声明ffi全局变量&#125; 调用ffi函数 由于此函数来自外部的c库，所以rust并不能保证该函数的安全性。因此，调用任何一个ffi函数需要一个unsafe块。 123let result: size_t = unsafe &#123; your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void)&#125;; 封装unsafe，暴露安全接口 在一个叫ffi.rs之类的文件中写上所有的extern块用以声明ffi函数。在一个叫wrapper.rs之类的文件中进行包装： 12345// ffi.rs#[link(name = &quot;yourlib&quot;)]extern &#123; fn your_func(arg1: c_int, arg2: *mut c_void) -&gt; size_t;&#125; 12345// wrapper.rs// 对外暴露(pub use)your_func_wrapper函数即可fn your_func_wrapper(arg1: i32, arg2: &amp;mut i32) -&gt; isize &#123; unsafe &#123; your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void) &#125; as isize&#125; 数据结构对应 结构体/Enum 123456789#[repr(C)]// 如果使用#[repr(C, packed)]将不为此结构体填充空位用以对齐struct RustObject &#123; a: c_int, // other members&#125;#[repr(C)]enum SomeEnum &#123;&#125; 回调函数 将一个rust函数转变成c可执行的回调函数非常简单：在函数前面加上extern &quot;C&quot;: 123456789101112131415extern &quot;C&quot; fn callback(a: c_int) &#123; // 这个函数是传给c调用的 println!(&quot;hello &#123;&#125;!&quot;, a);&#125;#[link(name = &quot;yourlib&quot;)]extern &#123; fn run_callback(data: i32, cb: extern fn(i32));&#125;fn main() &#123; unsafe &#123; // 调用c库中定义的run_callback函数，而run_callback函数中的回调函数callback则是在rust中定义的 run_callback(1 as i32, callback); // 打印 1 &#125;&#125; 对应c库代码： 12345typedef void (*rust_callback)(int32_t);void run_callback(int32_t data, rust_callback callback) &#123; callback(data); // 调用传过来的回调函数&#125; 字符串 CStr 对于产生于c的字符串(如在c程序中使用malloc产生)，rust使用CStr来表示，和str类型对应，表明我们并不拥有这个字符串 123456789101112131415use std::ffi::CStr;use libc::c_char;#[link(name = &quot;yourlib&quot;)]extern &#123; fn char_func() -&gt; *mut c_char;&#125;fn get_string() -&gt; String &#123; unsafe &#123; let raw_string: *mut c_char = char_func(); let cstr = CStr::from_ptr(my_string()); cstr.to_string_lossy().into_owned() &#125;&#125; 在这里get_string使用CStr::from_ptr从c的char*获取一个字符串，并且转化成了一个String. 注意to_string_lossy()的使用：因为在rust中一切字符都是采用utf8表示的而c不是， 因此如果要将c的字符串转换到rust字符串的话，需要检查是否都为有效utf-8字节。to_string_lossy将返回一个Cow&lt;str&gt;类型， 即如果c字符串都为有效utf-8字节，则将其0开销地转换成一个&amp;str类型，若不是，rust会将其拷贝一份并且将非法字节用U+FFFD填充。 CString 和CStr表示从c中来，rust不拥有归属权的字符串相反，CString表示由rust分配，用以传给c程序的字符串。 1234567891011use std::ffi::CString;use std::os::raw::c_char;extern &#123; fn my_printer(s: *const c_char);&#125;let c_to_print = CString::new(&quot;Hello, world!&quot;).unwrap();unsafe &#123; my_printer(c_to_print.as_ptr()); // 使用 as_ptr 将CString转化成char指针传给c函数&#125; 注意c字符串中并不能包含\\0字节(因为\\0用来表示c字符串的结束符),因此CString::new将返回一个Result， 如果输入有\\0的话则为Error(NulError)。 空指针 另一种很常见的情况是需要一个空指针。请使用0 as *const _ 或者 std::ptr::null()来生产一个空指针。 将Rust编译成库 调用约定和mangle 由于rust支持重载，所以函数名会被编译器进行混淆，就像c++一样。因此当你的函数被编译完毕后，函数名会带上一串表明函数签名的字符串。 比如：fn test() &#123;&#125;会变成_ZN4test20hf06ae59e934e5641haaE. 这样的函数名为ffi调用带来了困难，因此，rust提供了#[no_mangle]属性为函数修饰。 对于带有#[no_mangle]属性的函数，rust编译器不会为它进行函数名混淆。 12#[no_mangle]extern &quot;C&quot; fn test() &#123;&#125; 使用Any 由于在跨越ffi过程中，rust类型信息会丢失，比如当用rust提供一个OpaqueStruct给别的语言时： 12345678910111213141516171819202122232425262728use std::mem::transmute;#[derive(Debug)]struct Foo&lt;T&gt; &#123; t: T&#125;#[no_mangle]extern &quot;C&quot; fn new_foo_vec() -&gt; *const c_void &#123; Box::into_raw(Box::new(Foo &#123;t: vec![1,2,3]&#125;)) as *const c_void&#125;#[no_mangle]extern &quot;C&quot; fn new_foo_int() -&gt; *const c_void &#123; Box::into_raw(Box::new(Foo &#123;t: 1&#125;)) as *const c_void&#125;fn push_foo_element(t: &amp;mut Foo&lt;Vec&lt;i32&gt;&gt;) &#123; t.t.push(1);&#125;#[no_mangle]extern &quot;C&quot; fn push_foo_element_c(foo: *mut c_void)&#123; let foo2 = unsafe &#123; &amp;mut *(foo as *mut Foo&lt;Vec&lt;i32&gt;&gt;) // 这么确定是Foo&lt;Vec&lt;i32&gt;&gt;? 万一foo是Foo&lt;i32&gt;怎么办？ &#125;; push_foo_element(foo3);&#125; 以上代码中完全不知道foo是一个什么东西。安全也无从说起了，只能靠文档。 因此在ffi调用时往往会丧失掉rust类型系统带来的方便和安全。在这里提供一个小技巧:使用Box&lt;Box&lt;Any&gt;&gt;来包装你的类型。 rust的Any类型为rust带来了运行时反射的能力，使用Any跨越ffi边界将极大提高程序安全性。 12345678910111213141516171819202122232425262728293031use std::any::Any;#[derive(Debug)]struct Foo&lt;T&gt; &#123; t: T&#125;#[no_mangle]extern &quot;C&quot; fn new_foo_vec() -&gt; *const c_void &#123; Box::into_raw(Box::new(Box::new(Foo &#123;t: vec![1,2,3]&#125;) as Box&lt;Any&gt;)) as *const c_void&#125;#[no_mangle]extern &quot;C&quot; fn new_foo_int() -&gt; *const c_void &#123; Box::into_raw(Box::new(Box::new(Foo &#123;t: 1&#125;) as Box&lt;Any&gt;)) as *const c_void&#125;fn push_foo_element(t: &amp;mut Foo&lt;Vec&lt;i32&gt;&gt;) &#123; t.t.push(1);&#125;#[no_mangle]extern &quot;C&quot; fn push_foo_element_c(foo: *mut c_void)&#123; let foo2 = unsafe &#123; &amp;mut *(foo as *mut Box&lt;Any&gt;) &#125;; let foo3: Option&lt;&amp;mut Foo&lt;Vec&lt;i32&gt;&gt;&gt; = foo2.downcast_mut(); // 如果foo2不是*const Box&lt;Foo&lt;Vec&lt;i32&gt;&gt;&gt;, 则foo3将会是None if let Some(value) = foo3 &#123; push_foo_element(value); &#125;&#125; 这样一来，就非常不容易出错了。 属性 属性只能应用于Item（元素、项）， 例如 use 声明、模块、函数等。 在Rust中，Item是Crate（库）的一个组成部分。它包括 extern crate声明 use声明 模块（模块是一个Item的容器） 函数 type定义 结构体定义 枚举类型定义 常量定义 静态变量定义 Trait定义 实现（Impl） 这些Item是可以互相嵌套的，比如在一个函数中定义一个静态变量、在一个模块中使用use声明或定义一个结构体。这些定义在某个作用域里面的Item跟你把 它写到最外层作用域所实现的功能是一样的，只不过你要访问这些嵌套的Item就必须使用路径（Path），如a::b::c。但一些外层的Item不允许你使用路径去访问它的子Item，比如函数，在函数中定义的静态变量、结构体等，是不可以通过路径来访问的。 属性语法 1#[name(arg1, arg2 = &quot;param&quot;)] 它是由一个#开启，后面紧接着一个[]，里面便是属性的具体内容，它可以有如下几种写法： 单个标识符代表的属性名，如#[unix] 单个标识符代表属性名，后面紧跟着一个=，然后再跟着一个字面量（Literal），组成一个键值对，如#[link(name = &quot;openssl&quot;)] 单个标识符代表属性名，后面跟着一个逗号隔开的子属性的列表，如#[cfg(and(unix, not(windows)))] 在#后面还可以紧跟一个!，比如#![feature(box_syntax)]，这表示这个属性是应用于它所在的这个Item。而如果没有!则表示这个属性仅应用于紧接着的那个Item。 例如： 123456789101112131415161718// 为这个crate开启box_syntax这个新特性#![feature(box_syntax)]// 这是一个单元测试函数#[test]fn test_foo() &#123; /* ... */&#125;// 条件编译，只会在编译目标为Linux时才会生效#[cfg(target_os=&quot;linux&quot;)]mod bar &#123; /* ... */&#125;// 为以下的这个type定义关掉non_camel_case_types的编译警告#[allow(non_camel_case_types)]type int8_t = i8; Crate的属性 crate_name - 指定Crate的名字。如#[crate_name = &quot;my_crate&quot;]则可以让编译出的库名字为libmy_crate.rlib。 crate_type - 指定Crate的类型，有以下几种选择 &quot;bin&quot; - 编译为可执行文件； &quot;lib&quot; - 编译为库； &quot;dylib&quot; - 编译为动态链接库； &quot;staticlib&quot; - 编译为静态链接库； &quot;rlib&quot; - 编译为Rust特有的库文件，它是一种特殊的静态链接库格式，它里面会含有一些元数据供编译器使用，最终会静态链接到目标文件之中。 例#![crate_type = &quot;dylib&quot;]。 feature - 可以开启一些不稳定特性，只可在nightly版的编译器中使用。 no_builtins - 去掉内建函数。 no_main- 不生成main这个符号，当你需要链接的库中已经定义了main函数时会用到。 no_start - 不链接自带的native库。 no_std - 不链接自带的std库。 plugin - 加载编译器插件，一般用于加载自定义的编译器插件库。用法是 1234// 加载foo, bar两个插件#![plugin(foo, bar)]// 或者给插件传入必要的初始化参数#![plugin(foo(arg1, arg2))] recursive_limit - 设置在编译期最大的递归层级。比如自动解引用、递归定义的宏等。默认设置是#![recursive_limit = &quot;64&quot;] 模块的属性 no_implicit_prelude - 取消自动插入use std::prelude::*。 path - 设置此mod的文件路径。 如声明mod a;，则寻找 本文件夹下的a.rs文件 本文件夹下的a/mod.rs文件 1234567#[cfg(unix)]#[path = &quot;sys/unix.rs&quot;]mod sys;#[cfg(windows)]#[path = &quot;sys/windows.rs&quot;]mod sys; 函数的属性 main - 把这个函数作为入口函数，替代fn main，会被入口函数（Entry Point）调用。 plugin_registrar - 编写编译器插件时用，用于定义编译器插件的入口函数。 start - 把这个函数作为入口函数（Entry Point），改写 start language item。 test - 指明这个函数为单元测试函数，在非测试环境下不会被编译。 should_panic - 指明这个单元测试函数必然会panic。 cold - 指明这个函数很可能是不会被执行的，因此优化的时候特别对待它。 1234567891011121314151617181920212223242526272829303132// 把`my_main`作为主函数#[main]fn my_main() &#123;&#125;// 把`plugin_registrar`作为此编译器插件的入口函数#[plugin_registrar]pub fn plugin_registrar(reg: &amp;mut Registry) &#123; reg.register_macro(&quot;rn&quot;, expand_rn);&#125;// 把`entry_point`作为入口函数，不再执行标准库中的初始化流程#[start]fn entry_point(argc: isize, argv: *const *const u8) -&gt; isize &#123;&#125;// 定义一个单元测试// 这个单元测试一定会panic#[test]#[should_panic]fn my_test() &#123; panic!(&quot;I expected to be panicked&quot;);&#125;// 这个函数很可能是不会执行的，// 所以优化的时候就换种方式#[cold]fn unlikely_to_be_executed() &#123;&#125; 全局静态变量的属性 thread_local - 只可用于static mut，表示这个变量是thread local的。 FFI的属性 extern块可以应用以下属性 link_args - 指定链接时给链接器的参数，平台和实现相关。 link - 说明这个块需要链接一个native库，它有以下参数： name - 库的名字，比如libname.a的名字是name； kind - 库的类型，它包括 dylib - 动态链接库 static - 静态库 framework - OS X里的Framework 123456789#[link(name = &quot;readline&quot;)]extern &#123;&#125;#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]extern &#123;&#125; 在extern块里面，可以使用 link_name - 指定这个链接的外部函数的名字或全局变量的名字； linkage - 对于全局变量，可以指定一些LLVM的链接类型（ http://llvm.org/docs/LangRef.html#linkage-types ）。 对于enum类型，可以使用 repr - 目前接受C，C表示兼容C ABI。 12345#[repr(C)]enum eType &#123; Operator, Indicator,&#125; 对于struct类型，可以使用 repr - 目前只接受C和packed，C表示结构体兼容C ABI，packed表示移除字段间的padding。 宏的属性 macro_use - 把模块或库中定义的宏导出来 应用于mod上，则把此模块内定义的宏导出到它的父模块中 应用于extern crate上，则可以接受一个列表，如 12#[macro_use(debug, trace)]extern crate log; 则可以只导入列表中指定的宏，若不指定则导入所有的宏。 macro_reexport - 应用于extern crate上，可以再把这些导入的宏再输出出去给别的库使用。 macro_export - 应于在宏上，可以使这个宏可以被导出给别的库使用。 no_link - 应用于extern crate上，表示即使我们把它里面的库导入进来了，但是不要把这个库链接到目标文件中。 其他属性 export_function - 用于静态变量或函数，指定它们在目标文件中的符号名。 link_section - 用于静态变量或函数，表示应该把它们放到哪个段中去。 no_mangle - 可以应用于任意的Item，表示取消对它们进行命名混淆，直接把它们的名字作为符号写到目标文件中。 simd - 可以用于元组结构体上，并自动实现了数值运算符，这些操作会生成相应的SIMD指令。 doc - 为这个Item绑定文档，跟///的功能一样，用法是 12#[doc = &quot;This is a doc&quot;]struct Foo &#123;&#125; 条件编译属性 有时候，我们想针对不同的编译目标来生成不同的代码，比如在编写跨平台模块时，针对Linux和Windows分别使用不同的代码逻辑。 条件编译基本上就是使用cfg这个属性，直接看例子 123456789101112131415161718192021222324252627#[cfg(target_os = &quot;macos&quot;)]fn cross_platform() &#123; // Will only be compiled on Mac OS, including Mac OS X&#125;#[cfg(target_os = &quot;windows&quot;)]fn cross_platform() &#123; // Will only be compiled on Windows&#125;// 若条件`foo`或`bar`任意一个成立，则编译以下的Item#[cfg(any(foo, bar))]fn need_foo_or_bar() &#123;&#125;// 针对32位的Unix系统#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]fn on_32bit_unix() &#123;&#125;// 若`foo`不成立时编译#[cfg(not(foo))]fn needs_not_foo() &#123;&#125; 其中，cfg可接受的条件有 debug_assertions - 若没有开启编译优化时就会成立。 target_arch = &quot;...&quot; - 目标平台的CPU架构，包括但不限于x86, x86_64, mips, powerpc, arm或aarch64。 target_endian = &quot;...&quot; - 目标平台的大小端，包括big和little。 target_env = &quot;...&quot; - 表示使用的运行库，比如musl表示使用的是MUSL的libc实现, msvc表示使用微软的MSVC，gnu表示使用GNU的实现。 但在部分平台这个数据是空的。 target_family = &quot;...&quot; - 表示目标操作系统的类别，比如windows和unix。这个属性可以直接作为条件使用，如#[unix]，#[cfg(unix)]。 target_os = &quot;...&quot; - 目标操作系统，包括但不限于windows, macos, ios, linux, android, freebsd, dragonfly, bitrig, openbsd, netbsd。 target_pointer_width = &quot;...&quot; - 目标平台的指针宽度，一般就是32或64。 target_vendor = &quot;...&quot; - 生产商，例如apple, pc或大多数Linux系统的unknown。 test - 当启动了单元测试时（即编译时加了--test参数，或使用cargo test）。 还可以根据一个条件去设置另一个条件，使用cfg_attr，如 1#[cfg_attr(a, b)] 这表示若a成立，则这个就相当于#[cfg(b)]。 条件编译属性只可以应用于Item，如果想应用在非Item中怎么办呢？可以使用cfg!宏，如 123456789if cfg!(target_arch = &quot;x86&quot;) &#123;&#125; else if cfg!(target_arch = &quot;x86_64&quot;) &#123;&#125; else if cfg!(target_arch = &quot;mips&quot;) &#123;&#125; else &#123;&#125; 这种方式不会产生任何运行时开销，因为不成立的条件相当于里面的代码根本不可能被执行，编译时会直接被优化掉。 内联参数 内联函数即建议编译器可以考虑把整个函数拷贝到调用者的函数体中，而不是生成一个call指令调用过去。这种优化对于短函数非常有用，有利于提高性能。 编译器自己会根据一些默认的条件来判断一个函数是不是应该内联，若一个不应该被内联的函数被内联了，实际上会导致整个程序更慢。 可选的属性有： #[inline] - 建议编译器内联这个函数 #[inline(always)] - 要求编译器必须内联这个函数 #[inline(never)] - 要求编译器不要内联这个函数 内联会导致在一个库里面的代码被插入到另一个库中去。 自动实现Trait 编译器提供一个编译器插件叫作derive，它可以帮你去生成一些代码去实现（impl）一些特定的Trait，如 12345#[derive(PartialEq, Clone)]struct Foo&lt;T&gt; &#123; a: i32, b: T,&#125; 编译器会自动为你生成以下的代码 123456789101112131415161718impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; &#123; fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool &#123; self.a == other.a &amp;&amp; self.b == other.b &#125; fn ne(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool &#123; self.a != other.a || self.b != other.b &#125;&#125;impl&lt;T: Clone&gt; Clone for Foo&lt;T&gt; &#123; fn clone(&amp;self) -&gt; Foo&lt;T&gt; &#123; Foo &#123; a: self.a.clone(), b: self.b.clone(), &#125; &#125;&#125; 目前derive仅支持标准库中部分的Trait。 编译器rustc参数 Rust编译器程序的名字是rustc，使用它的方法很简单： 1$ rustc [OPTIONS] INPUT 其中，[OPTIONS]表示编译参数，而INPUT则表示输入文件。而编译参数有以下可选： -h, --help - 输出帮助信息到标准输出； --cfg SPEC - 传入自定义的条件编译参数，使用方法如 12345fn main() &#123; if cfg!(hello) &#123; println!(&quot;world!&quot;); &#125;&#125; 如上例所示，若cfg!(hello)成立，则运行程序就会输出&quot;world&quot;到标准输出。我们把这个文件保存为hello.rs然后编译它 1$ rustc --cfg hello hello.rs 运行它就会看到屏幕中输出了world!。 -L [KIND=]PATH - 往链接路径中加入一个文件夹，并且可以指定这个路径的类型（Kind），这些类型包括 dependency - 在这个路径下找依赖的文件，比如说mod； crate - 只在这个路径下找extern crate中定义的库； native - 只在这个路径下找Native库； framework - 只在OS X下有用，只在这个路径下找Framework； all - 默认选项。 -l [KIND=]NAME - 链接一个库，这个库可以指定类型（Kind） static - 静态库； dylib - 动态库； framework - OS X的Framework。 如果不传，默认为dylib。 此处举一个例子如何手动链接一个库，我们先创建一个文件叫myhello.rs，在里面写一个函数 1234567// myhello.rs/// 这个函数仅仅向标签输出打印 Hello World!/// 不要忘记要把它标记为 pub 哦。pub fn print_hello() &#123; println!(&quot;Hello World!&quot;);&#125; 然后把这个文件编译成一个静态库，libmyhello.a 1$ rustc --crate-type staticlib myhello.rs 然后再创建一个main.rs，链接这个库并打印出&quot;Hello World!&quot; 123456789// main.rs// 指定链接库 myhelloextern crate myhello;fn main() &#123; // 调用库函数 myhello::print_hello();&#125; 编译main.rs 1$ rustc -L. -lmyhello main.rs 运行main，就会看到屏幕输出&quot;Hello World!&quot;啦。 --crate-type - 指定编译输出类型，它的参数包括 bin - 二进行可执行文件 lib - 编译为库 rlib - Rust库 dylib - 动态链接库 staticlib - 静态链接库 --crate-name - 指定这个Crate的名字，默认是文件名，如main.rs编译成可执行文件时默认是main，但你可以指定它为foo 1$ rustc --crate-name foo main.rs 则会输出foo可执行文件。 --emit - 指定编译器的输出。编译器默认是输出一个可执行文件或库文件，但你可以选择输出一些其它的东西用于Debug asm - 输出汇编 llvm-bc - LLVM Bitcode； llvm-ir - LLVM IR，即LLVM中间码（LLVM Intermediate Representation）； obj - Object File（就是*.o文件）； link - 这个是要结合其它--emit参数使用，会执行Linker再输出结果； dep-info - 文件依赖关系（Debug用，类似于Makefile一样的依赖）。 以上参数可以同时使用，使用逗号分割，如 1$ rustc --emit asm,llvm-ir,obj main.rs 同时，在最后可以加一个=PATH来指定输出到一个特定文件，如 1$ rustc --emit asm=output.S,llvm-ir=output.ir main.rs 这样会把汇编生成到output.S文件中，把LLVM中间码输出到output.ir中。 --print - 打印一些信息，参数有 crate-name - 编译目标名； file-names - 编译的文件名； sysroot - 打印Rust工具链的根目录地址。 -g - 在目标文件中保存符号，这个参数等同于-C debuginfo=2。 -O - 开启优化，这个参数等同于-C opt-level=2。 -o FILENAME - 指定输出文件名，同样适用于--emit的输出。 --out-dir DIR - 指定输出的文件夹，默认是当前文件夹，且会忽略-o配置。 --explain OPT - 解释某一个编译错误，比如 若你写了一个main.rs，使用了一个未定义变量f 123fn main() &#123; f&#125; 编译它时编译器会报错： 12345main.rs:2:5: 2:6 error: unresolved name &#96;f&#96; [E0425]main.rs:2 f ^main.rs:2:5: 2:6 help: run &#96;rustc --explain E0425&#96; to see a detailed explanationerror: aborting due to previous error 虽然错误已经很明显，但是你也可以让编译器解释一下，什么是E0425错误： 12$ rustc --explain E0425// 编译器打印的说明 --test - 编译成一个单元测试可执行文件 --target TRIPLE - 指定目标平台，基本格式是cpu-manufacturer-kernel[-os]，例如 12## 64位OS X$ rustc --target x86_64-apple-darwin -W help - 打印Linter的所有可配置选项和默认值。 -W OPT, --warn OPT - 设置某一个Linter选项为Warning。 -A OPT, --allow OPT - 设置某一个Linter选项为Allow。 -D OPT, --deny OPT - 设置某一个Linter选项为Deny。 -F OPT, --forbit OPT - 设置某一个Linter选项为Forbit。 -C FLAG[=VAL], --codegen FLAG[=VAL] - 目标代码生成的的相关参数，可以用-C help来查看配置，值得关注的几个是 linker=val - 指定链接器； linker-args=val - 指定链接器的参数； prefer-dynamic - 默认Rust编译是静态链接，选择这个配置将改为动态链接； debug-info=level - Debug信息级数，0 = 不生成，1 = 只生成文件行号表，2 = 全部生成； opt-level=val - 优化级数，可选0-3； debug_assertion - 显式开启cfg(debug_assertion)条件。 -V, --version - 打印编译器版本号。 -v, --verbose - 开启啰嗦模式（打印编译器执行的日志）。 --extern NAME=PATH - 用来指定外部的Rust库（*.rlib）名字和路径，名字应该与extern crate中指定的一样。 --sysroot PATH - 指定工具链根目录。 -Z flag - 编译器Debug用的参数，可以用-Z help来查看可用参数。 --color auto|always|never - 输出时对日志加颜色 auto - 自动选择加还是不加，如果输出目标是虚拟终端（TTY）的话就加，否则就不加； always - 给我加！ never - 你敢加？ Cargo.toml参数配置 [package]段落 啥也不多说了，直接上例子，大家注意我在例子中的中文解释，个人觉得这样比较一目了然： 12345678910111213141516171819202122232425262728293031323334353637383940414243[package] # 软件包名称，如果需要在别的地方引用此软件包，请用此名称。name = &quot;hello_world&quot;# 当前版本号，这里遵循semver标准，也就是语义化版本控制标准。version = &quot;0.1.0&quot; # the current version, obeying semver# 软件所有作者列表authors = [&quot;you@example.com&quot;]# 非常有用的一个字段，如果要自定义自己的构建工作流，# 尤其是要调用外部工具来构建其他本地语言（C、C++、D等）开发的软件包时。# 这时，自定义的构建流程可以使用rust语言，写在&quot;build.rs&quot;文件中。build = &quot;build.rs&quot;# 显式声明软件包文件夹内哪些文件被排除在项目的构建流程之外，# 哪些文件包含在项目的构建流程中exclude = [&quot;build/**/*.o&quot;, &quot;doc/**/*.html&quot;]include = [&quot;src/**/*&quot;, &quot;Cargo.toml&quot;]# 当软件包在向公共仓库发布时出现错误时，使能此字段可以阻止此错误。publish = false# 关于软件包的一个简短介绍。description = &quot;...&quot;# 下面这些字段标明了软件包仓库的更多信息documentation = &quot;...&quot;homepage = &quot;...&quot;repository = &quot;...&quot;# 顾名思义，此字段指向的文件就是传说中的ReadMe，# 并且，此文件的内容最终会保存在注册表数据库中。readme = &quot;...&quot;# 用于分类和检索的关键词。keywords = [&quot;...&quot;, &quot;...&quot;]# 软件包的许可证，必须是cargo仓库已列出的已知的标准许可证。license = &quot;...&quot;# 软件包的非标许可证书对应的文件路径。license-file = &quot;...&quot; 依赖的详细配置 最直接的方式： 123[dependencies]hammer = &quot;0.5.0&quot;color = &quot;&gt; 0.6.0, &lt; 0.8.0&quot; 与平台相关的依赖定义格式不变，不同的是需要定义在[target]字段下。例如： 12345678910111213141516171819202122232425262728293031323334353637# 注意，此处的cfg可以使用not、any、all等操作符任意组合键值对。# 并且此用法仅支持cargo 0.9.0（rust 1.8.0）以上版本。# 如果是windows平台，则需要此依赖。[target.&#x27;cfg(windows)&#x27;.dependencies]winhttp = &quot;0.4.0&quot;[target.&#x27;cfg(unix)&#x27;.dependencies]openssl = &quot;1.0.1&quot;#如果是32位平台，则需要此依赖。[target.&#x27;cfg(target_pointer_width = &quot;32&quot;)&#x27;.dependencies]native = &#123; path = &quot;native/i686&quot; &#125;[target.&#x27;cfg(target_pointer_width = &quot;64&quot;)&#x27;.dependencies]native = &#123; path = &quot;native/i686&quot; &#125;# 另一种写法就是列出平台的全称描述[target.x86_64-pc-windows-gnu.dependencies]winhttp = &quot;0.4.0&quot;[target.i686-unknown-linux-gnu.dependencies]openssl = &quot;1.0.1&quot;# 如果使用自定义平台，请将自定义平台文件的完整路径用双引号包含[target.&quot;x86_64/windows.json&quot;.dependencies]winhttp = &quot;0.4.0&quot;[target.&quot;i686/linux.json&quot;.dependencies]openssl = &quot;1.0.1&quot;native = &#123; path = &quot;native/i686&quot; &#125;openssl = &quot;1.0.1&quot;native = &#123; path = &quot;native/x86_64&quot; &#125;# [dev-dependencies]段落的格式等同于[dependencies]段落，# 不同之处在于，[dependencies]段落声明的依赖用于构建软件包，# 而[dev-dependencies]段落声明的依赖仅用于构建测试和性能评估。# 此外，[dev-dependencies]段落声明的依赖不会传递给其他依赖本软件包的项目[dev-dependencies]iron = &quot;0.2&quot; 自定义编译器调用方式模板详细参数 cargo内置五种编译器调用模板，分别为dev、release、test、bench、doc，分别用于定义不同类型生成目标时的编译器参数，如果我们自己想改变这些编译模板，可以自己定义相应字段的值，例如（注意：下述例子中列出的值均为此模板字段对应的系统默认值）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 开发模板, 对应`cargo build`命令[profile.dev]opt-level = 0 # 控制编译器的 --opt-level 参数，也就是优化参数debug = true # 控制编译器是否开启 `-g` 参数rpath = false # 控制编译器的 `-C rpath` 参数lto = false # 控制`-C lto` 参数，此参数影响可执行文件和静态库的生成，debug-assertions = true # 控制调试断言是否开启codegen-units = 1 # 控制编译器的 `-C codegen-units` 参数。注意，当`lto = true`时，此字段值被忽略# 发布模板, 对应`cargo build --release`命令[profile.release]opt-level = 3debug = falserpath = falselto = falsedebug-assertions = falsecodegen-units = 1# 测试模板，对应`cargo test`命令[profile.test]opt-level = 0debug = truerpath = falselto = falsedebug-assertions = truecodegen-units = 1# 性能评估模板，对应`cargo bench`命令[profile.bench]opt-level = 3debug = falserpath = falselto = falsedebug-assertions = falsecodegen-units = 1# 文档模板，对应`cargo doc`命令[profile.doc]opt-level = 0debug = truerpath = falselto = falsedebug-assertions = truecodegen-units = 1 需要注意的是，当调用编译器时，只有位于调用最顶层的软件包的模板文件有效，其他的子软件包或者依赖软件包的模板定义将被顶层软件包的模板覆盖。 [features]段落 [features]段落中的字段被用于条件编译选项或者是可选依赖。例如： 12345678910111213141516171819202122232425262728293031[package]name = &quot;awesome&quot;[features]# 此字段设置了可选依赖的默认选择列表，# 注意这里的&quot;session&quot;并非一个软件包名称，# 而是另一个featrue字段sessiondefault = [&quot;jquery&quot;, &quot;uglifier&quot;, &quot;session&quot;]# 类似这样的值为空的feature一般用于条件编译，# 类似于`#[cfg(feature = &quot;go-faster&quot;)]`。go-faster = []# 此feature依赖于bcrypt软件包，# 这样封装的好处是未来可以对secure-password此feature增加可选项目。secure-password = [&quot;bcrypt&quot;]# 此处的session字段导入了cookie软件包中的feature段落中的session字段session = [&quot;cookie/session&quot;][dependencies]# 必要的依赖cookie = &quot;1.2.0&quot;oauth = &quot;1.1.0&quot;route-recognizer = &quot;=2.1.0&quot;# 可选依赖jquery = &#123; version = &quot;1.0.2&quot;, optional = true &#125;uglifier = &#123; version = &quot;1.5.3&quot;, optional = true &#125;bcrypt = &#123; version = &quot;*&quot;, optional = true &#125;civet = &#123; version = &quot;*&quot;, optional = true &#125; 如果其他软件包要依赖使用上述awesome软件包，可以在其描述文件中这样写： 1234[dependencies.awesome]version = &quot;1.3.5&quot;default-features = false # 禁用awesome 的默认featuresfeatures = [&quot;secure-password&quot;, &quot;civet&quot;] # 使用此处列举的各项features 使用features时需要遵循以下规则： feature名称在本描述文件中不能与出现的软件包名称冲突 除了default feature，其他所有的features均是可选的 features不能相互循环包含 开发依赖包不能包含在内 features组只能依赖于可选软件包 features的一个重要用途就是，当开发者需要对软件包进行最终的发布时，在进行构建时可以声明暴露给终端用户的features，这可以通过下述命令实现： 1$ cargo build --release --features &quot;shumway pdf&quot; 关于测试 当运行cargo test命令时，cargo将会按做以下事情： 编译并运行软件包源代码中被#[cfg(test)] 所标志的单元测试 编译并运行文档测试 编译并运行集成测试 编译examples 配置构建目标 所有的诸如[[bin]], [lib], [[bench]], [[test]]以及 [[example]]等字段，均提供了类似的配置，以说明构建目标应该怎样被构建。例如（下述例子中[lib]段落中各字段值均为默认值）： 12345678910111213141516171819202122232425262728[lib]# 库名称，默认与项目名称相同name = &quot;foo&quot;# 此选项仅用于[lib]段落，其决定构建目标的构建方式，# 可以取dylib, rlib, staticlib 三种值之一，表示生成动态库、r库或者静态库。crate-type = [&quot;dylib&quot;]# path字段声明了此构建目标相对于cargo.toml文件的相对路径path = &quot;src/lib.rs&quot;# 单元测试开关选项test = true# 文档测试开关选项doctest = true# 性能评估开关选项bench = true# 文档生成开关选项doc = true# 是否构建为编译器插件的开关选项plugin = false# 如果设置为false，`cargo test`将会忽略传递给rustc的--test参数。harness = true no_std OS提供系统调用来支持IO、网络、文件系统等的操作，Rust利用OS的特性来实现如发送消息到控制台、读取文件、打开URL等标准库（std）的操作。 若OS不提供这些系统调用，则这种特性被称为no_std，对于Rust的no_std我们只能使用不依赖OS的特性，如core crate no_std与std的区别在于： no_std下，不能使用std crate，但能使用大部分core crate中的模块 不能使用与堆相关的模块(box, collections, string等)，因为Rust内存分配机制默认依赖于OS系统调用实现堆的分配 如果写一个二进制crate，则必须实现一些lang items（rustc允许用户通过lang item来定制语言特性，而不是将所有操作都嵌入到编译器中） https://justjjy.com/Rust-no-std 外部crate lazy_static 给静态变量延迟赋值的宏。 使用这个宏,所有 static类型的变量可在执行的代码在运行时被初始化。 这包括任何需要堆分配,如vector或hash map,以及任何非常量函数调用。 由于const和static在初始化时，必须赋予一个常量表达式的值，如果想要初始化动态的数组，vector，map，结果是编译不通过： 12static VEC:Vec&lt;u8&gt; = vec![0x18u8, 0x11u8];static MAP: HashMap&lt;u32, String&gt; = HashMap::new(); 使用 lazy_static 消除上面所有问题，在使用时需要解引用： 123456789101112131415161718192021222324#[macro_use]extern crate lazy_static;use std::collections::HashMap;lazy_static! &#123; static ref VEC:Vec&lt;u8&gt; = vec![0x18u8, 0x11u8]; static ref MAP: HashMap&lt;u32, String&gt; = &#123; let mut map = HashMap::new(); map.insert(18, &quot;hury&quot;.to_owned()); map &#125;; static ref PAGE:u32 = mulit(18);&#125;fn mulit(i: u32) -&gt; u32 &#123; i * 2&#125;fn main() &#123; println!(&quot;&#123;:?&#125;&quot;, *PAGE); println!(&quot;&#123;:?&#125;&quot;, *VEC); println!(&quot;&#123;:?&#125;&quot;, *MAP);&#125; 创建全局静态可变变量 12345678use std::&#123;collections::HashMap, sync::Mutex&#125;;#[macro_use]extern crate lazy_static;lazy_static!&#123; static ref ENCLAVE_ID_MAP: Mutex&lt;HashMap&lt;sgx_enclave_id_t, u32&gt;&gt; = Mutex::new(HashMap::new());&#125; 使用： 1234ENCLAVE_ID_MAP.lock().unwrap().insert(eid1, 1);ENCLAVE_ID_MAP.lock().unwrap().insert(eid2, 2);ENCLAVE_ID_MAP.lock().unwrap().insert(eid3, 3);println!(&quot;&#123;:?&#125;&quot;, ENCLAVE_ID_MAP.lock().unwrap());","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Makefile学习","slug":"instruction/makefile","date":"2021-03-08T16:00:00.000Z","updated":"2022-04-28T06:43:14.000Z","comments":true,"path":"2021/03/09/instruction/makefile/","link":"","permalink":"http://example.com/2021/03/09/instruction/makefile/","excerpt":"makefile文件编写","text":"makefile概览 规则的基本形式 1234target ... : prerequisites ... command ... ... target：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label） prerequisites：生成该target所依赖的文件 command：该target要执行的命令（任意的shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说: prerequisites中如果有一个以上的文件比target文件要新 (比较修改日期) 的话，command所定义的命令就会被执行 一个简单的例子 123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o clean 不是一个文件，它只不过是一个label，其冒号后什么也没有，make不会自动去找它的依赖性，也就不会自动执行其后所定义的命令；要执行其后的命令，就要在make命令后明显得指出这个label的名字 make的工作方式 只输入 make 命令： make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。 如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。 使用变量 12345objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o edit $(objects)... makefile自动推导 只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个 whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，因此上述makefile可简化为： 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : -rm edit $(objects) .PHONY 表示 clean 是个伪目标文件 rm 前的 - 表示也许某些文件出现问题，但不要管，继续做后面的事 依赖关系也可以合并，如下： 12345678910111213objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : -rm edit $(objects) makefile文件名 默认使用 makefile 或 Makefile ，如果使用其他名称，如 make.linux ，那么需使用命令 make -f make.linux 引用其他makefile 你有这样几个Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含了 e.mk 和 f.mk ： 123include foo.make *.mk $(bar)# 等价于include foo.make a.mk b.mk c.mk e.mk f.mk 如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。 如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。 make的执行步骤 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 书写规则 通配符 make支持三个通配符： * ， ? 和 ~ * : 匹配0个或多个字符 ? : 匹配一个字符 ~ : home目录？ 在变量中使用通配符有所不同： objects = *.o 表示 objects 的值就是 *.o ，而不会展开 objects := $(wildcard *.o) 表示所有以 .o 结尾的文件 文件搜索 特殊变量 VPATH 如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件；如果定义了这个变量，那么make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件 1VPATH = src:../headers 多个目录使用冒号隔开，依次搜索 关键字vpath 12345678# 为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;vpath &lt;pattern&gt; &lt;directories&gt;# 清除符合模式&lt;pattern&gt;的文件的搜索目录vpath &lt;pattern&gt;# 清除所有已被设置好了的文件搜索目录vpath &lt;pattern&gt;需要包含 % 字符，表示匹配零或若干字符，例如， %.h 表示所有以 .h 结尾的文件 12vpath %.c foo:barvpath % blish 表示搜索 .c 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录 伪目标 为了避免和文件重名，使用特殊标记 .PHONY 来显式地指明一个目标是伪目标，不管是否有这个文件 123.PHONY : cleanclean : rm *.o temp 伪目标也可以指定所依赖的文件，可以用来在一个Makefile文件生成若干个可执行文件： 1234567891011all : prog1 prog2 prog3.PHONY : allprog1 : prog1.o utils.o cc -o prog1 prog1.o utils.oprog2 : prog2.o cc -o prog2 prog2.oprog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 伪目标的命名 all：所有目标的目标，其功能一般是编译所有的目标 clean：删除所有被make创建的文件 install：安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去 print：列出改变过的源文件 tar：把源程序打包备份，也就是一个tar文件 dist：创建一个压缩文件，一般是把tar文件压成Z文件，或是gz文件。 TAGS：更新所有的目标，以备完整地重编译使用 check和test：一般用来测试makefile的流程 静态模式 123456objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 目标从objects中获取， %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o ； 依赖模式 %.c 则取模式 %.o 的 % ，也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 命令中的 $&lt; 和 $@ 则是自动化变量， $&lt; 表示第一个依赖文件， $@ 表示目标集（也就是“foo.o bar.o”） 于是，上面的规则展开后等价于下面的规则： 1234foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 自动生成依赖 把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件， .d 文件中就存放对应 .c 文件的依赖关系，产生 .d 文件的模式规则如下： 12345%.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\ sed &#x27;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \\ rm -f $@.$$$$ 所有的 .d 文件依赖于 .c 文件 rm -f $@ 的意思是删除所有的目标，也就是 .d 文件 -M 参数表示自动找寻源文件中包含的头文件，并生成一个依赖关系 第二行的意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件， $@ 表示模式 %.d 文件，如果有一个C文件是name.c，那么 % 就是 name ， $$$$ 意为一个随机编号，第二行生成的文件有可能是name.d.12345 第三行使用sed命令做了一个替换 第四行删除临时文件 书写命令 每条命令的开头必须以 Tab 键开头，除非，命令是紧跟在依赖规则后面的分号后的 显示命令 通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 @ 字符在命令行前，那么，这个命令将不被make显示出来，如： 123456@echo 正在编译XXX模块......# 输出： 正在编译XXX模块……echo 正在编译XXX模块......# 输出： echo 正在编译XXX模块......# 正在编译XXX模块...... 带入make参数 -n 或 --just-print ，那么其只是显示命令，但不会执行命令，这个功能有利于我们调试Makefile，看看命令执行的顺序等 命令执行 如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令，如： 123456exec1: cd /home/hchen pwd exec2: cd /home/hchen; pwd 执行 make exec1，打印当前Makefile目录，cd 没有作用 执行 make exec2，打印出“/home/hchen” 命令出错 有时候希望能忽略命令出错，继续执行： 对于单个命令，最前面加- 12clean: -rm -f *.o 全局方法：给make加上 -i 或是 --ignore-errors 参数，那么，Makefile中所有命令都会忽略错误； -k 或是 --keep-going 参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则 对于单个规则，以 .IGNORE 作为目标，那么这个规则中的所有命令将会忽略错误 嵌套执行make 我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写： 12subsystem: cd subdir &amp;&amp; $(MAKE) 总控Makefile的变量可以传递到下级的Makefile中： 要传递变量到下级Makefile中： 1export &lt;variable ...&gt;; 不想让某些变量传递到下级Makefile中： 1unexport &lt;variable ...&gt;; 传递所有的变量，只要一个export就行了，后面什么也不用跟 注： 两个变量，一个是 SHELL ，一个是 MAKEFLAGS ，这两个变量不管你是否export，总是要传递到下层Makefile中 -w 或是 --print-directory 参数会在make的过程中输出一些信息，让你看到目前的工作目录 定义命令包（函数） 1234define run-yaccyacc $(firstword $^)mv y.tab.c $@endef 调用： 12foo.c : foo.y $(run-yacc) 命令包“run-yacc”中的 $^ 就是 foo.y ， $@ 就是 foo.c 使用变量 变量的基础 变量在声明时需要给予初值 在使用时，需要给在变量名前加上 $ 符号，使用小括号 () 或是大括号 &#123;&#125; 把变量给包括起来 如果要使用真实的 $ 字符，那么需要用 $$ 来表示 变量中的变量 使用变量的值定义变量 使用 = 123456foo = $(bar)bar = $(ugh)ugh = Huh?all: echo $(foo) = 右侧的变量的值可以定义在文件的任何一处 这种方法的缺点在于可能造成递归定义，如 12A = $(B)B = $(A) 使用 := 123x := fooy := $(x) barx := later 最终y的值为&quot;foo bar&quot;，x的值为&quot;later&quot; 前面的变量不能使用后面的变量，只能使用前面已定义好了的变量 使用 ?= 1FOO ?= bar 如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做 定义一个空格 12nullstring :=space := $(nullstring) # end of the line nullstring是一个Empty变量，其中什么也没有 space的值是一个空格：先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止 注： 如果以如下方式定义目录路径的变量： 1dir := /foo/bar # directory to put the frobs in dir这个变量的值是“/foo/bar”，后面还跟了4个空格 变量高级用法 变量值替换 替换变量中的共有的部分，其格式是 $(var:a=b) 或是 $&#123;var:a=b&#125; ，其意思是，把变量var中所有以a字串结尾的a替换成b字串。这里的结尾意思是空格或是结束符，如： 123foo := a.o b.o c.obar := $(foo:.o=.c)# bar的值为 a.c b.c c.c 也可以使用静态模式进行替换： 123foo := a.o b.o c.obar := $(foo:%.o=%.c)# bar的值为 &quot;a.c b.c c.c&quot; 变量值作为变量 1234x = yy = za := $($(x))# a的值为 &quot;z&quot; 12345first_second = Helloa = firstb = secondall = $($a_$b)# all的值为 &quot;Hello&quot; 追加变量值 1234567objects = main.o foo.o bar.o utils.oobjects += another.o# 相当于objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o override指示符 如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是: 123override &lt;variable&gt;; = &lt;value&gt;;override &lt;variable&gt;; := &lt;value&gt;; 多行变量 使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令 define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束 1234define two-linesecho fooecho $(bar)endef 环境变量 make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中 但如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖 如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量 目标变量 可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和全局变量同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值，其语法为： 123&lt;target ...&gt; : &lt;variable-assignment&gt;;&lt;target ...&gt; : overide &lt;variable-assignment&gt; 例子： 123456789101112prog : CFLAGS = -gprog : prog.o foo.o bar.o $(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c $(CC) $(CFLAGS) prog.cfoo.o : foo.c $(CC) $(CFLAGS) foo.cbar.o : bar.c $(CC) $(CFLAGS) bar.c 不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， $(CFLAGS) 的值都是 -g 模式变量 模式变量的好处是，可以给定一种“模式”，把变量定义在符合这种模式的所有目标上，如： 1%.o : CFLAGS = -O 给所有以 .o 结尾的目标定义目标变量 CFLAGS 条件判断 语法为： 1234567891011&lt;conditional-directive&gt;&lt;text-if-true&gt;endif# 或&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 其中 &lt;conditional-directive&gt; 表示条件关键字，在 &lt;conditional-directive&gt; 这一行上，多余的空格是被允许的，但是不能以 Tab 键作为开始（不然就被认为是命令）。而注释符 # 同样也是安全的。 else 和 endif 也一样，只要不是以 Tab 键开始就行了。 条件关键字有以下四种： ifeq 12345ifeq (&lt;arg1&gt;, &lt;arg2&gt;)ifeq &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;ifeq &quot;&lt;arg1&gt;&quot; &#x27;&lt;arg2&gt;&#x27;ifeq &#x27;&lt;arg1&gt;&#x27; &quot;&lt;arg2&gt;&quot; 比较参数 arg1 和 arg2 的值是否相同，相同则为真 参数可以使用make的函数 ifneq 12345ifneq (&lt;arg1&gt;, &lt;arg2&gt;)ifneq &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;ifneq &quot;&lt;arg1&gt;&quot; &#x27;&lt;arg2&gt;&#x27;ifneq &#x27;&lt;arg1&gt;&#x27; &quot;&lt;arg2&gt;&quot; 比较参数 arg1 和 arg2 的值是否相同，如果不同，则为真 ifdef 1ifdef &lt;variable-name&gt; 如果变量 &lt;variable-name&gt; 的值非空，那到表达式为真 &lt;variable-name&gt; 同样可以是一个函数的返回值 ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置，如： 123456789101112131415161718# 示例1bar =foo = $(bar)ifdef foo frobozz = yeselse frobozz = noendif# frobozz的结果为yes# 示例2foo =ifdef foo frobozz = yeselse frobozz = noendif# frobozz的结果为no ifndef 1ifndef &lt;variable-name&gt; 与 ifdef 相反 使用函数 函数调用语法 以 $ 来标识： 1$(&lt;function&gt; &lt;arguments&gt;) &lt;function&gt; 就是函数名 &lt;arguments&gt; 为函数的参数，参数间以逗号 , 分隔 函数名和参数之间以“空格”分隔 字符串处理函数 subst 1$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;) 名称：字符串替换函数 功能：把字串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt; 返回：函数返回被替换过后的字符串 示例： 1$(subst ee,EE,feet on the street) 把 feet on the street 中的 ee 替换成 EE ，返回结果是 fEEt on the strEEt patsubst 1$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 名称：模式字符串替换函数 功能：查找 &lt;text&gt; 中的单词（单词以空格、Tab或回车换行分隔）是否符合模式 &lt;pattern&gt; ，如果匹配的话，则以 &lt;replacement&gt; 替换 &lt;pattern&gt; 可以包括通配符 % 如果 &lt;replacement&gt; 中也包含 % ，那么， &lt;replacement&gt; 中的这个 % 将是 &lt;pattern&gt; 中的那个 % 所代表的字串 可以用 \\ 来转义，以 \\% 来表示真实含义的 % 字符 返回：函数返回被替换过后的字符串 示例： 1$(patsubst %.c,%.o,x.c.c bar.c) 把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o 注： $(var:&lt;pattern&gt;=&lt;replacement&gt;;) 相当于 $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var)) $(var: &lt;suffix&gt;=&lt;replacement&gt;) 相当于$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var)) 如： 1objects = foo.o bar.o baz.o， 那么， $(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的 strip 1$(strip &lt;string&gt;) 名称：去空格函数 功能：去掉 &lt;string&gt; 字串中开头和结尾的空字符 返回：返回被去掉空格的字符串值 示例： 1$(strip a b c ) 把字串 &quot;a b c “去掉开头和结尾的空字符，结果为&quot;a b c” findstring 1$(findstring &lt;find&gt;,&lt;in&gt;) 名称：查找字符串函数 功能：在字串 &lt;in&gt; 中查找 &lt;find&gt; 字串 返回：如果找到，那么返回 &lt;find&gt; ，否则返回空字符串 示例： 12$(findstring a,a b c)$(findstring a,b c) 第一个函数返回 a 字符串，第二个返回空字符串 filter 1$(filter &lt;pattern...&gt;,&lt;text&gt;) 名称：过滤函数 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词。可以有多个模式 返回：返回符合模式 &lt;pattern&gt; 的字串 示例： 123sources := foo.c bar.c baz.s ugh.hfoo: $(sources) cc $(filter %.c %.s,$(sources)) -o foo $(filter %.c %.s,$(sources)) 返回的值为 foo.c bar.c baz.s filter-out 1$(filter-out &lt;pattern...&gt;,&lt;text&gt;) 名称：反过滤函数 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，去除符合模式 &lt;pattern&gt; 的单词。可以有多个模式 返回：返回不符合模式 &lt;pattern&gt; 的字串 示例： 12objects=main1.o foo.o main2.o bar.omains=main1.o main2.o $(filter-out $(mains),$(objects)) 返回值为 foo.o bar.o sort 1$(sort &lt;list&gt;) 名称：排序函数 功能：给字符串 &lt;list&gt; 中的单词排序（升序） 返回：返回排序后的字符串 示例： $(sort foo bar lose) 返回 bar foo lose 备注： sort 函数会去掉 &lt;list&gt; 中相同的单词 word 1$(word &lt;n&gt;,&lt;text&gt;) 名称：取单词函数 功能：取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从1开始数） 返回：返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串 示例： $(word 2, foo bar baz) 返回值是 bar wordlist 1$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;) 名称：取单词串函数 功能：从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。 &lt;ss&gt; 和 &lt;e&gt; 是一个数字 返回：返回字符串 &lt;text&gt; 中从 &lt;ss&gt; 到 &lt;e&gt; 的单词字串。如果 &lt;ss&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。如果 &lt;e&gt; 大于 &lt;text&gt; 的单词数，那么返回从 &lt;ss&gt; 开始，到 &lt;text&gt; 结束的单词串 示例： $(wordlist 2, 3, foo bar baz) 返回值是 bar baz words 1$(words &lt;text&gt;) 名称：单词个数统计函数 功能：统计 &lt;text&gt; 中字符串中的单词个数 返回：返回 &lt;text&gt; 中的单词数 示例： $(words, foo bar baz) 返回值是 3 备注：如果我们要取 &lt;text&gt; 中最后的一个单词，我们可以这样： $(word $(words &lt;text&gt;),&lt;text&gt;) firstword 1$(firstword &lt;text&gt;) 名称：首单词函数 功能：取字符串 &lt;text&gt; 中的第一个单词 返回：返回字符串 &lt;text&gt; 的第一个单词 示例： $(firstword foo bar) 返回值是 foo 备注：这个函数可以用 word 函数来实现： $(word 1,&lt;text&gt;) 函数应用实例 make使用 VPATH 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS ，如： 1override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH))) 如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers ，这正是cc或gcc搜索头文件路径的参数 文件名操作函数 dir 1$(dir &lt;names...&gt;) 名称：取目录函数 功能：从文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./ 返回：返回文件名序列 &lt;names&gt; 的目录部分 示例： $(dir src/foo.c hacks) 返回值是 src/ ./ notdir 1$(notdir &lt;names...&gt;) 名称：取文件函数 功能：从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分 返回：返回文件名序列 &lt;names&gt; 的非目录部分 示例: $(notdir src/foo.c hacks) 返回值是 foo.c hacks basename 1$(basename &lt;names...&gt;) 名称：取前缀函数 功能：从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分 返回：返回文件名序列 &lt;names&gt; 的前缀序列，如果文件没有前缀，则返回空字串 示例： $(basename src/foo.c src-1.0/bar.c hacks) 返回值是 src/foo src-1.0/bar hacks addsuffix 1$(addsuffix &lt;suffix&gt;,&lt;names...&gt;) 名称：加后缀函数 功能：把后缀 &lt;suffix&gt; 加到 &lt;names&gt; 中的每个单词后面 返回：返回加过后缀的文件名序列 示例： $(addsuffix .c,foo bar) 返回值是 foo.c bar.c addprefix 1$(addprefix &lt;prefix&gt;,&lt;names...&gt;) 名称：加前缀函数 功能：把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词前面 返回：返回加过前缀的文件名序列 示例： $(addprefix src/,foo bar) 返回值是 src/foo src/bar join 1$(join &lt;list1&gt;,&lt;list2&gt;) 名称：连接函数 功能：把 &lt;list2&gt; 中的单词对应地加到 &lt;list1&gt; 的单词后面。如果 &lt;list1&gt; 的单词个数要比 &lt;list2&gt; 的多，那么， &lt;list1&gt; 中的多出来的单词将保持原样。如果 &lt;list2&gt; 的单词个数要比 &lt;list1&gt; 多，那么， &lt;list2&gt; 多出来的单词将被复制到 &lt;list1&gt; 中 返回：返回连接过后的字符串 示例： $(join aaa bbb , 111 222 333) 返回值是 aaa111 bbb222 333 foreach函数 1$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) 把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中 然后再执行 &lt;text&gt; 所包含的表达式 每一次 &lt;text&gt; 会返回一个字符串，循环过程中，&lt;text&gt; 的所返回的每个字符串会以空格分隔 最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值 &lt;var&gt; 一般是变量名，&lt;list&gt; 可以是表达式，&lt;text&gt; 一般使用 &lt;var&gt; 这个参数来枚举 &lt;list&gt; 中的单词 &lt;var&gt; 参数是一个临时的局部变量，foreach函数执行完后，参数 &lt;var&gt; 的变量将不在作用 示例： 12345names := a b c dfiles := $(foreach n,$(names),$(n).o)# files的值为 &quot;a.o b.o c.o d.o&quot; if函数 12345$(if &lt;condition&gt;,&lt;then-part&gt;)# 或$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;) if函数的返回值：如果 &lt;condition&gt; 为真（非空字符串）， &lt;then-part&gt; 会是整个函数的返回值；如果 &lt;condition&gt; 为假（空字符串），那么 &lt;else-part&gt; 会是整个函数的返回值，此时如果 &lt;else-part&gt; 没有被定义，那么，整个函数返回空字串 call函数 可以用来创建新的参数化的函数： 1$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;) &lt;expression&gt; 参数中的变量，如 $(1) 、 $(2) 等，会被参数 &lt;parm1&gt; 、 &lt;parm2&gt; 、 &lt;parm3&gt; 依次取代。而 &lt;expression&gt; 的返回值就是 call 函数的返回值，如： 1234reverse = $(2) $(1)foo = $(call reverse,a,b)# foo的值为 &quot;b a&quot; 需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。 origin函数 1$(origin &lt;variable&gt;) 注意， &lt;variable&gt; 是变量的名字，不应该是引用。所以你最好不要在 &lt;variable&gt; 中使用 $ 字符。 origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值: undefined ： &lt;variable&gt; 从来没有定义过， default ： &lt;variable&gt; 是一个默认的定义，比如“CC”这个变量 environment ： &lt;variable&gt; 是一个环境变量，并且当Makefile被执行时， -e 参数没有被打开 file ： &lt;variable&gt; 被定义在Makefile中 command line ：&lt;variable&gt; 是被命令行定义的 override ：&lt;variable&gt; 是被override指示符重新定义的 automatic ：&lt;variable&gt; 是一个命令运行中的自动化变量 假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写： 12345ifdef bletch ifeq &quot;$(origin bletch)&quot; &quot;environment&quot; bletch = barf, gag, etc. endifendif shell函数 shell函数的参数是操作系统shell的命令，shell函数把执行操作系统命令后的输出作为函数返回，于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如： 12contents := $(shell cat foo)files := $(shell echo *.c) 这个函数会新生成一个Shell程序来执行命令，所以要注意其运行性能 控制make的函数 检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止： error函数 1$(error &lt;text ...&gt;) 产生一个致命的错误， &lt;text ...&gt; 是错误信息 示例1： 1234ifdef ERROR_001 $(error error is $(ERROR_001))endif# 在变量ERROR_001定义了后执行时产生error调用 示例2： 1234567ERR = $(error found an error!).PHONY: errerr: $(ERR)# 在目录err被执行时发生error调用 warning函数 1$(warning &lt;text ...&gt;) 和 error 函数很像，但是不会让make退出，只是输出一段警告信息，而make继续执行 make的运行 make的退出码 make命令执行后有三个退出码： 0：表示成功执行 1：如果make运行时出现任何错误，返回1 2：如果使用make的“-q”选项，并且make使得一些目标不需要更新，那么返回2 指定makefile 使用 -f 或 --file 或 --makefile 参数： 1make –f hchen.mk 指定目标 一般来说，make的最终目标是makefile中的第一个目标 可以指示make，让其完成你所指定的目标：需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式） 有一个make的环境变量叫 MAKECMDGOALS ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值，使用方法如： 1234sources = foo.c bar.cifneq ( $(MAKECMDGOALS),clean) include $(sources:.c=.d)endif 只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile 检查规则 有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列，可以使用以下参数： -n, --just-print, --dry-run, --recon ：不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行 -t, --touch ：把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态 -q, --question ：找目标，如果目标存在，那么什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息 -W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt; ：指定一个文件。一般是是源文件（或依赖文件），make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令 make的参数 -b, -m ：忽略和其它版本make的兼容性 -B, --always-make ：认为所有的目标都需要更新（重编译） -C &lt;dir&gt;, --directory=&lt;dir&gt; ：指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog” -debug[=&lt;options&gt;] ：输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值： a: 也就是all，输出所有的调试信息（会非常的多） b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标 v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等 i: 也就是implicit，输出所以的隐含规则 j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等 m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息 -d ：相当于“–debug=a” -e, --environment-overrides ：指明环境变量的值覆盖makefile中定义的变量的值 -f=&lt;file&gt;, --file=&lt;file&gt;, --makefile=&lt;file&gt; ：指定需要执行的makefile -h, --help ：显示帮助信息 -i, --ignore-errors ：在执行时忽略所有的错误 -I&lt;dir&gt;, --include-dir=&lt;dir&gt; ：指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录 -j [&lt;jobsnum&gt;], --jobs[=&lt;jobsnum&gt;] ：指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的 -k, --keep-going ：出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了 -l &lt;load&gt;, --load-average[=&lt;load&gt;], --max-load[=&lt;load&gt;] ：指定make运行命令的负载 -n, --just-print, --dry-run, --recon ：仅输出执行过程中的命令序列，但并不执行 -o &lt;file&gt;, --old-file=&lt;file&gt;, --assume-old=&lt;file&gt; ：不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它 -p, --print-data-base ：输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用 “make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号 -q, --question ：不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生 -r, --no-builtin-rules ：禁止make使用任何隐含规则 -R, --no-builtin-variables ：禁止make使用任何作用于变量上的隐含规则 -s, --silent, --quiet ：在命令运行时不输出命令的输出 -S, --no-keeping-going, --stop ：取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效 -t, --touch ：相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行 -v, --version ：输出make程序的版本、版权等关于make的信息 -w, --print-directory ：输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用 --no-print-directory ：禁止“-w”选项 -W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt; ：假定目标&lt;file&gt;;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作；如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;;的修改时间为当前时间 --warn-undefined-variables ：只要make发现有未定义的变量，那么就输出警告信息 隐含规则 使用隐含规则 12foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 这个Makefile中并没有写下如何生成 foo.o 和 bar.o 这两目标的规则和命令。因为make调用的隐含规则，把 .o 的目标的依赖文件置成 .c ，并使用C的编译命令 cc –c $(CFLAGS) foo.c 来生成 foo.o 的目标 一些语言的隐含规则 编译C程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS) 编译C++程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.cc 或是 &lt;n&gt;.C ，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS) 。（建议使用 .cc 作为C++源文件的后缀，而不是 .C ） 编译Pascal程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.p ，并且其生成命令是 $(PC) –c $(PFLAGS) 。 编译Fortran/Ratfor程序的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F 或 &lt;n&gt;.f ，并且其生成命令是: .f $(FC) –c $(FFLAGS) .F $(FC) –c $(FFLAGS) $(CPPFLAGS) 预处理Fortran/Ratfor程序的隐含规则。 &lt;n&gt;.f 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是： .F $(FC) –F $(CPPFLAGS) $(FFLAGS) .r $(FC) –F $(FFLAGS) $(RFLAGS) 编译Modula-2程序的隐含规则。 &lt;n&gt;.sym 的目标的依赖目标会自动推导为 &lt;n&gt;.def ，并且其生成命令是： $(M2C) $(M2FLAGS) $(DEFFLAGS) 。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.mod ，并且其生成命令是： $(M2C) $(M2FLAGS) $(MODFLAGS) 。 汇编和汇编预处理的隐含规则。 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.s ，默认使用编译器 as ，并且其生成命令是： $ (AS) $(ASFLAGS) 。 &lt;n&gt;.s 的目标的依赖目标会自动推导为 &lt;n&gt;.S ，默认使用C预编译器 cpp ，并且其生成命令是： $(AS) $(ASFLAGS) 。 链接Object文件的隐含规则。 &lt;n&gt; 目标依赖于 &lt;n&gt;.o ，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是： $(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则: 1x : y.o z.o 并且 x.c 、 y.c 和 z.c 都存在时，隐含规则将执行如下命令: 1234567cc -c x.c -o x.occ -c y.c -o y.occ -c z.c -o z.occ x.o y.o z.o -o xrm -f x.orm -f y.orm -f z.o 如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。 Yacc C程序时的隐含规则。 &lt;n&gt;.c 的依赖文件被自动推导为 n.y （Yacc生成的文件），其生成命令是： $(YACC) $(YFALGS) 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料） Lex C程序时的隐含规则。 &lt;n&gt;.c 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。（关于“Lex”的细节请查看相关资料） Lex Ratfor程序时的隐含规则。 &lt;n&gt;.r 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。 从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。 &lt;n&gt;.ln （lint生成的文件）的依赖文件被自动推导为 n.c ，其生成命令是： $(LINT) $(LINTFALGS) $(CPPFLAGS) -i 。对于 &lt;n&gt;.y 和 &lt;n&gt;.l 也是同样的规则。 隐含规则使用的变量 关于命令的变量 AR : 函数库打包程序。默认命令是 ar AS : 汇编语言编译程序。默认命令是 as CC : C语言编译程序。默认命令是 cc CXX : C++语言编译程序。默认命令是 g++ CO : 从 RCS文件中扩展文件程序。默认命令是 co CPP : C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77 GET : 从SCCS文件中扩展文件的程序。默认命令是 get LEX : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex PC : Pascal语言编译程序。默认命令是 pc YACC : Yacc文法分析器（针对于C程序）。默认命令是 yacc YACCR : Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r MAKEINFO : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo TEX : 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex TEXI2DVI : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi WEAVE : 转换Web到TeX的程序。默认命令是 weave CWEAVE : 转换C Web 到 TeX的程序。默认命令是 cweave TANGLE : 转换Web到Pascal语言的程序。默认命令是 tangle CTANGLE : 转换C Web 到 C。默认命令是 ctangle RM : 删除文件命令。默认命令是 rm –f 关于命令参数的变量 如果没有指明默认值，则为空 ARFLAGS : 函数库打包程序AR命令的参数。默认值是 rv ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时） CFLAGS : C语言编译器参数 CXXFLAGS : C++语言编译器参数 COFLAGS : RCS命令参数 CPPFLAGS : C预处理器参数。（ C 和 Fortran 编译器也会用到） FFLAGS : Fortran语言编译器参数 GFLAGS : SCCS “get”程序参数 LDFLAGS : 链接器参数。（如： ld ） LFLAGS : Lex文法分析器参数。 PFLAGS : Pascal语言编译器参数 RFLAGS : Ratfor 程序的Fortran 编译器参数 YFLAGS : Yacc文法分析器参数 隐含规则链 有些时候，一个目标可能被一系列的隐含规则所作用。 例如，一个 .o 的文件生成，可能会是先被 Yacc的[.y]文件生成 .c ，然后再被C的编译器生成： 如果文件 .c 存在，那么就直接调用C的编译器的隐含规则 如果没有 .c 文件，但有一个 .y 文件，那么Yacc的隐含规则会被调用，生成 .c 文件，然后，再调用C编译的隐含规则最终由 .c 生成 .o 文件，达到目标 我们把这种 .c 的文件（或是目标），叫做中间目标 除非中间的目标不存在，才会引发中间规则 只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以 rm -f 删除 中间目标 显式说明一个文件或是目标是中间目标：.INTERMEDIATE : mid 阻止make自动删除中间目标：.SECONDARY : sec 在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况 模式规则 使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 % 字符；在依赖目标中同样可以使用 % ，只是依赖目标中的 % 的取值，取决于其目标。 注意： % 的展开发生在变量和函数的展开之后 变量和函数的展开发生在make载入Makefile时 模式规则中的 % 展开发生在运行时 模式规则示例 12%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@ 把所有的 .c 文件都编译成 .o 文件 12%.tab.c %.tab.h: %.y bison -d $&lt; 这条规则告诉make把所有的 .y 文件都以 bison -d &lt;n&gt;.y 执行，然后生成 &lt;n&gt;.tab.c 和 &lt;n&gt;.tab.h 文件（其中， &lt;n&gt; 表示一个任意字符串） 如果我们的执行程序 foo 依赖于文件 parse.tab.o 和 scan.o ，并且文件 scan.o 依赖于文件 parse.tab.h ，如果 parse.y 文件被更新了，那么根据上述的规则， bison -d parse.y 就会被执行一次，于是， parse.tab.o 和 scan.o 的依赖文件就齐了。（假设， parse.tab.o 由 parse.tab.c 生成，和 scan.o 由 scan.c 生成，而 foo 由 parse.tab.o 和 scan.o 链接生成，而且 foo 和其 .o 文件的依赖关系也写好，那么，所有的目标都会得到满足） 自动化变量 把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完 $@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， $@ 就是匹配于目标中模式定义的集合 $% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ，那么， $% 就是 bar.o ， $@ 就是 foo.a 。如果目标不是函数库文件（Unix下是 .a ，Windows下是 .lib ），那么，其值为空 $&lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的 $? : 所有比目标新的依赖目标的集合。以空格分隔 $^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份 $+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标 $* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么， $* 的值就是 dir/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 $* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为 .c 是make所能识别的后缀名，所以， $* 的值就是 foo 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 $* 就是空值 当你希望只对更新过的依赖文件进行操作时， $? 在显式规则中很有用，例如，假设有一个函数库文件叫 lib ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是： 12lib : foo.o bar.o lose.o win.o ar r lib $? 在上述所列出来的自动量变量中。四个变量（ $@ 、 $&lt; 、 $% 、 $* ）在扩展时只会有一个文件，而另三个的值是一个文件列表。 这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 D 或 F 字样： $(@D)：表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录） $(@F)：表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。 $(*D), $(*F)：和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ，而 $(*F) 返回 `foo`` ``$(%D), $(%F)：分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member)形式的目标中的member` 中包含了不同的目录很有用。 $(&lt;D), $(&lt;F)：分别表示依赖文件的目录部分和文件部分。 $(^D), $(^F)：分别表示所有依赖文件的目录部分和文件部分。（无相同的） $(+D), $(+F)：分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） $(?D), $(?F)：分别表示被更新的依赖文件的目录部分和文件部分 重载内建隐含规则 重新构造和内建隐含规则不同的命令，如： 12%.o : %.c $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date) 取消内建的隐含规则，只要不在后面写命令就行。如： 1%.o : %.s 隐含规则搜索算法 比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。如果目标是 archive(member) 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 member 当作T来搜索。 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 src/foo.o ，那么，D就是 src/ ，N就是 foo.o ） 创建所有匹配于T或是N的模式规则列表。 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。 移除列表中没有命令的规则。 对于第一个在列表中的模式规则： 推导其“茎”S，S应该是T或是N匹配于模式中 % 非空的部分。 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”） 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则： 如果规则是终止规则，那就忽略它，继续下一条模式规则。 计算依赖文件。（同第5步） 测试所有的依赖文件是否存在或是理当存在。 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。 一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。 使用make更新函数库文件 函数库文件也就是对Object文件（程序编译的中间文件）的打包文件 在Unix下，一般是由命令 ar 来完成打包工作 函数库文件的成员 一个函数库文件由多个文件组成，指定函数库文件及其组成： 1archive(member) 从而在 ar 命令中，如此使用： 12foolib(hack.o) : hack.o kludge.o ar cr foolib(hack.o kludge.o) 函数库成员的隐含规则 当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m) 。于是，如果我们的成员是 %.o 的模式定义，并且如果我们使用 make foo.a(bar.o) 的形式调用Makefile时，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，make会去找 bar.c 文件来生成 bar.o ，如果找得到的话，make执行的命令大致如下: 123cc -c bar.c -o bar.oar r foo.a bar.orm -f bar.o","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://example.com/tags/makefile/"}]},{"title":"Wasmi sgx 工作流程","slug":"learning-notes/wasmi-sgx","date":"2021-03-07T16:00:00.000Z","updated":"2022-04-28T07:36:14.000Z","comments":true,"path":"2021/03/08/learning-notes/wasmi-sgx/","link":"","permalink":"http://example.com/2021/03/08/learning-notes/wasmi-sgx/","excerpt":"Wasmi sgx 工作流程","text":"初始化enclave 1init_enclave() -&gt; SgxResult&lt;SgxEnclave&gt; 底层调用rsgx_create_enclave【通过file_name和launch_token来初始化一个enclave实例】，参数如下： file_name：经过编译后的enclave签名文件（enclave.signed.so） debug： 0 - 不开启debug 1 - 开启debug，enclave中的数据代码可以被enclave外的程序访问，用于调试 launch_token：初始化enclave时可以传入全0 buffer，函数会创建一个有效token与enclave对应，并更新该参数。之后如果要重新创建这个enclave，可以再使用这个token launch_token_updated： 0 - token没有被自动更新 1 - token被自动更新 misc_attr：misc选择和enclave属性 {暂时不清楚作用} init_enclave()返回一个SgxEnclave结构 12345pub struct SgxEnclave &#123; id: sgx_enclave_id_t, debug: i32, path: PathBuf,&#125; 初始化sgxwasm的SpecDriver 1fn sgx_enclave_wasm_init(enclave: &amp;SgxEnclave) -&gt; Result&lt;(),String&gt; 调用ECall函数sgxwasm_init()，传入两个隐参数： enclave_id：通过enclave.geteid()获取 retval：ECall函数的返回值，由Intel定义，不用在ECall函数中手动修改 在Enclave中会通过lazy_static的方式建立一个全局变量SPECDRIVER（带有互斥量） 1234lazy_static!&#123; static ref SPECDRIVER: SgxMutex&lt;SpecDriver&gt; = SgxMutex::new(SpecDriver::new());&#125; sgxwasm_init()在SPECDRIVER中新建一个SpecDriver 12345678910111213141516171819202122232425pub struct SpecDriver &#123; spec_module: SpecModule, instances: HashMap&lt;String, ModuleRef&gt;, last_module: Option&lt;ModuleRef&gt;,&#125;// 标准模块，是从wasm外部导入函数所使用的外部环境pub struct SpecModule &#123; table: TableRef, memory: MemoryRef, global_i32: GlobalRef, global_f32: GlobalRef, global_f64: GlobalRef,&#125;// ModuleRef是ModuleInstance的引用// ModuleInstance是一个wasm模块实例pub struct ModuleInstance &#123; signatures: RefCell&lt;Vec&lt;Arc&lt;Signature&gt;&gt;&gt;, tables: RefCell&lt;Vec&lt;TableRef&gt;&gt;, funcs: RefCell&lt;Vec&lt;FuncRef&gt;&gt;, memories: RefCell&lt;Vec&lt;MemoryRef&gt;&gt;, globals: RefCell&lt;Vec&lt;GlobalRef&gt;&gt;, exports: RefCell&lt;BTreeMap&lt;String, ExternVal&gt;&gt;,&#125; 在Enclave外加载wast文件 1wasm_main_loop(wast_file: &amp;str, enclave: &amp;SgxEnclave) -&gt; Result&lt;(), String&gt; 首先对读入的wast_file文本进行分析（使用ScriptParser），读取每一行的指令到结构Command中： 123456pub struct Command&lt;F32 = f32, F64 = f64&gt; &#123; /// 行号 pub line: u64, /// 指令类型 pub kind: CommandKind&lt;F32, F64&gt;,&#125; 对每一行指令匹配CommandKind，并执行对应的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485pub enum CommandKind&lt;F32 = f32, F64 = f64&gt; &#123; // 定义、验证、实例化一个module Module &#123; // wasm二进制模块 module: ModuleBinary, // 模块名称，可以将wasm模块注册到name name: Option&lt;String&gt;, &#125;, // 确保特定的指令会产生特定的结果 AssertReturn &#123; // 执行的指令 action: Action&lt;F32, F64&gt;, /// 预期的指令执行结果 expected: Vec&lt;Value&lt;F32, F64&gt;&gt;, &#125;, // 确保指定的指令产生NaN AssertReturnCanonicalNan &#123; // 执行的指令 action: Action&lt;F32, F64&gt;, &#125;, // 确保指定的指令产生 NaN with 1 in MSB of fraction field AssertReturnArithmeticNan &#123; // 执行的指令 action: Action&lt;F32, F64&gt;, &#125;, // 确保指定的指令产生trap AssertTrap &#123; // 执行的指令 action: Action&lt;F32, F64&gt;, // 错误信息 message: String, &#125;, // 确保特定的模块是无效的 AssertInvalid &#123; // 无效的模块 module: ModuleBinary, // 错误信息 message: String, &#125;, // 确保特定的模块不能被decode AssertMalformed &#123; module: ModuleBinary, // 错误信息 message: String, &#125;, // 确保特定的模块不能被实例化 AssertUninstantiable &#123; // 不能被实例化的模块 module: ModuleBinary, // 错误信息 message: String, &#125;, // 确保特定的指令在资源耗尽的时候执行 AssertExhaustion &#123; action: Action&lt;F32, F64&gt;, // 错误信息 message: String, &#125;, // 确保特定的模块不能被链接 AssertUnlinkable &#123; module: ModuleBinary, // 错误信息 message: String, &#125;, // 将已经注册过的模块改名 Register &#123; // 需要改名的模块名，若爲None则将使用最后定义的模块 name: Option&lt;String&gt;, // 新名称 as_name: String, &#125;, // 执行指定指令 PerformAction(Action&lt;F32, F64&gt;),&#125; 指令Action wasm模块中的指令： 123456789101112131415161718pub enum Action&lt;F32 = f32, F64 = f64&gt; &#123; // 调用函数 Invoke &#123; // 模块名称，若爲None，则取最后定义的模块 module: Option&lt;String&gt;, // 函数名 field: String, // 需要传递给函数的参数 args: Vec&lt;Value&lt;F32, F64&gt;&gt;, &#125;, // 读取全局变量 Get &#123; // 模块名称，若爲None，则取最后定义的模块 module: Option&lt;String&gt;, // 指令作用在字段field上 field: String, &#125;,&#125; sgxwasm中定义的指令： 1234567891011121314151617181920212223242526272829303132333435363738394041pub enum SgxWasmAction &#123; // 调用函数 Invoke &#123; // 模块名称，若爲None，则取最后定义的模块 module: Option&lt;String&gt;, // 函数名 field: String, // 需要传递给函数的参数 args: Vec&lt;BoundaryValue&gt; &#125;, // 读取全局变量 Get &#123; // 模块名称，若爲None，则取最后定义的模块 module: Option&lt;String&gt;, // 指令作用在字段field上 field: String, &#125;, // 加载模块 LoadModule &#123; // 模块名称，若爲None，则取最后定义的模块 name: Option&lt;String&gt;, // 二进制模块 module: Vec&lt;u8&gt;, &#125;, // 尝试加载一个模块 TryLoad &#123; // 二进制模块 module: Vec&lt;u8&gt;, &#125;, // 将已经注册过的模块改名 Register &#123; // 模块名称，若爲None，则取最后定义的模块 name: Option&lt;String&gt;, // 新名称 as_name: String, &#125;,&#125; CommandKind::Module 12345// 加载一个模块fn sgx_enclave_wasm_load_module(module : Vec&lt;u8&gt;, name : &amp;Option&lt;String&gt;, enclave : &amp;SgxEnclave) -&gt; Result&lt;(), String&gt; 创建一个SgxWasmAction::LoadModule结构，再调用sgx_enclave_wasm_invoke() CommandKind::AssertReturn 12// 根据wasm的Action执行指令fn sgx_enclave_wasm_run_action(action: &amp;Action, enclave: &amp;SgxEnclave) -&gt; Result&lt;Option&lt;RuntimeValue&gt;, InterpreterError&gt; 先匹配Action： 如果是Action::Invoke，那么创建一个SgxWasmAction::Invoke结构并交给sgx_enclave_wasm_invoke() 如果是Action::Get，那么创建一个SgxWasmAction::Get结构并交给sgx_enclave_wasm_invoke() 然后根据sgx_enclave_wasm_invoke()的返回结果来判断输出是否是我们想要的 **备注：**对于另外一些CommandKind（包括CommandKind::AssertReturnCanonicalNan、CommandKind::AssertReturnArithmeticNan、CommandKind::AssertExhaustion、CommandKind::AssertTrap），过程同CommandKind::AssertReturn，只不过是对返回值的判断有所不同 **备注2：**对于CommandKind::PerformAction，只需匹配和执行Action，不需要后面的判断 CommandKind::AssertInvalid 12// 尝试加载一个模块fn sgx_enclave_wasm_try_load(module : &amp;[u8], enclave : &amp;SgxEnclave) -&gt; Result&lt;(), InterpreterError&gt; 先创建一个SgxWasmAction::TryLoad结构，再交给sgx_enclave_wasm_invoke() **备注：**对于另外一些CommandKind（包括CommandKind::AssertMalformed、CommandKind::AssertUnlinkable、CommandKind::AssertUninstantiable），由于这些类型的SgxWasmAction都不能加载可用的模块，所以只能尝试加载模块 CommandKind::Register 12345// 注册一个模块fn sgx_enclave_wasm_register(name : Option&lt;String&gt;, as_name : String, enclave : &amp;SgxEnclave) -&gt; Result&lt;(), InterpreterError&gt; 创建一个SgxWasmAction::Register结构，再交给sgx_enclave_wasm_invoke() 调用函數sgx_enclave_wasm_invoke() 1234// 根据SgxWasmAction通过ECall执行指定的指令fn sgx_enclave_wasm_invoke(req_str : String, result_max_len : usize, enclave : &amp;SgxEnclave) -&gt; (Result&lt;Option&lt;BoundaryValue&gt;, InterpreterError&gt;, sgx_status_t) req_str：将SgxWasmAction序列化得到 result_max_len：返回结果的最大长度 sgx_enclave_wasm_invoke()调用ECall函数sgxwasm_run_action() 安全函数sgxwasm_run_action() 12fn sgxwasm_run_action(req_bin : *const u8, req_length: usize, result_bin : *mut u8, result_max_len: usize) -&gt; sgx_status_t req_bin：需要执行的SgxWasmAction请求 req_length：请求长度 result_bin：返回的内容 result_max_len：返回值的最大长度 首先通过req_bin和req_length来在Enclave中创建一个安全的SgxWasmAction结构action_req，再对其进行匹配： SgxWasmAction::Invoke 123// 调用函数fn wasm_invoke(module: Option&lt;String&gt;, field: String, args: Vec&lt;RuntimeValue&gt;) -&gt; Result&lt;Option&lt;RuntimeValue&gt;, InterpreterError&gt; 首先获取全局的SPECDRIVER存入变量program，根据module的值在SpecDriver.instances中查找对应名字的模块，如果module的值爲None，则通过SpecDriver.last_module返回最后注册的模块，得到一个ModuleRef结构module通过module的invoke_export()方法调用导出函数： 1module.invoke_export(&amp;field, &amp;args, program.spec_module()) &amp;field：函数名 &amp;args：传入函数的参数 program.spec_module()：externals，导入wasm函数的外部环境，实现Externals trait invoke_export()方法通过函数名查找导出函数，得到FuncRef类型的func_instance，并使用 FuncInstance::invoke(&amp;func_instance, args, externals) 调用函数，FuncInstance结构是一个函数实例，在wasm中，函数的定义方式有两种：在wasm模块中定义或者从宿主环境导入，分别对应FuncInstanceInternal::Internal和FuncInstanceInternal::Host 1234567891011121314pub struct FuncInstance(FuncInstanceInternal);#[derive(Clone)]pub(crate) enum FuncInstanceInternal &#123; Internal &#123; signature: Arc&lt;Signature&gt;, module: Weak&lt;ModuleInstance&gt;, body: Arc&lt;FuncBody&gt;, &#125;, Host &#123; signature: Signature, host_func_index: usize, &#125;,&#125; 在FuncInstance::invoke()调用函数时，首先判断传入参数是否符合函数籤名，然后匹配函数的定义方式FuncInstanceInternal Internal：初始化一个Interpreter，然后调用 interpreter.start_execution(externals) 执行函数（更底层的内容可能会写在下一章） 123456pub struct Interpreter &#123; value_stack: ValueStack, call_stack: CallStack, return_type: Option&lt;ValueType&gt;, state: InterpreterState,&#125; Host：调用 externals.invoke_index(*host_func_index, args.into()) ，externals即爲invoke_export()方法传入的第三参数：导入函数的外部环境。这里的externals就是SpecModule，它实现的Externals trait如下： 123456789101112131415impl Externals for SpecModule &#123; fn invoke_index( &amp;mut self, index: usize, args: RuntimeArgs, ) -&gt; Result&lt;Option&lt;RuntimeValue&gt;, Trap&gt; &#123; match index &#123; PRINT_FUNC_INDEX =&gt; &#123; println!(&quot;print: &#123;:?&#125;&quot;, args); Ok(None) &#125; _ =&gt; panic!(&quot;SpecModule doesn&#x27;t provide function at index &#123;&#125;&quot;, index), &#125; &#125;&#125; SgxWasmAction::Get 123// 获取全局变量fn wasm_get(module : Option&lt;String&gt;, field : String) -&gt; Result&lt;Option&lt;RuntimeValue&gt;, InterpreterError&gt; 首先获取全局的SPECDRIVER存入变量program，根据module的值在SpecDriver.instances中查找对应名字的模块，如果module的值爲None，则通过SpecDriver.last_module返回最后注册的模块，得到一个ModuleRef结构module 然后通过 module.export_by_name(&amp;field) 获得一个wasm的运行时的实体引用ExternVal，可能的值包括：函数、Table、Memory、全局变量 123456pub enum ExternVal &#123; Func(FuncRef), Table(TableRef), Memory(MemoryRef), Global(GlobalRef),&#125; 接着匹配module的该导出实体是否爲Global，若不是，返回None SgxWasmAction::LoadModule 123// 加载一个模块到SpecDriver中fn wasm_load_module(name: Option&lt;String&gt;, module: Vec&lt;u8&gt;) -&gt; Result&lt;(), InterpreterError&gt; 首先获取全局的SPECDRIVER存入变量spec_driver，然后通过 try_load_module(&amp;module[..]) 获得一个parity_wasm库的Module类型的module，接着通过 ModuleInstance::new(&amp;module, &amp;**spec_driver) 的方式新建一个NotStartedModuleRef实例，并使用 run_start(spec_driver.spec_module()) 方法将其转变爲ModuleRef类型 最后将该实例通过 spec_driver.add_module(name, instance.clone()) 存放入spec_driver中，将SpecDriver.last_module改爲该模块，并在SpecDriver.instances中插入该模块与其名字的键值对 SgxWasmAction::TryLoad 12// 尝试加载一个模块，不加载到SpecDriver中fn wasm_try_load(wasm: Vec&lt;u8&gt;) -&gt; Result&lt;(), InterpreterError&gt; 首先获取全局的SPECDRIVER存入变量spec_driver，然后通过 try_load_module(&amp;module[..]) 获得一个parity_wasm库的Module类型的module，接着通过 ModuleInstance::new(&amp;module, &amp;ImportsBuilder::default()) 的方式新建一个NotStartedModuleRef实例instance，尝试对其使用 run_start(spec_driver.spec_module())方法，若成功，返回Ok(())，若失败，返回错误 SgxWasmAction::Register 123// 使用as_name注册一个新模块fn wasm_register(name: &amp;Option&lt;String&gt;, as_name: String) -&gt; Result&lt;(), InterpreterError&gt; 首先获取全局的SPECDRIVER存入变量spec_driver，根据module的值在SpecDriver.instances中查找对应名字name的模块，如果name的值爲None，则通过SpecDriver.last_module返回最后注册的模块 最后将该模块通过 spec_driver.add_module(name, instance.clone()) 存放入spec_driver中，将SpecDriver.last_module改爲该模块，并在SpecDriver.instances中插入该模块与其名字的键值对 函数执行Interpreter底层","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Rust更换项目编译的Channel","slug":"instruction/rustup-channel","date":"2021-03-02T16:00:00.000Z","updated":"2022-04-28T07:19:14.000Z","comments":true,"path":"2021/03/03/instruction/rustup-channel/","link":"","permalink":"http://example.com/2021/03/03/instruction/rustup-channel/","excerpt":"使用非稳定版的nightly环境编译项目","text":"查看可用的Channel： 1rustup toolchain list 在项目根目录输入命令修改本项目的编译环境： 1rustup override set nightly","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Git - Learn","slug":"learning-notes/git-notes","date":"2020-12-22T16:00:00.000Z","updated":"2022-04-28T07:29:06.000Z","comments":true,"path":"2020/12/23/learning-notes/git-notes/","link":"","permalink":"http://example.com/2020/12/23/learning-notes/git-notes/","excerpt":"Git学习记录","text":"版本控制 1. 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS 2. 集中版本控制 所有的版本数据都存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3. 分布式版本控制 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN的主要区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git环境配置 Git配置 查看配置 1git config -l 查看不同级别的配置文件： 1234567# 查看系统configgit config --system --list# Git\\etc\\gitconfig：Git安装目录下的gitconfig # 查看当前用户（global）配置git config --global --list# C:\\Users\\Administrator\\.gitconfig 只适用于当前登录用户的配置 设置用户名与邮箱（用户标识，必要） 12git config --global user.name &quot;&lt;名称&gt;&quot; # 名称git config --global user.email &lt;邮箱&gt; # 邮箱 Git基本理论 三个区域 Git本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下: Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本： Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) Git项目搭建 创建工作目录与常用指令 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 创建权限仓库 创建全新的仓库，需要用GIT管理的项目的根目录执行： 12# 在当前目录新建一个Git代码库$ git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 12# 克隆一个项目和它的整个代码历史(版本信息)$ git clone &lt;url&gt; Git文件操作 文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态 12345678# 查看指定文件状态git status &lt;filename&gt;#查看所有文件状态git statusgit add . 添加所有文件到暂存区git commit -m &quot;消息内容&quot; 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 12345*.txt # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt # 但lib.txt除外/temp # 仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ # 忽略build/目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt Git分支 git分支中常用指令： 123456789101112131415161718192021# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] Git子模块 git子模块中常用指令：参考https://blog.csdn.net/guotianqing/article/details/82391665 123# 遇到报错git submodule: already exists in the index# (path为子模块在本地项目中存储的目录)git rm -r --cached &lt;path&gt;","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Rust-SGX环境配置","slug":"instruction/sgx-rust-install","date":"2020-12-09T16:00:00.000Z","updated":"2022-10-31T08:58:09.791Z","comments":true,"path":"2020/12/10/instruction/sgx-rust-install/","link":"","permalink":"http://example.com/2020/12/10/instruction/sgx-rust-install/","excerpt":"Rust-SGX-SDK的移植使用","text":"安装Intel SGX SGX Driver：cpu不支持DCAP，根据官方github安装 SGX PSW：根据安装手册添加源，再直接使用apt安装： 12345echo &#x27;deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu focal main&#x27; | sudo tee /etc/apt/sources.list.d/intel-sgx.listwget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | sudo apt-key addsudo apt-get updatesudo apt-get install libsgx-launch libsgx-urts libsgx-epid libsgx-quote-ex libsgx-dcap-ql libsgx-uae-servicesudo apt-get install libsgx-urts-dbgsym libsgx-enclave-common-dbgsym libsgx-dcap-ql-dbgsym libsgx-dcap-default-qpl-dbgsym SGX SDK：下载bin文件，移动到 /opt/intel/ 下，添加权限后直接运行 下载Rust-SGX-SDK 1git clone -b v1.1.4 https://github.com/apache/incubator-teaclave-sgx-sdk.git 添加环境变量 在~/.bashrc文件最后添加： 12export SGX_SDK_RUST=$HOME/sgx/incubator-teaclave-sgx-sdksource /opt/intel/sgxsdk/environment 再在终端执行 source ~/.bashrc 解决：Enclave代码运行出错（Invalid SGX Driver） 不清楚什么原因，反正重装一遍SGX Driver就好了 卸载： 1234sudo /sbin/modprobe -r isgxsudo rm -rf &quot;/lib/modules/&quot;`uname -r`&quot;/kernel/drivers/intel/sgx&quot;sudo /sbin/depmodsudo /bin/sed -i &#x27;/^isgx$/d&#x27; /etc/modules 重装： 12345678cd /opt/intel/linux-sgx-driversudo make cleansudo makesudo mkdir -p &quot;/lib/modules/&quot;`uname -r`&quot;/kernel/drivers/intel/sgx&quot; sudo cp isgx.ko &quot;/lib/modules/&quot;`uname -r`&quot;/kernel/drivers/intel/sgx&quot; sudo sh -c &quot;cat /etc/modules | grep -Fxq isgx || echo isgx &gt;&gt; /etc/modules&quot; sudo /sbin/depmodsudo /sbin/modprobe isgx 解决：./app: error while loading shared libraries: libsgx_uae_service.so: cannot open shared object file: No such file or directory 错误方案：当使用find命令查询文件之后发现在 /opt/intel/sgxsdk/lib64 中包含 libsgx_uae_service.so ，从而添加该路径到LD_LIBRARY_PATH。这样会导致新的error “Please use the correct uRTS library from PSW package.”，因为sgxsdk下的lib是用作开发环境的，而在 /lib/x86_64-linux-gnu 下的lib是用于生产环境的，相互不兼容 **正确方案：**出现该问题的原因是psw安装不齐全，即libsgx-uae-service未安装，只要使用命令 sudo apt-get install libsgx-uae-service 就能成功将对应的库安装到 /lib/x86_64-linux-gnu 下 关于最新的Linux内核支持in-kernel driver 不需要再进行额外的driver安装，若有之前版本的driver，应当先卸载，然后将所有psw的组件卸载重装","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Ubuntu设置终端只显示当前所在目录","slug":"instruction/ubuntu-terminal-path","date":"2020-12-08T16:00:00.000Z","updated":"2022-04-28T07:22:30.000Z","comments":true,"path":"2020/12/09/instruction/ubuntu-terminal-path/","link":"","permalink":"http://example.com/2020/12/09/instruction/ubuntu-terminal-path/","excerpt":"Ubuntu终端显示路径设置为当前目录，而不是全路径","text":"修改~/.bashrc文件： 1234if [ &quot;$color_prompt&quot; = yes ]; then PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ &#x27;else PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ &#x27; 将上面语句中的 w 改为大写的 W 若要查看绝对路径，使用命令 pwd 即可","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"解决 Blocking waiting for file lock on package cache","slug":"instruction/rust-cargo-block","date":"2020-12-02T16:00:00.000Z","updated":"2022-04-28T07:16:42.000Z","comments":true,"path":"2020/12/03/instruction/rust-cargo-block/","link":"","permalink":"http://example.com/2020/12/03/instruction/rust-cargo-block/","excerpt":"解决rust程序在cargo run时由于Blocking waiting for file lock on package cache无法编译的问题","text":"删除 home/.cargo/.package-cache 文件再重新编译即可","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Vscode快捷键","slug":"lookup/Vscode快捷键","date":"2020-12-02T16:00:00.000Z","updated":"2022-06-25T05:09:16.383Z","comments":true,"path":"2020/12/03/lookup/Vscode快捷键/","link":"","permalink":"http://example.com/2020/12/03/lookup/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"记录一些好用的vscode快捷键","text":"Ctrl+J : 隐藏(显示)底下的控制台/终端面板 Ctrl+Shift+P : 调出搜索设置 Ctrl+Shift+C : 在当前目录调出外部终端 Home ：光标移动到行首 End ：光标移动到行尾 Ctrl+L ：选中一整行","categories":[{"name":"Lookup","slug":"Lookup","permalink":"http://example.com/categories/Lookup/"}],"tags":[]},{"title":"翻译-SGX Analysis","slug":"paper-reading/translation-sgx-analysis","date":"2020-11-28T16:00:00.000Z","updated":"2022-04-28T07:45:06.000Z","comments":true,"path":"2020/11/29/paper-reading/translation-sgx-analysis/","link":"","permalink":"http://example.com/2020/11/29/paper-reading/translation-sgx-analysis/","excerpt":"论文Intel SGX Explained中的SGX Analysis部分翻译","text":"放在博客上链接不能跳转指定标题，暂时没有办法解决 6.1 SGX实现概述 SGX设计实现的一个未被记录和忽视的成就是，在英特尔处理器上实现它对芯片的硬件设计有非常低的影响。SGX对处理器执行核心(§2.9.4)的修改要么非常小，要么根本不存在。CPU的非核心(§2.9.3，§2.11.3)接收一个新的模块，内存加密引擎，它看起来是相当独立的。 SGX的大部分实现都归属于处理器的微码(§2.14)，它支持比芯片电路高得多的开发速度。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"翻译-SGX Programming Model","slug":"paper-reading/translation-sgx-programming-model","date":"2020-11-27T16:00:00.000Z","updated":"2022-04-28T07:45:12.000Z","comments":true,"path":"2020/11/28/paper-reading/translation-sgx-programming-model/","link":"","permalink":"http://example.com/2020/11/28/paper-reading/translation-sgx-programming-model/","excerpt":"论文Intel SGX Explained中的SGX Programming Model部分翻译","text":"放在博客上链接不能跳转指定标题，暂时没有办法解决 SGX的核心概念是enclave，一个受保护的环境，其中包含与安全敏感计算相关的代码和数据。 启用sgx的处理器通过将每个enclave的环境与enclave外部的不受信任的软件隔离，并实现允许远程方对运行在enclave内部的软件进行身份验证的软件认证方案，从而提供可信的计算。SGX的隔离机制旨在保护在enclave内执行的计算的机密性和完整性，防止来自同一台计算机上的恶意软件的攻击，以及一小部分物理攻击。 5.1 SGX物理内存组织 Enclave的代码和数据存储在 Processor Reserved Memory (PRM)中，PRM是DRAM的一个子集，不能被其他软件(包括系统软件和SMM代码)直接访问。CPU的集成内存控制器也拒绝针对PRM的DMA传输，从而保护它不被其他外设访问。 PRM是一个连续的内存范围，其边界使用一个基地址和一个掩码寄存器来决定，与可变内存类型范围具有相同的语义。因此，PRM的大小必须是2的整数次幂，并且它的起始地址必须对齐到同样的2次幂。由于这些限制，检查一个地址是否属于PRM可以在硬件上很容易地完成。 5.1.1 Enclave页面缓存 (EPC) Enclave的内容和相关的数据结构存储在Enclave页面缓存(EPC)中，EPC是PRM的一个子集，PRM是DRAM的一个连续范围，不能被系统软件或外设访问。如图所示： SGX设计支持同时在一个系统上有多个enclaves，这在多进程环境中是必需的。这是通过将EPC拆分为4 KB的页面来实现的，这些页面可以分配给不同的enclaves。EPC使用与体系结构的地址转换特性相同的页面大小。 EPC由管理计算机其余物理内存的系统软件管理。系统软件(可以是管理程序或操作系统内核)使用SGX指令将未使用的页面分配给enclaves，并释放之前分配的EPC页面。系统软件将向应用程序软件公开enclave创建和管理服务。 非enclave软件不能直接访问EPC，因为它包含在PRM中。这一限制在SGX的enclave隔离保证中发挥了关键作用，但当系统软件需要将初始代码和数据加载到新创建的enclave中时，就会造成障碍。SGX通过将分配EPC页面的指令同时也用作初始化页面的指令来解决这个问题。大多数EPC页是通过从非PRM内存页复制数据来初始化的。 5.1.2 Enclave页面缓存映射表 (EPCM) SGX设计期望系统软件将EPC页面分配给enclave。然而，由于系统软件不受信任，SGX处理器会检查系统软件分配的正确性，并拒绝执行任何危及SGX安全保证的行为。例如，如果系统软件试图将相同的EPC页面分配给两个enclaves，则执行分配的SGX指令将失败。 为了执行安全检查，SGX在 Enclave Page Cache Map (EPCM)中记录一些关于系统软件对每个EPC页面的分配决策的信息。EPCM是一个数组，每个EPC页面对应一个条目，因此计算页面的EPCM入口地址只需要逐位移位操作和加操作。 EPCM的内容仅用于SGX的安全检查。在正常操作下，EPCM不会产生任何软件可见的行为，因而enclave作者和系统软件开发人员基本上可以忽略它。因此，SDM (Intel’s Software Developer Manual) 只在非常高的级别上描述EPCM，列出其中包含的信息，并指出EPCM是“受信任的内存”，而没有公开EPCM使用的存储介质或内存布局。 EPCM使用下表中的字段来跟踪每个EPC页面的所有权。我们将EPCM的完整讨论推迟到后面的部分，因为它的内容与SGX的所有特征紧密结合，这将在接下来的几节中进行描述。 分配EPC页的SGX指令将相应EPCM条目的VALID位设置为1，并拒绝对已经设置了VALID位的EPC页进行操作。 分配EPC页的指令还决定了该页的预期用途，该用途记录在相应EPCM条目的 page type (PT)字段中。存储enclave代码和数据的页面被认为具有常规类型 PT_REG 。专用于存储SGX支持数据结构的页面被标记为特殊类型。例如，PT_SECS 类型标识保存SGX Enclave控制结构的页面，这将在下一节中进行描述。其他EPC页面类型将在以后的章节中描述。 最后，页面的EPCM条目还标识拥有EPC页面的enclave，此字段防止一个enclave访问另一个enclave的私有信息。由于EPCM为每个EPC页面标识一个具有所有权的enclave，因此enclave不可能使用EPC页面通过共享内存进行通信。幸运的是，enclaves可以共享不可信的非EPC内存，这将在§5.2.3中讨论。 5.1.3 SGX Enclave控制结构 (SECS) SGX将每个Enclave元数据存储在与每个Enclave关联的 SGX Enclave Control Structure (SECS)中。每个SECS存储在专用的EPC页面中，页面类型为 PT_SECS。 Enclave的身份几乎等同于它的SECS。启用enclave的第一步是分配EPC页面作为enclave的SECS，销毁enclave的最后一步是释放保存其SECS的页面。标识拥有EPC页面的enclave的EPCM入口字段指向enclave的SECS。当调用SGX指令时，系统软件使用SECS的虚拟地址来识别enclave。 所有SGX指令都以虚拟地址作为输入。由于SGX指令使用SECS地址来标识enclave，系统软件必须在其页表中创建指向其管理的enclave的SECS的条目。但是，系统软件不能访问任何SECS页面，因为这些页面存储在PRM中。SECS页面不会映射到它们的enclave的虚拟地址空间中，并且启用SGX的处理器显式地阻止enclave代码访问SECS页面。 这个看似随意的限制是为了使SGX实现能够在SECS内存储敏感信息，并且能够假定没有潜在的恶意软件能够访问该信息。例如，SDM声明每个enclave的度量都存储在SECS中。如果软件能够修改enclave的测量，SGX的软件认证方案将不能提供安全保证。 5.2 SGX Enclave的内存布局 SGX的设计目的是尽量减少[转换应用程序代码以利用enclave的优势]所需要的工作。历史表明，这是一个明智的决定，因为在英特尔架构的持续主导地位中，一个很大的因素是它保持向后兼容性的能力。为此，SGX enclave在概念上与领先的软件模块化结构，动态加载库类似。动态加载库在Unix上打包为.so文件，在Windows上打包为.dll文件。 为简单起见，我们描述enclave和非enclave软件之间的交互时假设每个enclave都由一个应用程序进程使用，我们将其称为enclave的主进程。但是，我们注意到SGX的设计并没有明确地禁止多个应用程序进程共享一个enclave。 5.2.1 Enclave线性地址范围 (ELRANGE) 每个enclave在其虚拟地址空间中指定一个区域，称为 Enclave Linear Address Range (ELRANGE)，该区域用于映射存储在enclave的EPC页面中的代码和敏感数据。ELRANGE之外的虚拟地址空间用于访问主进程的其他内存，内存映射使用系统软件管理的页表建立。如下图所示: SGX的设计保证了enclave在ELRANGE内部的内存访问服从虚拟内存抽象，而在ELRANGE外部的内存访问没有得到保证。因此，enclave必须将其所有代码和私有数据存储在ELRANGE内，并且必须将ELRANGE外的内存视为对外部世界的不可信接口。 ELRANGE中的“线性”一词指的是64位Intel架构中残余分割特性产生的线性地址。在大多数情况下，“linear”可以看作是“virtual”的同义词。 ELRANGE在enclave的SECS(§5.1.3)中使用一个基地址(BASEADDR字段)和一个大小(SIZE)来指定。ELRANGE必须满足与可变内存类型范围和PRM范围(§5.1)相同的约束条件，即大小必须是2的幂，并且基地址必须与大小对齐。有了这些限制，SGX实现就可以容易地检查一个地址是否属于enclave的ELRANGE，无论是在硬件上还是在软件上。 非enclave软件不能访问PRM内存。在PRM内部的内存访问将导致一个中断，该中断在体系结构级别上未定义，在当前处理器上，中断的写将被忽略，中断的读将返回一个所有bit都设置为1的值。在上面描述的场景中，这就发挥了作用，在该场景中，enclave作为动态加载的库加载到主应用程序进程中。该系统软件将ELRANGE中的enclave代码和数据映射到EPC页面。如果应用程序软件试图访问ELRANGE内的内存，它将经历中断原语。当前原语不会导致应用程序崩溃(例如，由于页面错误)，但也保证了主应用程序不能篡改enclave或读取其私有信息。 5.2.2 SGX Enclave属性 Enclave的执行环境很大程度上受到enclave SECS(§5.1.3)中ATTRIBUTES字段的值的影响。此工作的其余部分会将ATTRIBUTES字段的子字段(如下表所示)称为enclave属性。 从安全性的角度来看，最重要的属性是 DEBUG 标志。设置此标志后，将启用SGX的调试特性用于此enclave。这些调试特性包括读取和修改大部分enclave内存的能力。因此，调试应该只在开发环境中设置，因为这会导致enclave失去SGX的所有安全性保证。 SGX保证enclave代码将始终在XCR0寄存器设置为 extended features request mask (XFRM) 所指示的值的情况下运行。Enclave作者希望使用XFRM指定用于生成Enclave代码的编译器所支持的一组架构扩展。显式地指定XFRM允许Intel设计新的架构扩展来改变现有指令的语义，比如内存保护扩展(MPX)，而不必担心在开发时没有注意到新特性的enclave代码的安全影响。 对于使用64位Intel架构的enclave, MODE64BIT标志设置为true。从安全的角度来看，这个标志甚至不应该存在，因为支持次要架构会给SGX实现增加不必要的复杂性，并增加安全漏洞潜入的可能性。32位架构支持很可能是由于英特尔提供广泛向后兼容性的策略，到目前为止，这一策略取得了相当好的效果。清除MODE64BIT标志位可能会造成SGX漏洞，有待研究人员研究。 最后，在创建enclave的SECS时，INIT标志总是为false。这个标志在enclave生命周期的某个时刻被设置为true，这将在§5.3中进行总结。 5.2.3 SGX Enclaves地址转换 在SGX下，操作系统和管理程序仍然完全控制页表和EPT，每个enclave的代码使用和其主应用程序相同的地址转换过程和页表。这将使向现有系统软件添加SGX支持所需的更改量最小化。同时，让不受信任的系统软件管理页表会使SGX遭受§3.7所述的地址转换攻击。正如未来章节将揭示的，SGX设计的复杂性很大程度上可以归因于防止这些攻击的需要。 SGX的主动内存映射攻击防御机制围绕着确保每个EPC页面只能映射到一个特定的虚拟地址。在分配EPC页面时，它的预期虚拟地址记录在该页面的EPCM条目的ADDRESS字段中。 当地址转换的结果是EPC页面的物理地址时，CPU保证提供给地址转换过程的虚拟地址与页面EPCM条目中记录的预期虚拟地址相匹配。 通过确保每个EPC页面的访问权限始终与enclave作者的意图相匹配，SGX还可以防止一些被动内存映射攻击和故障注入攻击。每个EPC页面的访问权限是在分配页面时指定的，并记录在页面EPCM条目中的可读®、可写(W)和可执行(X)字段中，如下表所示: 当一个地址转换解析为一个EPC页面时，相应的EPCM条目的字段将覆盖页表中指定的访问权限属性。例如，EPCM条目中的W字段覆盖可写(W)属性，而X字段覆盖禁用执行(XD)属性。 因此，enclave作者必须在包含enclave的同时包含内存布局信息，这样，加载enclave的系统软件将知道每个enclave页面的预期虚拟内存地址和访问权限。作为回报，SGX设计向enclave作者保证，管理页表和EPT的系统软件将不能以与作者预期不一致的方式设置enclave的虚拟地址空间。 .so和.dll文件格式是SGX打算使用的enclave运载工具，它们已经规定了指定软件模块要使用的虚拟地址，以及模块的每个内存区域所需的访问权限。 最后，启用SGX的CPU将确保ELRANGE内的虚拟内存(§5.2.1)映射到EPC页面。这可以防止系统软件执行地址转换攻击，即将enclave的整个虚拟地址空间映射到PRM之外的DRAM页面，而PRM不会触发上述任何检查，系统软件可以直接访问这些页面。 5.2.4 线程控制结构 (TCS) SGX设计完全采用多核处理器。多个逻辑处理器可以通过不同的线程同时并发地执行同一个enclave的代码。 SGX实现为执行enclave代码的每个逻辑处理器使用一个 Thread Control Structure (TCS)。因此，enclave的作者必须至少提供与enclave支持的最大并发线程数相同的TCS实例。 每个TCS存储在专用的EPC页面中，其EPCM条目类型为 PT_TCS。SDM描述了TCS中的前几个字段。这些字段被认为属于结构的体系结构部分，因此保证在所有支持SGX的处理器上具有相同的语义。 保存TCS的EPC页面的内容不能直接访问，甚至不能由拥有TCS的enclave的代码访问。此限制类似于对访问持有SECS实例的EPC页面的限制。但是，TCS中的体系结构字段可以通过enclave调试指令读取。TCS中的体系结构字段列出了逻辑处理器在执行非enclave代码和enclave代码之间转换时执行的上下文切换。例如，OENTRY字段指定当TCS用于开始执行enclave代码时加载在 指令指针(RIP) 中的值，因此enclave作者可以严格控制enclave的主程序可用的入口点。此外，OFSBASGX和OFSBASGX字段指定了加载在FS和GS段寄存器中的基地址，这通常指向 线程本地存储(TLS)。 5.2.5 状态保存区域 (SSA) 当处理器在enclave中执行代码时遇到硬件异常，比如中断时，它会执行特权级别切换并调用系统软件提供的硬件异常处理程序。然而，在执行异常处理程序之前，处理器需要一个安全的区域来存储enclave代码的执行上下文，这样执行上下文中的信息就不会泄露给不受信任的系统软件。 在SGX设计中，在处理硬件异常时用于存储enclave线程的执行上下文的区域称为 State Save Area (SSA)，如下图所示（enclave虚拟地址空间的一种可能的布局。每个enclave有一个SECS，每个支持的并发线程有一个TCS。每个TCS指向一个SSA序列，并为RIP以及FS和GS的基址指定初始值）。每个TCS引用一个连续的SSA序列。SSA数组偏移量(OSSA)字段指定了第一个SSA在enclave的虚拟地址空间中的位置。SSA数量(NSSA)字段表示可用的SSAs的数量。 每个SSA从EPC页面的开头开始，并使用在enclave的SECS的SSAFRAMESIZE字段中指定的EPC页面数量。通过减少需要处理的特殊情况的数量，这些对齐和大小限制很可能简化了SGX的实现。 Enclave线程的执行上下文由通用寄存器(GPRs)和XSAVE指令的结果组成。因此，执行上下文的大小取决于XSAVE使用的 请求特性位图(RFBM)。enclave中的所有代码都使用相同的RFBM，它是在XFRM enclave属性(§5.2.2)中声明的。为每个SSA保留的EPC页面数量(在SSAFRAMESIZE中指定)必须足够大，以适合XSAVE输出的XFRM指定的特性位图。 SSA存储在常规EPC页面中，其EPCM页面类型为 PT_REG。因此，enclave软件可以访问SSA内容。SSA布局是体系结构的，并且完全记录在SDM中。这为主机应用程序在发生硬件异常后调用enclave异常处理程序并对SSA中的信息进行操作提供了可能性。 5.3 SGX Enclave的生命周期 Enclave的生命周期与资源管理密切相关，特别是EPC页面的分配。因此，在不同生命周期状态之间转换的指令只能由系统软件执行。系统软件将公开以下描述的SGX指令，作为enclave加载和销毁的服务。 下面的小节描述了enclave生命周期中的主要步骤，如下图所示: 5.3.1 创建 当系统软件发出 ECREATE 指令时，一个enclave就诞生了，该指令将一个空闲的EPC页面转换为用于新enclave的SECS(§5.1.3)。 ECREATE 使用系统软件拥有的非EPC页面中的信息初始化新创建的SECS。这个页面指定SDM中定义的所有SECS字段的值，比如BASEADDR和SIZE，使用的是一种体系结构布局，未来的实现保证会保留这种布局。 虽然最初的SGX实现使用的实际SECS布局很可能与架构布局非常接近，但是未来的实现可以自由地改变这个布局，只要它们保持使用架构布局初始化SECS的能力。软件不能访问包含SECS的EPC页面，因此它不能依赖于SECS的内部布局。这是在虚拟机控制结构(VMCS，§2.8.3)中使用的更强的封装版本。 ECREATE 验证用于初始化SECS的信息，如果信息无效，则会导致页面错误(#PF，§2.8.2)或一般保护错误(#GP，§2.8.2)。例如，如果SIZE字段不是2的幂，ECREATE结果是#GP。这种验证，加上软件无法访问SECS这一事实，简化了其他SGX指令的实现，这可以假设SECS内部的信息是有效的。 最后，ECREATE将enclave的INIT属性(§5.2.2)初始化为false值。在INIT属性被设置为true之前，enclave的代码不能执行，在初始化阶段会将INIT设置为true，这将在§5.3.3中描述。 5.3.2 加载 ECREATE 将新创建的SECS标记为未初始化。当enclave的SECS处于这种状态时，系统软件可以使用EADD指令将初始代码和数据加载到enclave中。EADD用于创建TCS页面(§5.2.4)和常规页面。 EADD 从页面信息(PAGEINFO)结构中读取其输入数据，如下图所示。该结构的内容仅用于与SGX实现通信，因此它完全是体系结构的，并在SDM中记录。 目前，PAGEINFO结构包含的将要分配的EPC页面的虚拟地址(LINADDR)、非EPC页面的虚拟地址（其内容将被复制到新分配的EPC页面(SRCPGE)）、一个虚拟地址，解析为SECS的enclave的页面(SECS)以及与新分配的EPC页面相关联的EPCM条目的某些字段的值(SECINFO)。 PAGEINFO结构中的SECINFO字段实际上是一个虚拟内存地址，并指向一个安全信息(SECINFO)结构，其中一些结构如上图所示。SECINFO结构包含新分配的EPC页面的访问权限(R、W、X)及其EPCM页面类型(PT_REG或PT_TCS)。与PAGEINFO一样，SECINFO结构仅用于与SGX实现通信数据，因此它的内容也完全是体系结构的。但是，该结构的大部分64字节内容被保留以备将来使用。 PAGEINFO和SECINFO结构都是由调用EADD指令的系统软件准备的，因此必须包含在非EPC页面中。两个结构必须按照其大小对齐——PAGEINFO是32字节长，因此每个PAGEINFO实例必须是32字节对齐的，而SECINFO是64字节对齐的，因此每个SECINFO实例必须是64字节对齐的。对齐要求可能通过减少必须处理的特殊情况的数量来简化SGX实现。 EADD在修改新分配的EPC页面或其EPCM条目之前验证其输入。最重要的是，尝试将一个页面EADD到SECS处于初始化状态（INIT属性为true）的enclave将导致一个#GP。此外，尝试EADD已经分配的EPC页面(其EPCM条目中的VALID字段为1)将导致一个#PF。EADD还确保页面的虚拟地址位于enclave的ELRANGE内，并且SECINFO中的所有保留字段都被设置为零。 EADD 指令将EPCM条目中的VALID字段置为1？ 在加载enclave时，系统软件还将使用EEXTEND指令，该指令将更新在软件认证过程中使用的enclave度量值。软件认证在§5.8中进行了讨论。 5.3.3 初始化 在将初始代码和数据页面加载到enclave后，系统软件必须使用Launch enclave(LE)来获取EINIT令牌结构，这是通过一个未文档化的过程实现的，将在§5.9.1中详细描述。然后将令牌提供给EINIT指令，该指令将enclave的SECS标记为initialized。 LE是由Intel提供的特权enclave，是使用由Intel以外的第三方编写的enclave的先决条件。LE是SGX的Enclave，因此必须使用本节中描述的进程来创建、加载和初始化它。然而，LE是用一个特殊的Intel密钥加密签名的(§3.1.3)，这个密钥被硬编码到SGX的实现中，这导致**EINIT在初始化LE时没有检查有效的EINIT令牌结构**。 当EINIT成功完成时，它将enclave的INIT属性设置为true。这就为ring 3(§2.3)应用软件使用§5.4中描述的SGX指令执行enclave的代码开辟了道路。另一方面，一旦INIT设置为true，就不能再在该enclave上调用EADD，因此在执行EINIT指令之前，系统软件必须加载构成enclave初始状态的所有页面。 5.3.4 销毁 Enclave完成了它要执行的计算之后，系统软件执行EREMOVE指令来释放enclave使用的EPC页面。 EREMOVE将EPC页面的EPCM条目的VALID字段设置为0，从而将该页面标记为可用。在释放页面之前，EREMOVE确保在拥有要删除的页面的enclave内部没有执行代码的逻辑处理器。 当保存SECS的EPC页面被释放时，enclave将被完全销毁。如果SECS页面被任何其他EPCM条目的ENCLAVESECS字段引用，EREMOVE将拒绝释放该页面，因此，只有在所有enclave页面都被释放之后，才能释放enclave的SECS页面。 5.4 SGX线程的生命周期 在enclave被初始化(§5.3.3)和被销毁(§5.3.4)这段时间内，任何将enclave的EPC页面映射到其虚拟地址空间的应用程序进程都可以执行enclave的代码。 当在enclave中执行代码时，逻辑处理器被称为处于enclave模式，它执行的代码可以访问属于当前执行的enclave的常规(PT_REG，§5.1.2)EPC页面。当逻辑进程处于enclave模式之外时，它会退回处理器保留内存范围(PRM, §5.1)内的任何内存访问，包括EPC。 每个执行enclave代码的逻辑处理器都使用一个线程控制结构(TCS，§5.2.4)。当一个TCS被一个逻辑处理器使用时，它被认为是忙碌的，并且它不能被任何其他逻辑处理器使用。下图演示了主进程用于执行enclave代码的指令，以及它们与目标TCS的交互，这是具有两个状态保存区(SSAs)的SGX线程控制结构(TCS)的生命周期的各个阶段。 假设没有发生硬件异常，enclave的主进程使用§5.4.1中描述的EENTER指令来执行enclave代码。当enclave代码完成它的任务时，它使用EEXIT指令(参见§5.4.2)将执行控制权返回给调用enclave的主进程。 如果在逻辑处理器处于enclave模式时发生硬件异常，则在调用系统软件的异常处理程序之前，使用异步enclave退出(AEX)将处理器从enclave模式中取出(§5.4.3)。在系统软件的处理程序被调用后，enclave的主进程可以使用§5.4.4中描述的ERESUME指令重新输入enclave并恢复它退出之前正在执行的计算。 5.4.1 同步Enclave进入 在较高的级别上，EENTER执行受控跳转到enclave代码，同时执行SGX的安全保证所需要的处理器配置。遍历所有配置步骤是一项冗长乏味的工作，但这是理解SGX使用的所有数据结构如何协同工作的必要先决条件。由于这个原因，EENTER和它的兄弟指令描述的比其他的SGX指令更详细。 下图所示的EENTER只能由运行在Ring 3(§2.3)的非特权应用程序软件执行，如果由系统软件执行，则会导致未定义指令(#UD)故障。 EENTER将逻辑处理器切换到enclave模式，但不执行特权级别切换。因此，enclave代码总是在Ring3执行，具有与调用它的应用程序代码相同的特权。这使得基础设施所有者可以允许用户提供的软件创建和使用enclave，同时保证OS内核和管理员仍然可以保护基础设施免受bug或恶意软件的攻击。 EENTER将TCS的虚拟地址作为它的输入，并要求TCS可用，并且TCS中至少有一个状态保存区域(SSA，§5.2.5)可用。后者是通过确保TCS中的当前SSA索引(CSSA)字段小于SSAs (NSSA)的数量来实现的。在执行enclave代码时发生硬件异常时，将使用CSSA所指示的SSA(应该称为当前SSA)。 EENTER将逻辑处理器转换为enclave模式，并将指令指针(RIP)设置为它接收到的TCS中的入口点偏移(OENTRY)字段所指示的值。EENTER被不受信任的调用者用来在一个受保护的环境中执行代码，因此它与用于调用系统软件的SYSCALL(§2.8)具有相同的安全考虑。将RIP设置为OENTRY所指示的值，可以向enclave作者保证enclave代码只会在定义良好的节点上调用，并防止恶意主机应用程序绕过enclave作者可能执行的任何安全检查。 EENTER还将XCR0(§2.6)设置为enclave属性的值XFRM(§5.2.2)，XCR0是一个寄存器，用于控制正在使用的扩展架构特性。确保XCR0是根据enclave作者的意图设置的，从而防止恶意操作系统通过启用enclave尚未准备处理的体系结构特性来绕过enclave的安全性。 此外，EENTER使用TCS中指定的值加载段寄存器(§2.7)FS和GS的基底。段的选择器和类型是硬编码为安全值的Ring3数据段。SGX设计的这个方面使得实现每个线程的线程本地存储(TLS)变得很容易。对于64位的enclave，这是一种方便的特性，而不是一种安全措施，因为enclave代码可以使用WRFSBASE和WRGSBASE指令安全地将新的基底加载到FS和GS中。 EENTER将备份它修改的寄存器的旧值，以便在enclave完成其计算时恢复这些值。就像SYSCALL一样，EENTER将以下指令的地址保存在RCX寄存器中。 有趣的是，SDM声明XCR0、FS和GS寄存器的旧值保存在专用于SGX实现的新寄存器中。但是，鉴于它们只用于enclave退出，我们希望寄存器保存在DRAM中，在TCS的保留区域中。 与SYSCALL一样，EENTER不修改堆栈指针寄存器(RSP)。为了避免任何安全漏洞，enclave代码应该将RSP设置为指向完全包含在EPC页面中的堆栈区域。通过设置每个线程的TLS区域以包含指向线程堆栈的指针，并将RSP设置为通过读取FS或GS段所指向的TLS区域获得的值，多线程enclave可以很容易地实现每个线程的堆栈区域。 最后，当EENTER进入enclave模式时，它会暂停一些处理器的调试特性，比如硬件断点和精确的基于事件的采样(PEBS)。从概念上讲，附加到主进程的调试器将enclave的执行看作一条单处理器指令。 5.4.2 同步Enclave退出 EEXIT只能在逻辑处理器处于enclave模式时执行，如果在任何其他情况下执行，则会导致一个(#UD)。简而言之，该指令将处理器返回到Ring3外部enclave模式，并恢复由EENTER保存的寄存器。 与SYSRET不同，EEXIT在退出enclave模式后将RIP设置为从RBX读取的值。这与EENTER不一致，EENTER将RIP值保存到RCX。除非这种不一致性源于SDM中的错误，否则enclave代码必须确保注意到这种差异。 SDM明确声明**EEXIT不会修改大多数寄存器**，因此enclave作者必须确保在将控制权返回给主进程之前清除存储在处理器寄存器中的任何秘密。此外，如果enclave软件没有将堆栈指针RSP和堆栈帧基指针RBP恢复到它们在EENTER被调用时拥有的值，那么它很可能会在调用者中造成错误。 Enclave代码可能会在其调用者中引发错误，这似乎很不幸。无论好坏，这完全符合应用程序调用动态加载模块的情况。更具体地说，模块的代码还负责保存与堆栈相关的寄存器，有bug的模块可能会跳转到主进程的应用程序代码中的任何位置。 本节描述64位enclave的EENTER行为。32位enclave的EENTER实现要复杂得多，因为在32位Intel架构中仍然存在成熟的分段模型引入了额外的特殊情况。 5.4.3 异步Enclave退出 如果在逻辑处理器执行enclave代码时发生了硬件异常，比如错误(§2.8.2)或中断(§2.12)，处理器在调用系统软件的异常处理程序之前执行异步enclave退出(AEX)，如下图所示： AEX保存enclave代码的执行上下文(§2.6)，恢复EENTER保存的状态，并设置处理器寄存器，以便系统软件的硬件异常处理程序返回到enclave的主进程中的异步退出处理程序。退出处理程序将使用ERESUME指令恢复被硬件异常中断的enclave计算。 除了§5.4.1中描述的行为外，EENTER还向当前SSA写入一些信息，这只在AEX发生时使用。EENTER将堆栈指针寄存器RSP和堆栈帧基指针寄存器RBP存储到当前SSA中的U_RSP和U_RBP字段中。最后，EENTER将值存储在当前SSA的异步退出处理程序指针(AEP)字段中的RCX中。 当在enclave模式下发生硬件异常时，SGX实现执行一系列步骤，将逻辑处理器从enclave模式中取出，并在系统软件中调用硬件异常处理程序。从概念上讲，SGX首先执行AEX以使逻辑处理器脱离enclave模式，然后使用§2.8.2中描述的标准英特尔架构的行为来处理硬件异常。实际的Intel处理器可能会将AEX实现与异常处理实现交错使用。然而，为了简单起见，该工作将AEX描述为一个单独的过程，在采取任何异常处理步骤之前执行。 在英特尔架构中，如果发生硬件异常，应用程序代码的执行上下文可以被系统软件的异常处理程序读取和修改(§2.8.2)。当应用程序软件信任系统软件时，这是可以接受的。然而，在SGX的威胁模式下，系统软件不被Enclave信任。因此，AEX步骤通过将其所有寄存器重置为预定义值来清除执行状态中可能存在的任何秘密。 在重置enclave的执行状态之前，将它备份到当前SSA中。具体来说，AEX备份SSA中的GPRSGX区域中的通用寄存器(GPRs，§2.6)，然后使用enclave SECS中的XFRM字段中指定的请求特性位图(RFBM)执行XSAVE(§2.6)。由于每个SSA都完全存储在分配给enclave的EPC页面中，因此系统软件不能读取或篡改备份的执行状态。当SSA接收到enclave的执行状态时，通过递增当前TCS中的CSSA字段，将其标记为used。 在清除执行上下文后，AEX进程将RSP和RBP设置为EENTER在当前SSA中保存的值，将RIP设置为当前SSA的AEP字段中的值。这样，当系统软件的硬件异常处理程序完成时，处理器将在enclave的主进程中执行异步退出处理程序代码。SGX的设计使得在包含EENTER指令的例程中将异步处理程序代码设置为异常处理程序变得很容易，因为RSP和RBP寄存器拥有的值与执行EENTER时相同。 AEX在enclave模式之外获取逻辑处理器所采取的许多操作都与EEXIT匹配。段寄存器FS和GS恢复到EENTER保存的值，所有被EENTER抑制的调试工具恢复到它们以前的状态。 5.4.4 从异步退出恢复 当在enclave模式下发生硬件异常时，处理器在调用系统软件设置的异常处理程序之前执行AEX。AEX设置执行上下文的方式是，当系统软件完成异常处理时，它返回到enclave的主进程中的异步退出处理程序。异步异常处理程序通常执行ERESUME指令，这将导致逻辑处理器返回到enclave模式并继续被硬件异常中断的计算。 ERESUME与EENTER共享其大部分功能。如下图所示： EENTER和ERESUME接收相同的输入，即§5.4.1中描述的TCS指针和§5.4.3中描述的AEP指针。最常见的应用程序设计将每个EENTER实例与使用完全相同的参数调用ERESUME的异步退出处理程序配对。 ERESUME和EENTER之间的主要区别在于前者使用一个由AEX“填写”的SSA(§5.4.3)，而后者使用一个空的SSA。因此，如果提供的TCS中的CSSA字段为0，则ERESUME会导致#GP故障，而如果CSSA大于或等于NSSA，则EENTER会失败。 当成功时，ERESUME递减TCS的CSSA字段，并恢复TCS中CSSA字段所指向的SSA备份的执行上下文。具体来说，ERESUME实现从SSA中的GPRSGX字段中恢复GPRs(§2.6)，并执行XRSTOR(§2.6)来加载与enclave所使用的扩展体系结构特性相关联的执行状态。 ERESUME与EENTER共享以下行为。这两个指令都写入当前SSA中的U_RSP、U_RBP和AEP字段。这两个指令遵循相同的过程来备份XCR0、FS和GS段寄存器，并基于当前TCS及其enclave的SECS将它们设置为相同的值。最后，这两个指令都禁用了逻辑处理器的调试特性的同一子集。 ERESUME正确处理的一个有趣的情况是，它在执行XRSTOR之前将XCR0设置为enclave属性XFRM 。如果SSA中的请求特性位图(RFBM)不是XFRM的子集，那么ERESUME就会失败。这很重要，因为尽管AEX总是使用XFRM值作为RFBM，但在另一个线程上执行的enclave代码可以在调用ERESUME之前自由地修改SSA内容。 ERESUME实现中正确的操作顺序可以防止恶意应用程序使用enclave修改与未在XFRM中声明的扩展体系结构特性相关联的寄存器。这将破坏系统软件提供线程级执行上下文隔离的能力。 5.5 EPC页面交换 现代操作系统内核利用地址转换(§2.5)来实现页面交换，也称为分页(§2.5)。简而言之，通过将很少使用的内存页交换到称为磁盘等较慢的存储介质，分页允许OS内核过量提交计算机的DRAM。 分页是有效利用计算机资源的关键因素。例如，用户并发运行多个程序的桌面系统可以退出分配给不活动应用程序的内存页，而不会显著降低用户体验。 不幸的是，不能允许OS通过像在PRM范围之外的DRAM内存页面交换一样来交换enclave的EPC页面。在SGX的威胁模型中，enclave不相信系统软件，因此SGX的设计提供了一种EPC页面交换方法，可以防御试图进行§3.7中所述的任何主动地址转换攻击的恶意操作系统。 SGX所提供的安全性的代价是，支持交换EPC页面的操作系统内核必须使用经过修改的页面交换实现，该实现与SGX机制交互。Enclave作者基本上可以忽略EPC交换，类似于今天的应用程序开发人员可以忽略OS内核的分页实现。 如下图所示，SGX支持将EPC页面交换到PRM范围之外的DRAM页面。系统软件使用现有的页交换技术实现将这些页的内容从DRAM中交换到磁盘上。 SGX的交换特性围绕着EWB指令，在§5.5.4中有详细描述。实际上，EWB将EPC页交换到EPC之外的DRAM页，并通过将该页EPCM条目中的VALID字段置零将EPC页标记为可用。 SGX设计依赖于对称密钥加密来保证被交换的EPC页面的机密性和完整性，并依赖于nonces(§3.1.4)来保证带回EPC的页面的新鲜度。这些nonces存储在§5.5.2中介绍的版本数组(VA)中，它们是专门用于nonce存储的EPC页面。 在EPC页面被交换并释放给其他enclaves使用之前，SGX实现必须确保没有TLB拥有与被交换的页面相关联的地址转换，以避免§3.7.4中描述的基于TLB的地址转换攻击。 正如§5.1.1中所解释的，SGX让系统软件负责管理EPC。自然地，本节中描述的用于实现EPC分页的SGX指令只对运行在Ring 0(§2.3)上的系统软件可用。 在今天的软件栈(§2.3)中，只有操作系统内核实现了页面交换，以支持DRAM的过度使用。管理程序仅用于在操作系统之间划分计算机的物理资源。因此，在编写本节时，我们期望OS内核也将承担EPC页面交换的责任。为了简单起见，我们经常使用术语“操作系统内核”而不是“系统软件”。读者应该知道，SGX设计并不排除系统管理程序实现自己的EPC页面交换的系统。因此，“OS内核”实际上应该理解为“执行EPC分页的系统软件”。 5.5.1 页面交换和TLB SGX没有向内存执行单元添加任何安全检查(§2.9.4，§2.10)。相反，SGX的访问控制检查是在地址转换(§2.5)完成之后进行的，就在转换结果写入TLBs之前(§2.11.5)。在整个SDM中，这个方面通常被忽略，但是在解释SGX的EPC页面清除机制时，它就变得显而易见了。 关于SGX的内存访问保护检查的完整讨论值得单独一节来讨论，请参见§6.2。只需使用SGX的安全模型中的两个需求就可以解释EPC页面清除机制。首先，当一个逻辑处理器通过EEXIT(§5.4.2)或AEX(§5.4.3)退出一个enclave时，它的TLB被刷新。其次，当从enclave释放EPC页面时，必须使得执行该enclave代码的所有逻辑处理器退出enclave。这足以保证删除任何针对已释放的EPC的TLB条目。 系统软件可以通过发送处理器间中断(IPI，§2.12)，使逻辑处理器退出enclave，这将在接收时触发AEX。 SGX不相信系统软件。因此，在将EPC页面的EPCM条目标记为free之前，SGX必须确保OS内核已经清除了所有可能包含该页面转换的TLB。此外，为每个页面清除执行IPIs和TLB刷新会给分页实现增加很大的开销，因此SGX设计允许使用一个IPI/TLB刷新序列来清除一批页面。 TLB刷新验证逻辑依赖于一个名为BLOCKED的1位EPCM条目字段。如下图所示，VALID和BLOCKED字段产生三种可能的EPC页面状态。当两个位都为零时，页面是空闲的；当VALID为1，BLOCKED为0时使用；当两个位都为1时，页面被阻塞。 被阻塞的页面被认为不能被enclave访问。如果一个地址转换导致一个被阻塞的EPC页面，SGX实现会导致一个页面错误(#PF，§2.8.2)。这保证了一旦一个页面被阻塞，CPU将不会创建任何新的指向它的TLB条目。 此外，每条SGX指令都确保它所操作的EPC页面不会被阻塞。例如，EENTER确保它提供的TCS没有被阻塞，它的enclave的SECS没有被阻塞，以及当前SSA中的每个页面没有被阻塞。 为了交换一批EPC页面，OS内核必须首先针对这些页面发出EBLOCK指令。SGX还希望OS从页表中删除EPC页的映射，但并不信任OS。 在所有所需的页面都被阻塞之后，操作系统内核必须执行一条ETRACK指令，这条指令指示SGX实现跟踪哪些逻辑处理器的TLBs已被刷新。ETRACK要求enclave的SECS(§5.1.3)的虚拟地址。如果OS希望交换属于多个enclave的一批EPC页面，它必须为每个enclave发出一个ETRACK。 按照ETRACK指令，操作系统内核必须在所有执行enclave代码的逻辑处理器上的enclave退出。SGX设计期望操作系统将使用IPIs在逻辑处理器中导致AEXs，而逻辑处理器的TLBs必须被刷新。 当OS对每个要交换的EPC页面执行EWB指令时，EPC页面交换过程就完成了。这条指令将在§5.5.4中详细描述，它将写入EPC页面的加密版本并将其交换到DRAM中，然后通过清除其EPCM条目中的VALID和BLOCKED位来释放该页面。在执行其任务之前，EWB确保它所目标的EPC页面已经被阻塞，并检查ETRACK设置的状态，以确保所有相关的TLB都已被刷新。 可以通过ELDU和ELDB指令将被交换的页面加载回EPC。这两个指令启动时都有一个空闲的EPC页面和一个DRAM页面(其中包含EPC页面的已交换内容)，然后将DRAM页面的内容解密到EPC页面，并恢复相应的EPCM条目。ELDU和ELDB之间的唯一区别是后者在页面的EPCM条目中设置阻塞位，而前者将其清除。 ELDU和ELDB类似于ECREATE和EADD，因为它们填充了一个空闲的EPC页面。由于他们操作的页面是空闲的，因此SGX安全模型断言没有TLB条目可能针对它。因此，这些指令不需要类似于EBLOCK或ETRACK的机制。 5.5.2 版本数组 (VA) 当EWB交换EPC的内容时，它会创建一个8字节的nonce(§3.1.4)，英特尔的文档将其称为页面版本。SGX的新鲜度保证是建立在安全存储nonces的假设之上的，所以EWB将它创建的nonce存储在一个版本数组(VA)中。 版本数组是EPC页面，专门用于存储由EWB生成的nonces。每个VA被划分成槽，每个槽都足够存储一个nonce。假设EPC页面的大小是4KB，每个nonce占用8字节，那么每个VA就有512个槽。 页是使用EPA指令分配的，该指令接受空闲EPC页的虚拟地址，并将其转换为具有空槽的版本数组。每一页在其EPCM条目中以PT_VA类型标识。与SECS页面一样，VA页面的EPCM条目中的ENCLAVEADDRESS字段设置为零，任何软件(包括enclave)都不能直接访问它们。 与到目前为止讨论的其他页面类型不同，VA页面不与任何enclave关联。这意味着可以通过EREMOVE释放它们，而不受任何限制。但是，将一个槽正在使用的VA页面释放时会丢弃这些槽中的nonces，这将导致丢失将相应的被交换的页面加载回EPC的能力。因此，一个正确的操作系统实现不太可能在一个非空闲槽的VA调用EREMOVE。 根据SDM中EPA和EWB的伪代码，SGX使用零值来表示VA中的空槽，这意味着所有生成的nonces必须是非零的。这还意味着EPA通过将底层EPC页面归零来初始化VA。然而，由于软件不能访问VA的内容，无论是使用一个特殊值，或值本身都不是体系结构的。 5.5.3 Enclave IDs EWB和ELDU / ELDB指令使用一个enclave ID (EID)来标识拥有被交换页面的enclave。EID与EPCM条目中的ENCLAVESECS(§5.1.2)字段具有相同的用途，后者也用于标识拥有EPC页面的enclave。本节通过比较两个值及其用法，说明使用两个值表示相同概念的必要性。 SDM声明EPCM条目中的ENCLAVESECS字段用于标识拥有相关EPC页面的enclave的SECS，但没有描述其格式。理论上，ENCLAVESECS字段可以在SGX实现之间更改，因为SGX指令从不向软件暴露其值。 然而，我们稍后将讨论，ENCLAVESECS最可信的表示是其字段中的enclave物理地址。因此，如果从EPC中交换出enclave的SECS并在另一个位置加载回该enclave，则与给定enclave关联的ENCLAVESECS值将发生更改。由此可见，ENCLAVESECS值仅适用于标识某个enclave，而其SECS仍在EPC中。 根据SDM, EID字段是存储在enclave的SECS中的64位字段。SDM中的ECREATE伪代码显示，在分配SECS时，通过原子递增全局计数器生成enclave的ID。假设计数器不会发生滚动，此过程将确保在电源循环期间创建的每个enclave都具有唯一的EID。 尽管SDM没有明确保证这一点，但enclave SECS中的EID字段似乎不会被任何指令修改。这使得EID的值适合在整个enclave的生命周期内标识它，甚至在从EPC中将其SECS页面驱逐出去时也是如此。 5.5.4 EPC页面交换 系统软件使用EWB指令交换EPC页面，EWB指令在稍后通过ELDU指令生成恢复交换页面所需的所有数据，如下图所示。 EWB的输出包括被交换的EPC页面内容的加密版本、与该页面对应的EPCM条目中的字段子集、§5.5.2中讨论的nonce和消息身份验证代码(MAC，§3.1.3)标记。除了nonce之外，EWB将其输出写入PRM区域之外的DRAM中，因此系统软件可以选择进一步将其交换出磁盘。 EPC页面内容被加密，以保护enclave数据的机密性，同时页面存储在PRM范围之外的不受信任的DRAM中。在不使用加密的情况下，系统软件可以通过将EPC页面从EPC中交换出来从而了解该页面的内容。 页面元数据存储在页面信息(PAGEINFO)结构中，如下图所示。这个结构类似于§5.3.2中描述的PAGEINFO结构，除了SECINFO字段被一个PCMD字段所取代，它包含一个页面加密元数据(PCMD)结构的虚拟地址。 PAGEINFO结构中的LINADDR字段用于存储EPCM条目中的地址字段，该字段指示用于访问页面的虚拟地址。PCMD结构嵌入了§5.3.2中描述的安全信息(SECINFO)，用于在EPCM条目中存储页面类型(PT)和访问权限标志(R, W, X)。PCMD结构还存储了enclave的ID (EID，§5.5.3)。这些字段稍后由ELDU或ELDB用于填充重新加载的EPC页面的EPCM条目。 上面描述的元数据是未加密存储的，因此操作系统可以选择按原样使用内部信息进行自己的记帐。这对安全性没有负面影响，因为元数据不是机密的。实际上，除了enclave ID之外，所有元数据字段都是在调用ECREATE时由系统软件指定的。enclave ID仅用于标识EPC页面所属的enclave，而且系统软件也已经拥有该信息。 除了上面描述的元数据之外，PCMD结构还存储由EWB生成的MAC标签。MAC标记涵盖EPC页面内容的真实性、元数据和nonce。MAC标记由ELDU和ELDB检查，只有在MAC验证确认了页面数据、元数据和nonce的真实性时，它们才会将一个被交换的页面加载回EPC。这个安全检查可以防止在§3.7.3中描述的页面交换攻击。 与EREMOVE类似，如果没有其他EPCM条目的ENCLAVESECS字段引用该SECS，则EWB只会交换包含enclave SECS的EPC页面。同时，作为一种优化，SGX实现在交换SECS时不执行与ETRACK相关的检查。这是安全的，因为只有在EPC没有属于SECS的页面时，才会交换SECS，这意味着EPC中没有属于enclave的任何TCS，因此没有处理器可以执行enclave代码。 与任何其他EPC页面一样，可以清除持有版本数组的页面。VA页面永远不能被软件访问，所以他们不能有任何TLB条目指向他们。因此，EWB在不执行任何ETRACK相关检查的情况下交换VA页面。 EWB的数据流(如下图所示)有一个方面可能会让操作系统开发人员感到困惑。该指令从寄存器(RBX)中读取将要被交换出的EPC页面的虚拟地址，并将其写入提供给它的PAGEINFO结构的LINADDR字段。可以通过在LINADDR字段中提供EPC页面的地址来删除单独的输入(RBX)。 5.5.5 将交换的页面加载回EPC 在交换出属于enclave的EPC页面之后，任何从enclave代码访问该页面的尝试都将导致页面错误(#PF，§2.8.2)。#PF将导致逻辑处理器通过AEX退出enclave模式(§5.4.3)，然后调用OS内核的页面错误处理程序。 页面错误从AEX流程接受特殊处理。当离开enclave时，AEX逻辑专门检查触发AEX的硬件异常是否为#PF。如果是这样，AEX实现将清除CR2寄存器中最不重要的12位，该寄存器存储虚拟地址，其转换导致了页面错误。 通常，操作系统内核的页面处理程序需要能够从CR2中提取虚拟页码(VPN，§2.5.1)，这样它就知道需要将哪些内存页加载回DRAM。操作系统内核还可以使用12个最不重要的地址位，这不是VPN的一部分，从而更好地预测应用程序软件的内存访问模式。然而，与组成VPN的位不同，最下面的12位对于故障处理程序执行其工作不是绝对必要的。因此，SGX的AEX实现清除这12位，以限制页面错误处理程序得到的信息量。 当OS页面错误处理程序检查CR2寄存器中的地址并确定错误地址在EPC中时，通常希望使用ELDU或ELDB指令将被交换的页面加载回EPC中。如果EWB的输出已经从DRAM中被交换到较慢的存储介质中，操作系统内核将不得不在调用ELDU / ELDB之前将输出读回DRAM中。 ELDU和ELDB验证由EWB产生的MAC标签，如§5.5.4所述。这可以防止操作系统内核执行§3.7.3中描述的基于页面交换的主动地址转换攻击。 5.5.6 交换树 SGX允许从EPC中交换VA页面，就像enclave页面一样。当从EPC中交换一个VA页面时，处理器将无法访问由VA槽存储的所有nonces。因此，在操作系统将VA页面加载回EPC之前，ELDB无法恢复与这些nonces关联的被交换的页面。 换句话说，一个被交换的页面依赖于存储其nonce的VA页面，并且在VA页面也被重新加载之前不能被加载回EPC。由此关系创建的依赖图是一个交换树的森林。如下图所示，一个交换树将EPC页面作为叶子，将VA页面作为内部节点。页面的父页面是保存其nonce的VA页面。由于EWB总是在一个页面中输出一个nonce，所以每个交换树的根节点在EPC中总是一个页面。 一个简单的归纳表明，当OS希望将一个交换的enclave页面加载回EPC时，它需要在从交换树的根到与该enclave页面对应的叶的路径上加载所有VA页面。因此，在EPC中满足页面错误所需的页面加载数量取决于包含该页面的交换树的形状。 SGX让OS完全掌控交换树的形状。这对安全性没有负面影响，因为树的形状只影响交换方案的性能，而不影响其正确性。 5.6 SGX Enclave度量 SGX实现了一个软件认证方案，该方案遵循了§3.3中概述的一般原则。对于本节而言，最相关的原则是远程方根据其度量对enclave进行身份验证，该度量用于识别正在enclave内部执行的软件。远程方将可信硬件报告的enclave度量与预期的度量进行比较，只有在两个值匹配时才进行。 §5.3解释了SGX enclave是使用ECREATE(§5.3.1)、EADD(§5.3.2)和EEXTEND指令构建的。在通过EINIT(§5.3.3)初始化enclave之后，上面提到的指令就不能再使用了。SGX度量的方案遵循§3.3.2中概述的原则，SGX enclave的度量是通过计算安全散列(§3.1.3)输入ECREATE, EADD和EEXTEND。EINIT结束了表示enclave度量值的散列。 除了enclave的内容之外，enclave作者还需要指定应该使用的指令序列，以便创建一个enclave，该enclave的度量将与软件认证过程中远程方使用的期望值相匹配。.so和.dll动态加载库文件格式是SGX打算使用的enclave传递方法，它们已经包含了加载算法的非正式规范。我们期望非正式的加载规范作为规范的起点，这些规范规定了应该用于从.so和.dll文件创建enclave的SGX指令的确切序列。 如§3.3.2所述，enclave的度量是使用安全的哈希算法计算的，因此系统软件只能按照enclave作者指定的指令顺序构建与预期度量匹配的enclave。 SGX设计使用256位SHA-2安全哈希函数来计算其度量值。SHA-2是一个块哈希函数(§3.1.3)，它对64字节的块进行操作，使用32字节的内部状态，并产生32字节的输出。每个enclave的度量都存储在enclave SECS的MRENCLAVE字段中。32字节字段存储256位SHA-2安全哈希函数的内部状态和最终输出。 5.6.1 ECREATE度量 在§5.3.1中概述的ECREATE指令，首先使用256位SHA-2初始化算法在新创建的SECS中初始化MRENCLAVE字段，然后使用下表中描述的64字节块扩展哈希。 enclave的度量不包括BASEADDR字段。此处省略是有意的，因为它允许系统软件在满足ELRANGE限制的主进程内的任何虚拟地址加载enclave，而不会改变enclave度量值。此特性可以与生成位置无关的enclave代码的编译器结合使用，以获得可重定位的enclave。 enclave的度量包括SSAFRAMESIZE字段，它保证AEX创建、EENTER(§5.4.1)和ERESUME(§5.4.4)使用的SSAs(§5.2.5)具有enclave作者所期望的大小。如果将此字段排除在enclave的度量之外，会允许恶意的enclave加载程序通过指定比enclave作者预期的更大的SSAFRAMESIZE来试图攻击enclave的安全检查，这可能导致AEX编写的SSA内容覆盖enclave的代码或数据。 5.6.2 度量Enclave属性 enclave的度量不包括在SECS中的ATTRIBUTES字段中指定的enclave属性(§5.2.2)。相反，它直接包含在认证签名所涵盖的信息中，这将在§5.8.1中讨论。 SGX软件认证需要涵盖enclave属性。例如，如果XFRM(§5.2.2 §5.2.5)不被覆盖，一个恶意的enclave装载机可以通过设置XFRM值试图颠覆一个enclave的安全检查，让体系结构扩展指令使用的enclave的语义变化，但仍然是产生符合SSAFRAMESIZE的XSAVE输出。 应用到ATTRIBUTES SECS字段的特殊处理从安全角度来看似乎是有问题的，因为它给软件认证验证器增加了额外的复杂性，从而转化为可利用的漏洞的更多机会。这个决定也增加了SGX软件认证设计的复杂性，在§5.8中有描述。 尽管存在上述问题，SGX设计决定走这条路的最可能的原因是希望能够使用单一度量来表示一个能够利用一些架构扩展的enclave，但也可以在没有它们的情况下执行其任务。 例如，考虑使用OpenCV这样的库执行图像处理的enclave，它具有针对SSE和VX优化的例程，但还包括针对不具备这些特性的处理器的通用回退。enclave的作者可能希望允许enclave加载器将位1(SSE)和位2(VX)设置为真或假。如果ATTRIBUTES(以及XFRM)是enclave度量的一部分，则enclave作者必须指定enclave有4个有效度量。通常，允许n个架构扩展独立使用将导致2n个无效度量。 5.6.3 度量EADD §5.3.2中描述的EADD指令用下表中所示的64字节块扩展了MRENCLAVE中的SHA-2哈希。 度量中包含的地址是EADD页面预期映射到enclave的虚拟地址空间中的地址。这可以确保系统软件根据enclave作者的规范设置enclave的虚拟内存布局。如果恶意的enclave加载程序试图错误地设置enclave的布局，可能是为了挂载一个活动的地址转换攻击(§3.7.2)，所加载的enclave的度量结果将与enclave作者期望的度量结果不同。 新创建的页面的虚拟地址相对于enclave的ELRANGE的起点进行度量。换句话说，度量中包含的值是LINADDR - BASEADDR。这使得enclave的度量对BASEADDR的变化保持不变，这对于可重定位的enclave是理想的。度量相对地址仍然保留了关于ELRANGE内内存布局的所有信息，因此没有负面的安全影响。 EADD同时也度量提供给EADD的SECINFO(§5.3.2)结构的前48字节，其中包含用于初始化页面的EPCM条目的页面类型(PT)和访问权限(R, W, X)字段值。同样，在度量中包含这些值可以保证加载enclave的系统软件构建的内存布局与enclave作者的规范相匹配。 上面提到的EPCM字段值在SECINFO结构中只占不到一个字节，其余的字节被保留，并被初始化为零。这为SGX未来的功能留下了大量的扩展空间。 上表中最值得注意的省路是用于初始化新创建的EPC页面的数据。因此，EADD提供的度量数据保证了enclave的内存布局将具有在所需虚拟地址上分配的有指定访问权限的页面。但是，度量不包括在这些页面中加载的代码或数据。 例如，EADD的度量数据保证enclave的内存布局由三个可执行页面和五个可写数据页面组成，但它不能保证任何代码页面包含enclave作者提供的代码。 5.6.4 度量EEXTEND EEXTEND指令的存在仅仅是为了度量加载在enclave的EPC页面中的数据。该指令读入一个虚拟地址，并使用下表中的5个64字节块扩展enclave的度量散列，这有效地保证了enclave内存中256字节数据块的内容。 在检查EEXTEND的细节之前，我们注意到，SGX的安全保证只有在对enclave的关键页面的内容进行测量时才有效。例如，EENTER(§5.4.1)只有在测量了所有线程控制结构(TCS，§5.2.4)页面的内容后，才保证在enclave的代码中执行受控跳转。否则，恶意的enclave加载程序可以在构建enclave时更改TCS中的OENTRY字段(§5.2.4，§5.4.1)，然后恶意的操作系统可以使用TCS在enclave代码中执行任意跳转。同样的道理，所有enclave的代码都应该用EEXTEND来度量。任何无法测量的代码片段都可以被恶意的enclave加载程序替换。 考虑到这些缺陷，令人惊讶的是SGX设计选择将由EADD完成的虚拟地址空间布局度量与由EEXTEND完成的内存内容度量分离。 乍一看，这种解耦似乎只有一个好处，即能够在构建enclave时将未测量的用户输入加载到该enclave中。但是，这种好处只会转化为很小的性能改进，因为可以将enclave设计为在初始化后从不受信任的DRAM复制用户输入。与此同时，由于没有通过EEXTEND调用度量所有重要数据，这种分离打开了依赖于一个没有提供有意义的安全保证的enclave的可能性。 然而，EADD / EEXTEND分离背后的真正原因是由SDM中的EINIT伪代码所暗示的，它表明该指令在执行计算密集型RSA签名检查时打开了一个中断窗口(§2.12)。如果在检查期间发生中断，EINIT会失败并出现错误代码，然后中断。对于处理器指令来说，这种非常不寻常的方法表明，SGX实现受到了其指令被允许添加到中断处理进程中的延迟时间的限制。 考虑到上面的问题，可以合理地推断引入了EEXTEND，因为使用256位SHA-2度量整个页面非常耗时，而且在EADD中这样做会导致指令超出SGX的延迟预算。需要达到某个延迟目标，这是对似乎任意的256字节块大小的合理解释。 如果使用构建当前动态加载模块(似乎是SGX设计的目标工作流)的相同工具编写enclave，那么EADD / EEXTEND分离将不会导致安全问题。在此工作流中，构建enclave的工具可以轻松识别需要度量的enclave数据。 从安全性的角度来看，让EEXTEND提供给散列函数的消息块除了包含数据内容外，还包含256字节块的地址是正确的，也是有意义的。如果地址不包括在内，恶意的enclave加载器就会装载§3.7.2中描述的内存映射攻击。 更具体地说，恶意加载程序将在用于泄漏的虚拟地址处EADD errorOut页面内容，在用于泄漏的虚拟地址处EADD disclose页面内容，然后以错误的顺序EEXTEND页面。如果EEXTEND不包含被测量的数据块的地址，那么上面的步骤将产生与正确构造的enclave相同的测量结果。 EEXTEND值得分析的最后一个方面是它对enclave迁移的支持。与EADD类似，EEXTEND测量的虚拟地址是相对于enclave的BASEADDR的。此外，唯一的SGX结构的内容将被EEXTEND测量是TCS。SGX的设计已经仔细地为所有代表enclave地址的TCS字段使用了相对地址，这是OENTRY, OFSBASGX和OGSBASGX。 5.6.5 度量EINIT EINIT指令(§5.3.3)结束了enclave的构建过程。在enclave上成功调用EINIT之后，enclave的内容是“密封的”，这意味着系统软件不能使用EADD指令将代码和数据加载到enclave中，也不能使用EEXTEND指令更新enclave的度量。 EINIT在enclave的SECS的MRENCLAVE字段上使用SHA-2算法(§3.1.3)。在EINIT之后，字段不再存储SHA-2算法的中间状态，而是存储安全哈希函数的最终输出。该值在EINIT完成后保持不变，并包含在SGX软件认证过程生成的认证签名中。 5.7 SGX Enclave版本支持 由可信平台模块(§4.4)引入的软件认证模型(§3.3)依赖于度量，它本质上是一个内容散列，用于识别容器内的软件。使用内容哈希进行标识的缺点是，存放同一软件的不同版本的容器的标识之间没有关系。 在实践中，基于安全容器的系统在初始软件认证过程中不访问远程方来处理软件更新是非常理想的。这需要有能力在拥有旧版本软件的容器和拥有更新版本的容器之间迁移秘密。这一需求转化为对能够识别同一软件的两个版本之间关系的独立身份系统的需求。 SGX支持在表示同一软件的不同版本的enclave之间迁移秘密，如下图所示。 秘密迁移特性依赖于一个一级证书层次结构(§3.2.1)，其中每个enclave作者都是一个证书颁发机构，每个enclave从作者那里收到一个证书。这些证书必须格式化为签名结构(SIGSTRUCT)，这在§5.7.1中有描述。这些证书中的信息是§5.7.2中介绍的enclave身份方案的基础，它可以识别同一软件的不同版本之间的关系。 EINIT指令(§5.3.3)检查目标enclave的证书，并使用其中的信息填充SECS(§5.1.3)字段，这些字段描述了enclave基于证书的标识。这个过程在§5.7.4中进行了总结。 最后，实际的秘密迁移过程是基于EGETKEY指令实现的密钥派生服务，在§5.7.5中进行了描述。发送enclave使用EGETKEY指令根据其身份获得一个对称密钥(§3.1.1)，用该密钥加密其秘密，并将加密的秘密交给不受信任的系统软件。接收enclave将发送enclave的身份传递给EGETKEY，获得与上面相同的对称密钥，并使用该密钥解密从系统软件接收到的秘密。 从EGETKEY获得的对称密钥可以与加密原语一起使用，这些原语可以在不受信任的系统软件迁移到另一个enclave时保护enclave秘密的机密性(§3.1.2)和完整性(§3.1.3)。但是，仅凭对称密钥无法提供新鲜度保证(§3.1)，因此秘密迁移容易受到重放攻击。当被迁移的秘密是不可变的，例如当秘密是通过软件认证获得的加密密钥时，这是可以接受的。 5.7.1 Enclave证书 SGX的设计要求每个enclave都有其作者颁发的证书。这一要求是由EINIT强制执行的(§5.3.3)，它拒绝在没有有效证书的enclave上操作。 SGX实现使用格式化为签名结构(SIGSTRUCT)的证书，这些证书将由enclave构建工具链生成，如下图所示。 SIGSTRUCT证书由元数据字段和保证元数据真实性的（其中最有趣的字段在下表中显示）。字段的语义将在下面的部分中揭示。 RSA签名组成格式如下表所示： enclave证书必须由RSA签名(§3.1.3)签名，该签名遵循RFC 3447中描述的方法，使用256位SHA-2]作为哈希函数来减少输入大小，以及PKCS #1 v1.5中描述的填充方法。 5.7.2 基于证书的Enclave身份 enclave的身份由其证书中的三个字段决定(§5.7.1)：用于签署证书的RSA密钥的模数(模数)、enclave的产品ID(ISVPRODID)和安全版本号(ISVSVN)。 用于颁发证书的公共RSA密钥标识enclave的作者。用于颁发enclave证书的所有RSA密钥必须将公开指数设置为3，因此它们仅通过模量进行区分。SGX不使用密钥的整个模量，而是模量的256位SHA-2哈希。这称为签名者度量(MRSIGNER)，与标识enclave内容的SHA-2散列的enclave度量(MRENCLAVE)名称量级相同。 SGX实现依赖于一个硬编码的MRSIGNER值来识别由Intel颁发的证书。拥有英特尔颁发的证书的enclave可以获得额外的特权，这在§5.8中有讨论。 enclave作者可以使用相同的RSA密钥为表示不同软件模块的enclave颁发证书。每个模块由一个唯一的产品ID(ISVPRODID)值标识。相反，假定证书具有相同ISVPRODID并由相同RSA密钥(因此具有相同的MRENCLAVE)颁发的所有enclave代表同一软件模块的不同版本。通常假定证书由不同密钥签名的enclave包含不同的软件模块。 表示模块的不同版本的enclave可以具有不同的安全版本号(SVN)。SGX的设计不允许秘密从具有较高SVN的enclave迁移到具有较低SVN的enclave。此限制旨在帮助分发安全补丁，如下所示。 如果在enclave中发现安全漏洞，作者可以发布具有更高SVN的固定版本。随着用户升级，SGX将帮助机密从enclave的脆弱版本转移到固定版本。一旦用户的秘密迁移完成，SGX中的SVN限制将基于构建易受攻击的enclave版本并使用它读取迁移后的秘密来转移任何攻击。 增加功能的软件升级不应该伴随着SVN的增加，因为SGX允许秘密在具有匹配SVN值的enclave之间自由迁移。如上所述，只有在发现安全漏洞时，软件模块的SVN才应该增加。SIGSTRUCT只给ISVSVN字段分配2个字节，转换成65,536个可能的SVN值。如果一个大型团队(错误地)设置了一个连续构建系统，为它生成的每个软件构建分配一个新的SVN，并且每个代码更改触发一个构建，那么这个空间就会耗尽。 5.7.3 CPU安全版本号 SGX实现本身有一个安全版本号(CPUSVN)，除了enclave的身份信息之外，它还用于EGETKEY实现的密钥派生过程中。CPUSVN是一个128位的值，根据SDM，它反映了处理器的微码更新版本。 SDM没有描述CPUSVN的结构，但是它指出使用整型比较来比较CPUSVN的值是没有意义的，并且只有一些CPUSVN值是有效的。此外，CPUSVNs承认的排序关系与enclave SVNs之间的排序关系具有相同的语义。特别地，一个SGX实现将考虑所有具有较低SVN的SGX实现由于安全漏洞而受到损害，并且不会信任它们。 SGX的一项专利披露，CPUSVN是小整数的串联，这些小整数表示构成SGX实现的各种组件的svn。这种结构与SDM中所做的所有声明一致。 5.7.4 建立Enclave身份 当EINIT(§5.3.3)指令准备执行代码的enclave时，它还会设置SECS(§5.1.3)字段，这些字段组成enclave的基于证书的标识，如下图所示。 EINIT需要颁发给enclave的SIGSTRUCT证书的虚拟地址，并使用证书中的信息初始化enclave的SECS中的基于证书的标识信息。在使用证书中的信息之前，EINIT首先验证其RSA签名。SIGSTRUCT字段Q1和Q2，以及RSA指数3，简化了验证算法，这在§6.5中讨论。 如果发现SIGSTRUCT证书被正确签名，EINIT将按照下面几段中讨论的步骤确保将证书颁发给正在初始化的enclave。检查完成后，EINIT计算MRSIGNER, SIGSTRUCT中模数字段的256位SHA-2哈希，并将其写入enclave的SECS中。EINIT还将ISVPRODID和ISVSVN字段从SIGSTRUCT复制到enclave的SECS中。正如在§5.7.2中所解释的，这些字段构成了enclave的基于证书的标识。 在验证了SIGSTRUCT中的RSA签名之后，EINIT将签名的填充复制到enclave的SECS中的填充字段中。PKCS #1 v1.5填充方案不包含随机性，因此填充对于所有enclave应该具有相同的值。 EINIT执行一些检查，以确保正在进行初始化的enclave确实是由提供的SIGSTRUCT证书授权的。最明显的检查包括确保SIGSTRUCT中的MRENCLAVE值等于enclave的度量，后者存储在enclave的SECS中的MRENCLAVE字段中。 但是，MRENCLAVE没有涵盖enclave的属性，这些属性存储在SECS的ATTRIBUTES字段中。正如在§5.6.2中所讨论的，从MRENCLAVE中省略一个ATTRIBUTES有助于编写具有优化实现的enclave，这些实现可以在存在时使用架构扩展，也可以在没有扩展的情况下在CPU上工作的回退实现。当使用XFRM(§5.2.2 §5.2.5)属性中的各种值构建时，这样的enclave可以正确执行。与此同时，允许系统软件在ATTRIBUTES字段中使用任意值，将危及SGX的安全保证。 当enclave使用软件认证(§3.3)访问机密时，用于构建该机密的附加值包含在SGX认证签名(§5.8)中。这使认证过程中的远程方有机会拒绝使用不需要的ATTRIBUTES值构建的enclave。但是，当使用基于证书的身份验证的迁移过程获得机密时，没有远程方可以检查enclave的属性。 SGX设计通过让enclave作者在为enclave颁发的SIGSTRUCT证书的ATTRIBUTES和ATTRIBUTEMASK字段中为enclave传递一组可接受的属性值来解决这个问题。如果在SECS中的ATTRIBUTES字段和SIGSTRUCT中的ATTRIBUTESMASK字段之间的位不等于SIGSTRUCT中的ATTRIBUTES字段，EINIT将拒绝使用SIGSTRUCT初始化enclave。此检查可防止具有不需要的属性的enclave在迁移过程中获取或泄漏机密。 任何enclave作者都可以使用SIGSTRUCT来请求enclave的ATTRIBUTES字段中的任何位为零。但是，对于由Intel签署的enclave，某些位只能设置为1。EINIT有一个限制ATTRIBUTES比特的掩码，在§5.8中讨论过。EINIT实现包含一个硬编码的MRSIGNER值，该值用于标识英特尔的特权enclave，并且只允许使用与受限制掩码中的任何位匹配的ATTRIBUTES值构建特权enclave。这个检查对于SGX软件认证过程的安全性是至关重要的，这在§5.8中描述。 最后，EINIT还检查SIGSTRUCT中的VENDOR字段。专用于SIGSTRUCT的一节中对VENDOR字段的SDM描述表明，该字段本质上用于区分由Intel签名的特殊enclave(使用VENDOR值0x8086)和其他所有人的enclave(使用VENDOR值0)。然而，EINIT伪代码似乎暗示了SGX实现只检查VENDOR是否为0或0x8086。 5.7.5 Enclave密钥分发 SGX的秘密迁移机制基于EGETKEY指令提供给enclave的对称密钥分发服务，如下图所示。 EGETKEY生成的密钥是基于当前enclave的SECS中的身份信息和存储在支持SGX的处理器内的安全硬件中的两个秘密分发的。其中一个秘密是对基本没有文档记录的一系列转换的输入，这些转换为密钥分发过程背后的加密原语生成对称密钥。另一个秘密，在SDM中称为CR_SEAL_FUSES，是在关键推导材料中使用的信息片段之一。 SDM没有指定密钥分发算法，但SGX专利披露密钥是使用FIPS SP 800-108中描述的方法，使用AES-CMAC]作为伪随机函数(PRF)。同样的专利声明，用于密钥分发的秘密存储在CPU的e-fuse中，这一点在ISCA 2015 SGX教程中得到证实。 这一附加信息意味着，使用相同密钥分发材料的所有EGETKEY调用将产生相同的密钥，即使是跨CPU能量周期。此外，如果不访问存储在CPU e-fuse中的密钥，对手是不可能从特定密钥派生材料中获得密钥的。SGX的关键层次结构在§5.8.2中有进一步的描述。 下面的段落讨论密钥分发材料中使用的数据片段，这些数据片段由下表中所示的密钥请求(KEYREQUEST)结构选择： KEYREQUEST中的KEYNAME字段总是参与密钥生成，它指示要生成的键的类型。虽然SGX设计定义了一些密钥类型，但秘密迁移特性总是使用密封密钥。其他关键类型由SGX软件认证过程使用，将在§5.8中概述。 KEYREQUEST中的KEYPOLICY字段有两个标志，用于指示是否将使用enclave的SECS中的MRENCLAVE和MRSIGNER字段进行密钥分发。虽然字段允许4个值，但只有两个值是有意义的，如下所述。 在KEYPOLICY中设置MRENCLAVE标志将分发的密钥与反映其内容的当前enclave度量绑定。其他enclave将无法获得相同的密钥。当分发的密钥用于加密enclave秘密时，这是非常有用的，因此它们可以由系统软件存储在非易失性内存中，从而在电源周期中存活。 如果设置了KEYPOLICY中的MRSIGNER标志，则分发的密钥将绑定到发布enclave证书的公共RSA密钥。因此，由同一作者发布的其他enclave可能能够获得相同的密钥，但要遵守下面的限制。这是唯一允许秘密迁移的KEYPOLICY值。 在KEYPOLICY中不设置标志没有什么意义。在这种情况下，分发的密钥没有有用的安全属性，因为它可以由与调用EGETKEY的enclave完全无关的其他enclave获得。相反，设置两个标志是多余的，因为仅设置MRENCLAVE就会导致分发的密钥绑定到当前enclave，这是最严格的策略。 KEYREQUEST结构指定了密钥分发过程中使用的enclave SVN (ISVSVN，§5.7.2)和SGX实现SVN (CPUSVN，§5.7.3)。但是，如果期望的enclave SVN大于当前enclave的SVN，或者期望的SGX实现的SVN大于当前实现的SVN, EGETKEY将拒绝派生请求并生成一个错误代码。 SVN限制可以防止秘密从具有较高SVN的集合转移到具有较低SVN的集合，或者从具有较高SVN的SGX实现转移到具有较低SVN的实现。§5.7.2认为SVN限制可以减少enclave和SGX实施中安全漏洞的影响。 EGETKEY总是使用来自当前enclave的SECS的ISVPRODID值进行密钥分发。因此，秘密永远不能在其SIGSTRUCT证书为其分配不同产品ID的enclaves之间流动。 类似地，密钥分发材料总是包含128位所有者轮数(OWNEREPOCH)SGX配置寄存器的值。这个寄存器是由计算机的固件设置为一个秘密生成一次，并存储在非易失性内存。在计算机更改所有权之前，旧的所有者可以从非易失性内存中清除OWNEREPOCH，从而使新所有者无法解密任何可能留在计算机上的enclave机密。 由于密钥分发过程的加密特性，外部观察者无法关联使用不同的OWNEREPOCH值分发的密钥。这使得软件开发人员不可能使用本节中描述的EGETKEY分发的密钥来跟踪处理器更改所有者。 EGETKEY分发材料还在KEYID字段中包含由enclave提供的256bit值。这使得enclave可以从EGETKEY生成密钥集合，而不是单个密钥。SDM规定KEYID应该用随机数填充，目的是帮助防止密钥损耗。 最后，密钥分发材料包括enclave的SECS中的ATTRIBUTES(§5.2.2)字段的位和和KEYREQUEST结构中的ATTRIBUTESMASK字段。该掩码的作用是从密钥分发材料中删除一些ATTRIBUTES比特，从而使在具有不同属性的enclave之间迁移秘密成为可能。§5.6.2和§5.7.4解释此功能的需要及其安全含义。 在将掩码属性值添加到密钥生成材料之前，EGETKEY强制掩码位对应INIT和调试属性(§5.2.2)。从实用的角度来看，这意味着秘密永远不会支持调试和生产的enclave之间迁移。 如果没有此限制，enclave作者使用相同的RSA密钥向调试和生产enclave颁发证书将是不安全的。调试enclave没有从SGX获得完整性保证，因此攻击者有可能修改调试enclave内的代码，使其泄漏它所能访问的任何秘密。 5.8 SGX软件认证 SGX实施的软件认证方案遵循了§3.3中概述的原则。启用SGX的处理器计算加载在每个enclave中的代码和数据的度量，这类似于TPM计算的度量(§4.4)。enclave内部的软件可以启动一个进程，从而产生SGX认证签名，其中包括enclave的度量和enclave消息。 SGX认证签名中使用的密码原语过于复杂，无法在硬件上实现，因此签名过程是由英特尔发行的一个有特权的引用Enclave来执行的，它可以访问SGX认证密钥。这个enclave在§5.8.2中进行了讨论。 图79: 建立一个SGX enclave并进行软件认证过程涉及到SGX指令EINIT和EREPORT，以及两个由英特尔编写的特殊enclave，SGX启动enclave和SGX引用enclave。 将签名功能推入引用Enclave，就需要在正在进行软件认证的Enclave和引用Enclave之间建立安全通信路径。SGX设计通过本地认证机制解决了这个问题，enclave可以使用该机制向同一启用SGX的CPU托管的任何其他enclave证明其身份。§5.8.1中描述的这个方案是通过EREPORT指令实现的。 引用enclave使用的SGX认证密钥在启用SGX的处理器离开工厂时不存在。认证密钥是稍后提供的，使用的过程包括一个由Intel发布的配置Enclave和两种特殊的EGETKEY(§5.7.5)密钥类型。这一过程的公开细节概述在§5.8.2中。 SGX启动enclave和EINITTOKEN结构将在§5.9中讨论。 5.8.1 本地认证 enclave通过如图80所示的EREPORT指令向另一个目标enclave证明其身份。SGX指令生成一个认证报告(报告)，该报告以加密方式将enclave提供的消息与enclave的基于度量(§5.6)和基于证书(§5.7.2)的身份绑定。加密绑定由MAC标签(§3.1.3)完成，MAC标签使用对称密钥计算，该密钥仅在目标enclave和SGX实现之间共享。 ​ 图80：EREPORT数据流 EREPORT指令从enclave的SECS(§5.1.3)中读取当前enclave的标识信息，并使用它填充报告结构。具体来说，EREPORT会复制SECS字段，这些字段表示enclave的度量(MRENCLAVE)、基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)和属性(ATTRIBUTES)。认证报告还包括SGX实现的SVN(CPUSVN)和enclave提供的64字节(512位)消息。 接收认证报告的目标enclave可以确信报告的真实性，如图81所示。这份报告的真实性证明是它的MAC标签。验证MAC所需的密钥只能由目标enclave获得，通过要求EGETKEY(§5.7.5)分发一个报告密钥。SDM声明MAC标记是使用基于块加密的MAC (CMAC)计算的，但是没有指定底层密码。SGX文件之一声明CMAC是基于128位AES。 EGETKEY返回的报告密钥来自于嵌入在处理器中的一个秘密(§5.7.5)，密钥材料包括目标enclave的度量。可以确保目标enclave报告中的MAC标签是由SGX产生的，原因如下。底层密钥分发的加密特性推导和MAC算法确保只有SGX所实现可以产生MAC标签，因为它是唯一的实体，可以访问处理器的秘密，这是不可能对攻击者获得报告密钥不知道处理器的秘密。SGX的设计保证了EGETKEY生成的密钥依赖于调用enclave的度量，因此只有目标enclave才能获得报告中用于生成MAC标签的密钥。 当KEYNAME设置为与报告密钥相关联的值时，EREPORT使用与EGETKEY相同的密钥分发过程。因此，EREPORT需要报告目标信息(TARGETINFO)结构的虚拟地址，该结构包含基于度量的标识和目标enclave的属性。 在分发一个报告密钥时，EGETKEY的行为与它在密封密钥情况下的行为略有不同，如图81所示。密钥生成材料从不包括与enclave的基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)对应的字段，并且KEYREQUEST结构中的KEYPOLICY字段将被忽略。因此，该报告只能由目标enclave加以核实。 图81: 由EREPORT创建的报告结构的真实性可以而且应该由报告的目标enclave验证。目标代码使用EGETKEY获取嵌入在报告结构中的MAC标记使用的密钥，然后验证标记。 此外，SGX实现用于密钥生成的SVN (CPUSVN)值是由当前的CPUSVN决定的，而不是从密钥请求结构中读取。因此，SGX实现升级，增加CPUSVN使所有未完成的报告无效。鉴于CPUSVN的增加与安全修复有关，§5.7.2中的论证表明，这一限制可能会减少SGX实现中漏洞的影响。 最后，EREPORT将密钥生成材料中的KEYID字段设置为SGX配置寄存器(CR_REPORT_KEYID)的内容，该寄存器在初始化SGX时以随机值初始化。KEYID值也保存在认证报告中，但是它不包含在MAC标签中。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"CSDN博客保存为PDF","slug":"useful-skills/csdn-pdf","date":"2020-11-26T14:30:42.000Z","updated":"2022-04-28T07:46:34.000Z","comments":true,"path":"2020/11/26/useful-skills/csdn-pdf/","link":"","permalink":"http://example.com/2020/11/26/useful-skills/csdn-pdf/","excerpt":"将CSDN博客去除无用信息并保存为PDF","text":"F12打开开发者工具，在Console输入以下js代码： 123456789101112131415161718(function()&#123; &#x27;use strict&#x27;; var articleBox = $(&quot;div.article_content&quot;); articleBox.removeAttr(&quot;style&quot;); $(&quot;#btn-readmore&quot;).parent().remove(); $(&quot;#side&quot;).remove(); $(&quot;#comment_title, #comment_list, #comment_bar, #comment_form, .announce, #ad_cen, #ad_bot&quot;).remove(); $(&quot;.nav_top_2011, #header, #navigator&quot;).remove(); $(&quot;.csdn-side-toolbar,.template-box,.reward-user-box,.blog-footer-bottom&quot;).remove(); $(&quot;.p4course_target, .comment-box, .recommend-box, #csdn-toolbar, #tool-box,#dmp_ad_58, .more-toolbox, .article-info-box, .btn-readmore, .pub-footer-new&quot;).remove(); $(&quot;aside&quot;).remove(); $(&quot;.tool-box&quot;).remove(); $(&quot;main&quot;).css(&#x27;display&#x27;,&#x27;content&#x27;); $(&quot;main&quot;).css(&#x27;float&#x27;,&#x27;left&#x27;); $(&quot;#mainBox&quot;).width(&quot;100%&quot;); document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8; window.print();&#125;)(); 或者： 12345678910111213141516(function doPrint()&#123; &#x27;use strict&#x27;; var articleBox = $(&quot;div.article_content&quot;); articleBox.removeAttr(&quot;style&quot;); var head_str = &quot;&quot;; var foot_str = &quot;&quot;; var older = document.body.innerHTML; var title= document.getElementsByClassName(&#x27;article-title-box&#x27;)[0].innerHTML; var main_body = document.getElementsByClassName(&#x27;article_content&#x27;)[0].innerHTML; document.body.innerHTML = head_str + title + main_body + foot_str; $(&quot;#mainBox&quot;).width(&quot;100%&quot;); document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8; window.print(); document.body.innerHTML = older; return false;&#125;)();","categories":[{"name":"Useful","slug":"Useful","permalink":"http://example.com/categories/Useful/"}],"tags":[{"name":"reproduction","slug":"reproduction","permalink":"http://example.com/tags/reproduction/"}]},{"title":"现代密码学 Notes","slug":"learning-notes/现代密码学-notes","date":"2020-11-25T11:09:27.000Z","updated":"2022-04-28T07:23:10.000Z","comments":true,"path":"2020/11/25/learning-notes/现代密码学-notes/","link":"","permalink":"http://example.com/2020/11/25/learning-notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/","excerpt":"现代密码学课程笔记","text":"古典替换密码 恺撒密码 每个字母用其后的第三个字母替换，即 Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC 恺撒密码的一般形式，可以将字母移动的位数由3变为1-25中的任何一个 混合单表替换密码 每个字母可以用其它任何一个字母替换（不能重复） 密钥长度为26个字母，因为每个字母需要一个映射 简单的单表替换密码 设置一个没有重复字母的“密钥字”，其它字母按顺序写在密钥字最后字母后面 给定密钥字 JULISCAER Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: JULISCAERTVWXYZBDFGHKMNOPQ 多字母替换密码 使用多个单字母替换表，因此一个字母可以被多个字母替换：用一个密钥选择每个字母使用哪个字母表，密钥的第i个字母表示使用第i个字母表，依次使用每个字母表，当密钥的字母使用完后，再从头开始 古典置换密码 方法：通过重新编排消息字母隐藏信息 特点：没有改变原来消息的字母集 关键思想：按一定规则写出明文，按另一规则读出密文 密钥：用于读密文的方法和写明文的方法 分组密码 在分组密码中，消息被分成许多块，每块都要被加密 替换运算 S-boxes 一个二进制字用其它二进制字替换，这种替换函数就构成密钥，可以看作是一个大的查表运算 混淆：使作用于明文的密钥和密文之间的关系复杂化 置换运算 P-boxes 二进制字次序被打乱，重新排序的方法构成密钥 扩散：将明文及密钥的影响尽可能迅速地散布到较多个输出的密文中 雪崩效应 输入改变1bit, 导致近一半的比特发生变化 保证小的输入变化导致大的输出变化 完备性效应 每个输出比特是所有输入比特的复杂函数的输出 保证每个输出比特依赖于所有的输入比特 Feistel密码 把输入块分成左右两部分 轮函数g是一个S-P网络 由第i个密钥控制（子密钥） L(i) = R(i-1) R(i) = L(i-1) xor g(K(i), R(i-1)) 求逆很容易 实际中，一些这样的连续变换形成完整密码变换 Feistel密码设计 分组大小：增加分组长度会提高安全性, 但降低了密码运算速度 密钥大小：增加密钥长度可以提高安全性(使得穷搜索困难)，但降低了密码速度 轮数：增加轮数可以提高安全性，但降低速度 子密钥生成：子密钥生成越复杂就越安全，但降低速度 Lucifer 分组长度是128-bit，密钥长度是128-bit 每轮使用的子密钥是密钥的左半部分 密钥每次要向左旋转56-bits，所以密钥的每部分都参加运算 轮函数的具体结构： 现代分组加密算法 简化的DES (S-DES) 加密算法涉及五个函数： 初始置换 IP 复合函数 fk1 ，由密钥K确定，具有转换和替换的运算 转换函数 SW 复合函数 fk2 初始置换IP的逆置换 IP-1 加解密流程 密文 = IP-1(fk2(SW(fk1(IP(明文))))) 明文 = IP-1(fk1(SW(fk2(IP(密文))))) 密钥生成： P10(k1, k2, k3, k4, k5, k6, k7, k8, k9, k10) = (k3, k5, k2, k7, k4, k10, k1, k9, k8, k6) P8(k1, k2, k3, k4, k5, k6, k7, k8, k9, k10) = (k6, k3, k7, k4, k8, k5, k10, k9) LS-1为循环左移1位，LS-2为循环左移2位 IP函数： IP= 1 2 3 4 5 6 7 8 ​ 2 6 3 1 4 8 5 7 IP-1= 1 2 3 4 5 6 7 8 ​ 4 1 3 5 7 2 8 6 函数fk：fk(L, R) = (L xor F(R, SK), R) , 其中SK为子密钥 F是一个4-bit到4-bit的映射： 首先对R做扩张/置换(E/P)运算 E/P运算：(1, 2, 3, 4) =&gt; (4, 1, 2, 3, 2, 3, 4, 1) 将子密钥SK（对应具体算法中的K1和K2）与E/P运算的结果异或得到8-bit数 P0,0 P0,1 P0,2 P0,3 P1,0 P1,1 P1,2 P1,3 第一行进入S盒S0，第二行进入S盒S1，分别产生2-bit输出 第1和第4输入比特决定行，第2和第3输入比特决定列，以确定选取S-盒元素的位置 如 (P0,0 P0,3)=(0 0),并且(P0,1 P0,2)=(1 0)，则选取S盒矩阵的第0行第2列的元素作为2-bit输出 加密具体过程 数据加密标准DES DES加密流程 对明文X，通过一个固定的初始置换IP得到X0： X0 = IP(X) = L0R0 , 分为左右两部分。 函数F的16次迭代：LiRi (1&lt;=i&lt;=16） Li = Ri-1 , Ri = Li-1 xor F(Ri-1, Ki) 其中Ki是长为48位的子密钥。 对比特串R16L16使用逆置换IP-1得到密文Y： Y = IP-1(R16L16) 加密相关的表见附录 DES一轮加密 轮函数F F(Ri-1, Ki) ，输入为32-bit的Ri-1和48-bit的子密钥Ki 对Ri-1使用扩展函数E，扩展为48-bit 计算 E(Ri-1) xor Ki ，结果写成8个6-bit串 B=b1b2b3b4b5b6 使用8个4*16的S盒，其中的元素取0~15的整数，每个S盒输出为4-bit串： b1b6确定S盒的行数，b2b3b4b5确定S盒的列数 最后，P为固定置换，输出为32-bit串 密钥K计算子密钥 密钥K是长度为64的位串：56位参加子密钥编排，8位是奇偶校验位，在密钥编排的计算中，不参加运算。 给定64位的密钥K，放弃奇偶校验位(8, 16, …, 64)，先进行PC-1固定置换，结果为前28-bit的C0和后28-bit的D0 对1 &lt;= i &lt;= 16，计算 Ci = LSi(Ci-1) Di = LSi(Di-1) 其中LSi表示循环左移1或2位，当i=1,2,9,16时移1位，其他情况移2位 计算 Ki = PC-2(CiDi) DES的S盒 DES的核心是S盒 S盒不是它输入变量的线性函数 改变S盒的一个输入位至少要引起两位的输出改变 对任何一个S盒，如果固定一个输入比特，其它输入变化时，输出数字中0和1的总数近于相等 双重DES 加密：C = EK2[EK1[P]] 解密：P = DK1[DK2[P]] 三重DES 两个密钥加密：C = EK1[DK2[EK1[P]]] IDEA 分组长度为64位，子分组长度为16位 密钥长度为128位 进行8轮循环 同一算法既可以加密也可以解密 IDEA加密总体方案 IDEA加密具体过程 是整数模216+1乘 (IDEA的S盒) 是整数模216加 IDEA的密钥生成 52个16-bit的加密子密钥从128-bit的密钥中生成： 前8个子密钥直接从密钥中取出； 对密钥进行25-bit循环左移，接下来的密钥从中取出； 重复进行直到52个子密钥全部生成。 解密密钥从加密子密钥中导出： 解密循环 i 的前4个子密钥从加密循环 10-i 的前4个子密钥中导出： 解密密钥的第1、4个子密钥对应于1、4加密子密钥的乘法逆元； 解密密钥的第2、3个子密钥对应于2、3加密子密钥的加法逆元 对前8个循环来说，循环 i 的最后两个子密钥等于加密循环 9-i 的最后两个子密钥 AES-Rijndael 可变块长、可变密钥长度 分组长度指定为128位 密钥长度为128，192或256位，相应的迭代轮数为10、12和14 AES框架 AES轮函数 每一轮迭代的结构都一样，只是最后一轮省略了列混合变换： 字节替换(Byte Sub) 对数据的每一字节应用一个非线性变换； 替换表是一个16×16的矩阵。表中纵向的x取自状态矩阵中的高4比特，横向的y取自低4比特。 行移位(Shift Row) 对每一行的字节循环重新排序，可以表示为: Bi,j = Ai,(i+j)mod4 列混合(Mix Column) 对矩阵的列应用一个线性变换: 将状态的每一列视为GF(28)上的多项式S(x)，然后乘以固定多项式a(x)，并模除x4+1。其中a(x) = {03}x3+{01}x2+{01}x+{02} a(x)存在关于x4+1的逆元，变换的矩阵为： 列混合变换的结果为： 轮密钥加(Add Round Key) 把轮密钥混合到中间数据，对状态和每轮的子密钥进行简单的异或操作 每轮子密钥是通过密钥调度算法从主密钥中产生，子密钥长度等于分组长度 轮密钥加运算需要用到4个导出的32比特子密钥 AES子密钥生成 Rijindael算法每一轮需要用到Nb比特的子密钥，共有Nr轮，另外，第一次轮密钥加的时候也需要用一轮子密钥，于是总共需要Nb*(Nr+1)比特的子密钥，对于AES-128来说就是用1408比特的子密钥 AES解密过程 逆字节替换、逆行移位、逆列混合、轮密钥加(其逆变换就是本身) 分组密码工作模式 ECB 电码本模式 消息分成相互独立的加密模块 每块独立使用DES算法 适合少量的数据加密 如果最后一个分组长度不够，需要填充 对于同一个明文分组，如果出现多次，其密文是相同的，因为每次的加密密钥都相同 (缺陷) CBC 密码分组链接模式 使重复的明文分组产生不同的密文分组：每次加密使用相同加密密钥，但是输入是当前明文分组盒前一个密文分组的异或 适合加密长度大于64比特的消息 如果最后一个分组长度不够，需要填充 可以用来进行用户鉴别 错误传播 解密时，每一个密文分组被解密后，再与前一个密文分组异或，便能得到明文分组 产生第一个密文分组时，需要一个初始向量IV与第一个明文分组异或，IV对于收发方都是已知的，且应该像密钥一样被保护 CFB 密码反馈模式 消息作为比特流，不需要对消息填充 适合数据以比特或字节为单位出现 错误传播 可以用于认证 加密过程： 解密过程： 将收到的密文单元和加密函数的输出进行异或 仍然使用加密算法而不是解密算法 OFB 输出反馈模式 结构类似CFB，不同之处在于OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器 消息作为比特流，不需要对消息填充 比特错误不会被传播 加密过程： 解密过程： CTR 计算器模式 可并行加密 预处理 吞吐量仅受可使用并行数量的限制 加密数据块随机访问 流密码 流密码简单结构 密钥源是一个容易记住的密钥 密钥流生成器生成一个周期较长、可用于加解密运算的伪随机序列 同步流密码与自同步流密码 同步流密码 密钥流的产生与明文消息流相互独立 无错误传播：在传输期间一个密文字符被改变只影响该符号的恢复，不会对后继的符号产生影响 自同步流密码 密钥流的产生与之前已经产生的若干密文有关 线性反馈移位寄存器 LFSR 用于生成密钥流： LFSR的结构非常适合硬件实现 LFSR的结构便于使用代数方法进行理论分析 产生的序列的周期可以很大 产生的序列具有良好的统计特性 反馈函数为：， 其中加法运算为模2加，乘法为普通乘法 第t+1时刻第i级寄存器的内容为： LFSR的联接多项式为： LFSR的周期与m序列 一个n级LFSR序列的周期最大只能是2n-1 若n级LFSR产生的非零序列的周期为2n-1，则称其为m序列 一个n级LFSR为最长移位寄存器的充要条件是它的联接多项式为F2上的n次本原多项式 2n-1为素数时，F2上的每一个n次不可约多项式均为n次本原多项式 伪随机序列 Golomb随机性假设 注：游程指一段连续的相同数字 m序列的伪随机性 线性复杂度 线性复杂度：能够输出该序列的最小线性移位寄存器的级数，即次数最小的联接多项式 如果序列的线性复杂度为l(&gt;=1)，则只要知道序列中任意相继的2l位，就可确定整个序列 安全的密钥流 周期充分长，一般不少于1016 随机统计特性好，即基本满足Golomb的随机性假设 大的线性复杂度，为序列长度的一半 基于LFSR的伪随机序列生成器 在LFSR的基础上加入非线性化的手段，产生适合于流密码应用的密钥序列(伪随机序列) 滤波生成器 由一个n级线性移位寄存器和一个m(&lt;n)元非线性滤波函数组成，滤波函数的输出为密钥流序列 g是一个m元布尔函数 组合生成器 若干个线性移位寄存器LFSRi(i=1, …, n)和一个非线性组合函数组成，组合函数的输出构成密钥流序列 其中LFSRi为n个级数分别为r1, r2, …, rn的线性移位寄存器 f是n元布尔函数 钟控制生成器 用一个或多个移位寄存器来控制另一个或多个移位寄存器的时钟 当LFSR1输出1时，移位时钟脉冲通过与门使LFSR2进行一次移位，从而生成下一位 当LFSR1输出0时，移位时钟脉冲无法通过与门影响LFSR2，因此LFSR2重复输出前一位 当LFSR1的输出是1时，LFSR2被时钟驱动 当LFSR1的输出是0时，LFSR3被时钟驱动 LFSR1的输出与LFSR2的输出做异或运算即为这个交错式停走生成器的输出 实用流密码 全球移动通信系统GSM中的A5算法 A5的钟控机制：如果在某一时刻钟控单元中三个值的某两个或三个相同，则对应的移位寄存器在下一时刻被驱动，而剩下的一个(或0个)值对应的移位寄存器则停走 RC4 参数n，长为n的秘密内部状态(2n数组)，当n取8时，内部状态有256(=2n)个元素(S[0], S[1], …, S[255])构成，每个元素都是0~255之间的一个数字 输入：一个可变长的密钥，用于初始化内部状态 输出：状态中按照一定方式选出的某一个元素K，该输出构成密钥流的一个字节，加解密时，K与一个明文/密文字节执行XOR运算 每生成一个K值，内部状态中的元素会被重新置换一次，以便下次生成K值 密钥调度算法 用来设置内部状态的随机排列，最开始设置为S[i]=i (i=0, 1, …, 255) 密钥长度可变，设为L个字节(K[0],…, K[L-1])，一般L在5~32之间，用这L个字节不断重复填充，直到得到 K[0],…, K[255]。该数组K将被用于对内部状态S进行随机化 伪随机生成算法 从内部状态中选取一个随机元素作为密钥流中的一个字节，并修改内部状态以便下一次选取 例子 公钥密码 对称密码体制的缺陷 密钥分配问题：缺少安全信道 密钥管理问题：任意两个用户之间都需要共享密钥，数量级很大 没有签名功能 公钥算法分类 Public Key Distribution Schemes (PKDS) 密钥交换 用于交换秘密信息(依赖于双方主体) 常用于交换对称加密算法的密钥 Public Key Encryption (PKE) 公钥加密 用于加密任何消息 任何人可以用公钥加密消息 私钥的拥有者可以解密消息 任何公钥加密方案能够用于密钥分配方案PKDS 许多公钥加密方案也是数字签名方案 Signature Schemes 用于生成对某消息的数字签名 私钥的拥有者生成数字签名 任何人可以用公钥验证签名 Diffie-Hellman密钥分配 不能用于交换任意消息 基于有限域上的指数问题 安全性是基于计算离散对数的困难性 能抵抗被动攻击，不能抵抗主动攻击（中间人） RSA 素数p, q要求足够大 通常选择小的加密指数E，可以对所有用户都相同 RSA快速实现 加密快，指数小；解密慢，指数大 利用中国剩余定理CRT快速实现RSA解密(M=CD mod N)： M1 = M mod p = (C mod p)Dmod(p-1) M2 = M mod q = (C mod q)Dmod(q-1) 解方程：M = M1 mod p 和 M = M2 mod q 具有唯一解(利用CRT)：M = (quM1 + pu’M2) mod N，其中pu mod q =1，qu’ mod p = 1 RABIN公钥密码体制 基于二次剩余问题和模n平方根问题 加密密钥为2，安全性等价于对大整数n的分解；解密更为困难 不能抵抗选择密文攻击 EI Gamal公钥加密 D-H算法的变形，用于安全交换密钥 安全性基于离散对数 缺点：增加消息长度（2倍） 认证和哈希函数 认证的主要目的： 实体认证(发送者非冒充) 消息认证(验证信息的完整性) 三类产生认证符的函数： 消息加密 消息认证码(MAC) 哈希函数 消息加密 对称加密：提供保密与一定程度的认证，不提供签名 公钥加密：(A -&gt; B) E(KUb, M) =&gt; 提供保密，不提供认证 E(KRa, M) =&gt; 提供认证和签名 E(KUb, E(KRa, M)) =&gt; 提供保密、认证和签名 消息认证码(MAC) 对选定消息使用一个密钥产生一个短小的定长数据分组，附加在消息中提供认证功能 (MAC = Ck(M)) 基本用法： M || Ck(M) =&gt; 提供认证 Ek2(M || Ck1(M)) =&gt; 提供认证(K1)和保密(K2) Ek2(M) || Ck1(Ek2(M)) =&gt; 提供认证(K1)和保密(K2) 适用于消息广播、比消息加密的工作量小、认证与保密分离、延长消息的保护期限 不可逆，且不提供数字签名 哈希函数 基本用法： Ek(M || H(M)) =&gt; 提供保密和鉴别 M || Ek(H(M)) =&gt; 提供鉴别 M || EKRa(H(M)) =&gt; 提供鉴别和数字签名 Ek(M || EKRa(H(M))) =&gt; 提供鉴别、数字签名以及保密 M || H(M || S) =&gt; 提供鉴别(S是通信双方共享的一个秘密值) Ek(M || H(M || S)) =&gt; 提供鉴别和保密 哈希函数要求： 消息长度任意，输出定长 易于计算 单向性 弱抗碰撞性：任意给定分组x，寻求不等于x的y，使得H(y)= H(x)在计算上不可行 强抗碰撞性：寻求对任何的(x,y)对使得H(x)=H(y)在计算上不可行 简单的异或哈希函数 每个n比特长度分组按比特异或，得到长度为n的哈希码 改进：(使得输入数据完全随机化，掩盖输入的数据格式) 先将n比特的哈希值设置为0 当前的哈希值循环左移一位 数据分组与哈希值异或形成新的哈希值 Merkle-Damgard结构： MD5 输入任意长度报文，输出128比特的摘要；输入分组长度为512比特；符合Merkle-Damgard结构 算法流程 在消息的最后添加填充位（一个1和若干个0），使得数据的长度满足length = 448 mod 512，填充完后，信息的长度为N*512+448(bit) 记录信息长度，用64位来存储填充前信息长度，如果信息长度超过264位，则只保留低64位。这64位加在第一步结果的后面，这样信息长度就变为(N+1)*512(bit) 初始化MD缓存，使用一个128位缓存存放哈希的中间和最后结果，缓存表示为4个32位的缓存器（A,B,C,D），初始化格式为低位字节存放在高地址字节 四轮循环处理512bit分组 输入：当前处理的512位分组Yq与上一轮输出CVq 循环：4轮循环依次记为F，G，H，I；借助列表T[1,…,64]（T[i]=232 * |sin(i)|的整数部分），列表提供随机化的32位模板以消除输入的规律 每个循环包括16步操作，每一步的基本形式： $$ b \\leftarrow b + ((a + g(b, c, d) + X[k] + T[i]) &lt;&lt;&lt; s) $$ +：模232加 a, b, c, d：MD缓存中的4个字，一开始被初始化，之后每一步操作结果都会替换其中一个字 &lt;&lt;&lt; s：循环左移s位 T[i]：矩阵T中的第i个32比特字，i = 1,…,16 g：循环函数F、G、H、I X[k]：当前分组的第k个字 输出：第4次循环输出加到第1轮循环的输入上产生CVq+1，相加是缓存中的4个字分别与CVq中对应的4个字以模232相加 MD5应用 对明文消息生成消息摘要 用于数字签名（UNIX、Linux等操作系统保护用户口令） MD5口令逆向 SHA-1 输入最大长度为264位的消息，输出160比特 ，分组为512比特 算法流程 在消息的最后添加填充位（一个1和若干个0），使得数据的长度满足length = 448 mod 512，填充完后，信息的长度为N*512+448(bit) 记录信息长度，用64位来存储填充前信息长度，如果信息长度超过264位，则只保留低64位。这64位加在第一步结果的后面，这样信息长度就变为(N+1)*512(bit) 初始化MD缓冲区，使用160位MD缓冲区来保存中间和最终哈希结果，表示为5个32位寄存器（A,B,C,D,E），存储为低位字节放在低地址字节上 以512位数据块为单位处理消息，4轮，每轮20步，每次循环分别使用一个额外的常数Kt 每一步的基本形式： $$ A,B,C,D,E\\leftarrow (E+f_t(B,C,D)+S5(A)+W_i+K_t),A,S{30}(B),C,D $$ +：模232加法 ft：逻辑函数，每轮循环不同 Si：32位常数循环左移i位 Kt：额外的常数 Wi：当前512位数据导出的一个32位字；共80个 前16个直接来自当前分组的16个字 其余： $$ W_t=S^1(W_{t-16}\\bigoplus W_{t-14}\\bigoplus W_{t-8}\\bigoplus W_{t-3}) $$ 第4次循环输出加到CVq，得到160位CVq+1（模232加） 哈希函数对比 SHA = MD4 ＋ 扩展变换 ＋ 外加一轮 ＋ 更好的雪崩 MD5 = MD4 ＋ 改进的比特杂凑 ＋ 外加一轮 ＋ 更好的雪崩 数字签名算法 只对消息的哈希签名，否则交换信息长度增加一倍；数字签名可以提供消息的不可否认性 RSA 给定(e, R), (d, p, q) 计算明文M的哈希h，S = hd(mod R)，发送(M, S) 接收方同样计算哈希h，Se mod R = h’ mod R，对比h和h’ 若先加密后签名，签名可能被替换 EI Gamal 加密算法不可交换——需要专门的签名算法 安全性基于离散对数的计算困难性 公钥：(y, g, p)，私钥(x) 签名方案: 随机数k，与p-1互素 计算K = gk mod p 计算S = k−1(M − Kx) mod (p−1) 发送签名(M, K, S)，销毁k 验证yKKS mod p=gM mod p 签名长度为消息的两倍 DSA El Gamal的变形，生成320位签名 安全性基于离散对数的计算困难性 密钥生成 公开参数 (p, q, g) p：大素数，2L，L为512到1024位且为64的倍数 q：160位（p-1）的素因子 g：h(p−1)/q, h &lt; p−1 且 h(p−1)/q(mod p) &gt; 1 选择私钥x，计算y = gx mod p，公钥为 (p, q, g, y) 签名生成（SHA：哈希函数） r = (gk mod p) mod q s = k−1(SHA(M) + xr) mod q 发送 (M, r, s) 签名验证 w = s−1 mod q u1 = SHA(M)w mod q u2 = rw mod q v = (gu1yu2 mod p) mod q 验证 v = r HMAC 以上为需要私钥的认证方案，计算量大 密钥与消息同时参加运算：KeyedHash = Hash(Key | Message)或Hash(Key1 | Hash(Key2 | Message)) HMAC：使用带密钥hash函数的结果 HMACK = Hash((K′ ⨁ opad) || Hash((K′ ⨁ ipad) || M)) K’：经过填充的密钥 opad、ipad：特殊的填充值 安全性基于原始的hash 信息隐藏与隐写分析 信息隐藏的基本概念 信息隐藏是将信息秘密嵌入在数字图像、声音、文档、视频等数字产品中，用以隐蔽通信、隐蔽标识，或识别所有者、完整性、发源地、使用权、序列号等。 信息隐藏技术的主要分支 隐蔽信道：系统存在的一些安全漏洞，通过某些非正常的访问控制操作，能形成隐秘数据流，而基于正常安全机制的软硬件不能觉察和有效控制 匿名通信 源重写技术：采用路由转发策略，发送者匿名 隐写术 版权标志 水印的分类 根据应用分类： 隐蔽通信 版权保护 认证和完整性 内容标注 根据嵌入域分类： 空域，如LSB 变换域，如DFT、DCT、DWT等 根据是否可见分类 可见水印 不可见水印 根据密钥分类 密钥水印 公钥水印 根据原始数据分类 私有水印：检测时需要原始数据 盲水印：检测时不需要原始数据 根据载体恢复分类 可逆水印 不可逆水印 根据鲁棒性分类 鲁棒水印：用于认证、版权保护 半易碎水印 易碎水印：对恶意改动敏感，用于完整性判定 鲁棒水印特性 不可见性 安全可靠性 鲁棒性 复杂性 容量 信息隐藏的一般过程 水印生成 类似噪声，具有不可预测的随机性 Arnold置乱技术：置乱96次回到原图 扩频技术 基于片率 基于伪随机序列 水印嵌入 加法嵌入：Xw(k) = X0(k) + a(k)w(k) 乘法嵌入：Xw(k) = X0(k)(1 + a(k)w(k)) 信息隐藏的常见算法 空域信息隐藏算法 通过直接修改像素值实现信息嵌入 优点：简单、快速、容量大 缺点：鲁棒性差 图像位平面特性： 位平面越高，对灰度值的贡献越大，相邻比特的相关也越强 最低位平面类似随机噪声 LSB算法 Patchwork算法 Checksum算法 频域水印算法 通过修改频域空间的系数实现水印嵌入 离散傅里叶变换（DFT） 离散余弦变换（DCT） 离散小波变换（DWT） 优点：鲁棒性好 缺点：复杂度高 附录 DES算法相关表 初始置换IP (对明文输入进行次序打乱) 初始置换的逆置换IP-1 扩展置换E (32-bit到48-bit) 置换函数P PC1 PC2 S-box 例子 AES算法相关表 字节替换表","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/tags/cryptography/"}]},{"title":"论文阅读-SGX Support for Dynamic Memory Management Inside an Enclave","slug":"paper-reading/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave","date":"2020-11-25T00:20:42.000Z","updated":"2020-11-26T09:31:42.000Z","comments":true,"path":"2020/11/25/paper-reading/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/","link":"","permalink":"http://example.com/2020/11/25/paper-reading/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/","excerpt":"论文SGX Support for Dynamic Memory Management Inside an Enclave阅读笔记","text":"1. Introduction SGX1 shortcomings enclave建立时必须分配其所需的所有内存，并且难以根据工作量自适应分配enclave，需要根据最坏情况的工作量来分配内存 enclave页的访问控制由EPCM来管理，当页被加入enclave时其权限就得写入EPCM中，并且不能再改变，这就意味着必须允许页上将来可能执行的任何操作，不能做到权限最小化 library OS，异常处理和代码延迟加载 2. SGX2 Considerations &amp; Requirements 动态内存管理需要满足的条件 enclave需要自己掌控其内存和权限 enclave代码在enclave不知情的情况下被改变时，将不会被执行 系统的资源管理器能够正常管理和分配资源 需要同时有EPCM权限和系统权限才能更改内存权限 安全考量 enclave软件需要改变页的权限来进行访问控制 权限更改时要保证旧的权限从TLB中移除 如果enclave要将页还回系统，并且想要在以后使用相同的内存地址，则enclave需要知道页是什么时候被还回的 软件考量 enclave内部的内存管理机构需要能够重新分配内存资源 3. SGX2 Overview and Usage SGX2新增的指令 Enclave内存分配 To implement dynamic memory allocation and commitment, the enclave runtime system and the operating system have to agree on a protocol that coordinates the operating system usage of EAUG and the enclave runtime system usage of EACCEPT. Committed： Virtual Size减去为程序保留的内存（未分配）。怎么理解为程序保留的但未分配的内存？就是告诉系统我要一块内存，但暂时还用不上，不过分配的地址得给我，系统就给程序一个不用的地址，但不分配内存，等程序真的要使用时（读写），就从页面或物理内存中分配出来映射到那个地址上。 提交的内存： 系统从物理内存或者换页内存分配给进程的那一部分。这部分内存在虚拟内存的线性地址中是连续的，不过在物理内存或者换页内存中，不一定是连续的。提交但未使用的内存一般都在换页内存里面，只有去使用的时候，才会换到物理内存里面，这点要注意。 Enclave内存释放 SGX2 provides a more robust reclamation of committed memory. OS and enclave runtime system need to coordinate the execution of EMODT, ETRACK, and EREMOVE by the OS and execution of EACCEPT by the enclave runtime. 改变页的权限 分为扩大权限和缩减权限。 扩大权限： The internal manager executes EMODPE to extend the page permissions in the EPCM. The internal manager requests the system manager to extend page permissions in the page tables. 缩减权限： The internal manager requests that the system manager to restrict permissions on a page. The system manager executes EMODPR and updates page table permissions. After permissions have been updated, the system manager executes ETRACK on the SECS of the calling enclave and sends IPIs (处理器间中断：允许一个CPU向系统其他的CPU发送中断信号) to all processors that may be executing inside the enclave to flush TLB mappings. After all IPIs have been acknowledged, control is returned to the internal manager. The internal manager verifies that page permissions have been restricted and TLB mappings flushed by executing EACCEPT. 权限的更改(同时包含扩大和缩减权限)：先缩减后扩大 —— 避免产生不安全的中间临时情况 线程控制机构TCS分配 The software protocol is very similar to page restriction except that instead of executing EMODPR the OS executes EMODT. 动态加载模块 To support dynamic loading of modules, SGX2 provides EACCEPTCOPY which allows the internal manager to atomically initialize the contents and permission of a page. Library OS支持 提供异常处理 由enclave产生的异常 异常的类型 错误情况的具体信息 SGX2还另外提供enclave运行时产生的enclave内部的异常","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Internet安全协议与分析Notes","slug":"learning-notes/Internet安全协议Notes","date":"2020-11-24T16:00:00.000Z","updated":"2022-04-28T07:30:06.000Z","comments":true,"path":"2020/11/25/learning-notes/Internet安全协议Notes/","link":"","permalink":"http://example.com/2020/11/25/learning-notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/","excerpt":"Internet安全协议与分析期末复习","text":"IPSec 通信保护协议 AH 通信提供数据源认证、抗抵赖性、数据完整性和反重播保证，但不提供机密性保护 AH传输模式 源IP地址、目的IP地址是不能修改的，否则会被检测出来，因此AH在传输模式下和NAT冲突 AH隧道模式 AH验证的范围也是整个IP包，因此AH和NAT的冲突在隧道模式下也存在 ESP 为IP提供机密性、数据源认证、抗重播以及数据完整性等安全服务，但不提供抗抵赖性 对IP头部不进行认证，因此不会和NAT冲突 ESP传输模式 ESP隧道模式 密钥交换管理协议IKE 安全机制 前向安全性：一个密钥被破解不影响其他密钥的安全性 数据验证 DH交换和密钥分发 阶段1 主模式协商 野蛮模式协商 两种模式对比 阶段2 SSL 安全机制 数据机密性：对称加密 身份验证机制：基于证书的数字签名 消息完整性：MAC算法 SSL连接和会话 连接是点对点的、暂时的 会话是客户端和服务器之间持久的关联 SSL分层结构 上层协议 SSL握手协议：协商加密套件，交换密钥，身份认证 SSL password变化协议：修改新的加密套件和密钥 SSL警告协议：当其他过程中出现错误或发送异常时，向对方报告告警信息 下层协议 SSL记录协议：对上层数据分块、压缩、加密、传输 SSL握手协议 阶段1：建立安全能力 协商加密套件 阶段2：服务器鉴别与密钥交换 阶段3：客户端鉴别与密钥交换 服务器和客户端分别发送自己的证书并交换密钥信息以便进行身份认证 阶段4：完成 检验双方是否获得同样的安全参数 SSL记录协议 为每个SSL连接提供： 机密性 完整性 SSL协议安全性分析 鉴别机制：公开密钥机制和数字证书 加密机制：混合密码体制 完整性机制：定义了共享的、可以用来形成报文鉴别码MAC的密钥 抗重放攻击：序列号，用随机数标记握手 SSL脆弱性分析 客户端假冒 无法提供基于UDP的应用的安全保护 不能对抗通信流量分析：SSL只对数据进行保护，数据包的IP头和TCP头暴露在外 SSL进程存储空间中的主密钥泄露 SET 双重数字签名 订单信息OI：客户给商家 支付信息PI：客户给银行 SET电子支付流程 支付初始化：持卡人选择商品，下订单，选择银行卡 初始请求：持卡人发送请求指定交易环境 初始应答：商家回复交易环境信息，以及证书等，并附上签名 购物请求： 持卡人检查商家初始应答发送的签名信息，确保数据完整性 持卡人发送PReq 商家验证持卡人的身份和授权 商家将相关信息发送给支付网关 支付网关认证 网关将信息发送给银行 收单银行处理 确保PI和AuthReq的一致性 校验持卡人和商家对于订购行为的一致性 发送AuthRes给商家 支付完成 通过捕获令牌(Capture Token)完成支付 下单回复 SET核心技术 公开密钥加密 数字签名 数字信封：公钥算法加密对称密钥 电子安全证书 PGP 提供可用于电子邮件和文件存储应用的保密与鉴别服务 PGP数字签名与认证 PGP保密性 邮件的存储转发特性不适合用DH算法交换密钥 使用公钥算法对每个消息生成一次性会话密钥 PGP保密和认证结合 PGP压缩 使用ZIP算法 先签名后压缩 只需要存储原始报文和签名 易于更换压缩算法 PGP密钥环 每个结点都有存储密钥的结构 私钥环：存储该结点拥有的公/私钥对 公钥环：存储该结点拥有的其他所有用户的公钥 PGP信任网 PGP中没有认证机构，而是由用户互相对对方的公钥进行数字签名 确认是否信任 通过自己的数字签名 通过自己完全信任的人的数字签名 通过自己有限信任的多个人的数字签名 Kerberos 采用传统加密算法(非公钥算法) 基本概念 Principle：安全个体，有名字和口令 KDC：网络服务，提供ticket和临时会话密钥 Ticket：客户用来向服务器证明身份的票据 其大多数信息被服务器的密钥加密 Authenticator：包含最近产生的信息的记录，需要用到会话密钥 Credentials：一个Ticket加上秘密的会话密钥 AS：Authentication Server 通过long-term key认证用户 授予用户ticket granting ticket和short-term key 认证服务 TGS：Ticket Granting Server 通过ticket granting ticket和short-term key认证用户 发放service granting ticket给用户以访问其他服务器 授权和访问控制服务 Kerberos工作流程 1. 认证服务交换：获得票据许可票据(ticket granting ticket) 2. 票据许可服务交换：获得服务许可票据(service granting ticket) 3. 客户/服务器认证交换：获得服务 Kerberos跨域认证 获得本地TGS访问权 请求一张远程TGS的票据许可票据 向远程TGS请求其域内的服务 Kerberos优缺点 优点 密码不在网上传输，不易被窃听，难以猜测 单点登录机制，只用输入一次口令 票据被盗之后难以使用，因为需要配合认证头来使用 缺点 缺乏撤销机制 密钥管理复杂 跨域认证复杂 需要始终同步 需要始终在线的AS和TGS BAN 所用符号 A, B, S：泛指参与协议的主体 P, Q, R：主体变量 X, Y: 公式变量 K: 密钥变量 Kab, Kbs, Kas: 主体之间的共享密钥 Ka, Kb, Ks: 主体的公钥 Ka-1, Kb-1, Ks-1: 主体的私钥 Na, Nb, Ns：主体各自生成的用于确认新鲜性的随机数Nonce {X}k：用密钥k加密X的结果 &lt;X&gt;Y：X和Y的组合 P-&gt;Q:(X)：P发送消息X给Q bel(P,Q)：主体P相信X sees(P,X)：P接收到X said(P,X)：P发送X cont(P,X)：P拥有对X正确与否的判决权 fresh(X)：X是新鲜的 skey(P,K,Q)：K是P,Q的共享密钥 goodkey(P,K,Q)：K是P,Q共享的良好密钥 pubkey(P,K)：K是P的公钥 secret(P,X,Q)：X是P和Q的共享秘密 推理规则 消息意义规则 从加密消息所使用密钥以及消息中包含的秘密来推断消息发送者的身份 例如对于共享密钥：bel(P,goodkey(P,K,Q)) and sees(P,{X}k) =&gt; bel(P,said(Q,X)) 随机数验证规则 如果P相信X是新鲜的，并且P相信Q曾经发送过X，那么P相信Q相信X bel(P,fresh(X)) and bel(P,said(Q,X)) =&gt; bel(P,bel(Q,X)) 仲裁规则 如果P相信Q对X是有仲裁权的，并且P相信Q相信X，那么P相信X bel(P,cont(Q,X)) and bel(P,bel(Q,X)) =&gt; bel(P,X) 信仰规则 bel(P,X) and bel(P,Y) =&gt; bel(P,(X,Y)) bel(P,(X,Y)) =&gt; bel(P,X) or bel(P,Y) bel(P,bel(Q,(X,Y))) =&gt; bel(P,bel(Q,X)) or bel(P,bel(Q,Y)) 接收规则 如果P接收到一个消息，那么P也接收到这个消息的一部分 sees(P,(X,Y)) =&gt; sees(P,X) sees(P,&lt;X&gt;Y) =&gt; sees(P,X) 如果P收到加密消息，那么以下三种情况P可以读出消息原文 bel(P,goodkey(P,K,Q)) and sees(P,{X}K) =&gt; sees(P,X) bel(P,pubkey(P,K)) and sees(P,{X}K) =&gt; sees(P,X) bel(P,pubkey(Q,K)) and sees(P,{X}K-1) =&gt; sees(P,X) 新鲜规则 如果消息的一部分是新鲜的，则整个消息是新鲜的 bel(P,fresh(X)) =&gt; bel(P,fresh(X,Y)) 传递规则 如果P相信Q曾经发送过整个消息，那么P相信Q曾经发送过消息的部分 bel(P,said(Q,(X,Y))) =&gt; bel(P,said(Q,X))","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[]},{"title":"SGX Developer Guide - Reading Notes","slug":"learning-notes/SGX-Developer-Guide-Notes","date":"2020-11-24T16:00:00.000Z","updated":"2022-04-28T07:34:32.000Z","comments":true,"path":"2020/11/25/learning-notes/SGX-Developer-Guide-Notes/","link":"","permalink":"http://example.com/2020/11/25/learning-notes/SGX-Developer-Guide-Notes/","excerpt":"Intel SGX Developer Guide 学习笔记","text":"专业名词 ECall：“Enclave Call”一个调用enclave内部接口函数的操作 OCall：“Out call”从enclave内部向外部的应用发起调用的操作 Trusted：任何在enclave内部 trusted 环境下执行的代码或者数据结构 Trusted Thread Context：线程的上下文存放在enclave中，主要包括以下几个部分组成： Thread Control Structure（TCS）线程控制结构 Thread Data/Thread Local Storage 在enclave中的线程相关的数据 State Save Area(SSA) 线程异常处理机制 Stack 线程栈 Untrusted：指代任何运行在应用的 untrusted 环境下（等价于enclave外部）的代码或者数据结构。 Enclave 编程模型 Enclave开发原则 enclave是一个庞大而单一的软件实体，目标在于将对于一个应用而言的可信计算基降低至可信运行时系统，ISV代码和第三方可信库。在上述组件中的任一个bug将会导致enclave的安全问题。 非可信域控制了enclave 接口函数什么时候被调用的顺序。 当调用进入enclave中，是由不可信域来在enclave中选择可信线程上下文去执行。 并不保证传递进去enclave（ecall）中的参数和从enclave向外部发送的参数（ocall）是正确的，因为这是由不可信域提供的。 enclave向外部发送的调用 OCall，不能保证不可信函数一定正确地被执行。 任何人都可以加载一个enclave。更为严重的是，攻击者可能使用攻击性应用程序去加载一个enclave，利用该enclave存在的安全漏洞，窃取相关数据。 Enclave文件格式 一个 enclave library 文件包括可信代码和数据部分，当enclave被创建时，这些将会被导入到受保护的 enclave 内存（即EPC）中 在一个enclave文件中，还存在着Intel SGX特定的数据结构，enclave元数据： 元数据没有导入EPC中，而是被不可信的加载器加载，并决定enclave如何导入到EPC中 元数据中定义了可信线程上下文的数量，包括可信堆和可信栈的大小，在enclave初始化的时候，可信堆和可信栈被可信运行时系统初始化 元数据同时包括enclave的签名，这对于enclave的认证和初始化时非常重要的 **注：**不管enclave中定义了多少个可信线程，在设计的过程中不能假设不可信应用将会以特定的顺序去调用 Enclave 中的接口函数。一旦enclave被初始化，一个攻击者可以调用 Enclave 接口函数，以任何可能的顺序去发起调用并且提供相应的输入参数。 Enclave可信计算基 Enclave Interface 函数 (ECalls) enclave无法控制哪个ECall被执行，或者ECall将会以怎样的顺序被调用 ISV接口函数仅仅只能在enclave初始化后被调用，这意味着： 任何必要的地址基地址重置被正确地执行。 可信全局数据，例如栈等被正确地初始化。 可信线程的上下文，可信线程被正确地初始化。 不直接说明的可信初始化函数执行完成。（例如ISV全局构造函数） Enclave的输入 Enclave输入和输出可以被不可信的代码观察和修改 为了防止针对输入函数的攻击，软件开发者应该采用加密的方式和完整性检测来保证enclave执行的可信性 当一个encalve函数被调用时： 函数的参数和其他任何通过引用传递的序列化数据参数进入到可信环境中，并且对于攻击者无法访问的。 在参数上进行读写操作，返回值和其他序列化的引用，根据enclave开发者的参数与特殊定义，将不会影响ISV代码和数据的保密和完整性。 参数和返回值，序列化数据被可信运行时分配和管理，不对任何ISV代码和数据进行覆盖。 参数，返回值和序列化引用的大小被ISV所指定。 通过引用传递的输入参数 当ISV接口函数被调用时，输入参数将被停留在enclave中。然而，当一个输入参数通过引用的形式传递，只有引用（或指针）将会放置到enclave中。引用所指向的值停留在外部，并且会不断地变化。例如，一个攻击者可能在enclave检查函数参数后改变所引用的值。 外部Enclave调用 (OCalls) Enclave无法直接访问OS提供的服务。作为替代的是，encalve必须发起一个OCall将其传递到不可信应用中。 当一个enclave内的ISV函数发起OCall时： OCall仅仅暴露其参数和返回值到不可信域中。 当一个OCall发生时，返回值和任何序列化数据的引用将传递进入可信执行环境中，对攻击者不可以访问。另外enclave需要检查指针。 当一个OCall发生时，可信线程上下文与OCall之前的相同，除了在栈上的数据和易变寄存器上的值。 Enclave签名 在软件中通过enclave建立信任的过程中主要有着以下三种行为： Measurement（度量）：作为enclave在可信环境中初始化时用来验证文件准确性的身份。 Attestation（认证）：向其它实体证明当前的环境被正确的初始化。 Sealing（数据的密封）：通过某种方式保证可信环境上的数据可以正确地持久化和重新加载。 Enclave签名包含允许Intel SGX硬件检测enclave的完整性是否被篡改的信息，同时可以识别enclave持有人的身份。encalve 签名包含这几个如下的重要字段，对于外部实体的认证非常重要。 Enclave Measurement - 一个简单的256位哈希值用来标注代码和放入到enclave中的初始化数据，包括他们放入到EPC中期待的顺序和位置，以及这些页面的安全属性。当enclave代码/数据加载到EPC中，CPU开始计算enclave measurement并且将这个值存储在MRENCLAVE 寄存器中。接着CPU比较MRENCLAVE寄存器中的内容和存放在SIGSTRUCT中的enclave measurement值。当且仅当它们相等的时候，CPU允许enclave被初始化。 Enclave所有者的公钥 - 当一个enclave被正确地初始化，CPU将enclave所有者的公钥的hash存放在MRSIGNER寄存器中。MRSIGNER中的内容将会用作enclave所有者的身份证明。被同一个key认证的enclave在MRSIGNER寄存器中的值相同。 Enclave的安全版本号（ISVSVN）- enclave所有者对于enclave的每个版本号分配一个安全版本号。安全版本号反映了enclave的安全属性级别，并且需要单调递增，随着安全属性的不断上升。在一个enclave被正确初始化后，CPU记录SVN，并且在远程认证的过程中被使用。一个有着相同安全属性的enclave的不同版本应该分配相同的安全版本号。例如，一个没有解决安全相关bug的新版本enclave需要与旧版本的enclave持有相同的安全版本号。 Enclave的产品ID（ISVPRODID）- enclave所有者针对每一个enclave分配一个产品ID。产品ID允许enclave所有者使用相同的enclave所有者身份去分割enclave。当一个enclave被正确的初始化后，CPU记录Product ID，在远程认证的过程中可以被使用。 Enclave认证 本地认证 一个enclave可以请求硬件生成一个证书，即report，其中通过密码学证据证明着enclave存在这个平台上。这个report可以给其他的enclave，让其进行验证report是同一平台上生成。内部enclave之间认证机制使用的是对称密钥，只有验证report结构的enclave和创建enclave report的硬件可以访问到，并且嵌入到硬件平台中。 一个enclave report包含着以下的信息： enclave中的code和初始化数据的measurement。 enclave初始化的时候记录ISV证书公钥的哈希值。 用户后来添加的数据。 其他安全相关的状态信息。 上述所有数据的一个签名，可以被生成report的同一平台去进行验证。 本地认证过程 在上图中，应用A持有enclave A，应用B持有enclave B。在不可信应用A和B为两个enclave建立通信后，enclave B向enclave A发送了MRENCLAVE的值。（应用A和B可以是同一应用） 有两种方法对于应用而言可以提取enclave的MRENCLAVE measurement: 应用B从enclave B的enclave证书中提取MRENCLAVE的值。 enclave B提供了一个接口来导出该值，通过创建一个report。 Encalve A请求硬件生成一份report送至enclave B，并且其中包含着从enclave B获取到的数据。enclave A通过不可信应用将数据发送给enclave B。 当enclave B收到了来自enclave A的报告，enclave B要求硬件去验证report来确认enclave A和B在同一平台上运行。enclave B从enclave A中提取相应的MRENCLAVE，然后请求硬件生成自己的report，接着发送给enclave A。 enclave A验证enclave B的report，并且验证enclave B和自己运行在同一平台上。 远程 (跨平台) 认证 一个持有enclave的应用可以要求enclave去生成一份report，接着将这份report传到平台服务去生成一种类型的证书，反映着enclave和平台的状态。这种类型的证书被称为quote。这个quote可以传递到平台外的实体，并且使用Intel Enhanced Privacy ID（Intel EPID）签名技术去进行验证。作为结果，CPU的密钥并没有直接从平台内部暴露出去。 一个quote包含这以下的数据： enclave中代码和初始化数据的measurement。 enclave初始化的时候记录ISV证书公钥的哈希值。 enclave的产品ID和安全版本号。 enclave的属性，例如，encalve是否运行在debug mode。 enclave中添加的用户数据。提供了一种方式由enclave向外部实体提供数据。 上述所有数据的一个签名，借助于Intel EPID组签名技术。 包含在quote中的enclave 数据（MRENCLAVE, MRSIGNER, ISVPRODID, ISVSVN, ATTRIBUTES等等）在远程认证过程的末尾提供给远程服务使用上。服务提供者将根据这些数据去进行判断是否可信。 EPID Intel EPID是一种组签名技术，允许平台去匿名签名对象并且可以保护签名者的隐私（如果使用机器的CPUID签名，会导致隐私的泄露）。通过Intel EPID签名技术，组里面的每一个签名者都有他们各自的私钥，但是验证者使用相同的公钥去验证个人的签名。因此，用户无法识别出两个交易是否来自于同一个机构，因为用户无法检测中是组里面哪个成员做了签名。在Intel SGX中，这个组是所有支持Intel SGX平台的集合。 QE Intel中内嵌了一种特殊的enclave，成为Quoting Enclave（QE），QE验证report正确地按照其MRENCLAVE mesurement值进行创建，然后将它用一个硬件特定的非对称密钥（Intel EPID key）进行签名，输出的内容就是quote。当enclave 系统正在运行的过程中，只有QE有权限访问Intel EPID key。因此quote可以看作直接来自于硬件本身，但是CPU key永远不会暴露到平台外部。 远程认证过程 当应用需要在平台外部的服务，它首先和外部服务提供系统建立连接。服务提供者发起挑战(包含一个nonce)来证明应用确实运行在enclave中 应用从应用的enclave请求一份report，并将来自外部服务提供商的nonce传递进enclave中 enclave生成一份report结构，并将其连同一个清单返回给应用，清单包含report中用户数据部分的值以及nonce和用于挑战应答交互的密钥 report发送给QE去做签名 QE验证report QE转换report的body转换为quote，并对其使用EPID进行签名 QE返回quote structure 应用返回quote结构体和其他相关的信息到外部服务者 外部服务者使用EPID验证公钥去验证quote的签名信息。 外部服务者对比来自enclave的信息，并与其它可信配置的信息进行比较。判断enclave是否满足条件。其中包括检测enclave是否运行在debug模式，及其的measurement，产品ID和enclave所有人等等。 区分不同的Enclave运行实例 Intel SGX不直接提供一种机制（例如，通过自动生成的REPORT字段）来区分同一个enclave的两个不同的实例。 如果想要尝试的话，可以使用RDRAND函数生成随机数，并作为作为用户数据，嵌入到REPORT中。 Enclave密封 为了保护和持久化数据，提供了一种由enclave软件从特定的enclave中提取key的机制。这个Key只能在特定的平台上被某个enclave生成。enclave 软件使用那个key去在平台上加密数据或者从平台上解密已经存在的数据。我们把这种加密和解密的操作成为密封和解封。 软件密封技术 密封到当前的enclave（依照于enclave度量） 密封到当前enclave 使用enclave measurement的当前版本（MRENCLAVE），当enclave创建的时候，将这个值绑定到密封操作所需要使用的key上。这个绑定操作由硬件执行通过EGETKEY指令。 只有有着相同的MRENCLAVE度量的enclave才能够将密封的数据进行解密。如果enclave的DLL，Dynamic Library，或者Shared Object文件被篡改，那么enclave的measurement将会发生改变。作为影响，密封的key同样会发生变化，数据将不会被还原。 密封到enclave当前的所有者 将数据密封到enclave的当前的所有者需要使用enclave所有者的身份，这个值由CPU在enclave初始化的过程中存储在MRSIGNER寄存器中，并且这个值被绑定到密封数据函数所需要使用到的key中。这个绑定是由硬件通过EGETKEY指令完成。被密封数据函数使用的key同时也被绑定到enclave的产品ID上。产品ID在enclave初始化时存储在CPU中。 当MRSIGNER度量寄存器的值和产品ID相同时，enclave才能解密。 这种机制的好处是： 它允许enclave的所有者对enclave进行升级，但是不需要进行复杂的升级过程来解密之前密封在之前版本的enclave（MRENCLAVE 度量值不同）中的数据，并且重新使用密封到新的版本 它允许来自相同的所有者的enclave实现共享数据 Enclave所有者生产出enclave后，可以为之指定安全版本号。这个安全版本号同样在enclave初始化的时候存储在CPU中。一个enclave在从CPU中获取密封key的请求中必须提供一个相应的安全版本号。一个enclave不能指定一个比它当前安全版本号靠后的enclave，但是encalve可以指定一个在当前安全版本号之前的安全版本号。这个选项使enclave获得了解封之前版本的enclave中的数据，对于enclave软件更新，是有着巨大的好处的。 密封和解封过程 在enclave中密封数据的主要过程如下： 为加密数据和密封数据结构在enclave中分配内存。其中密封数据结构主要包括要加密的数据和额外认证数据(AAD, 额外的参与MAC计算但不进行加密的数据或文本)。额外认证数据中的信息可能包括应用enclave，版本号，数据等 调用加密数据的API来执行加密操作，一个加密操作算法如下： 验证输入参数是有效的。例如，如果作为参数进行传递的是一个指向加密数据结构的指针，它指向的缓存必须存在于enclave中。 初始化并向其中填充一个将要被EGETKEY指令来执行密钥请求的数据结构。过程如下： 获取EREPORT去获得安全ISV和TCB安全版本号，将在key获取中使用 Key 名称：识别获取key的名字，在这种情况下即为Seal key Key Policy：识别即将使用的软件密封策略。使用MRSIGNER来表示密封到enclave的所有者上，使用MRENCLAVE来表示密封到当前的enclave（enclave measurement）中。保留位必须被清除 Key ID：调用RDRAND来获取一个随机数 属性字段：表明密封密钥应该与什么属性进行绑定 使用上一步构造出的密钥请求结构调用EGETKEY获取Seal key 使用加密算法来使用密封密钥来执行密封操作。推荐使用AES-GCM加解密函数，例如Rijndael128GCM 从内存删除seal key以防泄露 将密封数据结构（包括密钥请求结构）从enclave中保存到外部内存中。密钥请求结构将用来在今后的enclave初始化后去获取密封密钥。 在enclave中对加密数据进行解密主要包括以下过程： 为待解密的数据分配内存。 调用解密api去执行解密操作。一个解密操作算法如下： 验证输入参数的合法性。 从密封数据结构中提取密钥请求结构 借助密钥请求结构去通过EGETKEY指令获取密封密钥 调用解密算法使用密封密钥解密 从内存中删除密封密钥以防止泄露 验证解密算法生成的hash与加密过程中生成的hash一致 区分不同的Enclave实例 即使同一个enclave的两个不同的实例可以在它们认证时区分，但是当两个enclave都使用EGETKEY指令时，目前Intel SGX不提供一种机制来阻止一个enclave实例去访问另一个enclave的密封数据，两个实例将会返回相同的密钥值。 如果要区分enclave实例的SEAL key，推荐： Intel recommends that enclave writers use the KEYID field of the KEYREQUEST structure passed into the EGETKEY instruction to pass an enclave instance specific nonce. This will provide a different key even when the same enclave is in a different virtual machine. 处理器特征 在enclave中可以执行大部分Ring3软件能执行的指令 程序性能 Enclave创建 enclave的大小很大程度上影响了创建enclave的时间，主要是由于在enclave的度量（measurement）过程中，需要进行一系列操作以保证所有的代码加载到enclave中是可信的。 在enclave的创建过程中，一系列的EADD和EEXTEND指令将被运行，主要用于加载和度量enclave的页面。 EADD每次加载4k字节的数据。 EEXTEND每次度量256字节的数据。这意味着对于EADD添加的4KB的数据，需要发起16次的EEXTEND调用。 相关的性能优化建议： 减小enclave的大小。仔细检查在enclave中每段代码和数据元素，如有必要，将其移除。（使用工具：Intel VTune Amplifier）。例如，将即将静态链接的.o 文件先转换为诶.a文件。 Intel SGX 允许enclave通过 Enclave Dynamic Memory Management（EDMM）的方式去进行扩展。当你的OS支持EDMM，那么可以先创建一个比较小的enclave，然后扩展它。 通过在application中添加加载条的方式来获取用户的注意力，借此隐藏应用的加载时间。 避免频繁的enclave创建和重新加载，进而最小化重复的加载性能损耗。 Enclave切换 在enclave之间的频繁转变需要在上下文之间切换非常多次。当一个EENTER指令触发进入enclave时，为了保证enclave可以正常运行，属于不可信运行时的注册状态（register state）和其它信息被存储，enclave中的线程状态和其它属于可信状态的信息被加载，这部分工作主要是由SDK生成的代码执行。一个相反的过程发生在从enclave中退出（被EEXIT指令触发）：可信线程状态信息被保存，不可信的注册状态和其它信息被还原，在这个过程中同样执行着安全检查，这部分工作也主要由SDK生成的代码自动执行。这些行为构成了在应用和enclave之间控制权切换所带来的固定负载。 然而，这个转变中有一些可变变量影响着损耗，即传递参数的大小。参数在从不可信应用部分到可信enclave传递的过程中被序列化，并且返回值被反序列化。在可信enclave中，来自不可信应用的参数被反序列化，并且将返回值序列化。如果应用传递大量的参数，将会有显著的性能损耗。 如果在enclave和应用之间的控制权的转变很大程度地冲击着性能，考虑通过通过以下的方式降低影响： 减小传递参数的总大小。（使用工具：Intel VTunte Amplifier） 当确实有大量数据需要进行传递的时候，考虑使用指针的方式。需要说明的是，使用指针会带来一部分安全风险，为此你必须自己去实现指针检查器，如果使用这种方式的话。 过多缓存未命中 encalve所存储的内存内容在处理器cache之外的部分都是加密受保护的。这种类型的保护在从内存中获取cache lines带来了相应的负载。这种负载和Intel SGX实现方式有直接关系。 Intel SGX架构中在缓存未命中的情况下，相对于其他传统的负载，新增了两种类型的负载： 对于不在处理器cache中的每一条cache line所执行的完成check/anti-replay 检查，以及在系统内存中更新相应的数据结构（如果必要的话）。这种类型的负载依赖于内存访问模式。 在cache和内存中加载和移除数据所带来的加解密。 如果你的系统受到大量的缓存未命中而相关的性能损耗的冲击，可以考虑下面的步骤： 减小enclave中的数据的大小。观察数据，以保证只有必要的数据才能装载进入enclave中。更少的数据意味着更少的加减密和更少的数据结构检查，在Intel SGX内存控制/保护机制下。可以使用Intel VTune Amplifier来观察应用中的cache行为。 可以查看下面的文档去创建一个更加“缓存友好”的应用：PDF地址 过多的页写入 需要考虑Intel SGX应用频繁大量的页面切换对性能的影响，并且如何最小化这方面的后果： Intel SGX使用安全存储 EPC 来存储enclave中的内容。Enclave页面大小为4KB。当enclave比EPC总可用的内存要大的话，enclave分页机制可能会被某些特权软件来使用。当OS尝试交换enclave页面时，CPU使用EWB指令执行以下的步骤： 读取要替换出去的Intel SGX页面（移出） 加密页面中的内容 将加密的页面写到未收到保护的系统内存中 由于这个过程有着固定的负载，因此越多的页面被替换出去，越多的性能损耗发生。为了阻止应用频繁经历这种页面的交换，尽可能确保enclave的大小小于EPC。尽可能只将秘密数据和在这之上的操作放入enclave中，从而最小化页面交换的可能性。可以使用Intel VTune Amplifier工具来观察应用中页面替换的行为，来保证做出正确的决定 多线程下的性能 如果应用是多线程的，从数据同步，锁，线程模型和内存分配算法上去寻找改善性能的方法。 Intel SGX SDK 的一些关于同步和锁的原语已经被优化。 对于较重的多线程应用，推荐选择更好的内存分配算法。Intel SGX SDK针对linux提供了TCMalloc内存分配算法，相对于默认的dlmalloc内存分配算法，有着更好的性能表现。","categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"SGX程序基础","slug":"instruction/sgx-programming","date":"2020-11-23T16:00:00.000Z","updated":"2022-06-20T14:09:37.010Z","comments":true,"path":"2020/11/24/instruction/sgx-programming/","link":"","permalink":"http://example.com/2020/11/24/instruction/sgx-programming/","excerpt":"Intel SGX程序SampleCode Notes","text":"项目目录结构 以SampleEnclave为例，目录结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940.├── App│ ├── App.cpp│ ├── App.h│ ├── Edger8rSyntax│ │ ├── Arrays.cpp│ │ ├── Functions.cpp│ │ ├── Pointers.cpp│ │ └── Types.cpp│ └── TrustedLibrary│ ├── Libc.cpp│ ├── Libcxx.cpp│ └── Thread.cpp├── Enclave│ ├── Edger8rSyntax│ │ ├── Arrays.cpp│ │ ├── Arrays.edl│ │ ├── Functions.cpp│ │ ├── Functions.edl│ │ ├── Pointers.cpp│ │ ├── Pointers.edl│ │ ├── Types.cpp│ │ └── Types.edl│ ├── Enclave.config.xml│ ├── Enclave.cpp│ ├── Enclave.edl│ ├── Enclave.h│ ├── Enclave.lds│ ├── Enclave_private_test.pem│ └── TrustedLibrary│ ├── Libc.cpp│ ├── Libc.edl│ ├── Libcxx.cpp│ ├── Libcxx.edl│ ├── Thread.cpp│ └── Thread.edl├── Include│ └── user_types.h├── Makefile└── README.txt App目录：存放应用程序中的不可信代码部分 App.cpp文件：应用程序中的不可信部分代码，其中包括了创建Enclave及销毁Enclave的代码，也定义了一些相关的返回码供使用者查看Enclave程序的执行状态。其中的main函数是整个项目的入口函数。 App.h文件：应用程序中的不可信部分代码的头文件，定义了一些宏常量和函数声明。 Edger8rSyntax文件夹：提供了一些工具。 TrustedLibrary文件夹：提供了一些函数库。 Enclave目录：存放应用程序中的可信代码部分和可信与不可信代码接口文件 Enclave.config.xml文件：Enclave的配置文件，定义了Enclave的元数据信息。 Enclave.cpp文件：应用程序中的可信部分代码，包括了可信函数的实现。 Enclave.h文件：应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明。 Enclave.edl文件：Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口，trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。 Enclave.lds文件：定义了一些Enclave可执行文件信息。 Enclave_private_test.pem文件：SGX生成的私钥。 Edger8rSyntax文件夹：提供了一些工具。 TrustedLibrary文件夹：提供了一些函数库。 Include目录：存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义 user_types.h文件：定义了用户自定义的类型 Makefile文件：项目的编译文件，定义了项目的编译信息","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"}]},{"title":"Ubuntu将安装的应用固定到桌面","slug":"instruction/ubuntu-show-application","date":"2020-11-23T10:23:08.000Z","updated":"2022-04-28T07:22:22.000Z","comments":true,"path":"2020/11/23/instruction/ubuntu-show-application/","link":"","permalink":"http://example.com/2020/11/23/instruction/ubuntu-show-application/","excerpt":"Ubuntu20.04将国内版本的firefox固定到桌面","text":"升级了一下ubuntu，从18.04升到了20.04，发现自动安装了国际版的firefox，之前安装的国内版firefox目录还在/opt下，但是桌面显示的firefox是国际版的，且启动栏也没有国内版的firefox应用。 Step1 卸载国际版firefox 12dpkg --get-selections | grep firefoxsudo apt-get purge firefox ... # 所有上一步列出的应用 Step2 在/usr/share/applications/目录新建firefox.desktop，并添加内容： 123456[Desktop Entry]Name&#x3D;FirefoxExec&#x3D;&#x2F;opt&#x2F;firefox&#x2F;firefoxIcon&#x3D;&#x2F;opt&#x2F;firefox&#x2F;browser&#x2F;chrome&#x2F;icons&#x2F;default&#x2F;default128.pngTerminal&#x3D;FalseType&#x3D;Application Step3 更改firefox.desktop文件权限： 1sudo chmod 755 firefox.desktop Step4 在启动栏可以看见新建的应用图标，并且可以添加到侧边栏","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Rust - Learn","slug":"learning-notes/Rust-notes","date":"2020-11-15T16:00:00.000Z","updated":"2022-04-28T07:34:00.000Z","comments":true,"path":"2020/11/16/learning-notes/Rust-notes/","link":"","permalink":"http://example.com/2020/11/16/learning-notes/Rust-notes/","excerpt":"Rust基础学习笔记","text":"Ch0 安装Rust 使用rustup安装 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装时出现的问题（未完全解决）：默认.cargo环境变量设置为了/home/&lt;username&gt;/~/.cargo，导致在用户家目录下又新建了~目录，在安装完rust后，将.cargo目录移动到~/家目录下，并修改所有可能会更改环境变量的文件，包括~/.profile、/etc/profile、/etc/bash.bashrc、~/.cargo/env，将其中的/home/&lt;username&gt;/~/.cargo改为~/.cargo。但是每当打开终端时，环境变量PATH还是会自动添加/home/&lt;username&gt;/~/.cargo/bin 暂时的解决方案：在~/.bashrc文件中添加语句，覆盖错误的环境变量(重启后就成功了) 1export PATH=~/.cargo/bin:$PATH Ch1 Cargo 1.1 使用Cargo创建项目 创建hello_world目录，并在其中新建二进制项目hello_world 1$ cargo new hello_world 创建库项目 1$ cargo new hello_world --lib 1.1.1 Cargo.toml Cargo.toml是项目的配置文件，通过cargo new自动生成 1234567[package]name = &quot;hello_world&quot;version = &quot;0.1.0&quot;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]edition = &quot;2018&quot;[dependencies] [package]片段：配置一个包，包含项目名称、版本、作者和Rust版本 [dependencies]片段：罗列项目依赖 1.1.2 源代码目录src 包含main.rs以及其他源文件 1.2 构建并运行Cargo项目 编译项目 1$ cargo build 编译并运行项目 1$ cargo run 快速检查代码确保其可以编译，但不生成可执行文件 1$ cargo check 以上命令会生成以下文件： 1.2.1 可执行文件 存放目录为./target/debug/hello_world 1.2.2 Cargo.lock Cargo.lock记录项目依赖的实际版本，确保项目构建是可重现的，这个文件不需要人为修改 1.3 发布(release)构建 当项目最终准备好发布时，可以优化编译项目是的Rust代码运行更快 1$ cargo build --release 此时生成的可执行文件在./target/release/目录下 Ch2 引入 - guess_number 2.1 创建变量 1let mut guess = String::new(); let 创建变量，变量默认不可变 mut 使得变量可变 :: 表明new是String类型的一个关联函数 2.2 从标准输入读取 123use std::io;io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;); io::stdin函数返回一个终端标准输入句柄 read_line将标准输入存入字符串 &amp;表示这个参数是一个引用 read_line函数返回一个Result类型（枚举），成员有Ok和Err Result实例有expect方法： 若Result值为Ok，expect获取Ok中的值并原样返回 若Result值为Err，expect导致程序崩溃，并显式当做参数传给expect的信息 2.3 crate crate是一个Rust代码包 我们构建的项目是一个二进制crate rand crate是一个库crate 2.3.1 导入外部crate 以rand crate为例 在使用rand编写代码之前需要修改Cargo.toml文件 123[dependencies]rand = &quot;0.5.5&quot; 再进行cargo build，此时会从Crates.io拷贝数据并下载对应的库文件，需要更换国内镜像源进行加速，编辑.cargo/config文件，加入以下内容 12345[source.crates-io]registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;replace-with &#x3D; &#39;ustc&#39;[source.ustc]registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot; 2.3.2 更新crate 1$ cargo update 2.3.3 获取所有本地依赖提供的文档 查看应该 use哪个trait以及该从crate中调用哪个方法 1$ cargo doc --open Ch3 常见编程概念 3.1 变量和可变性 使用let声明的变量默认是不可改变的 12let x = 3;x = 5; // 非法 在变量名之前加mut来使其可变 12let mut x = 3;x = 5; // 合法 3.1.1 变量和常量的区别 常量使用关键字const声明，并且必须注明值的类型 不能对常量使用mut 常量只能被设置为常量表达式，而不能是函数调用的结果 3.1.2 隐藏 定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量 12let x = 5;let x = x + 1; 当再次使用let时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字 3.2 数据类型 Rust 是 静态类型语言，在编译时就必须知道所有变量的类型 3.2.1 标量类型 标量类型代表一个单独的值 整型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 数字字面值 例子 Decimal 98_222 Hex 0xff Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b'A' 浮点型 Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位 默认类型是 f64 布尔型 bool，两个可能的值true和false 字符类型 char 类型的大小为四个字节，并代表了一个 Unicode 标量值 3.2.2 复合类型 元组类型 元组长度固定：一旦声明，其长度不会增大或缩小 元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的 12345let tup: (i32, f64, u8) = (500, 6.4, 1);let (x, y, z) = tup; // 解构let five_hundred = tup.0; // 使用索引访问 数组类型 数组中的每个元素的类型必须相同 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小 1234567let a = [1, 2, 3, 4, 5];let a: [i32; 5] = [1, 2, 3, 4, 5];let b = [0; 10]; // 初始化一个长度为10的全零数组let first = a[0]; // 使用索引访问 3.3 函数 fn 关键字声明新函数 在函数签名中，必须声明每个参数的类型 1234fn another_function(x: i32, y: i32) &#123; println!(&quot;The value of x is: &#123;&#125;&quot;, x); println!(&quot;The value of y is: &#123;&#125;&quot;, y);&#125; 3.3.1 具有返回值的函数 以表达式结尾 123fn plus_one(x: i32) -&gt; i32 &#123; x + 1&#125; 3.4 注释 // 单行注释 3.5 控制流 3.5.1 if表达式 123456789if number % 4 == 0 &#123; println!(&quot;number is divisible by 4&quot;);&#125; else if number % 3 == 0 &#123; println!(&quot;number is divisible by 3&quot;);&#125; else if number % 2 == 0 &#123; println!(&quot;number is divisible by 2&quot;);&#125; else &#123; println!(&quot;number is not divisible by 4, 3, or 2&quot;);&#125; Rust 不会尝试自动地将非布尔值转换为布尔值，所以if后跟的表达式必须是bool 在let语句中使用if 12345let number = if condition &#123; 5&#125; else &#123; 6&#125;; 代码块的值是其最后一个表达式的值 if和else中返回的类型要相同 3.5.2 循环 loop 无限循环，直到按下ctrl+c，或有break 内循环可以 continue 或者 break 外循环，此时需要在外循环添加生命周期： 1234567891011121314#![allow(unreachable_code)]fn main() &#123; &#x27;outer: loop &#123; println!(&quot;Entered the outer loop&quot;); &#x27;inner: loop &#123; println!(&quot;Entered the inner loop&quot;); // This would break only the inner loop //break; // This breaks the outer loop break &#x27;outer; &#125; &#125;&#125; loop 可以返回值，返回 break 后的表达式 12345678910fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; &#125; &#125;; assert_eq!(result, 20);&#125; while 12345let mut number = 3;while number != 0 &#123; println!(&quot;&#123;&#125;!&quot;, number); number = number - 1;&#125; for遍历集合 123456789101112131415161718let a = [10, 20, 30, 40, 50];// iter引用集合a，在循环结束后仍然可以使用afor element in a.iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element);&#125;// into_iter移动集合a的所有权，在循环结束后不能使用afor element in a.into_iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element);&#125;let mut b = [1, 2, 3];// iter_mut引用可变集合b，可以在循环中改变b中的元素for element in b.iter_mut() &#123; *element += 1;&#125; Ch4 所有权 4.1 什么是所有权 Rust管理内存的方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查 4.1.1 所有权规则： Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 值有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 4.1.2 变量作用域 12345&#123; // s 在这里无效, 它尚未声明 let s = &quot;hello&quot;; // 从此处起，s 是有效的 // 使用 s&#125; // 此作用域已结束，s 不再有效 4.1.3 String类型 字符串的字面值是不可变的，而String类型的字符串是可变的 String类型的字符串被分配到堆上，所以能够存储在编译时未知大小的文本 12// 基于字符串字面值来创建Stringlet s = String::from(&quot;hello&quot;); 4.1.4 内存与分配 对于String类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着： 必须在运行时向操作系统请求内存 需要一个当我们处理完String时将内存返回给操作系统的方法 Rust处理第二点的策略：内存在拥有它的变量离开作用域后就被自动释放 4.1.5 存储在堆上的变量 1. 移动 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; String 由三部分组成，如上图所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。 当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做二次释放的错误，两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。 在Rust中，经过以上语句，会认为s1不再有效，即s1 被移动到了 s2 中，因此当s1离开作用域时不会释放内存。 克隆 12let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone(); s2深度复制了s1堆上的内容，而不仅仅是栈上的指针。 以上只针对存储在堆上的类型，而对于类似整型等存储在栈上的类型，可以直接拷贝，变量值不会被移动 4.1.6 所有权与函数 123456789101112131415161718192021222324fn main() &#123; let s1 = gives_ownership(); // gives_ownership 将返回值移给 s1 let s2 = String::from(&quot;hello&quot;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃fn gives_ownership() -&gt; String &#123; // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数&#125;// takes_and_gives_back 将传入字符串并返回该值fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数&#125; 4.2 引用与借用 当String类型的变量传入函数中时，如何以引用的方式传入而不是将所有权交给函数？ 12345678910fn main() &#123; let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);&#125;fn calculate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权， // 所以什么也不会发生 &amp;s1语法让我们创建一个指向值s1的引用，但是并不拥有它 我们将获取引用作为函数参数称为借用 引用默认不允许被修改 4.2.1 可变引用 12345678fn main() &#123; let mut s = String::from(&quot;hello&quot;); change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(&quot;, world&quot;);&#125; 可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用，如以下代码是非法的： 12345let mut s = String::from(&quot;hello&quot;);// s被引用了两次，非法let r1 = &amp;mut s;let r2 = &amp;mut s; 这样的限制可以避免数据竞争，即 两个或更多指针同时访问同一数据 至少有一个指针被用来写入数据。 没有同步数据访问的机制 可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能同时拥有 12345let mut s = String::from(&quot;hello&quot;);&#123; let r1 = &amp;mut s;&#125; // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用let r2 = &amp;mut s; 可变引用和不可变引用不能同时存在，如以下代码非法： 1234567let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题let r3 = &amp;mut s; // 大问题println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3); 由于一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，所以以下代码合法： 123456789let mut s = String::from(&quot;hello&quot;);let r1 = &amp;s; // 没问题let r2 = &amp;s; // 没问题println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);// 此位置之后 r1 和 r2 不再使用let r3 = &amp;mut s; // 没问题println!(&quot;&#123;&#125;&quot;, r3); 4.2.2 悬垂引用 所谓悬垂指针是其指向的内存可能已经被分配给其它持有者 在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域，如以下函数非法： 1234fn dangle() -&gt; &amp;String &#123; // dangle 返回一个字符串的引用 let s = String::from(&quot;hello&quot;); // s 是一个新字符串 &amp;s // 返回字符串 s 的引用&#125; // 这里 s 离开作用域并被丢弃。其内存被释放。危险！ 而应该直接返回String，将所有权移动出去 4.3 Slice类型 slice是一个没有所有权的数据类型 slice允许你引用集合中一段连续的元素序列，而不用引用整个集合 4.3.1 字符串slice 字符串 slice是String中一部分值的引用 12345let s = String::from(&quot;hello world&quot;);let hello = &amp;s[0..5];let world = &amp;s[6..11];let all_s = &amp;s[..]; 字符串字面值就是slice，如let s = &quot;Hello world&quot;中，s的类型是&amp;str，是一个指向二进制程序特定位置的slice 4.3.2 其他类型的slice 如数组slice: 123let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3]; Ch5 结构体 5.1 结构体的定义和实例化 123456789101112131415161718// 定义struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125;// 实例化let mut user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1,&#125;;// 获取并修改字段user1.email = String::from(&quot;anotheremail@example.com&quot;); 想要修改实例中的字段，必须将整个结构体声明为可变 12345let user2 = User &#123; email: String::from(&quot;another@example.com&quot;), username: String::from(&quot;anotherusername567&quot;), ..user1&#125;; ..语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值 5.1.1 元组结构体 元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型 12345struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0);let origin = Point(0, 0, 0); 5.1.2 结构体数据的所有权 结构体可以直接存放自身拥有所有权的类型，如String等 结构体在存储引用、slice等没有自身所有权的类型时，需要用上生命周期 5.2 结构体引用和打印 5.2.1 函数调用结构体 函数引用结构体时，不需要获得其所有权，所以采用引用的方式调用: 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, area(&amp;rect1) );&#125;fn area(rectangle: &amp;Rectangle) -&gt; u32 &#123; rectangle.width * rectangle.height&#125; 5.2.2 结构体打印 需要使用派生trait 1234567891011#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1); // 或 println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);&#125; 5.3 方法语法 使用关键字impl给结构体定义方法，可以避免另外定义函数 1234567891011121314151617181920#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 将self以不可变引用的方式调用 fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, rect1.area() );&#125; 5.3.1 关联函数 在impl块中定义不以self作为参数的函数，通常用作返回一个结构体实例的构造函数： 123456789101112#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 返回一个正方形的实例 fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, height: size &#125; &#125;&#125; 使用let sq = Rectangle::square(3);调用关联函数 Ch6 枚举和模式匹配 6.1 定义枚举 以IP地址类型为例，通过enum定义一个枚举类型： 1234enum IpAddrKind &#123; V4(u8, u8, u8, u8), V6(String),&#125; 创建IpAddrKind实例： 12let four = IpAddrKind::V4(127.0.0.1);let six = IpAddrKind::V6(String::from(&quot;::1&quot;)); 枚举类型也可以像结构体一样使用impl为其定义方法 6.1.1 Option枚举 Option是标准库定义的另一个枚举，且被包含在preclude中 Rust没有空值，但拥有Option枚举来编码存在或不存在 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; Some可以包含任意类型的数据 使用None需要指定类型 1234let some_number = Some(5);let some_string = Some(&quot;a string&quot;);let absent_number: Option&lt;i32&gt; = None; Option&lt;T&gt;类型的值不能和T类型的值直接运算，必须提前进行转换，因此空值在使用前必须被检查 6.2 match控制流运算符 123456789101112131415161718enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(&quot;Lucky penny!&quot;); 1 &#125;, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个match表达式的返回值 6.2.1 匹配Option&lt;T&gt; 12345678910fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125;let five = Some(5);let six = plus_one(five);let none = plus_one(None); 用于空值处理 匹配是有穷的，必须覆盖变量的所有情况 6.2.2 _通配符 可以在match的所有分支的最后使用_来匹配剩余的所有情况 12345678let some_u8_value = 0u8;match some_u8_value &#123; 1 =&gt; println!(&quot;one&quot;), 3 =&gt; println!(&quot;three&quot;), 5 =&gt; println!(&quot;five&quot;), 7 =&gt; println!(&quot;seven&quot;), _ =&gt; (),&#125; 6.3 if let 简单控制流 123456let some_u8_value = Some(0u8);if let Some(3) = some_u8_value &#123; println!(&quot;three&quot;);&#125; else &#123; println!(&quot;other&quot;);&#125; 可以用于替代只有两分支的match语句 Ch7 使用包、Crate和模块管理项目 7.1 包和crate crate是一个二进制项或者库 包 (package) 是提供一系列功能的一个或者多个 crate，一个包会包含有一个Cargo.toml文件，阐述如何去构建这些 crate 一个包中至多只能包含一个库 crate 一个包中可以包含任意多个二进制 crate 一个包中至少包含一个 crate，无论是库的还是二进制的 使用cargo new创建项目时，src/main.rs就是一个与包同名的二进制 crate 的 crate根 通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate 7.2 模块 模块定义： 123456789101112mod front_of_house &#123; mod hosting &#123; fn add_to_waitlist() &#123;&#125; fn seat_at_table() &#123;&#125; &#125; mod serving &#123; fn take_order() &#123;&#125; fn server_order() &#123;&#125; fn take_payment() &#123;&#125; &#125;&#125; 对应的模块树： 123456789crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 7.3 引用模块树中项的路径 路径的两种形式，都是通过::连接： **绝对路径 ** 从 crate 根开始，以 crate 名或者字面值 crate 开头。 相对路径 从当前模块开始，以 self、super 或当前模块的标识符开头。 7.3.1 使用pub关键字暴露路径 Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，父模块不能使用子模块的私有项，但子模块可以使用父模块中的项，同级的两个模块可以互相引用 当父模块需要使用子模块的项的，需要在子模块中将其声明为pub 7.3.2 使用super起始的相对路径 super相当于文件系统中的..，即当前模块的父模块 7.3.3 创建公有的结构体和枚举 如果在一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的 1234567891011121314151617181920212223mod back_of_house &#123; pub struct Breakfast &#123; pub toast: String, seasonal_fruit: String, &#125; impl Breakfast &#123; pub fn summer(toast: &amp;str) -&gt; Breakfast &#123; Breakfast &#123; toast: String::from(toast), seasonal_fruit: String::from(&quot;peaches&quot;), &#125; &#125; &#125;&#125;pub fn eat_at_restaurant() &#123; // Order a breakfast in the summer with Rye toast let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;); // Change our mind about what bread we&#x27;d like meal.toast = String::from(&quot;Wheat&quot;); println!(&quot;I&#x27;d like &#123;&#125; toast please&quot;, meal.toast);&#125; 因为 back_of_house::Breakfast 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造实例 Breakfast，否则无法在 eat_at_restaurant 中创建实例 7.4 use关键字 使用use关键字可以简化模块中项的调用： 123456789101112131415mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;use crate::front_of_house::hosting; // 绝对路径// 或 use front_of_house::hosting; 相对路径pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;fn main() &#123;&#125; 可以使用 as 关键字提供新名称 123456789101112use std::fmt::Result;use std::io::Result as IoResult;fn function1() -&gt; Result &#123; // --snip--# Ok(())&#125;fn function2() -&gt; IoResult&lt;()&gt; &#123; // --snip--# Ok(())&#125; 当使用 use 关键字将名称导入作用域时，在新作用域中可用的名称是私有的，可以使用 pub use 重导出，使得名称可以引入任何代码的作用域中 7.4.1 使用嵌套路径精简代码 123456789use std::cmp::Ordering;use std::io;// 可以精简为：use std::&#123;cmp::Ordering, io&#125;;use std::io;use std::io::Write;// 可以精简为：use std::io::&#123;self, Write&#125;; 7.4.2 glob运算符 如果希望将一个路径下所有公有项引入作用域，可以指定路径后跟 * 1use std::collections::*; 7.5 将模块分割进不同文件 先使用如下语句引入模块： 1mod front_of_house; Ch8 常见集合 8.1 vector 在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值 vector 只能储存相同类型的值 8.1.1 新建vector 新建空vector时需要指明类型 1let v: Vec&lt;i32&gt; = Vec::new(); 使用 vec! 宏来定义含有初值的vector 1let v = vec![1, 2, 3]; 8.1.2 vector添加元素 1234let mut v = Vec::new();v.push(5);v.push(6); 当vector离开作用域时，会连同其元素全部销毁 8.1.3 读取vector元素 1let v = vec![1, 2, 3, 4, 5]; 使用索引访问，若越界，则会报错崩溃(适用于访问边界严格的vector) 12let third: &amp;i32 = &amp;v[2];println!(&quot;The third element is &#123;&#125;&quot;, third); 使用 get 方法返回一个 Option&lt;&amp;T&gt;，若越界，则会返回None(适用于vector索引可能由用户输入而越界) 1234match v.get(2) &#123; Some(third) =&gt; println!(&quot;The third element is &#123;&#125;&quot;, third), None =&gt; println!(&quot;There is no third element.&quot;),&#125; 当获取了vector的一个元素的不可变引用后，不能在其末尾添加元素，如下代码非法： 1234let mut v = vec![1, 2, 3, 4, 5];let first = &amp;v[0];v.push(6); 8.1.4 遍历vector中的元素 遍历不可变引用 1234let v = vec![100, 32, 57];for i in &amp;v &#123; println!(&quot;&#123;&#125;&quot;, i);&#125; 遍历可变引用 1234let mut v = vec![100, 32, 57];for i in &amp;mut v &#123; *i += 50;&#125; 8.1.5 结合枚举来存储多种类型 1234567891011enum SpreadsheetCell &#123; Int(i32), Float(f64), Text(String),&#125;let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(&quot;blue&quot;)), SpreadsheetCell::Float(10.12),]; 8.2 字符串 8.2.1 新建字符串 新建空字符串 1let mut s = String::new(); 往空字符串中装载数据 1let s = &quot;initial contents&quot;.to_string(); 新建有初始值的字符串 1let s = String::from(&quot;initial contents&quot;); 8.2.2 更新字符串 使用 push_str 方法来附加字符串 slice 12let mut s = String::from(&quot;foo&quot;);s.push_str(&quot;bar&quot;); 使用 push 附加一个字符 12let mut s = String::from(&quot;lo&quot;);s.push(&#x27;l&#x27;); 使用 + 运算符 123let s1 = String::from(&quot;Hello, &quot;);let s2 = String::from(&quot;world!&quot;);let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用 使用 format! 宏 12345let s1 = String::from(&quot;tic&quot;);let s2 = String::from(&quot;tac&quot;);let s3 = String::from(&quot;toe&quot;);let s = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, s1, s2, s3); 8.2.3 索引字符串 Rust的 String 字符串不支持索引单个值，但能够创建字符串slice 12let hello = &quot;Здравствуйте&quot;;let s = &amp;hello[0..4]; 8.2.4 遍历字符串 遍历每个元素（每个元素可能不止一个字节） 123for c in &quot;नमस्ते&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; 遍历每个原始字节 123for b in &quot;नमस्ते&quot;.bytes() &#123; println!(&quot;&#123;&#125;&quot;, b);&#125; 8.3 哈希map HashMap&lt;K, V&gt; 类型储存了一个键类型 K 对应一个值类型 V 的映射 8.3.1 新建一个哈希map 12345678use std::collections::HashMap;// 新建一个空的Hashmaplet mut scores = HashMap::new();// 插入键值对scores.insert(String::from(&quot;Blue&quot;), 10);scores.insert(String::from(&quot;Yellow&quot;), 50); 哈希 map 将它们的数据储存在堆上 所有的键必须是相同类型，值也必须都是相同类型 也可以通过vector的 collect 方法创建 123456use std::collections::HashMap;let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];let initial_scores = vec![10, 50];let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect(); 8.3.2 哈希map和所有权 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map 对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者 8.3.3 访问哈希map中的值 12let team_name = String::from(&quot;Blue&quot;);let score = scores.get(&amp;team_name); get 方法返回的 score 是 Option&lt;T&gt; 类型 8.3.4 遍历哈希map 123for (key, value) in &amp;scores &#123; println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);&#125; 8.3.5 更新哈希map 使用相同的键插入不同的值，会覆盖旧值 使用 entry 方法，只有在键没有对应的值存在的时候插入 12scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);scores.entry(String::from(&quot;Blue&quot;)).or_insert(50); 根据旧值更新一个值 123456789101112use std::collections::HashMap;// 统计单词出现的次数let text = &quot;hello world wonderful world&quot;;let mut map = HashMap::new();for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); *count += 1;&#125;println!(&quot;&#123;:?&#125;&quot;, map); or_insert 方法事实上会返回这个键的值的一个可变引用（&amp;mut V） Ch9 错误处理 9.1 panic!与不可恢复的错误 遇到错误时，Rust 有 panic!宏，当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出 9.1.1 backtrace backtrace 是一个执行到目前位置所有被调用的函数的列表 使用backtrace来找到自己写的代码中错误出在哪一行 1$ RUST_BACKTRACE=1 cargo run 9.2 Result与可恢复的错误 Result 枚举： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; T 代表成功时返回的 Ok 成员中的数据的类型 E 代表失败时返回的 Err 成员中的错误的类型 9.2.1 匹配不同的错误 使用 match 代码比较冗长，且较难理解 123456789101112131415161718use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(&quot;hello.txt&quot;); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; match error.kind() &#123; ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) &#123; Ok(fc) =&gt; fc, Err(e) =&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e), &#125;, other_error =&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error), &#125;, &#125;;&#125; 9.2.2 unwrap 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值 如果 Result 是成员 Err，unwrap 会为我们调用 panic! 12345use std::fs::File;fn main() &#123; let f = File::open(&quot;hello.txt&quot;).unwrap();&#125; 9.2.3 expect 12345use std::fs::File;fn main() &#123; let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);&#125; 使用方法类似 unwrap ，但是可以自己指定显示的错误信息 9.2.4 传播错误 12345678910111213use std::io;use std::io::Read;use std::fs::File;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; // 若文件打开失败，函数会返回相应的错误 let mut f = File::open(&quot;hello.txt&quot;)?; let mut s = String::new(); // 若文件内容写入字符串失败，函数会返回相应的错误 f.read_to_string(&amp;mut s)?; // 若函数执行完成没有出错，则返回Ok Ok(s)&#125; Rust提供了fs::read_to_string 的函数来简化从文件读取到一个字符串中的操作： 123456use std::io;use std::fs;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; fs::read_to_string(&quot;hello.txt&quot;)&#125; 9.3 panic!的使用场景 在当有可能会导致有害状态的情况下建议使用 panic! —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况： 有害状态并不包含 预期 会偶尔发生的错误 之后的代码的运行依赖于处于这种有害状态 当没有可行的手段来将有害状态信息编码进所使用的类型中的情况 Ch10 泛型、trait和生命周期 10.1 泛型 使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型 10.1.1 在函数定义中使用泛型 12345678910fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list.iter() &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，所以需要在函数名称之后写上 &lt;T&gt; 10.1.2 结构体定义中的泛型 字段 x 和 y 必须是相同的类型 123456789struct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; 字段 x 和 y 可以是不同的类型 12345678910struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;fn main() &#123; let both_integer = Point &#123; x: 5, y: 10 &#125;; let both_float = Point &#123; x: 1.0, y: 4.0 &#125;; let integer_and_float = Point &#123; x: 5, y: 4.0 &#125;;&#125; 10.1.3 枚举定义中的泛型 Option&lt;T&gt; 枚举： 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; Result&lt;T, E&gt; 枚举： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; 10.1.4 方法定义中的泛型 123456789101112131415struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Point&lt;T&gt; &#123; fn x(&amp;self) -&gt; &amp;T &#123; &amp;self.x &#125;&#125;fn main() &#123; let p = Point &#123; x: 5, y: 10 &#125;; println!(&quot;p.x = &#123;&#125;&quot;, p.x());&#125; 在 Point&lt;T&gt; 结构体上实现方法 x，它返回 T 类型的字段 x 的引用 必须在 impl 后面声明 T，这样 Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型 10.1.5 泛型代码的性能 Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失 Rust 通过在编译时进行泛型代码的单态化来保证效率，即在编译时填充泛型所使用的具体类型，从而将通用代码转换为特定代码 10.2 trait：定义共享的行为 trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能 10.2.1 定义并使用trait 12345678910111213141516171819202122232425262728293031pub trait Summary &#123; // 实现这个 trait 的类型所需要的行为的方法签名 fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;// 在impl关键字之后，提供需要实现trait的名称，接着是for和需要实现trait的类型的名称impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content) &#125;&#125; 只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait 不能为外部类型实现外部 trait：例如，不能在 aggregator crate 中为 Vec&lt;T&gt; 实现 Display trait。这是因为 Display 和 Vec&lt;T&gt; 都定义于标准库中，它们并不位于 aggregator crate 本地作用域中 10.2.2 默认实现 有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为 123456// trait提供默认实现pub trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; String::from(&quot;(Read more...)&quot;) &#125;&#125; 10.2.3 trait作为参数 123pub fn notify(item: impl Summary) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 对于 item 参数，指定了 impl 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 notify 函数体中，可以调用任何来自 Summary trait 的方法，比如 summarize 使用trait bound重写上面的函数 123pub fn notify&lt;T: Summary&gt;(item: T) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; trait bound适合函数传入多个相同类型的参数 12345// item1和item2的类型可以不同，只要它们都实现了Summarypub fn notify(item1: impl Summary, item2: impl Summary) // item1和item2的类型必须相同pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) 指定多个trait bound 123pub fn notify(item: impl Summary + Display)// 或pub fn notify&lt;T: Summary + Display&gt;(item: T) 通过 where 简化trait bound 1234fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32 where T: Display + Clone, U: Clone + Debug&#123; 10.2.4 返回trait类型 12345678fn returns_summarizable() -&gt; impl Summary &#123; Tweet &#123; username: String::from(&quot;horse_ebooks&quot;), content: String::from(&quot;of course, as you probably already know, people&quot;), reply: false, retweet: false, &#125;&#125; 通过使用 impl Summary 作为返回值类型，我们指定了 returns_summarizable 函数返回某个实现了 Summary trait 的类型，但是不确定其具体的类型 只适用于返回单一类型的情况，如果有分支结构，每个分支返回不同类型，则编译不能通过 10.3 生命周期与引用有效性 10.3.1 生命周期防止悬垂引用 Rust 编译器有一个借用检查器，它比较作用域来确保所有的借用都是有效的 避免了引用比数据的生命周期短的情况 10.3.2 函数的泛型生命周期 1234567891011121314fn main() &#123; let string1 = String::from(&quot;abcd&quot;); let string2 = &quot;xyz&quot;; let result = longest(string1.as_str(), string2); println!(&quot;The longest string is &#123;&#125;&quot;, result);&#125;fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 x 或 y 生命周期注解语法 123&amp;i32 // 引用&amp;&#x27;a i32 // 带有显式生命周期的引用&amp;&#x27;a mut i32 // 带有显式生命周期的可变引用 当有两个或以上的引用参数的生命周期注解都定义为 &amp;'a i32 ，则这些参数的生命周期必须与这泛型生命周期一样长 函数签名中的生命周期注解 12345678// 重写上面的longest函数，指定了签名中所有的引用必须有相同的生命周期&#x27;afn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 10.3.3 结构体定义生命周期注解 有生命周期注解的结构体可以存放引用 123struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125; 10.3.4 生命周期省略 编译器采用三条规则来判断引用何时不需要明确的注解，这些规则适用于 fn 定义，以及 impl 块 每一个是引用的参数都有它自己的生命周期参数 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数 如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 &amp;self 或 &amp;mut self，那么 self 的生命周期被赋给所有输出生命周期参数 10.3.5 方法定义中的生命周期注解 （实现方法时）结构体字段的生命周期必须总是在 impl 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。 12345678910struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125; 10.3.6 静态生命周期 'static 其生命周期能够存活于整个程序期间 所有的字符串字面值都拥有 'static 生命周期 Ch11 编写自动化测试 11.1 如何编写测试 Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作： 设置任何所需的数据或状态 运行需要测试的代码 断言其结果是我们所期望的 11.1.1 测试函数剖析 为了将一个函数变成测试函数，需要在 fn 行之前加上 #[test] 使用 cargo test 命令运行测试 使用 Cargo 新建一个库项目时，它会自动为我们生成一个测试模块和一个测试函数 1234567#[cfg(test)]mod tests &#123; #[test] fn exploration() &#123; assert_eq!(2 + 2, 4); &#125;&#125; 11.1.2 使用assert!宏来检查结果 如果值是 true，assert! 什么也不做，同时测试会通过 如果值为 false，assert! 调用 panic! 宏，这会导致测试失败 11.1.3 使用assert_eq!和assert_ne!宏来测试相等 assert_eq! 判断是否相等，assert_ne! 判断是否不等 断言失败时他们会打印出这两个值具体是什么，以便于观察测试为什么失败 11.1.4 自定义失败信息 为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值 12345678#[test]fn greeting_contains_name() &#123; let result = greeting(&quot;Carol&quot;); assert!( result.contains(&quot;Carol&quot;), &quot;Greeting did not contain name, value was `&#123;&#125;`&quot;, result );&#125; 11.1.5 使用 should_panic 检查 panic #[should_panic] 属性位于 #[test] 之后，对应的测试函数之前 这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败 11.1.6 将 Result&lt;T, E&gt; 用于测试 1234567891011#[cfg(test)]mod tests &#123; #[test] fn it_works() -&gt; Result&lt;(), String&gt; &#123; if 2 + 2 == 4 &#123; Ok(()) &#125; else &#123; Err(String::from(&quot;two plus two does not equal four&quot;)) &#125; &#125;&#125; 11.2 运行测试 11.2.1 并行或连续的运行测试 当运行多个测试时， Rust 默认使用线程来并行运行 应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境 如果有依赖，可以限制线程： 1$ cargo test -- --test-threads=1 11.2.2 显示函数输出 默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容 如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 --nocapture 参数来禁用： 1$ cargo test --nocapture 11.2.3 通过指定名字来运行部分测试 运行单个测试，向 cargo test 传递任意测试的名称来只运行这个测试 1$ cargo test one_hundred 过滤运行多个测试，指定部分测试的名称，任何名称匹配这个名称的测试会被运行，以下命令运行了所有名字中带有 add 的测试 1$ cargo test add 11.2.4 忽略某些测试 使用 ignore 属性来标记耗时的测试并排除他们 12345678910#[test]fn it_works() &#123; assert_eq!(2 + 2, 4);&#125;#[test]#[ignore]fn expensive_test() &#123; // 需要运行一个小时的代码&#125; 如果只希望运行被忽略的测试，可以使用 cargo test -- --ignored 11.3 测试的组织结构 11.3.1 单元测试 单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。 单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。 规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块。 测试模块 测试模块的 #[cfg(test)] 注解告诉 Rust 只在执行 cargo test 时才编译和运行测试代码 11.3.2 集成测试 集成测试的目的是测试库的多个部分能否一起正常工作 二进制项目，即只有 src/main.rs 而没有 src/lib.rs 不能进行集成测试 为了编写集成测试，需要在项目根目录创建一个 tests 目录，与 src 同级，可以随意在这个目录中创建任意多的测试文件 需要在文件顶部添加 use 123456use adder;#[test]fn it_adds_two() &#123; assert_eq!(4, adder::add_two(2));&#125; Ch12 I/O项目：命令行程序 12.1 接受命令行参数 使用标准库提供的函数：std::env::args ，返回一个传递给程序的命令行参数的迭代器 1234567891011use std::env;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let query = &amp;args[1]; let filename = &amp;args[2]; println!(&quot;Searching for &#123;&#125;&quot;, query); println!(&quot;In file &#123;&#125;&quot;, filename);&#125; 12.2 读取文件 使用标准库 std::fs 来处理文件 123let contents = fs::read_to_string(filename) .expect(&quot;Something went wrong reading the file&quot;);println!(&quot;With text:\\n&#123;&#125;&quot;, contents); 12.3 重构改进模块性和错误处理 在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程: 将程序拆分成 main.rs 和 lib.rs 并将程序的逻辑放入 lib.rs 中。 当命令行解析逻辑比较小时，可以保留在 main.rs 中。 当命令行解析开始变得复杂时，也同样将其从 main.rs 提取到 lib.rs 中。 经过这些过程之后保留在 main 函数中的责任应该被限制为： 使用参数值调用命令行解析逻辑 设置任何其他的配置 调用 lib.rs 中的 run 函数 如果 run 返回错误，则处理这个错误 12.4 采用测试驱动开发完善库的功能 测试驱动开发（Test Driven Development, TDD）模式，是一个软件开发技术，它遵循如下步骤： 编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。 编写或修改刚好足够的代码来使得新的测试通过。 重构刚刚增加或修改的代码，并确保测试仍然能通过。 从步骤 1 开始重复！ 12.6 将错误信息输出到标准错误 使用 eprintln! 将错误信息写入标准错误而不是标准输出 使用输出重定向： 1$ cargo run to poem.txt &gt; output.txt 若出错，会输出到标准错误，即显示在命令行，而不写入 output.txt 若正常执行，会输出到标准输出，即重定向到 output.txt Ch13 迭代器和闭包 13.1 闭包 可以保存进变量或作为参数传递给其他函数的匿名函数 使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它 13.1.1 定义闭包 12345678910use std::thread;use std::time::Duration;let expensive_closure = |num| &#123; println!(&quot;calculating slowly...&quot;); thread::sleep(Duration::from_secs(2)); num&#125;;expensive_closure(5); 闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数 如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2| 13.1.2 闭包类型推断和注解 闭包不用于暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用 闭包定义会为每个参数和返回值推断一个具体类型 如果尝试调用闭包两次，第一次使用 String 类型作为参数而第二次使用 u32，则会得到一个错误 13.1.3 使用带有泛型和Fn trait的闭包 可以创建一个存放闭包和调用闭包结果的结构体，该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值 1234567891011121314151617181920212223242526272829303132333435struct Cacher&lt;T&gt; // 闭包有一个 u32 的参数并返回一个 u32 where T: Fn(u32) -&gt; u32&#123; calculation: T, value: Option&lt;u32&gt;,&#125;impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32&#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; /*检查self.value是否已经有了一个 Some 的结果值； 如果有，它返回 Some 中的值并不会再次执行闭包*/ Some(v) =&gt; v, /* 如果 self.value 是 None， 则会调用 self.calculation 中储存的闭包， 将结果保存到 self.value 以便将来使用， 并同时返回结果值*/ None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125;&#125; 在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果。 Cacher 实现的限制： 第一次初始化 value 的值之后，就无法再改动；可以通过使 Cacher 存储一个哈希map而不是一个单独的值解决 它的应用被限制为只接受获取一个 u32 值并返回一个 u32 值的闭包 13.1.4 闭包会捕获其环境 闭包周围的作用域被称为其环境 闭包可以捕获其环境并访问其被定义的作用域的变量 123456789fn main() &#123; let x = 4; /* x 并不是 equal_to_x 的一个参数， 但equal_to_x 闭包也被允许使用变量 x， 因为它与 equal_to_x 定义于相同的作用域*/ let equal_to_x = |z| z == x; let y = 4; assert!(equal_to_x(y));&#125; 闭包有三种方式捕获其环境 FnOnce 消费从周围作用域捕获的变量。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次 FnMut 获取可变的借用值，所以可以改变其环境 Fn 从其环境获取不可变的借用值 13.2 迭代器 迭代器（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑 迭代器是惰性的，即在调用方法使用迭代器之前它都不会有效果 123456789let v1 = vec![1, 2, 3];// 创建一个迭代器，但是没有任何效果let v1_iter = v1.iter();/* 使用迭代器遍历，迭代器中的元素才开始迭代用 for 循环时无需使 v1_iter 可变，因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变*/for val in v1_iter &#123; println!(&quot;Got: &#123;&#125;&quot;, val);&#125; 13.2.1 Iterator trait 和 next方法 123456789// Iterator 是定义于标准库的 traitpub trait Iterator &#123; // Item类型将是迭代器next方法返回元素的类型 type Item; // next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; // 此处省略了方法的默认实现&#125; 在迭代器上直接调用 next 方法 1234567891011#[test]fn iterator_demonstration() &#123; let v1 = vec![1, 2, 3]; // 需要将迭代器定义为可变，因为next方法会改变迭代器 let mut v1_iter = v1.iter(); assert_eq!(v1_iter.next(), Some(&amp;1)); assert_eq!(v1_iter.next(), Some(&amp;2)); assert_eq!(v1_iter.next(), Some(&amp;3)); assert_eq!(v1_iter.next(), None);&#125; 13.2.2 消费适配器 调用 next 方法的方法，如 sum 123456789#[test]fn iterator_sum() &#123; let v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); // 调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权 let total: i32 = v1_iter.sum(); assert_eq!(total, 6);&#125; 13.2.3 迭代器适配器 将当前迭代器变为不同类型的迭代器，如 map 1234let v1: Vec&lt;i32&gt; = vec![1, 2, 3];// 调用 map 方法创建一个新迭代器，接着调用collect方法消费新迭代器并创建一个vectorlet v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();assert_eq!(v2, vec![2, 3, 4]); 13.2.4 创建自定义迭代器 可以实现 Iterator trait 来创建任何我们希望的迭代器 123456789101112131415161718192021222324252627282930313233struct Counter &#123; count: u32,&#125;impl Counter &#123; fn new() -&gt; Counter &#123; Counter &#123; count: 0 &#125; &#125;&#125;impl Iterator for Counter &#123; type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; self.count += 1; if self.count &lt; 6 &#123; Some(self.count) &#125; else &#123; None &#125; &#125;&#125;// 使用自定义的Counter迭代器的多种方法// 获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加#[test]fn using_other_iterator_trait_methods() &#123; let sum: u32 = Counter::new().zip(Counter::new().skip(1)) .map(|(a, b)| a * b) .filter(|x| x % 3 == 0) .sum(); assert_eq!(18, sum);&#125; Ch14 进一步认识Cargo和Crates.io 14.1 采用发布配置自定义构建 Cargo 有两个主要的配置： 运行 cargo build 时采用的 dev 配置 运行 cargo build --release 的 release 配置 dev 配置被定义为开发时的好的默认配置，release 配置则有着良好的发布构建的默认配置 可以在 Cargo.toml 文件中定义 [profile.*] 部分来覆盖默认配置 12345[profile.dev]opt-level = 0[profile.release]opt-level = 3 opt-level 设置控制 Rust 会对代码进行何种程度的优化，值从0到3，越高的优化级别需要更多的时间编译 14.2 将 crate 发布到 Crates.io 14.3 Cargo工作空间 14.4 从 Crates.io 安装二进制文件 使用命令 cargo install 可以从crates.io下载二进制crate，安装到 ~/.cargo/bin Ch15 智能指针 15.1 Box&lt;T&gt; box 允许将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针 使用场景： 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候 15.1.1 Box创建递归类型 Rust 需要在编译时知道类型占用多少空间，而递归类型无法在编译的时候知道大小 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了 以cons list为例 cons list 的每一项都包含两个元素：当前项的值和下一项。 其最后一项值包含一个叫做 Nil 的值且没有下一项。 cons list 通过递归调用 cons 函数产生。 代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。 12345678910enum List &#123; Cons(i32, List), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Cons(2, Cons(3, Nil)));&#125; Rust编译器无法计算一个 List 需要的大小，因为编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons成员储存了一个 i32 值和一个List值，这样的计算将无限进行下去。 使用Box&lt;T&gt;给递归类型一个已知的大小 12345678910111213enum List &#123; Cons(i32, Box&lt;List&gt;), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));&#125; 任何 List 值最多需要一个 i32 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了。 15.2 Deref trait 实现 Deref trait 允许我们重载解引用运算符 * 15.2.1 像引用一样使用 Box&lt;T&gt; 1234567fn main() &#123; let x = 5; let y = Box::new(x); assert_eq!(5, x); assert_eq!(5, *y);&#125; 15.2.2 自定义智能指针 定义 MyBox&lt;T&gt; 类型: 1234567struct MyBox&lt;T&gt;(T);impl&lt;T&gt; MyBox&lt;T&gt; &#123; fn new(x: T) -&gt; MyBox&lt;T&gt; &#123; MyBox(x) &#125;&#125; 15.2.3 在自定义智能指针实现 Deref trait 12345678910use std::ops::Deref;impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123; // 定义trait的关联类型 type Target = T; fn deref(&amp;self) -&gt; &amp;T &#123; // deref返回了我希望通过*运算符访问的值的引用 &amp;self.0 &#125;&#125; 当运行如下代码： 1234let x = 5;let y = MyBox::new(x);assert_eq!(5, *y); *y 在Rust底层运行了 *(y.deref()) 15.2.4 函数和方法的隐式解引用强制多态 解引用强制多态是 Rust 在函数或方法传参上的一种便利。将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。 123456789fn hello(name: &amp;str) &#123; println!(&quot;Hello, &#123;&#125;!&quot;, name);&#125;fn main() &#123; let m = MyBox::new(String::from(&quot;Rust&quot;)); // 解引用强制多态将 &amp;MyBox&lt;String&gt; 自动转换为 &amp;str hello(&amp;m);&#125; 15.3 Drop trait 允许我们在值要离开作用域时执行一些代码，可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源 通过 Drop trait 中的 drop 方法，可以在变量离开作用域时自动丢弃该值 15.3.1 通过 std::mem::drop 提早丢弃值 Rust不允许我们主动调用 Drop trait 的 drop 方法 当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop，其位于preclude，可以直接通过 drop(variable); 调用 15.4 Rc&lt;T&gt; 引用计数智能指针 有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。 Rust 使用引用计数 Rc&lt;T&gt; 的类型来启用多所有权，记录了一个值引用的数量来知晓这个值是否仍在被使用。 Rc&lt;T&gt; 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。 Rc&lt;T&gt; 只能用于单线程场景 15.4.1 使用 Rc&lt;T&gt; 共享数据 使用 Box&lt;T&gt; 定义的 cons list 的两个列表 b 和 c, 共享第三个列表 a 的所有权 12345678910111213enum List &#123; Cons(i32, Rc&lt;List&gt;), Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;use std::rc::Rc;fn main() &#123; let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(&amp;a)); let c = Cons(4, Rc::clone(&amp;a));&#125; Rc::clone 只会增加引用计数，而不会深拷贝 在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 Rc::strong_count 函数获得 15.5 RefCell&lt;T&gt; 和内部可变性模式 内部可变性是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的 15.6 引用循环与内存泄漏 Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存，但是创建引用循环从而造成内存泄漏的可能性是存在的 Ch16 并发 16.1 使用线程同时运行代码 线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题： 竞争状态，多个线程以不一致的顺序访问数据或资源 死锁，两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行 只会发生在特定情况且难以稳定重现和修复的 bug 16.1.1 使用 spawn 创建新线程 为了创建一个新线程，需要调用 thread::spawn 函数并传递一个闭包，并在其中包含希望在新线程运行的代码 123456789101112131415161718192021222324252627282930use std::thread;use std::time::Duration;fn main() &#123; thread::spawn(|| &#123; for i in 1..10 &#123; println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i); // thread::sleep调用强制线程停止执行一小段时间，允许其他不同的线程运行 thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125;&#125;/*输出：hi number 1 from the main thread!hi number 1 from the spawned thread!hi number 2 from the main thread!hi number 2 from the spawned thread!hi number 3 from the main thread!hi number 3 from the spawned thread!hi number 4 from the main thread!hi number 4 from the spawned thread!hi number 5 from the spawned thread!*/ 当主线程结束时，新线程也会结束，而不管其是否执行完毕 16.1.2 使用 join 等待所有线程结束 thread::spawn 的返回值类型是 JoinHandle JoinHandle 是一个拥有所有权的值，当对其调用 join 方法时，它会等待其线程结束 通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束 12345678910111213141516171819use std::thread;use std::time::Duration;fn main() &#123; // 从thread::spawn保存一个JoinHandle来确保该线程能够运行结束 let handle = thread::spawn(|| &#123; for i in 1..10 &#123; println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i); thread::sleep(Duration::from_millis(1)); &#125; handle.join().unwrap();&#125; 16.1.3 线程与 move 闭包 在参数列表前使用 move 关键字强制闭包获取其使用的环境值的所有权，可用于创建新线程时将值的所有权从一个线程移动到另一个线程 1234567891011use std::thread;fn main() &#123; let v = vec![1, 2, 3]; let handle = thread::spawn(move || &#123; println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v); &#125;); handle.join().unwrap();&#125; 16.2 线程间消息传递 Rust 中一个实现消息传递并发的主要工具是通道 1234567891011121314use std::thread;use std::sync::mpsc;fn main() &#123; let (tx, rx) = mpsc::channel(); thread::spawn(move || &#123; let val = String::from(&quot;hi&quot;); tx.send(val).unwrap(); &#125;); let received = rx.recv().unwrap(); println!(&quot;Got: &#123;&#125;&quot;, received);&#125; 使用 mpsc::channel 函数创建一个新的通道，可以有多个发送端，但只能有一个接收端， mpsc::channel 函数返回一个元组：(发送端，接收端)，或 (tx, rx) 通道的发送端有一个 send 方法用来获取需要放入通道的值，返回一个 Result&lt;T, E&gt; 类型 send 函数获取其参数的所有权并移动这个值归接收者所有，所以线程在发送 val 之后就不能再使用它了 通道的接收端有两个有用的方法：recv 和 try_recv recv 会阻塞主线程执行直到从通道中接收一个值，一旦发送了一个值，recv 会在一个 Result&lt;T, E&gt; 中返回它；当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了 try_recv 不会阻塞，立刻返回一个 Result&lt;T, E&gt;：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息 可以将 rx 作为迭代器来接收发送端发送的多个数据，并通过 for 循环打印 可以通过 clone 方法来创建多个发送端: 12let (tx, rx) = mpsc::channel();let tx1 = mpsc::Sender::clone(&amp;tx); 16.3 共享状态并发 16.3.1 互斥器 通过锁来保证任意时刻只有一个线程能访问某些数据 使用方式： 在使用数据之前尝试获取锁。 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。 使用 Mutex&lt;T&gt; 实现 通过关联函数 new 来创建 Mutex&lt;T&gt; 使用 lock 方法获取锁，该方法会阻塞当前线程，直到拥有锁为止 lock 调用返回一个叫做 MutexGuard 的智能指针，当其离开作用域时，会自动释放锁 16.3.2 在线程间共享 Mutex&lt;T&gt; 12345678910111213141516171819202122use std::sync::&#123;Mutex, Arc&#125;;use std::thread;fn main() &#123; let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 &#123; let counter = Arc::clone(&amp;counter); let handle = thread::spawn(move || &#123; let mut num = counter.lock().unwrap(); *num += 1; &#125;); handles.push(handle); &#125; for handle in handles &#123; handle.join().unwrap(); &#125; println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());&#125; 使用原子引用计数 Arc&lt;T&gt; 来实现 Mutex&lt;T&gt; 在多线程之间共享所有权 Ch17 Rust面向对象 17.1 面向对象语言的特征 对象包含数据和行为：结构体和枚举包含数据，impl 块提供对应方法 封装隐藏了实现细节：不添加 pub 就是私有的 通过继承重用代码：使用 trait 对象 17.2 为使用不同类型的值而设计的 trait 对象 17.3 面向对象设计模式的实现 Ch18 模式 18.1 用到模式的位置 18.1.1 match分支 在形式上 match 表达式由 match 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式 12345match VALUE &#123; PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION, PATTERN =&gt; EXPRESSION,&#125; 18.1.2 if let 表达式 等同于只关心一个情况的 match 语句简写 if let 表达式的缺点在于其穷尽性没有为编译器所检查，而 match 表达式则检查了 18.1.3 while let 条件循环 允许只要模式匹配就一直进行 while 循环 18.1.4 for循环 1for (index, value) in v.iter().enumerate() &#123;&#125; 使用 (index, value) 来匹配 enumerate 18.1.5 let语句 1let PATTERN = EXPRESSION; 18.1.6 函数参数 123fn foo(x: i32) &#123; // 代码&#125; x 部分就是一个模式 18.2 可反驳和不可反驳 能匹配任何传递的可能值的模式被称为是不可反驳的，如 let x = 5; 中的 x 对某些可能的值进行匹配会失败的模式被称为是可反驳的，如 if let Some(x) = a_value 中的 Some(x) 函数参数、 let 语句和 for 循环只能接受不可反驳的模式 匹配分支必须使用可反驳模式，如 if let 18.3 模式语法 18.3.1 匹配字面值 12345678let x = 1;match x &#123; 1 =&gt; println!(&quot;one&quot;), 2 =&gt; println!(&quot;two&quot;), 3 =&gt; println!(&quot;three&quot;), _ =&gt; println!(&quot;anything&quot;),&#125; 18.3.2 匹配命名变量 命名变量是匹配任何值的不可反驳模式，当其用于 match 表达式时，情况会不一样 123456789101112131415161718fn main() &#123; let x = Some(5); let y = 10; match x &#123; Some(50) =&gt; println!(&quot;Got 50&quot;), Some(y) =&gt; println!(&quot;Matched, y = &#123;:?&#125;&quot;, y), _ =&gt; println!(&quot;Default case, x = &#123;:?&#125;&quot;, x), &#125; println!(&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;, x, y);&#125;/*会打印：Matched, y = 5at the end: x = Some(5), y = 10*/ 在 match 表达式的新作用域中， y 是一个新变量，而不是开头声明为值 10 的那个 y ，新的 y 绑定会匹配任何 Some 中的值，在这里是 x 中的值 18.3.3 多个模式 使用 | 语法匹配多个模式 1234567let x = 1;match x &#123; 1 | 2 =&gt; println!(&quot;one or two&quot;), 3 =&gt; println!(&quot;three&quot;), _ =&gt; println!(&quot;anything&quot;),&#125; 18.3.4 通过 …= 匹配值的范围 使用 1..=5 替代 1 | 2 | 3 | 4 | 5 对 char 类型也适用：'a'..='j' 18.3.5 忽略模式中的值 使用 _ 忽略整个值 通过 _x 来忽略未使用的变量 使用 .. 忽略剩余的值 123456789fn main() &#123; let numbers = (2, 4, 8, 16, 32); match numbers &#123; (first, .., last) =&gt; &#123; println!(&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;, first, last); &#125;, &#125;&#125; 18.3.6 匹配守卫 匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支 1234567let num = Some(4);match num &#123; Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: &#123;&#125;&quot;, x), Some(x) =&gt; println!(&quot;&#123;&#125;&quot;, x), None =&gt; (),&#125; 18.3.7 @绑定 @ 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式 使用 @ 可以在一个模式中同时测试和保存变量值 12345678910111213141516171819enum Message &#123; Hello &#123; id: i32 &#125;,&#125;let msg = Message::Hello &#123; id: 5 &#125;;match msg &#123; // 将id值保存在id_variable中 Message::Hello &#123; id: id_variable @ 3..=7 &#125; =&gt; &#123; println!(&quot;Found an id in range: &#123;&#125;&quot;, id_variable) &#125;, // 无法保存id值 Message::Hello &#123; id: 10..=12 &#125; =&gt; &#123; println!(&quot;Found an id in another range&quot;) &#125;, Message::Hello &#123; id &#125; =&gt; &#123; println!(&quot;Found some other id: &#123;&#125;&quot;, id) &#125;,&#125; Ch19 高级特征 19.1 不安全的Rust 19.2 高级trait 19.3 高级类型 19.4 高级函数与闭包 19.5 宏","categories":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"Pointers on C - Learn","slug":"learning-notes/C和指针notes","date":"2020-11-10T16:00:00.000Z","updated":"2022-06-20T14:10:09.212Z","comments":true,"path":"2020/11/11/learning-notes/C和指针notes/","link":"","permalink":"http://example.com/2020/11/11/learning-notes/C%E5%92%8C%E6%8C%87%E9%92%88notes/","excerpt":"C学习记录","text":"Ch2 基本概念 2.1 环境 2.1.1 翻译环境 翻译过程：各源文件通过编译过程分别转为目标代码 -&gt; 各目标代码文件由链接器捆绑为单一完整的可执行程序 编译过程：预处理器处理 -&gt; 源代码经过解析判断语句的意思，从而生成目标代码 -&gt; 优化器对目标代码进一步处理 2.1.4 执行环境 程序执行过程：程序载入内存 -&gt; 启动程序调用main函数 -&gt; 程序的终止 程序运行过程中使用一个运行时的堆栈，用于存储函数的局部变量和返回地址；同时，程序也可以使用静态内存，其中的值在程序整个执行过程都会保留 2.2 词法规则 2.2.1 字符 \\ddd：三个八进制数字表示的字符 \\xddd：三个十六进制数字表示的字符 2.2.2 注释 //：单行注释 /* */：多行注释 TIPS: 有的程序从标准输入读取数据，读到EOF停止，在终端输入时Ctrl+D即为输入EOF Ch3 数据 3.1 基本数据类型 3.1.1 整型 变量的最小范围 类型 最小范围 char 0 ~ 27-1 signed char -(27-1) ~ 27-1 unsigned char 0 ~ 28-1 short int -(215-1) ~ 215-1 unsigned short int 0 ~ 216-1 int -(215-1) ~ 215-1 unsigned int 0 ~ 216-1 long int -(231-1) ~ 231-1 unsigned long int 0 ~ 232-1 short int至少16位，long int至少32位 头文件limits.h说明各种不同的整型的特点 一、整型常量 声明为const，初始化之后不能被改变 十进制整型常量可能是int、long、unsigned long。缺省情况下为最短类型但能完整容纳这个值 八进制整数以0开头 十六进制整数以0x开头 字符常量：类型为int，是单引号包围的单个字符 1&#x27;M&#x27; &#x27;\\n&#x27; 宽字符常量：多字节字符常量的前面有个L 1L&#x27;X&#x27; L&#x27;e^&#x27; 二、枚举类型 12345// 声明类型enum Jar_Type &#123;CUP, PINT, QUART, HALF_GALLON, GALLON&#125;;// 定义变量enum Jar_Type milk_jug, gas_can, medicine_bottle; 以整型方式存储，符号名实际值都是整型值。如CUP=0，PINT=1，以此类推 可以显式定值，若未指定值，则比前一个符号名大1 3.1.2 浮点类型 包括float、double、long double类型 所有浮点类型至少能容纳从10-37到1037之间的任何值 头文件float.h说明各种不同的浮点型的特点 浮点数默认为double类型；后面跟L/l表示long double；后面跟F/f表示float 3.1.3 指针 一、指针常量 一般都通过操作符来获得一个变量的地址，而不是通过表示为字面值的指针常量，如0xff2044ec 二、字符串常量 字符串：以NUL字节结尾的零个或多个字符，存储在字符数组中 字符串常量：直接值是一个“指向字符的指针”，而不是这些字符本身 3.2 基本声明 3.2.2 声明简单数组 1int value[20]; 编译器不检查数组的下标是否在合法范围内，所以当下标是通过用户输入计算而来的，必须检测是否越界 如果越界，不会报错，只会返回null 3.2.3 声明指针 1234567int *a;char *message = &quot;Hello World&quot;;// 把message声明为一个指向字符的指针，并用字符串常量中的第1个字符的地址对其初始化// 等价于以下语句char *message;message = &quot;Hello World&quot;; 3.3 typedef 为各种数据类型定义新名字 12345// 将变量ptr_to_char声明为一个指向字符的指针类型的新名字typedef char *ptr_to_char;// 声明a是一个指向字符的指针ptr_to_char a; 3.4 常量 const 123456789// 声明整数常量const int a;int const a;// 声明一个指向整型常量的指针int const *pci;// 声明一个指向整型的常量指针int * const cpi; #define 1#define MAX_LEN 20 3.5 作用域 3.5.1 代码块作用域 代码块：位于一对花括号之间的所有语句 嵌套代码块中，内层可以访问外层变量，而外层无法访问内层变量，但是当内外层有名字相同的变量时，内层无法访问外层的那个同名变量 非嵌套的代码块中，作用域没有重叠，所以编译器可以把它们存储在同一个内存地址 3.5.2 文件作用域 任何在所有代码块之外声明的标识符都具有文件作用域，在声明处到源文件末尾都可以访问 3.5.3 原型作用域 只适用于在函数原型中声明的参数名 3.5.4 函数作用域 只适用于语句标签，语句标签用于goto语句 3.6 链接属性 一、none 没有链接属性 声明的同名标识符被当作独立不同的实体 二、internal属性 单个文件中声明的同名标识符表示同一个实体 三、external属性 多个文件中声明的同名标识符表示同一个实体 只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。 默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体。 四、关键字extern和static 如果某个标识符在正常情况下具有external链接属性(只能是具有文件作用域的标识符)，在其前面加上static关键字可以将其链接属性变为internal 链接属性只能修改一次，也就是说一旦将标识符的链接属性变为internal，就无法变回external了 3.7 存储类型 存储变量的内存类型，有普通内存、运行时堆栈、硬件寄存器 在任何代码块之外声明的变量存储在静态内存中，为静态变量，在程序运行之前创建 在代码块内部声明的变量的缺省存储类型是自动的，即存储于堆栈中，进入代码块创建，离开代码块销毁 在代码块内部声明的变量加上static关键字，变为静态变量，但作用域不变。如在函数中声明static变量a，则a在程序开始执行时就被初始化，并且每次函数被调用时，a不会重新初始化 关键字register声明自动变量，存储在硬件寄存器中，为寄存器变量 初始化 如果不显式指定初值，静态变量将初始化为0，而自动变量初始值不确定 3.8 static关键字 用于函数定义或在代码块外声明变量时，将标识符的链接属性从external改为internal，但变量的存储类型和作用域不受影响 在代码块内部声明变量时将标识符的存储类型从自动变量改为静态变量，但变量的链接属性和作用域不受影响 3.9 总结 Ch4 语句 4.1 空语句 1; 只包含一个分号，不执行任何任务 4.2 表达式语句 C不存在赋值语句，赋值通过表达式语句(在表达式之后加上一个分号)实现，如： 1x = y + 3; 以下语句也是合法的，但结果被立即丢弃： 1y + 3; 4.3 代码块 位于一对花括号之内的可选的声明和语句列表 4.4 if语句 123456if (expression) &#123; statement&#125;else &#123; statement&#125; C语言不存在布尔变量，而使用整型的0和1代替，所以expression的结果不是0就是1 4.5 while语句 123while (expression) &#123; statement&#125; break终止所在while代码块的所有循环；continue终止所在while代码块的当前循环 4.6 for语句 123for (初始化部分; 条件部分; 调整部分)&#123; statement&#125; 4.7 do语句 123do &#123; statement&#125; while (expression); 循环体至少执行一次 4.8 switch语句 123456789switch (expression) &#123; case constant-expression-1: statement-1 break; case constant-expression-2: statement-2 break; ......&#125; switch的条件expression必须为整型值 每个case标签必须具有唯一的值 每个switch语句都应该添加一条并且只能添加一条default语句，可以在case语句列表的任何位置 4.9 goto语句 1goto 语句标签; 语句标签是在标识符后添加一个冒号，并跟上一些表达式语句 要尽可能避免使用goto语句 Ch5 操作符和表达式 5.1 操作符 5.1.1 算术操作符 1+ - * / % 5.1.2 移位操作符 左移：&lt;&lt; 右移：&gt;&gt; 无符号数的所有移位操作都是逻辑移位，有符号数是逻辑移位还是算术移位取决于编译器 5.1.3 位操作符 12&amp; | ~// 与或非 将value指定位置1 1value = value | 1 &lt;&lt; bit_number; 将value指定位置0 1value = value &amp; ~ (1 &lt;&lt; bit_number); 5.1.5 单目操作符 !：逻辑取反，产生整型结果0或1 ~：操作数每一位取反 -：取负 &amp;：取操作数的地址 *：间接访问，访问指针所指向的值 sizeof：判断操作数的类型长度，以字节为单位，操作数可以是变量，也可以是加上括号的类型 sizeof (a = b + 1)并没有向a赋值 强制类型转换，如获得整型变量a对应的浮点数值 1(float) a c+：增值操作符，a在变量被使用之前增加它的值，a在变量被使用之后增加它的值 5.1.6 关系操作符 1&gt; &gt;= &lt; &lt;= == != 产生的结果是整型的0或1 5.1.7 逻辑操作符 &amp;&amp;：对于expression1 &amp;&amp; expression2，若expression1为假，则不再对expression2求值 ||：对于expression1 || expression2，若expression1为真，则不再对expression2求值 5.1.8 条件操作符 expression1 ? expression2 : expression3 5.2 布尔值 C没有显式的布尔类型，用整数代替，0是假，任何非零值都是真 5.4 表达式求值 函数进行表达式求值时应该尽量避免以下形式： 1f() + g() + h() 而使用以下形式，因为如果函数的返回值和执行顺序相关，则会产生不确定性 123temp = f();temp += g();temp += h(); Ch6 指针 6.1 内存和地址 内存中的每个位置由一个独一无二的地址标识 内存中的每个位置都包含一个值 编译器帮助实现通过变量访问内存位置，但是硬件仍然通过地址访问内存位置 6.2 值和类型 不能简单地通过检查一个值的位来判断它的类型，因为不同的数据类型和指令会将其解释为不同的类型 6.5 未初始化和非法的指针 在对指针进行间接访问之前，一定要进行初始化，下面是一个错误例子，因为指针a指向的位置不能确定： 12int *a;*a = 12; 6.6 NULL指针 NULL指针不指向任何东西 要使一个指针变量为NULL，可以给它赋一个零值；测试一个指针变量是否为NULL，可以将它与零值比较 6.7 指针、间接访问和左值 12345678int a;int *d = &amp;a;// 合法，对指针d指向的值(a)进行修改*d = 10 - *d;// 非法，整型数的计算结果赋给指针d = 10 - *d; 6.10 指针的指针 123int a = 12;int *b = &amp;a;int **c = &amp;b; 表达式 相当的表达式 a 12 b &amp;a *b a, 12 c &amp;b *c b, &amp;a **c *b, a, 12 6.11 指针表达式 6.13 指针运算 6.13.1 算术运算 当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据对应变量的类型的长度进行调整。例如若float类型指针变量p占4个字节，则p+1不会指向p的第二字节，而是会指向p所占的4个字节之后的那个字节 两个指针只有当都指向同一个数组中的元素时，才允许进行相减，并且减法的结果是两个元素在数组中的距离，而不是内存地址的差值，即在减法运算的同时会除掉变量类型的长度 6.13.2 关系运算 对于指向同一个数组中的元素的指针，可以用关系操作符(&gt; &lt; &gt;= &lt;=)来判断哪个指针指向数组中更前或更后的元素 Ch7 函数 7.2 函数声明 7.2.1 原型 原型总结了函数定义的起始部分的声明，向编译器提供有关函数应该如何调用的完整信息 函数原型的使用： 1234567// func_use.c#include &quot;func.h&quot;... // func.hint *func(int *value, int len);... 声明一个没有参数的函数原型： 1int *func(void); 7.2.2 函数的缺省认定 当程序调用一个无法见到原型的函数时，编译器会认为该函数返回一个整型 7.3 函数的参数 所有参数都是传值调用，函数不会修改实际传递的参数 当传递的参数是指针时，可以通过指针的间接访问修改指针所指的值，称为传址调用 7.4 ADT和黑盒 使用static关键字限制对非接口函数和数据的访问 7.5 递归 通过运行时堆栈支持递归函数的实现 通过一个简单的递归作为实例： 123456789101112// 接受一个整型值(无符号)，把它转换为字符并打印，前导零被删除#include &lt;stdio.h&gt;void binary_to_ascii(unsigned int value) &#123; unsigned int quotient; quotient = value / 10; if (quotient != 0) &#123; binary_to_ascii(quotient); &#125; putchar(value % 10 + &#x27;0&#x27;);&#125; 7.5.1 追踪递归函数 程序运行时堆栈的变化： ​ … 7.5.2 递归与迭代 如果一个递归函数内部所执行的最后一条语句就是调用自身时，被称为尾部递归，这样的递归很容易被改写为循环迭代的形式，而迭代的效率通常较高 7.6 可变参数列表 7.6.1 stdarg宏 定义于stdarg.h头文件 类型va_list：用于声明变量来访问参数列表的未确定部分 此时声明函数的方式为float average(int n, ...) 宏va_start：初始化va_list声明的变量，第1个参数是va_list变量名，第2个参数是省略号前的最后一个有名字的参数 宏va_arg：用于访问参数，第1个参数是va_list变量名，第2个参数是参数列表中下一个参数的类型，返回这个参数的值，并指向下一个可变参数 宏va_end：访问完最后一个可变参数后调用，参数为va_list变量名 7.6.2 可变参数的限制 这些宏无法判断实际存在的参数的数量 这些宏无法判断每个参数的类型 Ch8 数组 8.1 一维数组 8.1.1 数组名 1int b[10]; b[3]的类型是整型 b是一个指向b[0]的常量指针，因而不能修改数组名的值，即不能修改数组存储的内存地址 数组的赋值 12345678int a[10];int b[10];int *c;// 以下两个表达式作用相同，将c指向a[0]c = &amp;a[0];c = a; // 以下表达式非法，不能将数组复制给数组，数组间的复制只能通过循环逐个元素复制 b = a; // 以下表达式非法，a是常量，不能被修改 a = c; 123456789 #### 8.1.2 下标引用通过以下例子说明：​&#96;&#96;&#96;cint array[10];int *ap &#x3D; array + 2; 表达式 对等表达式 ap array+2, &amp;array[2] *ap array[2], *(array+2) ap[0] array[2] ap+6 array+8, &amp;array[8] *ap+6 array[2]+6 *(ap+6) array[8] ap[-1] array[1] ap[9] 非法 8.1.3 指针与下标 指针有时比下标更加高效 在数组中一次一步移动时，与固定数字相乘的运算在编译的时候完成，所以在运行时所需的指令就少 但这在实际中不常用，因为可能编译器对循环会有优化 8.1.5 数组和指针 12int a[5]; // 数组int *b; // 指针 a和b都具有指针值，都可以进行间接访问和下标引用操作 区别： 声明数组时，编译器会为数组保留内存空间，然后再创建数组名 声明指针变量时，编译器只为指针本身保留内存空间，而不为整型值分配内存空间 在上述声明后： *a是合法的，*b是非法的，因为*b将访问内存中某个不确定的位置 b是合法的，a是非法的，因为a是常量指针 8.1.7 声明数组参数 下面的函数原型是等价的： 12int strlen(char *string);int strlen(char string[]); 8.1.8 初始化 1int vector[5] = &#123;1, 2, 3, 4, 5&#125;; 静态初始化：静态变量存储在静态内存，只初始化一次 自动初始化：自动变量在缺省情况下是未初始化的，若给定初值，则每次进入代码块都会重新初始化 8.1.9 不完整的初始化 1int vector[5] = &#123;1, 2, 3, 4&#125;; vector[4]被初始化为0 8.1.10 自动计算数组长度 如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有初始值的长度 8.1.11 字符数组的初始化 12345// 初始化一个字符串数组char message1[] = &quot;Hello&quot;;// 初始化一个字符串常量char *message2 = &quot;Hello&quot;; 8.2 多维数组 8.2.1 存储顺序 定义一个数组： 1int array[3][6]; 其在内存中的存储形式为： 这18个元素的下标值依次是(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (1,0) … (2,4) (2,5) 8.2.2 数组名 如在int matrix[3][10]中，matrix是指向一个包含10个整型元素的数组的指针 那么matrix+1则指向： 而*(matrix + 1) + 5就等价于matrix[1] + 5，是一个指向整型的指针： 8.2.4 指向数组的指针 声明一个指向整型数组的指针，并令其指向matrix数组的第一行： 1int (*p)[10] = matrix; 8.2.5 作为函数参数的多维数组 可以使用以下两张形式的任何一种： 12void func(int (*mat)[10]);void func(int mat[][10]); 8.2.6 初始化 8.2.7 数组长度自动计算 在多维数组中，只有第1维才能根据初始化列表缺省地提供，剩余的几个维必须显式写出 8.3 指针数组 定义方式如下： 1234567char const *keyword[] = &#123; &quot;do&quot;, &quot;for&quot;, &quot;if&quot;, &quot;return&quot;, NULL&#125; 这样定义的好处在于如果要遍历这个表，只需要for (kwp=keyword; *kwp!=NULL; kwp++) Ch9 字符串、字符和字节 9.1 字符串基础 字符串的长度不包含最后的NUL字节 头文件string.h包含了使用字符串函数所需的原型和声明 9.2 字符串长度 1size_t strlen(char const *string); 返回类型为size_t，是一个无符号整数类型 不要在表达式中同时包含有符号数和无符号数，因此应该把strlen的返回值强制转换为int 9.3 不受限制的字符串函数 9.3.1 复制字符串 1char *strcpy(char *dst, char const *src); dst必须是一个字符数组或是一个指向动态分配内存的数组的指针 复制字符串前必须保证目标字符数组的空间足以容纳需要复制的字符串，不然会覆盖数组之后内存的内容 9.3.2 连接字符串 1char *strcat(char *dst, char const *src); 将src字符串的拷贝添加到dst字符串之后 9.3.4 字符串比较 1int strcmp(char const *s1, char const *s2); 若s1小于s2，返回一个小于0的值；若s1大于s2，返回一个大于0的值；若s1和s2相等，返回0 9.4 长度受限的字符串函数 字符串复制，将src的前len个字符(不够补NUL)复制给dst，但当src的长度大于len时，只能复制len个字符给dst，因此结果的dst最后是没有NUL的 1char *strncpy(char *dst, char const *src, size_t len); 字符串连接，将src的前len个字符(不够补NUL)连接到dst后面，会自动添加一个NUL在dst的最后 1char *strncat(char *dst, char const *src, size_t len); 字符串比较，比较两个字符串的前len位 1int strncmp(char const *s1, char const *s2, size_t len); 9.5 字符串查找基础 9.5.1 查找一个字符 12char *strchr(char const *str, int ch);char *strrchr(char const *str, int ch); 在字符串str中查找字符ch第一次出现的位置，返回一个指向该位置的指针，若没有找到返回NULL指针 strchr从左开始找，strrchr从右开始找 9.5.2 查找任何几个字符 1char *strpbrk(char const *str, char const *group); 返回一个指向str中第一个匹配group中任何一个字符的位置指针 9.5.3 查找一个子串 1char *strstr(char const *s1, char const *s2); 在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针 9.6 高级字符串查找 9.6.1 查找一个字符串前缀 12size_t strspn(char const *str, char const *group);size_t strcspn(char const *str, char const *group); strspn返回str起始部分匹配group中任意字符的字符数，而strcspn找的是非group中的字符 例如得到指向字符串中第一个非空白字符： 1prt = buffer + strspn(buffer, &quot;\\n\\t\\r\\f\\v&quot;); 9.6.2 查找标记 1char *strtok(char *str, char const *sep); 从字符串中隔离各个单独的称为标记的部分 sep定义了用作分隔符的字符集合 若strtok的第一个参数不是NULL，函数将找到字符串的第一个标记，同时保存它在字符串中的位置；若strtok的第一个参数是NULL，函数将在同一个字符串中从保存的位置开始查找下一个标记；若找不到下一个标记，则返回NULL 例子：查找被空白分隔的单词 123for (token=strtok(line, whitespace); token!=NULL; token=strtok(NULL, whitespace)) &#123; printf(&quot;%s\\n&quot;, token);&#125; 9.7 错误信息 1char *strerror(int error_number); 参数为错误代码，返回一个指向用于描述错误的字符串的指针 9.8 字符操作 头文件ctype.h 9.8.1 字符分类 9.8.2 字符大小写转换 12int tolower(int ch);int toupper(int ch); 9.9 内存操作 12345void *memcpy(void *dst, void const *src, size_t length);void *memmove(void *dst, void const *src, size_t length);void *memcmp(void const *a, void const *b, size_t length);void *memchr(void const *a, int ch, size_t length);void *memset(void *a, int ch, size_t length); 与strn带头的函数不同，这些函数遇到NUL字节时不会停止操作 Ch10 结构和联合 10.1 结构基础知识 当一个结构变量在表达式中使用时，并不被替换成一个指针，而是一个标量类型 10.1.1 结构声明 12345struct &#123; int a; char b; float c;&#125; x, y[20], *z; 声明了结构体x，包含20个结构体的数组y，指向结构体的指针z 1234567struct SIMPLE &#123; int a; char b; float c;&#125;;struct SIMPLE x, y[20], *z; 推荐使用以下声明方法： 1234567typedef struct &#123; int a; char b; float c;&#125; Simple;Simple x, y[20], *z; 10.1.2 结构成员 直接访问： 1234Simple simp;// 访问成员asimp.a 间接访问： 1234Simple *simp;// 访问成员asimp-&gt;a 10.1.5 结构的自引用 123456789101112131415161718192021222324252627// 错误struct SELF_REF &#123; int a; struct SELF_REF b; int c;&#125;;// 正确struct SELF_REF &#123; int a; struct SELF_REF *b; int c;&#125;;// 错误typedef struct &#123; int a; struct SELF_REF *b; int c;&#125; SELF_REF;// 正确typedef struct SELF_REF_TAG &#123; int a; struct SELF_REF_TAG *b; int c;&#125; SELF_REF; 10.1.6 不完整的声明 用于多个相互依赖的结构体之间的声明 123456789struct B;struct A &#123; struct B *partner;&#125;;struct B &#123; struct A *partner;&#125;; 10.2 结构、指针和成员 后面几节都以以下结构体为例： 1234567891011typedef struct &#123; int a; short b[2];&#125; Ex2;typedef struct Ex &#123; int a; char b[3]; Ex2 c; struct EX *d;&#125;; 若声明一个结构体： 12Ex x = &#123;10, &quot;Hi&quot;, &#123;5, &#123;-1, 25&#125;&#125;, 0&#125;;Ex *px = &amp;x; 10.2.1 访问指针 px的右值： px的左值： px+1是一个非法的左值 10.2.2 访问结构 *px的右值： *px的左值（接受一个新值）： *px+1是非法的，因为没办法将结构体和整型相加 *(px+1)也是非法的 10.2.3 访问结构成员 px-&gt;a的右值： 如果进行以下声明： 12int *pi;pi = &amp;px-&gt;a; 则pi为： ​ **注：**px的结果是整个结构，而pi的结果是一个整型数 px-&gt;b的右值为指针常量，所以没有合法左值： 对数组元素的访问采用px-&gt;b[1] 10.2.4 访问嵌套的结构 px-&gt;c的左值是整个结构，右值如下： px-&gt;c.a的右值： *px-&gt;c.b的右值： 10.2.5 访问指针成员 对px-&gt;d进行初始化，使其指向一个结构体： 12Ex y;px-&gt;d = &amp;y; px-&gt;d-&gt;c.b[1]的右值： 10.3 结构的存储分配 12345struct ALIGN &#123; char a; int b; char c;&#125;; 对于上述结构体，若整型长度为4字节，而且它的起始存储位置必须能被4整除，于是a存储为1字节，但是后面必须空出3字节才能存放b，其存储形式为： 一个结构体占了12个字节的存储空间，有效利用空间却只有6字节 如果声明改为如下形式，则只需要8个字节就能存储这个结构体： 12345struct ALIGN &#123; int b; char a; char c;&#125;; sizeof可以得出一个结构体的整体长度，包括跳过的字节 使用offset(type, member)能获得结构体中某成员的实际位置，如offset(struct ALIGN, b) 10.4 作为函数参数的结构 最好使用指针来传递参数，并声明为寄存器变量来提高效率 若结构体成员不能改变，则： 1void test(register ALIGN const *test); 若需要根据程序运行结果修改结构体中的值，则： 1void test(register ALIGN *test); 调用方式都为： 1test(&amp;align); 10.5 位段 注重可移植性的程序应该避免使用位段 10.6 联合 联合的所有成员引用的是内存中的相同位置 如果联合的各个成员具有不同的长度，联合的长度就是最长成员的长度 应用场景比如： 12345678struct VARIABLE &#123; enum &#123;INT, FLOAT, STRING&#125; type; union &#123; int i; float f; char *s; &#125; value;&#125;; 对于整型，type设为INT，存储于value.i中；对于浮点数，type设为FLOAT，存储于value.f中； 联合的初始化，初始值必须是联合第一个成员的类型，如 12345union &#123; int a; float b; char c[4];&#125; x = &#123;5&#125;; Ch11 动态内存分配 11.1 为什么使用动态分配内存 声明数组时，数组的长度往往在运行时才能知道，但是编译时需要指定数组的长度，因为需要提前开辟内存空间。 11.2 malloc和free 在头文件stdlib.h中声明 11.2.1 malloc 1void *malloc(size_t size); malloc从内存池中提取一块合适的内存，并返回一个指向这块内存起始位置的指针(如果内存池中的内存可以满足需求的话，否则返回NULL) 参数是需要分配的内存字节数 malloc分配的是一块连续的内存 分配的内存不会被初始化 11.2.2 free 1void free(void *pointer); 参数是NULL时不会产生任何效果 参数是先前从malloc、calloc或realloc返回的值时，将分配的内存归还给内存池 11.3 calloc和realloc 11.3.1 calloc 1void *calloc(size_t num_elements, size_t element_size); 参数包括所需元素的数量和每个元素的字节数 将分配的内存初始化为0 11.3.2 realloc 1void *realloc(void *ptr, size_t new_size); 用于修改一个原先已经分配的内存块的大小 扩大内存块时，在原先的内存块之后添加；缩小内存块时，从原先内存块的尾部删除 11.4 使用动态分配的内存 获得足够存储25个整型的内存 12int *pi;pi = malloc(25 * sizeof(int)); 11.5 常见的动态内存错误 对NULL指针进行解引用操作 对分配的内存进行操作时越界 释放并非动态分配的内存 试图释放一块动态分配的内存的一部分 一块动态内存被释放之后被继续使用 内存泄漏：在使用完毕动态内存后没有进行释放 Ch12 使用结构和指针 12.2 单链表 声明一个节点： 1234typedef struct NODE &#123; struct NODE *link; int value;&#125; Node; 链表结构如图所示： 12.2.1 插入一个有序单链表 1234567891011121314151617181920212223242526272829// 函数的参数是一个指向链表第一个节点的指针，以及一个需要插入的新值#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;sll_node.h&quot;#define FALSE 0#define TRUE 1int sll_insert(register Node **linkp, int new_value) &#123; register Node *current; register Node *new; // 寻找正确的插入位置 while ((current=*linkp) != NULL &amp;&amp; current-&gt;value &lt; new_value) &#123; linkp = &amp;current-&gt;link; &#125; // 为新节点分配内存 new = (Node *)malloc(sizeof(Node)); if (new == NULL) &#123; return FALSE; &#125; new-&gt;value = new_value; // 插入节点 new-&gt;link = current; *linkp = new; return TRUE;&#125; 12.3 双链表 声明一个双链表节点: 12345typedef struct NODE &#123; struct NODE *fwd; struct NODE *bwd; int value;&#125; Node; 双链表结构如图所示： Ch14 预处理器 14.1 预定义符号 符号 样例 含义 _FILE_ “name.c” 进行编译的文件名 _LINE_ 25 文件当前行的行号 _DATE_ “Jan 31 1997” 文件被编译的日期 _TIME_ “18:04:30” 文件被编译的时间 _STDC_ 1 如果编译器遵循ANSI C，值为1 14.2 #define 1#define name stuff 替换文本不仅限于数值字面值常量。 123#define reg register#define do_forever for(;;)#define CASE break;case 14.2.1 宏 #define允许把参数替换到文本中，如： 123#define SQUARE(x) (x)*(x)SQUARE(5) // 输出25 14.2.3 宏与函数 可以使用宏来实现简单的函数，如比较大小： 1#define MAX(a, b) ((a)&gt;(b) ? (a) : (b)) 14.2.6 #undef 移除一个宏定义 1#undef name 14.3 条件编译 1234567#if 常量表达式 statements#elif 常量表达式 statements#else statements#endif 如果常量表达式非零，则statements正常编译，否则不编译","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"复习 - SQ1复形","slug":"others/复习-SQ1复形","date":"2020-11-04T10:51:12.000Z","updated":"2020-11-05T02:32:04.000Z","comments":true,"path":"2020/11/04/others/复习-SQ1复形/","link":"","permalink":"http://example.com/2020/11/04/others/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/","excerpt":"太久没练复形都忘光了。。。整理复习一下","text":"Overview CS Algs by Depth Depth 1 Shape Scramble Solve / / Depth 2 Shape Scramble Solve /-3-3/ /33/ /3/ /-3/ Depth 3 Shape Scramble Solve /3/1/ /-1/-3/ /-3/-2/ /2/3/ /3/3/ /-3/-3/ /3/12/ /-1-2/-3/ /33/-1-2/ /12/-3-3/ /33/-1/ /1/-3-3/ /-3-3/2/ /-2/33/ /3/1-4/ /-14/-3/ Depth 4 Shape Scramble Solve /33/-1-2/-2-4/ /24/12/-3-3/ /-3-3/01/-2-2/ -2/22/12/-3-3/ /3/1-4/42/ /24/1/-4/3/ /3/1-4/-2-4/ /-4-2/1/-4/3/ /33/-1-2/0-4/ /04/12/-3-3/ /33/12/02/ /0-2/21/33/ /33/-1-2/0-2/ /02/12/-3-3/ /-3-3/01/-2/ /2/0-1/33/ /3/1-4/4/ y2 /0-4/-41/3/ 1-1/0-3/5-2/04/ y2 /-4/1/-4/3/ /03/12/-32/ /-34/12/03/ 1-1/0-3/-1-2/3-2/ /-32/12/03/ /3/1-4/02/ /0-2/-14/-3/ /0-3/0-1/02/ /0-2/01/03/ /0-3/0-1/12/ /-1-2/01/03/ 1-1/3/21/-2/ /2/12/03/ /3/12/4/ /-4/-1-2/-3/ 1-1/0-3/-1-2/0-4/ /04/12/03/ 1-1/3/21/-2-3/ /23/-2-1/-3/ /3/12/23/ /-2-3/-1-2/-3/ /33/-1/4/ /-4/1/-3-3/ 1-1/3/21/0-3/ /03/-2-1/-3/ /0-3/0-1/1/ /-1/01/03/ /0-3/0-1/04/ /0-4/01/03/ Depth 5 Shape Scramble Solve Note /03/12/-3/02/ /0-2/3/-1-2/0-3/ /0-3/0-1/1/02/ /0-2/-1/01/03/ 1-1/03/01/-1/0-2/ /02/02/1/03/ /3/12/2-3/34/ /32/-34/12/03/ 1-1/0-3/-1-2/3-4/-3/ /3/-34/12/03/ 1-1/0-3/-1-2/3-2/3/ /-3/-32/12/03/ 1-1/0-3/-1-2/0-4/-3/ /3/04/12/03/ /03/12/04/3/ /-3/62/-12/03/ /33/1/-2/2/ /-2/2/-1/-3-3/ /33/-1-2/-2/1-2/ /-12/2/12/-3-3/ /33/-1-2/02/2-1/ /-21/0-2/12/-3-3/ 1-1/3/21/2-3/2-1/ /-21/-23/-2-1/-3/ 1-1/3/21/4-3/-21/ /2-1/-43/-2-1/-3/ /0-3/0-1/1/32/ /-3-2/-1/01/03/ 1-1/0-3/-1/0-2/-3-2/ /32/02/1/03/ /33/-1-2/-2-4/-3/ /3/24/12/-3-3/ 1-1/0-3/-1-2/0-4/-32/ /3-2/04/12/03/ 1-1/-3/-1-2/4/-2/ /2/-4/12/3/ /33/-1-2/0-4/02/ /0-2/04/12/-3-3/ 1-1/3/21/2/0-1/ /01/-2/-2-1/-3/ 1-1/0-3/-1-2/02/0-1/ /01/0-2/12/03/ /3/12/-2/01/ /0-1/2/-1-2/-3/ /03/12/02/3-2/ /-32/0-2/-1-2/0-3/ /3/1/-2/2/ /-2/2/-1/-3/ /3/1/-2-1/01/ /0-1/21/-1/-3/ 三小角换风筝尾 /3/1/-2/0-1/ /01/2/-1/-3/ 1-1/0-3/-1-2/3-4/32/ /-3-2/-34/12/03/ /3/12/-23/21/ /-2-1/2-3/-1-2/-3/ 1-1/0-3/-1-2/3-2/-3/ /3/-32/12/03/ /03/12/-32/3/ /-3/3-2/-1-2/0-3/ 1-1/0-3/-1-2/3-2/0-2/ /02/-32/12/03/ /3/1-4/02/-1/ /1/0-2/-14/-3/ 构造飞镖 /3/1-4/02/0-2/ /02/0-2/-14/-3/ 构造飞镖 1-1/3/21/2-3/0-1/ /01/-23/-2-1/-3/ /33/-1-2/2/0-1/ /01/-2/12/-3-3/ 三小角并一小角 /-3-3/01/-2-2/1-2/ \\ 合并六星 Depth 6 Shape Scramble Solve Note /0-3/-2-1/-32/-1-2/-4/ /4/12/3-2/21/03/ 1-1/-3/-1-2/2-3/-2-1/0-4/ /04/21/-23/12/3/ 待优化 1-1/0-3/-1-2/3-4/-1-2/-2/ /2/12/ -34/12/03/ 1-1/3/21/4-3/21/02/ /0-2/-2-1/-43/-2-1/-3/ /0-3/0-1/12/2/-1/ /1/-2/-1-2/01/03/ /3/1/-2-1/0-2/01/ /0-1/02/21/-1/-3/ /3/1/-2/2/03/ /0-3/-2/2/-1/-3/ /33/1/-2-2/21/-2-2/ \\ 两步变六星 /3/1/-2/0-1/2/ /-2/01/2/-1/-3/ 两步后23动1 /3/1/-2-1/01/-2/ /2/0-1/21/-1/-3/ /33/1/-2/2/-2-3/ /23/-2/2/-1/-3-3/ /3/12/-2/01/2/ /-2/0-1/2/-1-2/-3/ /3/12/-2/2-3/-2/ /21/2-1/21/-1/-3/ /3/1/-2/2/-23/ /2-3/-2/2/-1/-3/ /33/-1-2/-2/1/2/ /33/12/2/-1/-2/ 1-1/3/2-5/2/0-1/-4/ /4/01/-2/-25/-3/ 构造shield-paw /3/1/-2/2/-2/ /2/-2/2/-1/-3/ 构造shield-kite Depth 7 Shape Scramble Solve /3/1/-2/2/-2/1/ /-1/2/-2/2/-1/-3/ /0-3/0-1/02/0-2/02/0-1/ /01/0-2/02/0-2/01/03/","categories":[{"name":"Cube","slug":"Cube","permalink":"http://example.com/categories/Cube/"}],"tags":[{"name":"sq1","slug":"sq1","permalink":"http://example.com/tags/sq1/"},{"name":"cube","slug":"cube","permalink":"http://example.com/tags/cube/"}]},{"title":"Linux - Learn","slug":"learning-notes/Linux学习","date":"2020-11-03T16:00:00.000Z","updated":"2022-04-28T07:30:40.000Z","comments":true,"path":"2020/11/04/learning-notes/Linux学习/","link":"","permalink":"http://example.com/2020/11/04/learning-notes/Linux%E5%AD%A6%E4%B9%A0/","excerpt":"Linux学习记录","text":"了解系统信息 硬盘大小 123fdisk -l&#x2F;dev&#x2F;sda 操作系统中第一块硬盘的名称以及所在路径Linux操作系统一切皆文件 （文件名） sd (硬盘类型) a（第一块） 内存大小 1cat &#x2F;proc&#x2F;meminfo cpu大小 1cat &#x2F;proc&#x2F;cpuinfo 收集系统信息 1uname -a Linux文件系统 12345678910111213&#x2F;bin 普通用户和管理员都可以执行的命令&#x2F;sbin 只有管理员才能执行的命令 eg.关机重启&#x2F;boot 引导 主引导目录 独立的分区 启动菜单 内核&#x2F;dev device 设备文件存放目录&#x2F;etc 配置文件存放目录&#x2F;home 普通用户的家目录&#x2F;root 管理员的家&#x2F;media 光驱的挂载目录&#x2F;mnt 临时设备的挂载目录&#x2F;proc 里面的数据都在内存中，进程的所在目录&#x2F;tmp 临时文件存放目录&#x2F;usr 第三方软件的安装目录&#x2F;var 常变文件存放目录 eg.日志文件、邮件文件 挂载光驱 12弹出光驱：umount &#x2F;dev&#x2F;cdrom挂载光驱：mount &#x2F;dev&#x2F;cdrom &#x2F;media Linux文件类型的显示颜色 1234567蓝色 目录黑色 普通文件浅蓝色 符号链接（快捷方式）黑底黄字 设备文件 硬盘 sda红色 压缩包绿色 带有执行权限的文件紫色 图片 模块文件 压缩和解压缩 文件压缩和解压缩 12gzip bigfilegunzip bigfile.gz 12bzip2 bigfilebunzip2 bigfile.bz2 目录(文件夹)打包压缩 12tar -zcf &#x2F;tmp&#x2F;allfile.tar.gz &#x2F;tmp&#x2F;allfiletar -jcf &#x2F;tmp&#x2F;allfile.tar.bz2 &#x2F;tmp&#x2F;allfile 目录(文件夹)解压缩并解包 123tar -zxf &#x2F;tmp&#x2F;allfile.tar.gz -C &#x2F;tmptar -jxf &#x2F;tmp&#x2F;allfile.tar.bz2 -C &#x2F;tmp-C 指定解包位置 vim 模式切换 123命令模式 -&gt; 输入模式：i输入模式 -&gt; 命令模式：Esc命令模式 -&gt; 末行模式：: 末行模式命令 12345:wq 保存并退出:q! 不保存退出:set nu 显示行号:% s&#x2F;old&#x2F;new&#x2F;g 每一行中的old替换成new:50,56 d 删除50-56行的数据 命令模式命令 123456780 光标移动到当前行首$ 光标移动到当前行末yy 复制当前行2yy 复制当前行以及后一行，其他数字以此类推p 粘贴到当前行下一行dd 删除当前行gg 回到第一行G 回到最后一行 Linux软件安装——封装后的软件包 后缀名 123rpm red hat系统deb debian系统源码包 不考虑系统版本 有关软件包安装的命令 123456rpm -qa 列出所有已经安装的rpm包查询特定的rpm包使用管道符：rpm -qa | grep &quot;tree&quot;rpm -qpi 软件名 确认该软件的作用rpm -qpl 软件名 确认该软件的安装路径(无法修改)rpm -ivh 软件名 安装软件rpm -e 软件名 软件卸载 Linux软件安装——yum 12yum install 软件名yum remove 软件名 用户和组 三个重要文件 12345678910111213&#x2F;etc&#x2F;passwd 保存操作系统中所有的用户信息root : x : 0 : 0 : root : &#x2F;root : &#x2F;bin&#x2F;bash每一条目共7个字段，用冒号隔开字段1：用户名字段2：密码占位符字段3：用户的UID 0 表示超级用户 500-60000 普通用户 1-499 程序用户字段4：基本组的GID，先有组才有用户字段5：用户信息记录字段字段6：用户的家目录字段7：用户登录系统后使用的命令解释器 12345678910&#x2F;etc&#x2F;shadow 保存了用户密码信息root : $6$ME9wjPHAid5ds$PO&#x2F;GlBVEt1 : 18325 : 0 : 99999 : 7 :::字段1：用户名*字段2：用户的密码加盐并通过散列算法后的字符串（sha）字段3：距离1970&#x2F;1&#x2F;1密码最近一次修改的时间字段4：密码的最短有效期*字段5：密码的最长有效期（建议时间 90）字段6：密码过期前7天警告字段7：密码的不活跃期字段8：用户的失效时间 1&#x2F;etc&#x2F;group 记录了系统中所有组的信息 建立和调整用户属性 123456789101112131415161718192021222324252627282930313233343536371、建立一个名为class1的组ID为1000，class2的组ID为2000建立：groupadd class1groupadd -g 2000 class2修改gid：groupmod -g 1000 class1查看：vim &#x2F;etc&#x2F;group2、建立tom用户要求其基本组是class1,附加组为class2，tom用户的UID为600建立：useradd -g class1 -G class2 -u 600 tom修改：usermod查看：id tom3、建立一个程序用户UID为250,用户名为testuser，没有家目录（程序用户没有登录系统权限）useradd -u 250 -M -s &#x2F;sbin&#x2F;nologin testuser-M：没有家目录-s &#x2F;sbin&#x2F;nologin：不能登录4、为tom用户设定密码为123，并设定密码最长有效期为90天，将用户密码进行锁定使其无法登录passwd tom 设定密码chage -M 90 tom 设定密码最长有效期或者修改配置文件&#x2F;etc&#x2F;login.defspasswd -l tom 锁定passwd -u tom 解锁查看：passwd -S tomvim &#x2F;etc&#x2F;shadow5、删除tom用户和testuser用户，删除class1组和class2组userdel -r tom （-r 连同用户的家目录一起删除）userdel -r testusergroupdel class1groupdel class1 文件目录权限 列出文件信息 123456ls -a 列出所有文件，包括隐藏文件ls -l(ll) 列出文件详细信息文件：-rw-rw-r--.(权限) 1(链接数) centos(所属用户) centos(所属组) 12(文件大小，字节) Sep 12 10:07(最后修改时间) test.txt目录：drwxrwxr-x.(权限) 2(子目录数) centos(所属用户) centos(所属组) 6 Sep 12 10:06(最后修改时间) testdirls -ld 列出某一目录的详细信息ls -h 用人能看懂的方式显示文件大小 权限详细 1234567891011121314- rw- rw- r--.d rwx rwx r-x.共4个字段字段1：文件类型 -普通文件 d目录文件 l符号链接文件 b块设备字段2：文件所属者的权限 r w x 文件 读取 写入 可执行 目录 查看目录文件 增删文件 进入目录字段3：文件所属组的权限字段4：其他用户的权限 赋权限 12345方法1：chmod 对象 算术运算符 权限 文件 对象：u-所属者 g-所属组 o-其他用户 a-所有用户 算术运算符：- + &#x3D; 权限：r w x方法2：chmod 777 文件 改变文件的所属者和所属组 12chown 用户 文件chgrp 组 文件 粘滞位 sgid suid权限 12345678910粘滞位针对目录赋权，目录中创建的文件只有建立者可以删除 chmod o+t 文件 chmod o-t 文件sgid 针对目录建立的权限，在该目录中建立的文件所属组继承父目录的所属组 chmod g+s 文件 chmod g-s 文件suid 对可执行文件建立。谁运行该文件，就具有该文件所属者的权限 chmod u+s 文件 chmod u-s 文件 eg. chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim 查找有异常权限的文件 1234查找有suid权限的可执行文件find &#x2F;usr&#x2F;bin -perm 4755其中权限的第一个4表示suid权限，如果是2则表示sgid权限，如果是1则表示粘滞位权限的多一位也可以用于赋权限 不再允许添加新用户 123456789新建用户时会更改的文件 &#x2F;etc&#x2F;group &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow home&#x2F;xxxx锁定文件从而不能添加新用户 chattr +i &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow查看文件是否被锁定 lsattr &#x2F;etc&#x2F;passwd umask 1234567一般目录的最高权限是777一般文件的最高权限是666用户创建的文件通过umask来确定其权限root的umask是0022(第一位是特殊权限)普通用户并且uid&#x3D;sid的umask是0002umask的设置在&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc两个文件中 网络地址配置 12345678910111. 确认网卡信息：ip addr &#x2F; ifconfig2. 关闭NetworkManager服务：systemctl stop NetworkManager3. 网卡启用桥接模式，并配置网络地址： ip addr add IP&#x2F;掩码长度 dev ens334. 设置网关： ip route add default via IP dev ens335. 配置DNS： vim &#x2F;etc&#x2F;resolv.conf nameserver 202.120.2.1016. 关闭防火墙： systemctl stop firewalld.service 日志文件 123456789101112位置：&#x2F;var&#x2F;log日志记录的配置文件：&#x2F;etc&#x2F;rsyslog.conf 其中配置方式为 日志类型.日志级别 ，如authpriv.*表示记录所有级别的登录日志日志分类： 系统日志 &#x2F;var&#x2F;log&#x2F;messages 登录日志 &#x2F;var&#x2F;log&#x2F;secure 程序日志日志记录的日志级别：debug, info, notice, warning(warn), err(error), crit, alert, emerg(panic)最不严重 -&gt; 最严重配置日志备份服务器：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43252204&#x2F;article&#x2F;details&#x2F;105518163 WEB服务-apache 开启并使用apache 1234561. 启动服务 service httpd start2. 验证服务是否开启 ss -antpl | grep 803. 主页建立 vim &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html httpd配置文件 12345678910111213141516171819位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf默认会开启共享目录功能，这样会导致别人可以远程下载&#x2F;var&#x2F;www&#x2F;html中的内容，建议将其关闭： Options Indexes FollowSymLinks改为Options FollowSymLinks限制访问，将Require all granted修改为以下语句： &lt;RequireAll&gt; Require all granted Require not ip 192.168.1.10 192.168.2.0&#x2F;24 &#x2F;&#x2F;拒绝192.168.1.10和192.168.2.0网段客户机访问 &lt;&#x2F;RequireAll&gt;用户授权限制，只有通过指定的用户名密码才能访问网页： 设置用户名密码：htpasswd -c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser test (-c表示新建文件) 设置该文件只有apache用户可读： chown apache httpuser chmod 400 httpuser 修改配置文件： Authtype basic Authname &quot;Input username and password&quot; &#x2F;&#x2F; 提示信息 Authuserfile &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser Require valid-user lamp平台搭建 12345678910111213141. 安装apache2. 安装mysql yum install mysql-server &#x2F;&#x2F; 安装 service mysqld start &#x2F;&#x2F; 启动 mysqladmin -u root -p password &quot;123.sck&quot; &#x2F;&#x2F; 设置root密码 mysql -u root -p &#x2F;&#x2F; 登录数据库3. 安装php yum install php yum install php-mysqlnd yum install php-mbstring4. 配置php配置文件 vim &#x2F;etc&#x2F;php.ini 将short_open_tag从Off改为On5. 在&#x2F;var&#x2F;www&#x2F;html新建一个php文件 iptables防火墙 12345四个表： raw mangle nat 网络地址转换 filter 过滤","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Hexo+Volantis个人博客部署","slug":"instruction/Hexo-Volantis个人博客部署","date":"2020-11-03T09:46:42.000Z","updated":"2022-04-28T06:42:26.000Z","comments":true,"path":"2020/11/03/instruction/Hexo-Volantis个人博客部署/","link":"","permalink":"http://example.com/2020/11/03/instruction/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/","excerpt":"个人博客配置心得","text":"配置部署Hexo 配置流程 参考链接 安装npm 安装git 其中配置npm源 123456# 获取npm源npm get registry# 修改为淘宝源npm config set registry http://registry.npm.taobao.org/# 重置# npm config set registry https://registry.npmjs.org/ 常用命令 12345# 上传至githubhexo g &amp;&amp; hexo d# 本地运行hexo g &amp;&amp; hexo s Markdown公式显示问题 使用hexo-renderer-markdown-it插件 处理Markdown图片问题 在最开始的尝试中遇到以下问题： 直接将图片保存到github，在hexo编译生成的html网页中通过相对路径访问速度太慢 将博客部署到gitee上，由于服务器在国内，图片加载速度确实比github快很多，但是问题在于部署在gitee上的博客会有各种奇怪显示问题，所以也放弃 最终的解决办法： 先在github新建一个仓库Source，专门用来存放博客文章用到的图片 使用jsdelivr提供的cdn加速 在本地编写好markdown后，将图片文件夹复制到Source目录下并push到github仓库 在markdown文档中通过ctrl+f将所有图片的路径前缀改为https://cdn.jsdelivr.net/gh/&lt;github用户名&gt;/Source@latest/&lt;文件夹名&gt; Volantis主题配置 主题安装 修改./_config.yml 1theme: volantis 下载主题 1npm i hexo-theme-volantis volantis主题会安装在./node_modules/hexo-theme-volantis中 主题个性化 搜索工具安装 1npm i -S hexo-generator-search hexo-generator-json-content 字数统计工具安装 1npm i hexo-wordcount 主题配置文件 顶部导航栏 1234567891011121314151617181920212223navbar: logo: # choose [img] or [icon + title] img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/taiga.svg menu: - name: 主页 icon: fab fa-stack-overflow url: / - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: Search... # Search bar placeholder 封面 12345678910111213141516171819202122cover: layout_scheme: dock # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) background: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/interstellar.jpg logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;Schenk - Blog&#x27; subtitle: &#x27;SJTUer | Cuber&#x27; features: - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ 全局CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556custom_css: navbar: height: 44px width: auto # auto, max effect: [shadow, blur, floatable] # [shadow, floatable, blur] sidebar: effect: [shadow, floatable] # [shadow, floatable, blur] body: effect: [shadow, floatable] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true grayscale: false # Enable grayscale effect text_align: # left, right, justify, center h1: center h2: left h3: left h4: left p: justify gap: h2: 30px # Spacing above H2 (only px unit) h3: 18px # Spacing above H3 (only px unit) h4: 8px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... fontsize: root: 16px h1: 1.5rem # 不推荐用在文章中 h2: 1.5rem h3: 1.25rem h4: 1.125rem h5: 1rem h6: 1rem list: .9375rem meta: .875rem code: .875rem footnote: .78125rem fontfamily: logofont: fontfamily: &#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27; name: &#x27;Microsoft Yahei&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27; name: &#x27;Microsoft Yahei&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf weight: normal style: normal codefont: fontfamily: &#x27;UbuntuMono&#x27; name: &#x27;UbuntuMono&#x27; url: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/UbuntuMono-Regular.ttf weight: normal style: normal 页脚 1234567site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [copyright] # site copyright copyright: &#x27;[Copyright © 2020 Schenk](https://github.com/Schenk75/Schenk75.github.io)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; 文章布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: false # true, false # show readmore button readmore: always # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, wordcount, counter] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: data:image/png;base64,666 # ---------------- # 打赏组件 (for layout: post) donate: enable: false height: 128px images: - https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags] # meta library meta_library: # 默认文章作者（可在 front-matter 中覆盖） author: avatar: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg name: Schenk url: / # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag 侧边栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106sidebar: # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, webinfo] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg shape: circle # circle, rectangle url: /about/ title: Schenk subtitle: jinrishici: false # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/github-icon.svg size: 30px url: https://github.com/Schenk75 - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/struts.svg url: / - img: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/logos/WCAlogo.svg url: https://cubingchina.com/results/person/2018SHEN04 # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fas fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2020/11/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: service: busuanzi # busuanzi, leancloud siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; 统计工具 12analytics: busuanzi: https://cdn.jsdelivr.net/gh/Schenk75/Source@master/tools/busuanzi.pure.mini.js 关闭评论 1234comments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: # valine, minivaline, disqus, gitalk, vssue, livere, isso, hashover 插件 1234567891011plugins: ######## Plugins to optimize the experience: # Codeblock Copy Button clipboard: enable: true js: https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js ######## Plugins for SEO: # npm i hexo-wordcount wordcount: enable: true 页面布局模板 参考链接 front-matter设置 参考链接","categories":[{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Docker - Learn","slug":"lookup/docker-notes","date":"2020-10-23T16:00:00.000Z","updated":"2022-04-28T07:38:08.000Z","comments":true,"path":"2020/10/24/lookup/docker-notes/","link":"","permalink":"http://example.com/2020/10/24/lookup/docker-notes/","excerpt":"Docker学习记录","text":"底层原理 Docker是怎么工作的？ Docker是一个C-S结构的系统，Docker的守护进程运行在服务主机上，通过Socket从客户端访问。 DockerServer接收到DockerClient的指令就会执行这个命令。 Docker为什么比VM快？ Docker有着比虚拟机更少的抽象层 Docker利用的是宿主机的内核，VM需要有Guest OS。所以新建一个容器的时候，docker不需要像VM一样重新加载一个操作系统内核，避免引导 Docker常用命令 docker的默认工作路径 1/var/lib/docker 帮助命令 123docker version # 显示docker的版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker &lt;命令&gt; --help # 查看帮助命令 镜像命令 docker images 查看所有本地的主机上的镜像 1234567891011121314[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 9 months ago 13.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IDCREATED 镜像的创建时间SIZE 镜像的大小# 命令可选项-a, --all 列出所有镜像-q, --quiet 只显示镜像的id docker search 搜索镜像 1234567[root@localhost ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10046 [OK] mariadb MariaDB is a community-developed fork of MyS… 3680 [OK] # 可选项，通过收藏数过滤--filter=STAR=3000 搜索出来的镜像是STARS大于3000的 docker pull [:tag] 下载镜像 123456789101112131415161718192021222324252627282930313233343536[root@localhost ~]# docker pull mysqlUsing default tag: latest # 如果不写tag，默认是latestlatest: Pulling from library/mysqld121f8d1c412: Pull complete # 分层下载，docker镜像的核心 联合文件系统f3cebc0b4691: Pull complete 1862755a0b37: Pull complete 489b44f3dbb4: Pull complete 690874f836db: Pull complete baa8be383ffb: Pull complete 55356608b4ac: Pull complete dd35ceccb6eb: Pull complete 429b35712b19: Pull complete 162d8291095c: Pull complete 5e500ef7181b: Pull complete af7528e958b6: Pull complete Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 下载指定版本，共用的层会复用，不用重复下载[root@localhost ~]# docker pull mysql:5.75.7: Pulling from library/mysqld121f8d1c412: Already exists f3cebc0b4691: Already exists 1862755a0b37: Already exists 489b44f3dbb4: Already exists 690874f836db: Already exists baa8be383ffb: Already exists 55356608b4ac: Already exists 277d8f888368: Pull complete 21f2da6feb67: Pull complete 2c98f818bcb9: Pull complete 031b0a770162: Pull complete Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像 12docker rmi -f &lt;镜像id&gt; [&lt;镜像id&gt; &lt;镜像id&gt;] # 删除指定的镜像docker rmi -f $(docker images -aq) # 删除所有镜像 容器命令 **注：**有了镜像才可以创建容器，以centos镜像为例 1docker pull centos docker run [可选参数] 新建并启动容器 1234567891011121314151617# 参数说明--name=&quot;&lt;Name&gt;&quot; 容器名字，自定义，用来区分容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p 指定容器的端口，配置端口转发 -p ip:主机端口:容器端口 -p 主机端口:容器端口（常用） -p 容器端口-P 随机指定端口例：# 启动并进入容器[root@localhost ~]# docker run -it centos /bin/bash# 退出容器并关闭容器[root@bebbdced119e /]# exit# 退出容器但不关闭容器Ctrl + p + q docker ps [可选参数] 列出运行的容器 1234# 参数说明-a 列出所有运行过的容器-n=&lt;n&gt; 列出最近创建的n个容器-q 只显示容器编号 **docker rm 删除容器 123docker rm &lt;容器id&gt; 删除指定容器，不能删除正在运行的容器，若要强制删除加参数-fdocker rm -f $(docker ps -aq) 删除所有的容器docker ps -a -q|xargs docker rm 删除所有的容器 启动和停止容器 1234docker start &lt;容器id&gt; 启动容器docker restart &lt;容器id&gt; 重启容器docker stop &lt;容器id&gt; 停止容器docker kill &lt;容器id&gt; 强制停止容器 常用其他命令 后台启动容器 1234docker run -d centos# 问题：docker ps发现centos停止了# 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 查看日志 12docker logs -ft &lt;容器id&gt; # 查看所有日志docker logs -ft --tail &lt;n&gt; &lt;容器id&gt; # 查看最新的n条日志 **查看容器中的进程信息 ** 1docker top &lt;容器id&gt; 查看容器的元数据 1docker inspect &lt;容器id&gt; 进入正在后台运行的容器 1234567# 方法1docker exec -it &lt;容器id&gt; &lt;bashshell&gt;# 进入容器后开启一个新的终端，可以在里面操作（常用）# 方法2docker attach &lt;容器id&gt;# 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件 1docker cp &lt;容器id&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"Lookup","slug":"Lookup","permalink":"http://example.com/categories/Lookup/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]}],"categories":[{"name":"SGX","slug":"SGX","permalink":"http://example.com/categories/SGX/"},{"name":"Paper Reading","slug":"Paper-Reading","permalink":"http://example.com/categories/Paper-Reading/"},{"name":"Instruction","slug":"Instruction","permalink":"http://example.com/categories/Instruction/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/categories/Rust/"},{"name":"ORAM","slug":"ORAM","permalink":"http://example.com/categories/ORAM/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"Lookup","slug":"Lookup","permalink":"http://example.com/categories/Lookup/"},{"name":"Go","slug":"Go","permalink":"http://example.com/categories/Go/"},{"name":"Useful","slug":"Useful","permalink":"http://example.com/categories/Useful/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Cube","slug":"Cube","permalink":"http://example.com/categories/Cube/"}],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://example.com/tags/sgx/"},{"name":"db","slug":"db","permalink":"http://example.com/tags/db/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"oram","slug":"oram","permalink":"http://example.com/tags/oram/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"distributed system","slug":"distributed-system","permalink":"http://example.com/tags/distributed-system/"},{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/tags/cryptography/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"blockchain","slug":"blockchain","permalink":"http://example.com/tags/blockchain/"},{"name":"wasm","slug":"wasm","permalink":"http://example.com/tags/wasm/"},{"name":"eos","slug":"eos","permalink":"http://example.com/tags/eos/"},{"name":"makefile","slug":"makefile","permalink":"http://example.com/tags/makefile/"},{"name":"reproduction","slug":"reproduction","permalink":"http://example.com/tags/reproduction/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"sq1","slug":"sq1","permalink":"http://example.com/tags/sq1/"},{"name":"cube","slug":"cube","permalink":"http://example.com/tags/cube/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]}