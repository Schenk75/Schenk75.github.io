<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust - Learn</title>
      <link href="2020/11/13/Rust-notes/"/>
      <url>2020/11/13/Rust-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Ch0-安装Rust">Ch0 安装Rust</h2><ul><li><p>使用rustup安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></li><li><p>安装时出现的问题（<s>未完全</s>解决）：默认<code>.cargo</code>环境变量设置为了<code>/home/&lt;username&gt;/~/.cargo</code>，导致在用户家目录下又新建了<code>~</code>目录，在安装完rust后，将<code>.cargo</code>目录移动到<code>~/</code>家目录下，并修改所有可能会更改环境变量的文件，包括<code>~/.profile</code>、<code>/etc/profile</code>、<code>/etc/bash.bashrc</code>、<code>~/.cargo/env</code>，将其中的<code>/home/&lt;username&gt;/~/.cargo</code>改为<code>~/.cargo</code>。但是每当打开终端时，环境变量PATH还是会自动添加<code>/home/&lt;username&gt;/~/.cargo/bin</code></p><ul><li><p><s>暂时的</s>解决方案：在<code>~/.bashrc</code>文件中添加语句，覆盖错误的环境变量(重启后就成功了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/.cargo/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Ch1-Cargo">Ch1 Cargo</h2><h3 id="1-1-使用Cargo创建项目">1.1 使用Cargo创建项目</h3><ul><li><p>创建hello_world目录，并在其中新建二进制项目hello_world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world</span><br></pre></td></tr></table></figure></li><li><p>创建库项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world --lib</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-1-Cargo-toml">1.1.1 Cargo.toml</h4><p>Cargo.toml是项目的配置文件，通过cargo new自动生成</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><ul><li>[package]片段：配置一个包，包含项目名称、版本、作者和Rust版本</li><li>[dependencies]片段：罗列项目依赖</li></ul><h4 id="1-1-2-源代码目录src">1.1.2 源代码目录src</h4><p>包含main.rs以及其他源文件</p><h3 id="1-2-构建并运行Cargo项目">1.2 构建并运行Cargo项目</h3><p><strong>编译项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><p><strong>编译并运行项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br></pre></td></tr></table></figure><p><strong>快速检查代码确保其可以编译，但不生成可执行文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br></pre></td></tr></table></figure><p>以上命令会生成以下文件：</p><h4 id="1-2-1-可执行文件">1.2.1 可执行文件</h4><p>存放目录为<code>./target/debug/hello_world</code></p><h4 id="1-2-2-Cargo-lock">1.2.2 Cargo.lock</h4><p>Cargo.lock记录项目依赖的实际版本，确保项目构建是可重现的，这个文件不需要人为修改</p><h3 id="1-3-发布-release-构建">1.3 发布(release)构建</h3><p>当项目最终准备好发布时，可以优化编译项目是的Rust代码运行更快</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br></pre></td></tr></table></figure><p>此时生成的可执行文件在<code>./target/release/</code>目录下</p><h2 id="Ch2-引入-guess-number">Ch2 引入 - guess_number</h2><h3 id="2-1-创建变量">2.1 创建变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure><ul><li><code>let</code> 创建变量，变量默认不可变</li><li><code>mut</code> 使得变量可变</li><li><code>::</code> 表明new是<code>String</code>类型的一个关联函数</li></ul><h3 id="2-2-从标准输入读取">2.2 从标准输入读取</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>io::stdin</code>函数返回一个终端标准输入句柄</li><li><code>read_line</code>将标准输入存入字符串</li><li><code>&amp;</code>表示这个参数是一个引用</li><li><code>read_line</code>函数返回一个<code>Result</code>类型（枚举），成员有<code>Ok</code>和<code>Err</code></li><li><code>Result</code>实例有<code>expect</code>方法：<ul><li>若<code>Result</code>值为<code>Ok</code>，<code>expect</code>获取<code>Ok</code>中的值并原样返回</li><li>若<code>Result</code>值为<code>Err</code>，<code>expect</code>导致程序崩溃，并显式当做参数传给<code>expect</code>的信息</li></ul></li></ul><h3 id="2-3-crate">2.3 crate</h3><p>crate是一个Rust代码包</p><ul><li>我们构建的项目是一个<strong>二进制crate</strong></li><li>rand crate是一个<strong>库crate</strong></li></ul><h4 id="2-3-1-导入外部crate">2.3.1 导入外部crate</h4><p>以rand crate为例</p><ul><li><p>在使用rand编写代码之前需要修改<code>Cargo.toml</code>文件</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.5.5&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>再进行<code>cargo build</code>，此时会从Crates.io拷贝数据并下载对应的库文件，需要更换国内镜像源进行加速，编辑<code>.cargo/config</code>文件，加入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;</span><br><span class="line">replace-with &#x3D; &#39;ustc&#39;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-更新crate">2.3.2 更新crate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo update</span><br></pre></td></tr></table></figure><h4 id="2-3-3-获取所有本地依赖提供的文档">2.3.3 获取所有本地依赖提供的文档</h4><p>查看应该 <code>use</code>哪个<code>trait</code>以及该从<code>crate</code>中调用哪个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo doc --open</span><br></pre></td></tr></table></figure><h2 id="Ch3-常见编程概念">Ch3 常见编程概念</h2><h3 id="3-1-变量和可变性">3.1 变量和可变性</h3><ul><li><p>使用<code>let</code>声明的变量默认是不可改变的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">5</span>;   <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure></li><li><p>在变量名之前加<code>mut</code>来使其可变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">5</span>;   <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-1-变量和常量的区别">3.1.1 变量和常量的区别</h4><ul><li><p>常量使用关键字<code>const</code>声明，并且必须<strong>注明值的类型</strong></p></li><li><p>不能对常量使用<code>mut</code></p></li><li><p>常量只能被设置为常量表达式，而不能是函数调用的结果</p></li></ul><h4 id="3-1-2-隐藏">3.1.2 隐藏</h4><ul><li><p>定义一个与之前变量同名的新变量，而新变量会<strong>隐藏</strong>之前的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>当再次使用<code>let</code>时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字</p></li></ul><h3 id="3-2-数据类型">3.2 数据类型</h3><p>Rust 是 <strong>静态类型</strong>语言，在编译时就必须知道所有变量的类型</p><h4 id="3-2-1-标量类型">3.2.1 标量类型</h4><ul><li><strong>标量</strong>类型代表一个单独的值</li></ul><h5 id="整型">整型</h5><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal</td><td><code>98_222</code></td></tr><tr><td>Hex</td><td><code>0xff</code></td></tr><tr><td>Octal</td><td><code>0o77</code></td></tr><tr><td>Binary</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr></tbody></table><h5 id="浮点型">浮点型</h5><ul><li><p>Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位</p></li><li><p>默认类型是 <code>f64</code></p></li></ul><h5 id="布尔型">布尔型</h5><ul><li><code>bool</code>，两个可能的值<code>true</code>和<code>false</code></li></ul><h5 id="字符类型">字符类型</h5><ul><li><code>char</code> 类型的大小为四个字节，并代表了一个 Unicode 标量值</li></ul><h4 id="3-2-2-复合类型">3.2.2 复合类型</h4><h5 id="元组类型">元组类型</h5><ul><li><p>元组长度固定：一旦声明，其长度不会增大或缩小</p></li><li><p>元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;   <span class="comment">// 解构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five_hundred = tup.<span class="number">0</span>;   <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure><h5 id="数组类型">数组类型</h5><ul><li>数组中的每个元素的类型必须相同</li><li>Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">0</span>; <span class="number">10</span>];   <span class="comment">// 初始化一个长度为10的全零数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];   <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure><h3 id="3-3-函数">3.3 函数</h3><ul><li><p><code>fn</code> 关键字声明新函数</p></li><li><p>在函数签名中，<strong>必须</strong>声明每个参数的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-1-具有返回值的函数">3.3.1 具有返回值的函数</h4><ul><li><p>以表达式结尾</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-注释">3.4 注释</h3><ul><li>// 单行注释</li></ul><h3 id="3-5-控制流">3.5 控制流</h3><h4 id="3-5-1-if表达式">3.5.1 if表达式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rust 不会尝试自动地将非布尔值转换为布尔值，所以<code>if</code>后跟的表达式必须是<code>bool</code></li></ul><h5 id="在let语句中使用if">在let语句中使用if</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>代码块的值是其最后一个表达式的值</li><li><code>if</code>和<code>else</code>中返回的类型要相同</li></ul><h4 id="3-5-2-循环">3.5.2 循环</h4><h5 id="loop">loop</h5><ul><li>无限循环，直到按下ctrl+c，或有break</li></ul><h5 id="while">while</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    number = number - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for遍历集合">for遍历集合</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch4-所有权">Ch4 所有权</h2><h3 id="4-1-什么是所有权">4.1 什么是所有权</h3><ul><li>Rust管理内存的方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查</li></ul><h4 id="4-1-1-所有权规则：">4.1.1 所有权规则：</h4><blockquote><ol><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol></blockquote><h4 id="4-1-2-变量作用域">4.1.2 变量作用域</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3-String类型">4.1.3 String类型</h4><ul><li>字符串的字面值是不可变的，而<code>String</code>类型的字符串是可变的</li><li><code>String</code>类型的字符串被分配到<strong>堆</strong>上，所以能够存储在编译时未知大小的文本</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于字符串字面值来创建String</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-1-4-内存与分配">4.1.4 内存与分配</h4><p>对于<code>String</code>类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向操作系统请求内存</li><li>需要一个当我们处理完<code>String</code>时将内存返回给操作系统的方法</li></ul><p>Rust处理第二点的策略：内存在拥有它的变量离开作用域后就被自动释放</p><h4 id="4-1-5-存储在堆上的变量">4.1.5 存储在堆上的变量</h4><h5 id="1-移动">1. 移动</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234252508.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234252508.png" srcset="data:image/png;base64,666" alt="image-20201110234252508"></p><p><code>String</code> 由三部分组成，如上图所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。</p><p>当 <code>s2</code> 和 <code>s1</code> 离开作用域，他们都会尝试释放相同的内存。这是一个叫做<strong>二次释放</strong>的错误，两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>在Rust中，经过以上语句，会认为s1不再有效，即<code>s1</code> 被<strong>移动</strong>到了 <code>s2</code> 中，因此当<code>s1</code>离开作用域时不会释放内存。</p><h5 id="克隆">克隆</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br></pre></td></tr></table></figure><p><code>s2</code>深度复制了<code>s1</code>堆上的内容，而不仅仅是栈上的指针。</p><ul><li>以上只针对存储在堆上的类型，而对于类似整型等存储在栈上的类型，可以直接拷贝，变量值不会被移动</li></ul><h4 id="4-1-6-所有权与函数">4.1.6 所有权与函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中, </span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-引用与借用">4.2 引用与借用</h3><p>当<code>String</code>类型的变量传入函数中时，如何以引用的方式传入而不是将所有权交给函数？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;  <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">   <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234314662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234314662.png" srcset="data:image/png;base64,666" alt="image-20201110234314662"></p><ul><li><p><code>&amp;s1</code>语法让我们创建一个<strong>指向</strong>值<code>s1</code>的引用，但是并不拥有它</p></li><li><p>我们将获取引用作为函数参数称为<strong>借用</strong></p></li><li><p>引用<strong>默认</strong>不允许被修改</p></li></ul><h4 id="4-2-1-可变引用">4.2.1 可变引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用，如以下代码是非法的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s被引用了两次，非法</span></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure><ul><li><p>这样的限制可以避免<strong>数据竞争</strong>，即</p><ul><li>两个或更多指针同时访问同一数据</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制</li></ul></li><li><p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能<strong>同时</strong>拥有</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可变引用和不可变引用不能同时存在，如以下代码非法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><ul><li><p>由于一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，所以以下代码合法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-2-2-悬垂引用">4.2.2 悬垂引用</h4><ul><li><p>所谓<strong>悬垂指针</strong>是其指向的内存可能已经被分配给其它持有者</p></li><li><p>在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域，如以下函数非法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。危险！</span></span><br></pre></td></tr></table></figure><ul><li>而应该直接返回<code>String</code>，将所有权移动出去</li></ul></li></ul><h3 id="4-3-Slice类型">4.3 Slice类型</h3><ul><li><code>slice</code>是一个没有所有权的数据类型</li><li><code>slice</code>允许你引用集合中一段连续的元素序列，而不用引用整个集合</li></ul><h4 id="4-3-1-字符串slice">4.3.1 字符串slice</h4><p>字符串 slice是<code>String</code>中一部分值的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> all_s = &amp;s[..];</span><br></pre></td></tr></table></figure><ul><li>字符串字面值就是slice，如<code>let s = &quot;Hello world&quot;</code>中，<code>s</code>的类型是<code>&amp;str</code>，是一个指向二进制程序特定位置的slice</li></ul><h4 id="4-3-2-其他类型的slice">4.3.2 其他类型的slice</h4><p>如数组slice:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="Ch5-结构体">Ch5 结构体</h2><h3 id="5-1-结构体的定义和实例化">5.1 结构体的定义和实例化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并修改字段</span></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>想要修改实例中的字段，必须将整个结构体声明为可变</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>..</code>语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值</li></ul><h4 id="5-1-1-元组结构体">5.1.1 元组结构体</h4><ul><li>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5-1-2-结构体数据的所有权">5.1.2 结构体数据的所有权</h4><ul><li>结构体可以直接存放自身拥有所有权的类型，如<code>String</code>等</li><li>结构体在存储<code>引用</code>、<code>slice</code>等没有自身所有权的类型时，需要用上生命周期</li></ul><h3 id="5-2-结构体引用和打印">5.2 结构体引用和打印</h3><h4 id="5-2-1-函数调用结构体">5.2.1 函数调用结构体</h4><p>函数引用结构体时，不需要获得其所有权，所以采用引用的方式调用:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        area(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-结构体打印">5.2.2 结构体打印</h4><p>需要使用派生trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    <span class="comment">// 或 println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-方法语法">5.3 方法语法</h3><p>使用关键字<code>impl</code>给结构体定义方法，可以避免另外定义函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 将self以不可变引用的方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.area()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-关联函数">5.3.1 关联函数</h4><p>在<code>impl</code>块中定义不以<code>self</code>作为参数的函数，通常用作返回一个结构体实例的构造函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 返回一个正方形的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>let sq = Rectangle::square(3);</code>调用关联函数</li></ul><h2 id="Ch6-枚举和模式匹配">Ch6 枚举和模式匹配</h2><h3 id="6-1-定义枚举">6.1 定义枚举</h3><ul><li>以IP地址类型为例，通过<code>enum</code>定义一个枚举类型：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建<code>IpAddrKind</code>实例：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4(<span class="number">127.0</span>.<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>枚举类型也可以像结构体一样使用<code>impl</code>为其定义方法</li></ul><h4 id="6-1-1-Option枚举">6.1.1 Option枚举</h4><ul><li><p><code>Option</code>是标准库定义的另一个枚举，且被包含在<code>preclude</code>中</p></li><li><p>Rust没有空值，但拥有<code>Option</code>枚举来编码存在或不存在</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Some</code>可以包含任意类型的数据</p></li><li><p>使用<code>None</code>需要指定类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Option&lt;T&gt;</code>类型的值不能和<code>T</code>类型的值直接运算，必须提前进行转换，因此空值在使用前必须被检查</p></li></ul><h3 id="6-2-match控制流运算符">6.2 match控制流运算符</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">   Penny,</span><br><span class="line">   Nickel,</span><br><span class="line">   Dime,</span><br><span class="line">   Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个<code>match</code>表达式的返回值</li></ul><h4 id="6-2-1-匹配Option-T">6.2.1 匹配Option&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> six = plus_one(five);</span><br><span class="line"><span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure><ul><li>用于空值处理</li><li>匹配是有穷的，必须覆盖变量的所有情况</li></ul><h4 id="6-2-2-通配符">6.2.2 _通配符</h4><ul><li><p>可以在match的所有分支的最后使用<code>_</code>来匹配剩余的所有情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-if-let-简单控制流">6.3 if let 简单控制流</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以用于替代只有两分支的<code>match</code>语句</li></ul><h2 id="Ch7-使用包、Crate和模块管理项目">Ch7 使用包、Crate和模块管理项目</h2><h3 id="7-1-包和crate">7.1 包和crate</h3><ul><li>crate是一个二进制项或者库</li><li>包 (package) 是提供一系列功能的一个或者多个 crate，一个包会包含有一个<code>Cargo.toml</code>文件，阐述如何去构建这些 crate<ul><li>一个包中至多<strong>只能</strong>包含一个库 crate</li><li>一个包中可以包含任意多个二进制 crate</li><li>一个包中至少包含一个 crate，无论是库的还是二进制的</li></ul></li><li>使用<code>cargo new</code>创建项目时，<code>src/main.rs</code>就是一个与包同名的二进制 crate 的 crate根</li><li>通过将文件放在 <code>src/bin</code> 目录下，一个包可以拥有多个二进制 crate：每个 <code>src/bin</code> 下的文件都会被编译成一个独立的二进制 crate</li></ul><h3 id="7-2-模块">7.2 模块</h3><p>模块定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">server_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模块树：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><h3 id="7-3-引用模块树中项的路径">7.3 引用模块树中项的路径</h3><p>路径的两种形式，都是通过<code>::</code>连接：</p><ul><li>**绝对路径 ** 从 crate 根开始，以 crate 名或者字面值 <code>crate</code> 开头。</li><li><strong>相对路径</strong> 从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li></ul><h4 id="7-3-1-使用pub关键字暴露路径">7.3.1 使用pub关键字暴露路径</h4><ul><li>Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，父模块不能使用子模块的私有项，但子模块可以使用父模块中的项，同级的两个模块可以互相引用</li><li>当父模块需要使用子模块的项的，需要在子模块中将其声明为<code>pub</code></li></ul><h4 id="7-3-2-使用super起始的相对路径">7.3.2 使用super起始的相对路径</h4><ul><li><code>super</code>相当于文件系统中的<code>..</code>，即当前模块的父模块</li></ul><h4 id="7-3-3-创建公有的结构体和枚举">7.3.3 创建公有的结构体和枚举</h4><ul><li>如果在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造实例 <code>Breakfast</code>，否则无法在 <code>eat_at_restaurant</code> 中创建实例</li></ul><h3 id="7-4-use关键字">7.4 use关键字</h3><ul><li>使用use关键字可以简化模块中项的调用：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;  <span class="comment">// 绝对路径</span></span><br><span class="line"><span class="comment">// 或 use front_of_house::hosting;  相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用 <code>as</code> 关键字提供新名称</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用 <code>use</code> 关键字将名称导入作用域时，在新作用域中可用的名称是私有的，可以使用 <code>pub use</code> 重导出，使得名称可以引入任何代码的作用域中</p></li></ul><h4 id="7-4-1-使用嵌套路径精简代码">7.4.1 使用嵌套路径精简代码</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 可以精简为：</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="comment">// 可以精简为：</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-2-glob运算符">7.4.2 glob运算符</h4><p>如果希望将一个路径下<strong>所有</strong>公有项引入作用域，可以指定路径后跟 <code>*</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure><h3 id="7-5-将模块分割进不同文件">7.5 将模块分割进不同文件</h3><p>先使用如下语句引入模块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br></pre></td></tr></table></figure><h2 id="Ch8-常见集合">Ch8 常见集合</h2><h3 id="8-1-vector">8.1 vector</h3><ul><li>在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值</li><li>vector 只能储存相同类型的值</li></ul><h4 id="8-1-1-新建vector">8.1.1 新建vector</h4><ul><li><p>新建空vector时需要指明类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>vec!</code> 宏来定义含有初值的vector</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-2-vector添加元素">8.1.2 vector添加元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>当vector离开作用域时，会连同其元素全部销毁</li></ul><h4 id="8-1-3-读取vector元素">8.1.3 读取vector元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li><p>使用索引访问，若越界，则会报错崩溃(适用于访问边界严格的vector)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>get</code> 方法返回一个 <code>Option&lt;&amp;T&gt;</code>，若越界，则会返回None(适用于vector索引可能由用户输入而越界)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当获取了vector的一个元素的不可变引用后，不能在其末尾添加元素，如下代码<code>非法</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.push(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-4-遍历vector中的元素">8.1.4 遍历vector中的元素</h4><ul><li><p>遍历不可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-5-结合枚举来存储多种类型">8.1.5 结合枚举来存储多种类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="8-2-字符串">8.2 字符串</h3><h4 id="8-2-1-新建字符串">8.2.1 新建字符串</h4><ul><li><p>新建空字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure></li><li><p>往空字符串中装载数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;initial contents&quot;</span>.to_string();</span><br></pre></td></tr></table></figure></li><li><p>新建有初始值的字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;initial contents&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-2-更新字符串">8.2.2 更新字符串</h4><ul><li><p>使用 <code>push_str</code> 方法来附加字符串 slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>push</code> 附加一个字符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.push(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>+</code> 运算符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>format!</code> 宏</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-3-索引字符串">8.2.3 索引字符串</h4><p>Rust的 <code>String</code> 字符串不支持索引单个值，但能够创建字符串slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><h4 id="8-2-4-遍历字符串">8.2.4 遍历字符串</h4><ul><li><p>遍历每个元素（每个元素可能不止一个字节）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历每个原始字节</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-哈希map">8.3 哈希map</h3><p><code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射</p><h4 id="8-3-1-新建一个哈希map">8.3.1 新建一个哈希map</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个空的Hashmap</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li>哈希 map 将它们的数据储存在堆上</li><li>所有的键必须是相同类型，值也必须都是相同类型</li></ul><p>也可以通过vector的 <code>collect</code> 方法创建</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure><h4 id="8-3-2-哈希map和所有权">8.3.2 哈希map和所有权</h4><ul><li>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map</li><li>对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者</li></ul><h4 id="8-3-3-访问哈希map中的值">8.3.3 访问哈希map中的值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure><ul><li><code>get</code> 方法返回的 <code>score</code> 是 <code>Option&lt;T&gt;</code> 类型</li></ul><h4 id="8-3-4-遍历哈希map">8.3.4 遍历哈希map</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-5-更新哈希map">8.3.5 更新哈希map</h4><ul><li><p>使用相同的键插入不同的值，会覆盖旧值</p></li><li><p>使用 <code>entry</code> 方法，只有在键没有对应的值存在的时候插入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure></li><li><p>根据旧值更新一个值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计单词出现的次数</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure><ul><li><code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）</li></ul></li></ul><h2 id="Ch9-错误处理">Ch9 错误处理</h2><h3 id="9-1-panic-与不可恢复的错误">9.1 panic!与不可恢复的错误</h3><p>遇到错误时，Rust 有 <code>panic!</code>宏，当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出</p><h4 id="9-1-1-backtrace">9.1.1 backtrace</h4><ul><li><p>backtrace 是一个执行到目前位置所有被调用的函数的列表</p></li><li><p>使用backtrace来找到自己写的代码中错误出在哪一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-Result与可恢复的错误">9.2 Result与可恢复的错误</h3><p><code>Result</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型</li><li><code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型</li></ul><h4 id="9-2-1-匹配不同的错误">9.2.1 匹配不同的错误</h4><ul><li>使用 <code>match</code> 代码比较冗长，且较难理解</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, </span><br><span class="line">                other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-unwrap">9.2.2 unwrap</h4><ul><li>如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值</li><li>如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-3-expect">9.2.3 expect</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).expect(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用方法类似 <code>unwrap</code> ，但是可以自己指定显示的错误信息</li></ul><h4 id="9-2-4-传播错误">9.2.4 传播错误</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 若文件打开失败，函数会返回相应的错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="comment">// 若文件内容写入字符串失败，函数会返回相应的错误</span></span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="comment">// 若函数执行完成没有出错，则返回Ok</span></span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust提供了<code>fs::read_to_string</code> 的函数来简化从文件读取到一个字符串中的操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-panic-的使用场景">9.3 panic!的使用场景</h3><p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code> —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况：</p><ul><li>有害状态并不包含 <strong>预期</strong> 会偶尔发生的错误</li><li>之后的代码的运行依赖于处于这种有害状态</li><li>当没有可行的手段来将有害状态信息编码进所使用的类型中的情况</li></ul><h2 id="Ch10-泛型、trait和生命周期">Ch10 泛型、trait和生命周期</h2><h3 id="10-1-泛型">10.1 泛型</h3><p>使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型</p><h4 id="10-1-1-在函数定义中使用泛型">10.1.1 在函数定义中使用泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，所以需要在函数名称之后写上 <code>&lt;T&gt;</code></li></ul><h4 id="10-1-2-结构体定义中的泛型">10.1.2 结构体定义中的泛型</h4><ul><li>字段 <code>x</code> 和 <code>y</code> 必须是相同的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段 <code>x</code> 和 <code>y</code> 可以是不同的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> both_integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> both_float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> integer_and_float = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-3-枚举定义中的泛型">10.1.3 枚举定义中的泛型</h4><p><code>Option&lt;T&gt;</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result&lt;T, E&gt;</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-4-方法定义中的泛型">10.1.4 方法定义中的泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用</li><li>必须在 <code>impl</code> 后面声明 <code>T</code>，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型</li></ul><h4 id="10-1-5-泛型代码的性能">10.1.5 泛型代码的性能</h4><ul><li>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失</li><li>Rust 通过在编译时进行泛型代码的<strong>单态化</strong>来保证效率，即在编译时填充泛型所使用的具体类型，从而将通用代码转换为特定代码</li></ul><h3 id="10-2-trait：定义共享的行为">10.2 trait：定义共享的行为</h3><p><em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能</p><h4 id="10-2-1-定义并使用trait">10.2.1 定义并使用trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实现这个 trait 的类型所需要的行为的方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在impl关键字之后，提供需要实现trait的名称，接着是for和需要实现trait的类型的名称</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait</li><li>不能为外部类型实现外部 trait：例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中，它们并不位于 <code>aggregator</code> crate 本地作用域中</li></ul><h4 id="10-2-2-默认实现">10.2.2 默认实现</h4><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait提供默认实现</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-trait作为参数">10.2.3 trait作为参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>item</code> 参数，指定了 <code>impl</code> 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code></p><ul><li><p>使用trait bound重写上面的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>trait bound适合函数传入多个相同类型的参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item1和item2的类型可以不同，只要它们都实现了Summary</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: <span class="keyword">impl</span> Summary, item2: <span class="keyword">impl</span> Summary) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// item1和item2的类型必须相同</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定多个trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display)</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: T)</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>where</code> 简化trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-2-4-返回trait类型">10.2.4 返回trait类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型</li><li>只适用于返回单一类型的情况，如果有分支结构，每个分支返回不同类型，则编译不能通过</li></ul><h3 id="10-3-生命周期与引用有效性">10.3 生命周期与引用有效性</h3><h4 id="10-3-1-生命周期防止悬垂引用">10.3.1 生命周期防止悬垂引用</h4><ul><li>Rust 编译器有一个<strong>借用检查器</strong>，它比较作用域来确保所有的借用都是有效的</li><li>避免了引用比数据的生命周期短的情况</li></ul><h4 id="10-3-2-函数的泛型生命周期">10.3.2 函数的泛型生命周期</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code></li></ul><h5 id="生命周期注解语法">生命周期注解语法</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><ul><li>当有两个或以上的引用参数的生命周期注解都定义为 <code>&amp;'a i32</code> ，则这些参数的生命周期必须与这泛型生命周期一样长</li></ul><h5 id="函数签名中的生命周期注解">函数签名中的生命周期注解</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写上面的longest函数，指定了签名中所有的引用必须有相同的生命周期&#x27;a</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-3-结构体定义生命周期注解">10.3.3 结构体定义生命周期注解</h4><p>有生命周期注解的结构体可以存放引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-4-生命周期省略">10.3.4 生命周期省略</h4><p>编译器采用三条规则来判断引用何时不需要明确的注解，这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块</p><ul><li>每一个是引用的参数都有它自己的生命周期参数</li><li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数</li><li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数</li></ul><h4 id="10-3-5-方法定义中的生命周期注解">10.3.5 方法定义中的生命周期注解</h4><p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return_part</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-6-静态生命周期">10.3.6 静态生命周期</h4><ul><li><p><code>'static</code> 其生命周期<strong>能够</strong>存活于整个程序期间</p></li><li><p>所有的字符串字面值都拥有 <code>'static</code> 生命周期</p></li></ul><h2 id="Ch11-编写自动化测试">Ch11 编写自动化测试</h2><h3 id="11-1-如何编写测试">11.1 如何编写测试</h3><p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p><ol><li>设置任何所需的数据或状态</li><li>运行需要测试的代码</li><li>断言其结果是我们所期望的</li></ol><h4 id="11-1-1-测试函数剖析">11.1.1 测试函数剖析</h4><ul><li>为了将一个函数变成测试函数，需要在 <code>fn</code> 行之前加上 <code>#[test]</code></li><li>使用 <code>cargo test</code> 命令运行测试</li><li>使用 Cargo 新建一个<strong>库项目</strong>时，它会自动为我们生成一个测试模块和一个测试函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">exploration</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-2-使用assert-宏来检查结果">11.1.2 使用assert!宏来检查结果</h4><ul><li>如果值是 <code>true</code>，<code>assert!</code> 什么也不做，同时测试会通过</li><li>如果值为 <code>false</code>，<code>assert!</code> 调用 <code>panic!</code> 宏，这会导致测试失败</li></ul><h4 id="11-1-3-使用assert-eq-和assert-ne-宏来测试相等">11.1.3 使用assert_eq!和assert_ne!宏来测试相等</h4><ul><li><code>assert_eq!</code> 判断是否相等，<code>assert_ne!</code> 判断是否不等</li><li>断言失败时他们会打印出这两个值具体是什么，以便于观察测试<strong>为什么</strong>失败</li></ul><h4 id="11-1-4-自定义失败信息">11.1.4 自定义失败信息</h4><p>为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 <code>greeting</code> 函数的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greeting_contains_name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = greeting(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.contains(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">        <span class="string">&quot;Greeting did not contain name, value was `&#123;&#125;`&quot;</span>, result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-5-使用-should-panic-检查-panic">11.1.5 使用 should_panic 检查 panic</h4><ul><li><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前</li><li>这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败</li></ul><h4 id="11-1-6-将-Result-T-E-用于测试">11.1.6 将 Result&lt;T, E&gt; 用于测试</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-运行测试">11.2 运行测试</h3><h4 id="11-2-1-并行或连续的运行测试">11.2.1 并行或连续的运行测试</h4><ul><li><p>当运行多个测试时， Rust 默认使用线程来并行运行</p></li><li><p>应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境</p></li><li><p>如果有依赖，可以限制线程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --test-threads=1</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-2-显示函数输出">11.2.2 显示函数输出</h4><ul><li><p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容</p></li><li><p>如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 <code>--nocapture</code> 参数来禁用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --nocapture</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-3-通过指定名字来运行部分测试">11.2.3 通过指定名字来运行部分测试</h4><ul><li><p>运行单个测试，向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> one_hundred</span><br></pre></td></tr></table></figure></li><li><p>过滤运行多个测试，指定部分测试的名称，任何名称匹配这个名称的测试会被运行，以下命令运行了所有名字中带有 <code>add</code> 的测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> add</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-4-忽略某些测试">11.2.4 忽略某些测试</h4><p>使用 <code>ignore</code> 属性来标记耗时的测试并排除他们</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 需要运行一个小时的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code></p><h3 id="11-3-测试的组织结构">11.3 测试的组织结构</h3><h4 id="11-3-1-单元测试">11.3.1 单元测试</h4><ul><li>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。</li><li>单元测试与他们要测试的代码共同存放在位于 <em>src</em> 目录下相同的文件中。</li><li>规范是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块。</li></ul><h5 id="测试模块">测试模块</h5><p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码</p><h4 id="11-3-2-集成测试">11.3.2 集成测试</h4><ul><li><p>集成测试的目的是测试库的多个部分能否一起正常工作</p></li><li><p>二进制项目，即只有 <em>src/main.rs</em> 而没有 <em>src/lib.rs</em> 不能进行集成测试</p></li><li><p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级，可以随意在这个目录中创建任意多的测试文件</p></li><li><p>需要在文件顶部添加 <code>use</code></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch12-I-O项目：命令行程序">Ch12 I/O项目：命令行程序</h2><h3 id="12-1-接受命令行参数">12.1 接受命令行参数</h3><ul><li>使用标准库提供的函数：<code>std::env::args</code> ，返回一个传递给程序的命令行参数的<strong>迭代器</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-读取文件">12.2 读取文件</h3><ul><li>使用标准库  <code>std::fs</code> 来处理文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>, contents);</span><br></pre></td></tr></table></figure><h3 id="12-3-重构改进模块性和错误处理">12.3 重构改进模块性和错误处理</h3><p>在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程:</p><ul><li>将程序拆分成 <em><a href="http://main.rs">main.rs</a></em> 和 <em><a href="http://lib.rs">lib.rs</a></em> 并将程序的逻辑放入 <em><a href="http://lib.rs">lib.rs</a></em> 中。</li><li>当命令行解析逻辑比较小时，可以保留在 <em><a href="http://main.rs">main.rs</a></em> 中。</li><li>当命令行解析开始变得复杂时，也同样将其从 <em><a href="http://main.rs">main.rs</a></em> 提取到 <em><a href="http://lib.rs">lib.rs</a></em> 中。</li></ul><p>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>设置任何其他的配置</li><li>调用 <em><a href="http://lib.rs">lib.rs</a></em> 中的 <code>run</code> 函数</li><li>如果 <code>run</code> 返回错误，则处理这个错误</li></ul><h3 id="12-4-采用测试驱动开发完善库的功能">12.4 采用测试驱动开发完善库的功能</h3><p>测试驱动开发（Test Driven Development, TDD）模式，是一个软件开发技术，它遵循如下步骤：</p><ol><li>编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。</li><li>编写或修改刚好足够的代码来使得新的测试通过。</li><li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li><li>从步骤 1 开始重复！</li></ol><h3 id="12-6-将错误信息输出到标准错误">12.6 将错误信息输出到标准错误</h3><ul><li><p>使用 <code>eprintln!</code> 将错误信息写入标准错误而不是标准输出</p></li><li><p>使用输出重定向：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run to poem.txt &gt; output.txt</span><br></pre></td></tr></table></figure><ul><li>若出错，会输出到标准错误，即显示在命令行，而不写入 <em>output.txt</em></li><li>若正常执行，会输出到标准输出，即重定向到 <em>output.txt</em></li></ul></li></ul><h2 id="Ch13-迭代器和闭包">Ch13 迭代器和闭包</h2><h3 id="13-1-闭包">13.1 闭包</h3><ul><li><p>可以保存进变量或作为参数传递给其他函数的匿名函数</p></li><li><p>使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它</p></li></ul><h4 id="13-1-1-定义闭包">13.1.1 定义闭包</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">expensive_closure(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>闭包的定义以一对竖线（<code>|</code>）开始，在竖线中指定闭包的参数</li><li>如果有多于一个参数，可以使用逗号分隔，比如 <code>|param1, param2|</code></li></ul><h4 id="13-1-2-闭包类型推断和注解">13.1.2 闭包类型推断和注解</h4><ul><li>闭包不用于暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用</li><li>闭包定义会为每个参数和返回值推断一个具体类型</li><li>如果尝试调用闭包两次，第一次使用 <code>String</code> 类型作为参数而第二次使用 <code>u32</code>，则会得到一个错误</li></ul><h4 id="13-1-3-使用带有泛型和Fn-trait的闭包">13.1.3 使用带有泛型和Fn trait的闭包</h4><p>可以创建一个存放闭包和调用闭包结果的结构体，该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="comment">// 闭包有一个 u32 的参数并返回一个 u32</span></span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="comment">/*检查self.value是否已经有了一个 Some 的结果值；</span></span><br><span class="line"><span class="comment">            如果有，它返回 Some 中的值并不会再次执行闭包*/</span></span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="comment">/* 如果 self.value 是 None，</span></span><br><span class="line"><span class="comment">            则会调用 self.calculation 中储存的闭包，</span></span><br><span class="line"><span class="comment">            将结果保存到 self.value 以便将来使用，</span></span><br><span class="line"><span class="comment">            并同时返回结果值*/</span></span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> v = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="literal">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行闭包之前，<code>value</code> 将是 <code>None</code>。如果使用 <code>Cacher</code> 的代码请求闭包的结果，这时会执行闭包并将结果储存在 <code>value</code> 字段的 <code>Some</code> 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 <code>Some</code> 成员中的结果。</p><ul><li><code>Cacher</code> 实现的限制：<ul><li>第一次初始化 <code>value</code> 的值之后，就无法再改动；可以通过使 <code>Cacher</code> 存储一个哈希map而不是一个单独的值解决</li><li>它的应用被限制为只接受获取一个 <code>u32</code> 值并返回一个 <code>u32</code> 值的闭包</li></ul></li></ul><h4 id="13-1-4-闭包会捕获其环境">13.1.4 闭包会捕获其环境</h4><ul><li><p>闭包周围的作用域被称为其<strong>环境</strong></p></li><li><p>闭包可以捕获其环境并访问其被定义的作用域的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/* x 并不是 equal_to_x 的一个参数，</span></span><br><span class="line"><span class="comment">但equal_to_x 闭包也被允许使用变量 x，</span></span><br><span class="line"><span class="comment">因为它与 equal_to_x 定义于相同的作用域*/</span></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>闭包有三种方式捕获其环境</p><ul><li><code>FnOnce</code> 消费从周围作用域捕获的变量。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次</li><li><code>FnMut</code> 获取可变的借用值，所以可以改变其环境</li><li><code>Fn</code> 从其环境获取不可变的借用值</li></ul></li></ul><h3 id="13-2-迭代器">13.2 迭代器</h3><ul><li><p><strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑</p></li><li><p>迭代器是惰性的，即在调用方法使用迭代器之前它都不会有效果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 创建一个迭代器，但是没有任何效果</span></span><br><span class="line"><span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="comment">/* 使用迭代器遍历，迭代器中的元素才开始迭代</span></span><br><span class="line"><span class="comment">用 for 循环时无需使 v1_iter 可变，</span></span><br><span class="line"><span class="comment">因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变*/</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-1-Iterator-trait-和-next方法">13.2.1 Iterator trait 和 next方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator 是定义于标准库的 trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="comment">// Item类型将是迭代器next方法返回元素的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"><span class="comment">// next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代器上直接调用 <code>next</code> 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_demonstration</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 需要将迭代器定义为可变，因为next方法会改变迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-2-2-消费适配器">13.2.2 消费适配器</h4><ul><li><p>调用 <code>next</code> 方法的方法，如 <code>sum</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="comment">// 调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权</span></span><br><span class="line">    <span class="keyword">let</span> total: <span class="built_in">i32</span> = v1_iter.sum();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-3-迭代器适配器">13.2.3 迭代器适配器</h4><ul><li><p>将当前迭代器变为不同类型的迭代器，如 <code>map</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 调用 map 方法创建一个新迭代器，接着调用collect方法消费新迭代器并创建一个vector</span></span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-4-创建自定义迭代器">13.2.4 创建自定义迭代器</h4><p>可以实现 <code>Iterator</code> trait 来创建任何我们希望的迭代器</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Counter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的Counter迭代器的多种方法</span></span><br><span class="line"><span class="comment">// 获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">using_other_iterator_trait_methods</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum: <span class="built_in">u32</span> = Counter::new().zip(Counter::new().skip(<span class="number">1</span>))</span><br><span class="line">                                 .map(|(a, b)| a * b)</span><br><span class="line">                                 .filter(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                 .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch14-进一步认识Cargo和Crates-io">Ch14 <a href="http://xn--CargoCrates-km8q749dp96e4c7etpa368c.io">进一步认识Cargo和Crates.io</a></h2><h3 id="14-1-采用发布配置自定义构建">14.1 采用发布配置自定义构建</h3><p>Cargo 有两个主要的配置：</p><ul><li>运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置</li><li>运行 <code>cargo build --release</code> 的 <code>release</code> 配置</li></ul><p><code>dev</code> 配置被定义为开发时的好的默认配置，<code>release</code> 配置则有着良好的发布构建的默认配置</p><p>可以在 <em>Cargo.toml</em> 文件中定义 <code>[profile.*]</code> 部分来覆盖默认配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><code>opt-level</code> 设置控制 Rust 会对代码进行何种程度的优化，值从0到3，越高的优化级别需要更多的时间编译</li></ul><h3 id="14-2-将-crate-发布到-Crates-io">14.2 将 crate 发布到 <a href="http://Crates.io">Crates.io</a></h3><h3 id="14-3-Cargo工作空间">14.3 Cargo工作空间</h3><h3 id="14-4-从-Crates-io-安装二进制文件">14.4 从 <a href="http://Crates.io">Crates.io</a> 安装二进制文件</h3><p>使用命令 <code>cargo install</code> 可以从crates.io下载二进制crate，安装到 <em>~/.cargo/bin</em></p><h2 id="Ch15-智能指针">Ch15 智能指针</h2><h3 id="15-1-Box-T">15.1 Box&lt;T&gt;</h3><p>box 允许将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针</p><p>使用场景：</p><ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li></ul><h4 id="15-1-1-Box创建递归类型">15.1.1 Box创建递归类型</h4><ul><li>Rust 需要在编译时知道类型占用多少空间，而<strong>递归类型</strong>无法在编译的时候知道大小</li><li>box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了</li></ul><h5 id="以cons-list为例">以cons list为例</h5><ul><li><p>cons list 的每一项都包含两个元素：当前项的值和下一项。</p></li><li><p>其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。</p></li><li><p>cons list 通过递归调用 <code>cons</code> 函数产生。</p></li><li><p>代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust编译器无法计算一个 <code>List</code> 需要的大小，因为编译器尝试计算出储存一个 <code>List</code> 枚举需要多少内存，并开始检查 <code>Cons</code> 成员，那么 <code>Cons</code> 需要的空间等于 <code>i32</code> 的大小加上 <code>List</code> 的大小。为了计算 <code>List</code> 需要多少内存，它检查其成员，从 <code>Cons</code> 成员开始。<code>Cons</code>成员储存了一个 <code>i32</code> 值和一个<code>List</code>值，这样的计算将无限进行下去。</p><h5 id="使用Box-T-给递归类型一个已知的大小">使用Box&lt;T&gt;给递归类型一个已知的大小</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>,</span><br><span class="line">            <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>,</span><br><span class="line">                <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何 <code>List</code> 值最多需要一个 <code>i32</code> 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 <code>List</code> 值需要的大小了。</p><h3 id="15-2-Deref-trait">15.2 Deref trait</h3><p>实现 <code>Deref</code> trait 允许我们重载<strong>解引用运算符</strong> <code>*</code></p><h4 id="15-2-1-像引用一样使用-Box-T">15.2.1 像引用一样使用 Box&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-自定义智能指针">15.2.2 自定义智能指针</h4><p>定义 <code>MyBox&lt;T&gt;</code> 类型:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-3-在自定义智能指针实现-Deref-trait">15.2.3 在自定义智能指针实现 Deref trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义trait的关联类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        <span class="comment">// deref返回了我希望通过*运算符访问的值的引用</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br></pre></td></tr></table></figure><p><code>*y</code> 在Rust底层运行了 <code>*(y.deref())</code></p><h4 id="15-2-4-函数和方法的隐式解引用强制多态">15.2.4 函数和方法的隐式解引用强制多态</h4><p><strong>解引用强制多态</strong>是 Rust 在函数或方法传参上的一种便利。将实现了 <code>Deref</code> 的类型的引用转换为原始类型通过 <code>Deref</code> 所能够转换的类型的引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">// 解引用强制多态将 &amp;MyBox&lt;String&gt; 自动转换为 &amp;str</span></span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-Drop-trait">15.3 Drop trait</h3><ul><li><p>允许我们在值要离开作用域时执行一些代码，可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源</p></li><li><p>通过 <code>Drop</code> trait 中的 <code>drop</code> 方法，可以在变量离开作用域时自动丢弃该值</p></li></ul><h4 id="15-3-1-通过-std-mem-drop-提早丢弃值">15.3.1 通过 std::mem::drop 提早丢弃值</h4><ul><li>Rust不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法</li><li>当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>，其位于preclude，可以直接通过 <code>drop(variable);</code> 调用</li></ul><h3 id="15-4-Rc-T-引用计数智能指针">15.4 Rc&lt;T&gt; 引用计数智能指针</h3><ul><li><p>有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。</p></li><li><p>Rust 使用<strong>引用计数</strong> <code>Rc&lt;T&gt;</code> 的类型来启用多所有权，记录了一个值引用的数量来知晓这个值是否仍在被使用。</p></li><li><p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。</p></li><li><p><code>Rc&lt;T&gt;</code> 只能用于单线程场景</p></li></ul><h4 id="15-4-1-使用-Rc-T-共享数据">15.4.1 使用 Rc&lt;T&gt; 共享数据</h4><p>使用 <code>Box&lt;T&gt;</code> 定义的 cons list 的两个列表 <code>b</code> 和 <code>c</code>, 共享第三个列表 <code>a</code> 的所有权</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201112210915469.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201112210915469.png" srcset="data:image/png;base64,666" alt="image-20201112210915469"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Rc::clone</code> 只会增加引用计数，而不会深拷贝</li><li>在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 <code>Rc::strong_count</code> 函数获得</li></ul><h3 id="15-5-RefCell-T-和内部可变性模式">15.5 RefCell&lt;T&gt; 和内部可变性模式</h3><p><strong>内部可变性</strong>是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的</p><h3 id="15-6-引用循环与内存泄漏">15.6 引用循环与内存泄漏</h3><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存，但是创建引用循环从而造成内存泄漏的可能性是存在的</p><h2 id="Ch16-并发">Ch16 并发</h2><h3 id="16-1-使用线程同时运行代码">16.1 使用线程同时运行代码</h3><p>线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p><ul><li>竞争状态，多个线程以不一致的顺序访问数据或资源</li><li>死锁，两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li><li>只会发生在特定情况且难以稳定重现和修复的 bug</li></ul><h4 id="16-1-1-使用-spawn-创建新线程">16.1.1 使用 spawn 创建新线程</h4><p>为了创建一个新线程，需要调用 <code>thread::spawn</code> 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            <span class="comment">// thread::sleep调用强制线程停止执行一小段时间，允许其他不同的线程运行</span></span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 4 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>当主线程结束时，新线程也会结束，而不管其是否执行完毕</li></ul><h4 id="16-1-2-使用-join-等待所有线程结束">16.1.2 使用 join 等待所有线程结束</h4><ul><li><code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code></li><li><code>JoinHandle</code> 是一个拥有所有权的值，当对其调用 <code>join</code> 方法时，它会等待其线程结束</li><li>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 从thread::spawn保存一个JoinHandle来确保该线程能够运行结束</span></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-1-3-线程与-move-闭包">16.1.3 线程与 move 闭包</h4><p>在参数列表前使用 <code>move</code> 关键字强制闭包获取其使用的环境值的所有权，可用于创建新线程时将值的所有权从一个线程移动到另一个线程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-2-线程间消息传递">16.2 线程间消息传递</h3><p>Rust 中一个实现消息传递并发的主要工具是<strong>通道</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>mpsc::channel</code> 函数创建一个新的通道，可以有多个<strong>发送端</strong>，但只能有一个<strong>接收端</strong>， <code>mpsc::channel</code> 函数返回一个元组：(发送端，接收端)，或 <code>(tx, rx)</code></p></li><li><p>通道的发送端有一个 <code>send</code> 方法用来获取需要放入通道的值，返回一个 <code>Result&lt;T, E&gt;</code> 类型</p><ul><li><code>send</code> 函数获取其参数的所有权并移动这个值归接收者所有，所以线程在发送 <code>val</code> 之后就不能再使用它了</li></ul></li><li><p>通道的接收端有两个有用的方法：<code>recv</code> 和 <code>try_recv</code></p><ul><li><code>recv</code> 会阻塞主线程执行直到从通道中接收一个值，一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它；当通道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了</li><li><code>try_recv</code> 不会阻塞，立刻返回一个 <code>Result&lt;T, E&gt;</code>：<code>Ok</code> 值包含可用的信息，而 <code>Err</code> 值代表此时没有任何消息</li></ul></li><li><p>可以将 <code>rx</code> 作为迭代器来接收发送端发送的多个数据，并通过 <code>for</code> 循环打印</p></li><li><p>可以通过 <code>clone</code> 方法来创建多个发送端:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br></pre></td></tr></table></figure></li></ul><h3 id="16-3-共享状态并发">16.3 共享状态并发</h3><h4 id="16-3-1-互斥器">16.3.1 互斥器</h4><ul><li>通过<strong>锁</strong>来保证任意时刻只有一个线程能访问某些数据</li><li>使用方式：<ul><li>在使用数据之前尝试获取锁。</li><li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li></ul></li><li>使用 <code>Mutex&lt;T&gt;</code> 实现<ul><li>通过关联函数 <code>new</code> 来创建 <code>Mutex&lt;T&gt;</code></li><li>使用 <code>lock</code> 方法获取锁，该方法会阻塞当前线程，直到拥有锁为止</li><li><code>lock</code> 调用返回一个叫做 <code>MutexGuard</code> 的智能指针，当其离开作用域时，会自动释放锁</li></ul></li></ul><h4 id="16-3-2-在线程间共享-Mutex-T">16.3.2 在线程间共享 Mutex&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<strong>原子引用计数</strong> <code>Arc&lt;T&gt;</code> 来实现 <code>Mutex&lt;T&gt;</code> 在多线程之间共享所有权</li></ul><h2 id="Ch17-Rust面向对象">Ch17 Rust面向对象</h2><h3 id="17-1-面向对象语言的特征">17.1 面向对象语言的特征</h3><ul><li>对象包含数据和行为：结构体和枚举包含数据，<code>impl</code> 块提供对应方法</li><li>封装隐藏了实现细节：不添加 <code>pub</code> 就是私有的</li><li>通过继承重用代码：使用 <code>trait</code> 对象</li></ul><h3 id="17-2-为使用不同类型的值而设计的-trait-对象">17.2 为使用不同类型的值而设计的 trait 对象</h3><h3 id="17-3-面向对象设计模式的实现">17.3 面向对象设计模式的实现</h3><h2 id="Ch18-模式">Ch18 模式</h2><h3 id="18-1-用到模式的位置">18.1 用到模式的位置</h3><h4 id="18-1-1-match分支">18.1.1 match分支</h4><p>在形式上 <code>match</code> 表达式由 <code>match</code> 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-1-2-if-let-表达式">18.1.2 if let 表达式</h4><ul><li>等同于只关心一个情况的 <code>match</code> 语句简写</li><li><code>if let</code> 表达式的缺点在于其穷尽性没有为编译器所检查，而 <code>match</code> 表达式则检查了</li></ul><h4 id="18-1-3-while-let-条件循环">18.1.3 while let 条件循环</h4><p>允许只要模式匹配就一直进行 <code>while</code> 循环</p><h4 id="18-1-4-for循环">18.1.4 for循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.iter().enumerate() &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>(index, value)</code> 来匹配 <code>enumerate</code></p><h4 id="18-1-5-let语句">18.1.5 let语句</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PATTERN = EXPRESSION;</span><br></pre></td></tr></table></figure><h4 id="18-1-6-函数参数">18.1.6 函数参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x</code> 部分就是一个模式</p><h3 id="18-2-可反驳和不可反驳">18.2 可反驳和不可反驳</h3><ul><li><p>能匹配任何传递的可能值的模式被称为是<strong>不可反驳的</strong>，如 <code>let x = 5;</code> 中的 <code>x</code></p></li><li><p>对某些可能的值进行匹配会失败的模式被称为是<strong>可反驳的</strong>，如 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code></p></li><li><p>函数参数、 <code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式</p></li><li><p>匹配分支必须使用可反驳模式，如 <code>if let</code></p></li></ul><h3 id="18-3-模式语法">18.3 模式语法</h3><h4 id="18-3-1-匹配字面值">18.3.1 匹配字面值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-2-匹配命名变量">18.3.2 匹配命名变量</h4><p>命名变量是匹配任何值的不可反驳模式，当其用于 <code>match</code> 表达式时，情况会不一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">会打印：</span></span><br><span class="line"><span class="comment">Matched, y = 5</span></span><br><span class="line"><span class="comment">at the end: x = Some(5), y = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>match</code> 表达式的新作用域中， <code>y</code> 是一个新变量，而不是开头声明为值 10 的那个 <code>y</code> ，新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值</li></ul><h4 id="18-3-3-多个模式">18.3.3 多个模式</h4><p>使用 <code>|</code> 语法匹配多个模式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-4-通过-…-匹配值的范围">18.3.4 通过 …= 匹配值的范围</h4><ul><li><p>使用 <code>1..=5</code> 替代 <code>1 | 2 | 3 | 4 | 5</code></p></li><li><p>对 <code>char</code> 类型也适用：<code>'a'..='j'</code></p></li></ul><h4 id="18-3-5-忽略模式中的值">18.3.5 忽略模式中的值</h4><ul><li><p>使用 <code>_</code> 忽略整个值</p></li><li><p>通过 <code>_x</code> 来忽略未使用的变量</p></li><li><p>使用 <code>..</code> 忽略剩余的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., last) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="18-3-6-匹配守卫">18.3.6 匹配守卫</h4><p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-7-绑定">18.3.7 @绑定</h4><ul><li><p><code>@</code> 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式</p></li><li><p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="built_in">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    <span class="comment">// 将id值保存在id_variable中</span></span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无法保存id值</span></span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch19-高级特征">Ch19 高级特征</h2><h3 id="19-1-不安全的Rust">19.1 不安全的Rust</h3><h3 id="19-2-高级trait">19.2 高级trait</h3><h3 id="19-3-高级类型">19.3 高级类型</h3><h3 id="19-4-高级函数与闭包">19.4 高级函数与闭包</h3><h3 id="19-5-宏">19.5 宏</h3>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pointers on C - Learn</title>
      <link href="2020/11/11/C%E5%92%8C%E6%8C%87%E9%92%88notes/"/>
      <url>2020/11/11/C%E5%92%8C%E6%8C%87%E9%92%88notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Ch2-基本概念">Ch2 基本概念</h2><h3 id="2-1-环境">2.1 环境</h3><h4 id="2-1-1-翻译环境">2.1.1 翻译环境</h4><ul><li><p>翻译过程：各源文件通过<code>编译过程</code>分别转为<strong>目标代码</strong> -&gt; 各目标代码文件由<strong>链接器</strong>捆绑为单一完整的可执行程序</p></li><li><p>编译过程：预处理器处理 -&gt; 源代码经过<strong>解析</strong>判断语句的意思，从而生成目标代码 -&gt; 优化器对目标代码进一步处理</p></li></ul><h4 id="2-1-4-执行环境">2.1.4 执行环境</h4><ul><li><p>程序执行过程：程序载入内存 -&gt; 启动程序调用main函数 -&gt; 程序的终止</p></li><li><p>程序运行过程中使用一个运行时的<strong>堆栈</strong>，用于存储函数的局部变量和返回地址；同时，程序也可以使用<strong>静态内存</strong>，其中的值在程序整个执行过程都会保留</p></li></ul><h3 id="2-2-词法规则">2.2 词法规则</h3><h4 id="2-2-1-字符">2.2.1 字符</h4><ul><li><p>\ddd：三个八进制数字表示的字符</p></li><li><p>\xddd：三个十六进制数字表示的字符</p></li></ul><h4 id="2-2-2-注释">2.2.2 注释</h4><ul><li><p>//：单行注释</p></li><li><p>/*     */：多行注释</p></li></ul><h3 id="TIPS">TIPS:</h3><ul><li>有的程序从标准输入读取数据，读到EOF停止，在终端输入时Ctrl+D即为输入EOF</li></ul><h2 id="Ch3-数据">Ch3 数据</h2><h3 id="3-1-基本数据类型">3.1 基本数据类型</h3><h4 id="3-1-1-整型">3.1.1 整型</h4><p>变量的最小范围</p><table><thead><tr><th>类型</th><th>最小范围</th></tr></thead><tbody><tr><td>char</td><td>0 ~ 2<sup>7</sup>-1</td></tr><tr><td>signed char</td><td>-(2<sup>7</sup>-1) ~ 2<sup>7</sup>-1</td></tr><tr><td>unsigned char</td><td>0 ~ 2<sup>8</sup>-1</td></tr><tr><td>short int</td><td>-(2<sup>15</sup>-1) ~ 2<sup>15</sup>-1</td></tr><tr><td>unsigned short int</td><td>0 ~ 2<sup>16</sup>-1</td></tr><tr><td>int</td><td>-(2<sup>15</sup>-1) ~ 2<sup>15</sup>-1</td></tr><tr><td>unsigned int</td><td>0 ~ 2<sup>16</sup>-1</td></tr><tr><td>long int</td><td>-(2<sup>31</sup>-1) ~ 2<sup>31</sup>-1</td></tr><tr><td>unsigned long int</td><td>0 ~ 2<sup>32</sup>-1</td></tr></tbody></table><ul><li><p>short int至少16位，long int至少32位</p></li><li><p>头文件limits.h说明各种不同的整型的特点</p></li></ul><p><strong>一、整型常量</strong></p><ul><li><p>声明为const，初始化之后不能被改变</p></li><li><p>十进制整型常量可能是int、long、unsigned long。缺省情况下为最短类型但能完整容纳这个值</p></li><li><p>八进制整数以0开头</p></li><li><p>十六进制整数以0x开头</p></li><li><p>字符常量：类型为int，是单引号包围的单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;M&#x27;</span><span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>宽字符常量：多字节字符常量的前面有个L</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&#x27;X&#x27;L&#x27;e^&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二、枚举类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Jar_Type</span> &#123;</span>CUP, PINT, QUART, HALF_GALLON, GALLON&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Jar_Type</span> <span class="title">milk_jug</span>, <span class="title">gas_can</span>, <span class="title">medicine_bottle</span>;</span></span><br></pre></td></tr></table></figure><ul><li>以整型方式存储，符号名实际值都是整型值。如CUP=0，PINT=1，以此类推</li><li>可以显式定值，若未指定值，则比前一个符号名大1</li></ul><h4 id="3-1-2-浮点类型">3.1.2 浮点类型</h4><ul><li>包括float、double、long double类型</li><li>所有浮点类型至少能容纳从10<sup>-37</sup>到10<sup>37</sup>之间的任何值</li><li>头文件float.h说明各种不同的浮点型的特点</li><li>浮点数默认为double类型；后面跟L/l表示long double；后面跟F/f表示float</li></ul><h4 id="3-1-3-指针">3.1.3 指针</h4><p><strong>一、指针常量</strong></p><ul><li>一般都通过操作符来获得一个变量的地址，而不是通过表示为字面值的指针常量，如0xff2044ec</li></ul><p><strong>二、字符串常量</strong></p><ul><li>字符串：以NUL字节结尾的零个或多个字符，存储在字符数组中</li><li>字符串常量：直接值是一个“指向字符的指针”，而不是这些字符本身</li></ul><h3 id="3-2-基本声明">3.2 基本声明</h3><h4 id="3-2-2-声明简单数组">3.2.2 声明简单数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><ul><li>编译器不检查数组的下标是否在合法范围内，所以当下标是通过用户输入计算而来的，必须检测是否越界<ul><li>如果越界，不会报错，只会返回null</li></ul></li></ul><h4 id="3-2-3-声明指针">3.2.3 声明指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">// 把message声明为一个指向字符的指针，并用字符串常量中的第1个字符的地址对其初始化</span></span><br><span class="line"><span class="comment">// 等价于以下语句</span></span><br><span class="line"><span class="keyword">char</span> *message;</span><br><span class="line">message = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-typedef">3.3 typedef</h3><p>为各种数据类型定义新名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将变量ptr_to_char声明为一个指向字符的指针类型的新名字</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *ptr_to_char;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明a是一个指向字符的指针</span></span><br><span class="line">ptr_to_char a;</span><br></pre></td></tr></table></figure><h3 id="3-4-常量">3.4 常量</h3><p>const</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明整数常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *pci;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向整型的常量指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> cpi;</span><br></pre></td></tr></table></figure><p>#define</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 20</span></span><br></pre></td></tr></table></figure><h3 id="3-5-作用域">3.5 作用域</h3><h4 id="3-5-1-代码块作用域">3.5.1 代码块作用域</h4><ul><li><p>代码块：位于一对花括号之间的所有语句</p></li><li><p>嵌套代码块中，内层可以访问外层变量，而外层无法访问内层变量，但是当内外层有名字相同的变量时，内层无法访问外层的那个同名变量</p></li><li><p>非嵌套的代码块中，作用域没有重叠，所以编译器可以把它们存储在同一个内存地址</p></li></ul><h4 id="3-5-2-文件作用域">3.5.2 文件作用域</h4><ul><li>任何在所有代码块之外声明的标识符都具有文件作用域，在声明处到源文件末尾都可以访问</li></ul><h4 id="3-5-3-原型作用域">3.5.3 原型作用域</h4><ul><li>只适用于在函数原型中声明的参数名</li></ul><h4 id="3-5-4-函数作用域">3.5.4 函数作用域</h4><ul><li>只适用于语句标签，语句标签用于goto语句</li></ul><h3 id="3-6-链接属性">3.6 链接属性</h3><p><strong>一、none 没有链接属性</strong></p><ul><li>声明的同名标识符被当作独立不同的实体</li></ul><p><strong>二、internal属性</strong></p><ul><li>单个文件中声明的同名标识符表示同一个实体</li></ul><p><strong>三、external属性</strong></p><ul><li>多个文件中声明的同名标识符表示同一个实体</li><li>只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。</li><li>默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体。</li></ul><p><strong>四、关键字extern和static</strong></p><ul><li>如果某个标识符在正常情况下具有external链接属性(只能是具有文件作用域的标识符)，在其前面加上static关键字可以将其链接属性变为internal</li><li>链接属性只能修改一次，也就是说一旦将标识符的链接属性变为internal，就无法变回external了</li></ul><h3 id="3-7-存储类型">3.7 存储类型</h3><ul><li>存储变量的内存类型，有普通内存、运行时堆栈、硬件寄存器</li><li>在任何代码块之外声明的变量存储在<strong>静态内存</strong>中，为静态变量，在程序运行之前创建</li><li>在代码块内部声明的变量的缺省存储类型是自动的，即存储于<strong>堆栈</strong>中，进入代码块创建，离开代码块销毁<ul><li>在代码块内部声明的变量加上static关键字，变为静态变量，但作用域不变。如在函数中声明static变量a，则a在程序开始执行时就被初始化，并且每次函数被调用时，a不会重新初始化</li></ul></li><li>关键字register声明自动变量，存储在<strong>硬件寄存器</strong>中，为寄存器变量</li></ul><p><strong>初始化</strong></p><ul><li>如果不显式指定初值，静态变量将初始化为0，而自动变量初始值不确定</li></ul><h3 id="3-8-static关键字">3.8 static关键字</h3><ul><li>用于函数定义或在代码块外声明变量时，将标识符的链接属性从external改为internal，但变量的存储类型和作用域不受影响</li><li>在代码块内部声明变量时将标识符的存储类型从自动变量改为静态变量，但变量的链接属性和作用域不受影响</li></ul><h3 id="3-9-总结">3.9 总结</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201028211529931.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201028211529931.png" srcset="data:image/png;base64,666" alt="image-20201028211529931"></p><h2 id="Ch4-语句">Ch4 语句</h2><h3 id="4-1-空语句">4.1 空语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><p>只包含一个分号，不执行任何任务</p><h3 id="4-2-表达式语句">4.2 表达式语句</h3><ul><li><p>C不存在赋值语句，赋值通过表达式语句(在表达式之后加上一个分号)实现，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>以下语句也是合法的，但结果被立即丢弃：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码块">4.3 代码块</h3><p>位于一对花括号之内的可选的声明和语句列表</p><h3 id="4-4-if语句">4.4 if语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C语言不存在布尔变量，而使用整型的0和1代替，所以expression的结果不是0就是1</li></ul><h3 id="4-5-while语句">4.5 while语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>break终止所在while代码块的所有循环；continue终止所在while代码块的当前循环</li></ul><h3 id="4-6-for语句">4.6 for语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化部分; 条件部分; 调整部分)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-do语句">4.7 do语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure><ul><li>循环体至少执行一次</li></ul><h3 id="4-8-switch语句">4.8 switch语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression<span class="number">-1</span>:</span><br><span class="line">        statement<span class="number">-1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression<span class="number">-2</span>:</span><br><span class="line">        statement<span class="number">-2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch的条件expression必须为整型值</li><li>每个case标签必须具有唯一的值</li><li>每个switch语句都应该添加一条并且只能添加一条default语句，可以在case语句列表的任何位置</li></ul><h3 id="4-9-goto语句">4.9 goto语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 语句标签;</span><br></pre></td></tr></table></figure><ul><li>语句标签是在标识符后添加一个冒号，并跟上一些表达式语句</li><li>要尽可能避免使用goto语句</li></ul><h2 id="Ch5-操作符和表达式">Ch5 操作符和表达式</h2><h3 id="5-1-操作符">5.1 操作符</h3><h4 id="5-1-1-算术操作符">5.1.1 算术操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure><h4 id="5-1-2-移位操作符">5.1.2 移位操作符</h4><ul><li><p>左移：&lt;&lt;</p></li><li><p>右移：&gt;&gt;</p></li><li><p>无符号数的所有移位操作都是逻辑移位，有符号数是逻辑移位还是算术移位取决于编译器</p></li></ul><h4 id="5-1-3-位操作符">5.1.3 位操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; | ~</span><br><span class="line"><span class="comment">// 与或非</span></span><br></pre></td></tr></table></figure><ul><li><p>将value指定位置1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = value | <span class="number">1</span> &lt;&lt; bit_number;</span><br></pre></td></tr></table></figure></li><li><p>将value指定位置0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = value &amp; ~ (<span class="number">1</span> &lt;&lt; bit_number);</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-5-单目操作符">5.1.5 单目操作符</h4><ul><li><p>!：逻辑取反，产生整型结果0或1</p></li><li><p>~：操作数每一位取反</p></li><li><p>-：取负</p></li><li><p>&amp;：取操作数的地址</p></li><li><p>*：间接访问，访问指针所指向的值</p></li><li><p>sizeof：判断操作数的类型长度，以字节为单位，操作数可以是变量，也可以是加上括号的类型</p><ul><li>sizeof (a = b + 1)并没有向a赋值</li></ul></li><li><p>强制类型转换，如获得整型变量a对应的浮点数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">float</span>) a</span><br></pre></td></tr></table></figure></li><li><p>c+：增值操作符，<ins>a在变量被使用之前增加它的值，a</ins>在变量被使用之后增加它的值</p></li></ul><h4 id="5-1-6-关系操作符">5.1.6 关系操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;=    &lt;  &lt;=    ==  !=</span><br></pre></td></tr></table></figure><ul><li>产生的结果是整型的0或1</li></ul><h4 id="5-1-7-逻辑操作符">5.1.7 逻辑操作符</h4><ul><li>&amp;&amp;：对于expression1 &amp;&amp; expression2，若expression1为假，则不再对expression2求值</li><li>||：对于expression1 || expression2，若expression1为真，则不再对expression2求值</li></ul><h4 id="5-1-8-条件操作符">5.1.8 条件操作符</h4><p>expression1 ? expression2 : expression3</p><h3 id="5-2-布尔值">5.2 布尔值</h3><ul><li>C没有显式的布尔类型，用整数代替，0是假，任何非零值都是真</li></ul><h3 id="5-4-表达式求值">5.4 表达式求值</h3><ul><li><p>函数进行表达式求值时应该尽量避免以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f() + g() + h()</span><br></pre></td></tr></table></figure><p>而使用以下形式，因为如果函数的返回值和执行顺序相关，则会产生不确定性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = f();</span><br><span class="line">temp += g();</span><br><span class="line">temp += h();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch6-指针">Ch6 指针</h2><h3 id="6-1-内存和地址">6.1 内存和地址</h3><ul><li>内存中的每个位置由一个独一无二的地址标识</li><li>内存中的每个位置都包含一个值</li><li>编译器帮助实现通过变量访问内存位置，但是硬件仍然通过地址访问内存位置</li></ul><h3 id="6-2-值和类型">6.2 值和类型</h3><p>不能简单地通过检查一个值的位来判断它的类型，因为不同的数据类型和指令会将其解释为不同的类型</p><h3 id="6-5-未初始化和非法的指针">6.5 未初始化和非法的指针</h3><p>在对指针进行间接访问之前，一定要进行初始化，下面是一个<strong>错误例子</strong>，因为指针a指向的位置不能确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">*a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="6-6-NULL指针">6.6 NULL指针</h3><ul><li><p>NULL指针不指向任何东西</p></li><li><p>要使一个指针变量为NULL，可以给它赋一个零值；测试一个指针变量是否为NULL，可以将它与零值比较</p></li></ul><h3 id="6-7-指针、间接访问和左值">6.7 指针、间接访问和左值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *d = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法，对指针d指向的值(a)进行修改</span></span><br><span class="line">*d = <span class="number">10</span> - *d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法，整型数的计算结果赋给指针</span></span><br><span class="line">d = <span class="number">10</span> - *d;</span><br></pre></td></tr></table></figure><h3 id="6-10-指针的指针">6.10 指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>相当的表达式</th></tr></thead><tbody><tr><td>a</td><td>12</td></tr><tr><td>b</td><td>&amp;a</td></tr><tr><td>*b</td><td>a, 12</td></tr><tr><td>c</td><td>&amp;b</td></tr><tr><td>*c</td><td>b, &amp;a</td></tr><tr><td>**c</td><td>*b, a, 12</td></tr></tbody></table><h3 id="6-11-指针表达式">6.11 指针表达式</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112510530.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112510530.png" srcset="data:image/png;base64,666" alt="image-20201030112510530"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112528313.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112528313.png" srcset="data:image/png;base64,666" alt="image-20201030112528313"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112553253.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112553253.png" srcset="data:image/png;base64,666" alt="image-20201030112553253"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112611434.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112611434.png" srcset="data:image/png;base64,666" alt="image-20201030112611434"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112624338.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112624338.png" srcset="data:image/png;base64,666" alt="image-20201030112624338"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112817215.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112817215.png" srcset="data:image/png;base64,666" alt="image-20201030112817215"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112834050.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112834050.png" srcset="data:image/png;base64,666" alt="image-20201030112834050"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112852658.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112852658.png" srcset="data:image/png;base64,666" alt="image-20201030112852658"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112905585.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112905585.png" srcset="data:image/png;base64,666" alt="image-20201030112905585"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112918911.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112918911.png" srcset="data:image/png;base64,666" alt="image-20201030112918911"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112931420.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112931420.png" srcset="data:image/png;base64,666" alt="image-20201030112931420"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112944852.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112944852.png" srcset="data:image/png;base64,666" alt="image-20201030112944852"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112958540.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112958540.png" srcset="data:image/png;base64,666" alt="image-20201030112958540"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030113010189.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030113010189.png" srcset="data:image/png;base64,666" alt="image-20201030113010189"></p><h3 id="6-13-指针运算">6.13 指针运算</h3><h4 id="6-13-1-算术运算">6.13.1 算术运算</h4><ul><li>当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据对应变量的类型的长度进行调整。例如若float类型指针变量p占4个字节，则p+1不会指向p的第二字节，而是会指向p所占的4个字节之后的那个字节</li><li>两个指针只有当都指向同一个数组中的元素时，才允许进行相减，并且减法的结果是两个元素在数组中的距离，而不是内存地址的差值，即在减法运算的同时会除掉变量类型的长度</li></ul><h4 id="6-13-2-关系运算">6.13.2 关系运算</h4><p>对于指向同一个数组中的元素的指针，可以用关系操作符(<code>&gt; &lt; &gt;= &lt;=</code>)来判断哪个指针指向数组中更前或更后的元素</p><h2 id="Ch7-函数">Ch7 函数</h2><h3 id="7-2-函数声明">7.2 函数声明</h3><h4 id="7-2-1-原型">7.2.1 原型</h4><ul><li><p>原型总结了函数定义的起始部分的声明，向编译器提供有关函数应该如何调用的完整信息</p></li><li><p>函数原型的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func_use.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// func.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>声明一个没有参数的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2-2-函数的缺省认定">7.2.2 函数的缺省认定</h4><p>当程序调用一个无法见到原型的函数时，编译器会认为该函数返回一个整型</p><h3 id="7-3-函数的参数">7.3 函数的参数</h3><ul><li>所有参数都是<strong>传值调用</strong>，函数不会修改实际传递的参数</li><li>当传递的参数是指针时，可以通过指针的间接访问修改指针所指的值，称为<strong>传址调用</strong></li></ul><h3 id="7-4-ADT和黑盒">7.4 ADT和黑盒</h3><p>使用static关键字限制对非接口函数和数据的访问</p><h3 id="7-5-递归">7.5 递归</h3><ul><li>通过运行时堆栈支持递归函数的实现</li></ul><p>通过一个简单的递归作为实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个整型值(无符号)，把它转换为字符并打印，前导零被删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_to_ascii</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quotient;</span><br><span class="line">    </span><br><span class="line">    quotient = value / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (quotient != <span class="number">0</span>) &#123;</span><br><span class="line">        binary_to_ascii(quotient);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(value % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-1-追踪递归函数">7.5.1 追踪递归函数</h4><p>程序运行时堆栈的变化：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144906982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144906982.png" srcset="data:image/png;base64,666" alt="image-20201030144906982"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144921304.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144921304.png" srcset="data:image/png;base64,666" alt="image-20201030144921304"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144933258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144933258.png" srcset="data:image/png;base64,666" alt="image-20201030144933258"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144943300.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144943300.png" srcset="data:image/png;base64,666" alt="image-20201030144943300"></p><p>​…</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144956035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144956035.png" srcset="data:image/png;base64,666" alt="image-20201030144956035"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145042009.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145042009.png" srcset="data:image/png;base64,666" alt="image-20201030145042009"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145053160.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145053160.png" srcset="data:image/png;base64,666" alt="image-20201030145053160"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145101621.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145101621.png" srcset="data:image/png;base64,666" alt="image-20201030145101621"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145110915.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145110915.png" srcset="data:image/png;base64,666" alt="image-20201030145110915"></p><h4 id="7-5-2-递归与迭代">7.5.2 递归与迭代</h4><ul><li>如果一个递归函数内部所执行的最后一条语句就是调用自身时，被称为尾部递归，这样的递归很容易被改写为循环迭代的形式，而迭代的效率通常较高</li></ul><h3 id="7-6-可变参数列表">7.6 可变参数列表</h3><h4 id="7-6-1-stdarg宏">7.6.1 stdarg宏</h4><p>定义于stdarg.h头文件</p><ul><li>类型va_list：用于声明变量来访问参数列表的未确定部分<ul><li>此时声明函数的方式为<code>float average(int n, ...)</code></li></ul></li><li>宏va_start：初始化va_list声明的变量，第1个参数是va_list变量名，第2个参数是省略号前的最后一个有名字的参数</li><li>宏va_arg：用于访问参数，第1个参数是va_list变量名，第2个参数是参数列表中下一个参数的类型，返回这个参数的值，并指向下一个可变参数</li><li>宏va_end：访问完最后一个可变参数后调用，参数为va_list变量名</li></ul><h4 id="7-6-2-可变参数的限制">7.6.2 可变参数的限制</h4><ul><li>这些宏无法判断实际存在的参数的数量</li><li>这些宏无法判断每个参数的类型</li></ul><h2 id="Ch8-数组">Ch8 数组</h2><h3 id="8-1-一维数组">8.1 一维数组</h3><h4 id="8-1-1-数组名">8.1.1 数组名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><p>b[3]的类型是整型</p></li><li><p>b是一个指向b[0]的常量指针，因而不能修改数组名的值，即不能修改数组存储的内存地址</p></li><li><p>数组的赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个表达式作用相同，将c指向a[0]</span></span><br><span class="line">c = &amp;a[<span class="number">0</span>];</span><br><span class="line">c = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>// 以下表达式非法，不能将数组复制给数组，数组间的复制只能通过循环逐个元素复制<br>b = a;</p><p>// 以下表达式非法，a是常量，不能被修改<br>a = c;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 8.1.2 下标引用</span><br><span class="line"></span><br><span class="line">通过以下例子说明：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">int array[10];</span><br><span class="line">int *ap &#x3D; array + 2;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>对等表达式</th></tr></thead><tbody><tr><td>ap</td><td>array+2, &amp;array[2]</td></tr><tr><td>*ap</td><td>array[2], *(array+2)</td></tr><tr><td>ap[0]</td><td>array[2]</td></tr><tr><td>ap+6</td><td>array+8, &amp;array[8]</td></tr><tr><td>*ap+6</td><td>array[2]+6</td></tr><tr><td>*(ap+6)</td><td>array[8]</td></tr><tr><td>ap[-1]</td><td>array[1]</td></tr><tr><td>ap[9]</td><td>非法</td></tr></tbody></table><h4 id="8-1-3-指针与下标">8.1.3 指针与下标</h4><p>指针有时比下标更加高效</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172144100.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172144100.png" srcset="data:image/png;base64,666" alt="image-20201030172144100"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172236189.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172236189.png" srcset="data:image/png;base64,666" alt="image-20201030172236189"></p><ul><li>在数组中一次一步移动时，与固定数字相乘的运算在编译的时候完成，所以在运行时所需的指令就少</li><li>但这在实际中不常用，因为可能编译器对循环会有优化</li></ul><h4 id="8-1-5-数组和指针">8.1.5 数组和指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];   <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> *b;     <span class="comment">// 指针</span></span><br></pre></td></tr></table></figure><ul><li><p>a和b都具有指针值，都可以进行间接访问和下标引用操作</p></li><li><p>区别：</p><ul><li>声明数组时，编译器会为数组保留内存空间，然后再创建数组名</li><li>声明指针变量时，编译器只为指针本身保留内存空间，而不为整型值分配内存空间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030175554658.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030175554658.png" srcset="data:image/png;base64,666" alt="image-20201030175554658"></p></li><li><p>在上述声明后：</p><ul><li>*a是合法的，*b是非法的，因为*b将访问内存中某个不确定的位置</li><li>b<ins>是合法的，a</ins>是非法的，因为a是常量指针</li></ul></li></ul><h4 id="8-1-7-声明数组参数">8.1.7 声明数组参数</h4><p>下面的函数原型是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-1-8-初始化">8.1.8 初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>静态初始化：静态变量存储在静态内存，只初始化一次</li><li>自动初始化：自动变量在缺省情况下是未初始化的，若给定初值，则每次进入代码块都会重新初始化</li></ul><h4 id="8-1-9-不完整的初始化">8.1.9 不完整的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>vector[4]被初始化为0</p><h4 id="8-1-10-自动计算数组长度">8.1.10 自动计算数组长度</h4><p>如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有初始值的长度</p><h4 id="8-1-11-字符数组的初始化">8.1.11 字符数组的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字符串数组</span></span><br><span class="line"><span class="keyword">char</span> message1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个字符串常量</span></span><br><span class="line"><span class="keyword">char</span> *message2 = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030233429373.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030233429373.png" srcset="data:image/png;base64,666" alt="image-20201030233429373"></p><h3 id="8-2-多维数组">8.2 多维数组</h3><h4 id="8-2-1-存储顺序">8.2.1 存储顺序</h4><p>定义一个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><p>其在内存中的存储形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030235423211.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030235423211.png" srcset="data:image/png;base64,666" alt="image-20201030235423211"></p><p>这18个元素的下标值依次是(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (1,0) … (2,4) (2,5)</p><h4 id="8-2-2-数组名">8.2.2 数组名</h4><p>如在<code>int matrix[3][10]</code>中，matrix是指向一个包含10个整型元素的数组的指针</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000129705.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000129705.png" srcset="data:image/png;base64,666" alt="image-20201031000129705"></p><p>那么matrix+1则指向：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000214011.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000214011.png" srcset="data:image/png;base64,666" alt="image-20201031000214011"></p><p>而*(matrix + 1) + 5就等价于matrix[1] + 5，是一个指向整型的指针：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000530029.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000530029.png" srcset="data:image/png;base64,666" alt="image-20201031000530029"></p><h4 id="8-2-4-指向数组的指针">8.2.4 指向数组的指针</h4><p>声明一个指向整型数组的指针，并令其指向matrix数组的第一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = matrix;</span><br></pre></td></tr></table></figure><h4 id="8-2-5-作为函数参数的多维数组">8.2.5 作为函数参数的多维数组</h4><p>可以使用以下两张形式的任何一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*mat)[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> mat[][<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-2-6-初始化">8.2.6 初始化</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031171919198.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031171919198.png" srcset="data:image/png;base64,666" alt="image-20201031171919198"></p><h4 id="8-2-7-数组长度自动计算">8.2.7 数组长度自动计算</h4><p>在多维数组中，只有第1维才能根据初始化列表缺省地提供，剩余的几个维必须显式写出</p><h3 id="8-3-指针数组">8.3 指针数组</h3><p>定义方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *keyword[] = &#123;</span><br><span class="line">    <span class="string">&quot;do&quot;</span>,</span><br><span class="line">    <span class="string">&quot;for&quot;</span>,</span><br><span class="line">    <span class="string">&quot;if&quot;</span>,</span><br><span class="line">    <span class="string">&quot;return&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义的好处在于如果要遍历这个表，只需要<code>for (kwp=keyword; *kwp!=NULL; kwp++)</code></p><h2 id="Ch9-字符串、字符和字节">Ch9 字符串、字符和字节</h2><h3 id="9-1-字符串基础">9.1 字符串基础</h3><ul><li>字符串的长度不包含最后的NUL字节</li><li>头文件string.h包含了使用字符串函数所需的原型和声明</li></ul><h3 id="9-2-字符串长度">9.2 字符串长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回类型为size_t，是一个无符号整数类型</p></li><li><p>不要在表达式中同时包含有符号数和无符号数，因此应该把strlen的返回值<strong>强制转换为int</strong></p></li></ul><h3 id="9-3-不受限制的字符串函数">9.3 不受限制的字符串函数</h3><h4 id="9-3-1-复制字符串">9.3.1 复制字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>dst必须是一个字符数组或是一个指向动态分配内存的数组的指针</li><li>复制字符串前必须保证目标字符数组的空间足以容纳需要复制的字符串，不然会覆盖数组之后内存的内容</li></ul><h4 id="9-3-2-连接字符串">9.3.2 连接字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将src字符串的拷贝添加到dst字符串之后</li></ul><h4 id="9-3-4-字符串比较">9.3.4 字符串比较</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若s1小于s2，返回一个小于0的值；若s1大于s2，返回一个大于0的值；若s1和s2相等，返回0</li></ul><h3 id="9-4-长度受限的字符串函数">9.4 长度受限的字符串函数</h3><ul><li><p>字符串复制，将src的前len个字符(不够补NUL)复制给dst，但当src的长度大于len时，只能复制len个字符给dst，因此结果的dst最后是没有NUL的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串连接，将src的前len个字符(不够补NUL)连接到dst后面，会自动添加一个NUL在dst的最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串比较，比较两个字符串的前len位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-5-字符串查找基础">9.5 字符串查找基础</h3><h4 id="9-5-1-查找一个字符">9.5.1 查找一个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在字符串str中查找字符ch第一次出现的位置，返回一个指向该位置的指针，若没有找到返回NULL指针</li><li>strchr从左开始找，strrchr从右开始找</li></ul><h4 id="9-5-2-查找任何几个字符">9.5.2 查找任何几个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回一个指向str中第一个匹配group中任何一个字符的位置指针</li></ul><h4 id="9-5-3-查找一个子串">9.5.3 查找一个子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针</li></ul><h3 id="9-6-高级字符串查找">9.6 高级字符串查找</h3><h4 id="9-6-1-查找一个字符串前缀">9.6.1 查找一个字符串前缀</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strspn</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strcspn</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>strspn返回str起始部分匹配group中任意字符的字符数，而strcspn找的是非group中的字符</p></li><li><p>例如得到指向字符串中第一个非空白字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prt = buffer + <span class="built_in">strspn</span>(buffer, <span class="string">&quot;\n\t\r\f\v&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-6-2-查找标记">9.6.2 查找标记</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *sep)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>从字符串中隔离各个单独的称为标记的部分</p></li><li><p>sep定义了用作分隔符的字符集合</p></li><li><p>若strtok的第一个参数不是NULL，函数将找到字符串的第一个标记，同时保存它在字符串中的位置；若strtok的第一个参数是NULL，函数将在同一个字符串中从保存的位置开始查找下一个标记；若找不到下一个标记，则返回NULL</p></li><li><p>例子：查找被空白分隔的单词</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (token=strtok(line, whitespace); token!=<span class="literal">NULL</span>; token=strtok(<span class="literal">NULL</span>, whitespace)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-7-错误信息">9.7 错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> error_number)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数为错误代码，返回一个指向用于描述错误的字符串的指针</li></ul><h3 id="9-8-字符操作">9.8 字符操作</h3><p>头文件ctype.h</p><h4 id="9-8-1-字符分类">9.8.1 字符分类</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031215526209.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031215526209.png" srcset="data:image/png;base64,666" alt="image-20201031215526209"  /><h4 id="9-8-2-字符大小写转换">9.8.2 字符大小写转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-9-内存操作">9.9 内存操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a, <span class="keyword">void</span> <span class="keyword">const</span> *b, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>与strn带头的函数不同，这些函数遇到NUL字节时不会停止操作</li></ul><h2 id="Ch10-结构和联合">Ch10 结构和联合</h2><h3 id="10-1-结构基础知识">10.1 结构基础知识</h3><p>当一个结构变量在表达式中使用时，并不被替换成一个指针，而是一个标量类型</p><h4 id="10-1-1-结构声明">10.1.1 结构声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125; x, y[<span class="number">20</span>], *z;</span><br></pre></td></tr></table></figure><ul><li>声明了结构体x，包含20个结构体的数组y，指向结构体的指针z</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">x</span>, <span class="title">y</span>[20], *<span class="title">z</span>;</span></span><br></pre></td></tr></table></figure><p>推荐使用以下声明方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125; Simple;</span><br><span class="line"></span><br><span class="line">Simple x, y[<span class="number">20</span>], *z;</span><br></pre></td></tr></table></figure><h4 id="10-1-2-结构成员">10.1.2 结构成员</h4><ul><li><p>直接访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple simp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问成员a</span></span><br><span class="line">simp.a</span><br></pre></td></tr></table></figure></li><li><p>间接访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple *simp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问成员a</span></span><br><span class="line">simp-&gt;a</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-1-5-结构的自引用">10.1.5 结构的自引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; SELF_REF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; SELF_REF;</span><br></pre></td></tr></table></figure><h4 id="10-1-6-不完整的声明">10.1.6 不完整的声明</h4><p>用于多个相互依赖的结构体之间的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-2-结构、指针和成员">10.2 结构、指针和成员</h3><p>后面几节都以以下结构体为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b[<span class="number">2</span>];</span><br><span class="line">&#125; Ex2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ex</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">    Ex2 c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EX</span> *<span class="title">d</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184819038.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184819038.png" srcset="data:image/png;base64,666" alt="image-20201101184819038" style="zoom:80%;" /><p>若声明一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex x = &#123;<span class="number">10</span>, <span class="string">&quot;Hi&quot;</span>, &#123;<span class="number">5</span>, &#123;<span class="number">-1</span>, <span class="number">25</span>&#125;&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">Ex *px = &amp;x;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184841055.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184841055.png" srcset="data:image/png;base64,666" alt="image-20201101184841055"></p><h4 id="10-2-1-访问指针">10.2.1 访问指针</h4><ul><li>px的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185055208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185055208.png" srcset="data:image/png;base64,666" alt="image-20201101185055208"></p><ul><li>px的左值：<ul><li>px+1是一个非法的左值</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185116789.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185116789.png" srcset="data:image/png;base64,666" alt="image-20201101185116789"></p><h4 id="10-2-2-访问结构">10.2.2 访问结构</h4><ul><li>*px的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185329988.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185329988.png" srcset="data:image/png;base64,666" alt="image-20201101185329988"></p><ul><li>*px的左值（接受一个新值）：<ul><li>*px+1是非法的，因为没办法将结构体和整型相加</li><li>*(px+1)也是非法的</li></ul></li></ul><h4 id="image-2020110118534746710-2-3-访问结构成员"><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185347467.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185347467.png" srcset="data:image/png;base64,666" alt="image-20201101185347467">10.2.3 访问结构成员</h4><ul><li>px-&gt;a的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185553782.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185553782.png" srcset="data:image/png;base64,666" alt="image-20201101185553782"></p><ul><li><p>如果进行以下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = &amp;px-&gt;a;</span><br></pre></td></tr></table></figure><p>则pi为：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185756719.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185756719.png" srcset="data:image/png;base64,666" alt="image-20201101185756719"></p><p>​**注：**<em>px的结果是整个结构，而</em>pi的结果是一个整型数</p><ul><li>px-&gt;b的右值为指针常量，所以没有合法左值：<ul><li>对数组元素的访问采用px-&gt;b[1]</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190015612.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190015612.png" srcset="data:image/png;base64,666" alt="image-20201101190015612"></p><h4 id="10-2-4-访问嵌套的结构">10.2.4 访问嵌套的结构</h4><ul><li>px-&gt;c的左值是整个结构，右值如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190226613.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190226613.png" srcset="data:image/png;base64,666" alt="image-20201101190226613"></p><ul><li>px-&gt;c.a的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190313143.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190313143.png" srcset="data:image/png;base64,666" alt="image-20201101190313143"></p><ul><li>*px-&gt;c.b的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190339608.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190339608.png" srcset="data:image/png;base64,666" alt="image-20201101190339608"></p><h4 id="10-2-5-访问指针成员">10.2.5 访问指针成员</h4><p>对px-&gt;d进行初始化，使其指向一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex y;</span><br><span class="line">px-&gt;d = &amp;y;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190547718.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190547718.png" srcset="data:image/png;base64,666" alt="image-20201101190547718"></p><ul><li>px-&gt;d-&gt;c.b[1]的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190624854.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190624854.png" srcset="data:image/png;base64,666" alt="image-20201101190624854"></p><h3 id="10-3-结构的存储分配">10.3 结构的存储分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上述结构体，若整型长度为4字节，而且它的起始存储位置必须能被4整除，于是a存储为1字节，但是后面必须空出3字节才能存放b，其存储形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101191932308.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101191932308.png" srcset="data:image/png;base64,666" alt="image-20201101191932308"></p><p>一个结构体占了12个字节的存储空间，有效利用空间却只有6字节</p><p>如果声明改为如下形式，则只需要8个字节就能存储这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>sizeof可以得出一个结构体的整体长度，包括跳过的字节</li><li>使用offset(type, member)能获得结构体中某成员的实际位置，如offset(struct ALIGN, b)</li></ul><h3 id="10-4-作为函数参数的结构">10.4 作为函数参数的结构</h3><ul><li><p>最好使用指针来传递参数，并声明为寄存器变量来提高效率</p><ul><li><p>若结构体成员不能改变，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">register</span> ALIGN <span class="keyword">const</span> *test)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>若需要根据程序运行结果修改结构体中的值，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">register</span> ALIGN *test)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>调用方式都为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(&amp;align);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="10-5-位段">10.5 位段</h3><ul><li>注重可移植性的程序应该避免使用位段</li></ul><h3 id="10-6-联合">10.6 联合</h3><ul><li><p>联合的所有成员引用的是内存中的相同位置</p></li><li><p>如果联合的各个成员具有不同的长度，联合的长度就是最长成员的长度</p></li><li><p>应用场景比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VARIABLE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>INT, FLOAT, STRING&#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">float</span> f;</span><br><span class="line">        <span class="keyword">char</span> *s;</span><br><span class="line">    &#125; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于整型，type设为INT，存储于value.i中；对于浮点数，type设为FLOAT，存储于value.f中；</p></li><li><p>联合的初始化，初始值必须是联合第一个成员的类型，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">4</span>];</span><br><span class="line">&#125; x = &#123;<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch11-动态内存分配">Ch11 动态内存分配</h2><h3 id="11-1-为什么使用动态分配内存">11.1 为什么使用动态分配内存</h3><p>声明数组时，数组的长度往往在运行时才能知道，但是编译时需要指定数组的长度，因为需要提前开辟内存空间。</p><h3 id="11-2-malloc和free">11.2 malloc和free</h3><ul><li>在头文件stdlib.h中声明</li></ul><h4 id="11-2-1-malloc">11.2.1 malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>malloc从内存池中提取一块合适的内存，并返回一个指向这块内存起始位置的指针(如果内存池中的内存可以满足需求的话，否则返回NULL)</li><li>参数是需要分配的内存字节数</li><li>malloc分配的是一块连续的内存</li><li>分配的内存不会被初始化</li></ul><h4 id="11-2-2-free">11.2.2 free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *pointer)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数是NULL时不会产生任何效果</li><li>参数是先前从malloc、calloc或realloc返回的值时，将分配的内存归还给内存池</li></ul><h3 id="11-3-calloc和realloc">11.3 calloc和realloc</h3><h4 id="11-3-1-calloc">11.3.1 calloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num_elements, <span class="keyword">size_t</span> element_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数包括所需元素的数量和每个元素的字节数</li><li>将分配的内存初始化为0</li></ul><h4 id="11-3-2-realloc">11.3.2 realloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>用于修改一个原先已经分配的内存块的大小</li><li>扩大内存块时，在原先的内存块之后添加；缩小内存块时，从原先内存块的尾部删除</li></ul><h3 id="11-4-使用动态分配的内存">11.4 使用动态分配的内存</h3><ul><li><p>获得足够存储25个整型的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = <span class="built_in">malloc</span>(<span class="number">25</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-5-常见的动态内存错误">11.5 常见的动态内存错误</h3><ul><li><p>对NULL指针进行解引用操作</p></li><li><p>对分配的内存进行操作时越界</p></li><li><p>释放并非动态分配的内存</p></li><li><p>试图释放一块动态分配的内存的一部分</p></li><li><p>一块动态内存被释放之后被继续使用</p></li><li><p>内存泄漏：在使用完毕动态内存后没有进行释放</p></li></ul><h2 id="Ch12-使用结构和指针">Ch12 使用结构和指针</h2><h3 id="12-2-单链表">12.2 单链表</h3><p>声明一个节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>链表结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105130430994.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105130430994.png" srcset="data:image/png;base64,666" alt="image-20201105130430994"></p><h4 id="12-2-1-插入一个有序单链表">12.2.1 插入一个有序单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的参数是一个指向链表第一个节点的指针，以及一个需要插入的新值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sll_node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sll_insert</span><span class="params">(<span class="keyword">register</span> Node **linkp, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> Node *current;</span><br><span class="line">    <span class="keyword">register</span> Node *<span class="keyword">new</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找正确的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> ((current=*linkp) != <span class="literal">NULL</span> &amp;&amp; current-&gt;value &lt; new_value) &#123;</span><br><span class="line">        linkp = &amp;current-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    <span class="keyword">new</span> = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;link = current;</span><br><span class="line">    *linkp = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-双链表">12.3 双链表</h3><p>声明一个双链表节点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">fwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">bwd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>双链表结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105133824925.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105133824925.png" srcset="data:image/png;base64,666" alt="image-20201105133824925"></p><h2 id="Ch14-预处理器">Ch14 预处理器</h2><h3 id="14-1-预定义符号">14.1 预定义符号</h3><table><thead><tr><th>符号</th><th>样例</th><th>含义</th></tr></thead><tbody><tr><td>_<em>FILE</em>_</td><td>“name.c”</td><td>进行编译的文件名</td></tr><tr><td>_<em>LINE</em>_</td><td>25</td><td>文件当前行的行号</td></tr><tr><td>_<em>DATE</em>_</td><td>“Jan 31 1997”</td><td>文件被编译的日期</td></tr><tr><td>_<em>TIME</em>_</td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td>_<em>STDC</em>_</td><td>1</td><td>如果编译器遵循ANSI C，值为1</td></tr></tbody></table><h3 id="14-2-define">14.2 #define</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> name stuff</span></span><br></pre></td></tr></table></figure><p>替换文本不仅限于数值字面值常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_forever for(;;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE break;case</span></span><br></pre></td></tr></table></figure><h4 id="14-2-1-宏">14.2.1 宏</h4><p>#define允许把参数替换到文本中，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) (x)*(x)</span></span><br><span class="line"></span><br><span class="line">SQUARE(<span class="number">5</span>)   <span class="comment">// 输出25</span></span><br></pre></td></tr></table></figure><h4 id="14-2-3-宏与函数">14.2.3 宏与函数</h4><p>可以使用宏来实现简单的函数，如比较大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><h4 id="14-2-6-undef">14.2.6 #undef</h4><p>移除一个宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> name</span></span><br></pre></td></tr></table></figure><h3 id="14-3-条件编译">14.3 条件编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 常量表达式</span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>如果常量表达式非零，则statements正常编译，否则不编译</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习 - SQ1复形</title>
      <link href="2020/11/04/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/"/>
      <url>2020/11/04/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview">Overview</h2><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104190715236.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104190715236.png" srcset="data:image/png;base64,666" alt="image-20201104190715236"></p><h2 id="CS-Algs-by-Depth">CS Algs by Depth</h2><h3 id="Depth-1">Depth 1</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104191942490.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104191942490.png" srcset="data:image/png;base64,666" alt="image-20201104191942490"></td><td>/</td><td>/</td></tr></tbody></table><h3 id="Depth-2">Depth 2</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192059289.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192059289.png" srcset="data:image/png;base64,666" alt="image-20201104192059289"></td><td>/-3-3/</td><td>/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192131237.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192131237.png" srcset="data:image/png;base64,666" alt="image-20201104192131237"></td><td>/3/</td><td>/-3/</td></tr></tbody></table><h3 id="Depth-3">Depth 3</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192837328.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192837328.png" srcset="data:image/png;base64,666" alt="image-20201104192837328"></td><td>/3/1/</td><td>/-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104193911825.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104193911825.png" srcset="data:image/png;base64,666" alt="image-20201104193911825"></td><td>/-3/-2/</td><td>/2/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194301885.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194301885.png" srcset="data:image/png;base64,666" alt="image-20201104194301885"></td><td>/3/3/</td><td>/-3/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194351763.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194351763.png" srcset="data:image/png;base64,666" alt="image-20201104194351763"></td><td>/3/12/</td><td>/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194631403.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194631403.png" srcset="data:image/png;base64,666" alt="image-20201104194631403"></td><td>/33/-1-2/</td><td>/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194831210.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194831210.png" srcset="data:image/png;base64,666" alt="image-20201104194831210"></td><td>/33/-1/</td><td>/1/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194906760.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194906760.png" srcset="data:image/png;base64,666" alt="image-20201104194906760"></td><td>/-3-3/2/</td><td>/-2/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195100188.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195100188.png" srcset="data:image/png;base64,666" alt="image-20201104195100188"></td><td>/3/1-4/</td><td>/-14/-3/</td></tr></tbody></table><h3 id="Depth-4">Depth 4</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195239653.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195239653.png" srcset="data:image/png;base64,666" alt="image-20201104195239653"></td><td>/33/-1-2/-2-4/</td><td>/24/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195402306.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195402306.png" srcset="data:image/png;base64,666" alt="image-20201104195402306"></td><td>/-3-3/01/-2-2/</td><td>-2/22/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195546376.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195546376.png" srcset="data:image/png;base64,666" alt="image-20201104195546376"></td><td>/3/1-4/42/</td><td>/24/1/-4/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104200419264.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104200419264.png" srcset="data:image/png;base64,666" alt="image-20201104200419264"></td><td>/3/1-4/-2-4/</td><td><strong><code>/-4-2/1/-4/3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104203853713.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104203853713.png" srcset="data:image/png;base64,666" alt="image-20201104203853713"></td><td>/33/-1-2/0-4/</td><td>/04/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204102761.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204102761.png" srcset="data:image/png;base64,666" alt="image-20201104204102761"></td><td>/33/12/02/</td><td>/0-2/21/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204218035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204218035.png" srcset="data:image/png;base64,666" alt="image-20201104204218035"></td><td>/33/-1-2/0-2/</td><td>/02/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204256742.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204256742.png" srcset="data:image/png;base64,666" alt="image-20201104204256742"></td><td>/-3-3/01/-2/</td><td>/2/0-1/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204502256.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204502256.png" srcset="data:image/png;base64,666" alt="image-20201104204502256"></td><td>/3/1-4/4/</td><td>y2 /0-4/-41/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204733435.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204733435.png" srcset="data:image/png;base64,666" alt="image-20201104204733435"></td><td>1-1/0-3/5-2/04/</td><td><strong><code>y2 /-4/1/-4/3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205118213.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205118213.png" srcset="data:image/png;base64,666" alt="image-20201104205118213"></td><td>/03/12/-32/</td><td>/-34/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205234862.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205234862.png" srcset="data:image/png;base64,666" alt="image-20201104205234862"></td><td>1-1/0-3/-1-2/3-2/</td><td>/-32/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205624947.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205624947.png" srcset="data:image/png;base64,666" alt="image-20201104205624947"></td><td>/3/1-4/02/</td><td><strong><code>/0-2/-14/-3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205728979.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205728979.png" srcset="data:image/png;base64,666" alt="image-20201104205728979"></td><td>/0-3/0-1/02/</td><td>/0-2/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205859708.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205859708.png" srcset="data:image/png;base64,666" alt="image-20201104205859708"></td><td>/0-3/0-1/12/</td><td>/-1-2/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205950415.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205950415.png" srcset="data:image/png;base64,666" alt="image-20201104205950415"></td><td>1-1/3/21/-2/</td><td><strong><code>/2/12/03/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210319195.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210319195.png" srcset="data:image/png;base64,666" alt="image-20201104210319195"></td><td>/3/12/4/</td><td>/-4/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210408388.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210408388.png" srcset="data:image/png;base64,666" alt="image-20201104210408388"></td><td>1-1/0-3/-1-2/0-4/</td><td>/04/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210512395.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210512395.png" srcset="data:image/png;base64,666" alt="image-20201104210512395"></td><td>1-1/3/21/-2-3/</td><td>/23/-2-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210603505.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210603505.png" srcset="data:image/png;base64,666" alt="image-20201104210603505"></td><td>/3/12/23/</td><td>/-2-3/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210645921.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210645921.png" srcset="data:image/png;base64,666" alt="image-20201104210645921"></td><td>/33/-1/4/</td><td>/-4/1/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210758160.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210758160.png" srcset="data:image/png;base64,666" alt="image-20201104210758160"></td><td>1-1/3/21/0-3/</td><td>/03/-2-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210924727.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210924727.png" srcset="data:image/png;base64,666" alt="image-20201104210924727"></td><td>/0-3/0-1/1/</td><td>/-1/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104211056172.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104211056172.png" srcset="data:image/png;base64,666" alt="image-20201104211056172"></td><td>/0-3/0-1/04/</td><td>/0-4/01/03/</td></tr></tbody></table><h3 id="Depth-5">Depth 5</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th><th>Note</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104214123694.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104214123694.png" srcset="data:image/png;base64,666" alt="image-20201104214123694"></td><td>/03/12/-3/02/</td><td><strong><code>/0-2/3/-1-2/0-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104215905927.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104215905927.png" srcset="data:image/png;base64,666" alt="image-20201104215905927"></td><td>/0-3/0-1/1/02/</td><td><strong><code>/0-2/-1/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104220413801.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104220413801.png" srcset="data:image/png;base64,666" alt="image-20201104220413801"></td><td>1-1/03/01/-1/0-2/</td><td><strong><code>/02/02/1/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221315982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221315982.png" srcset="data:image/png;base64,666" alt="image-20201104221315982"></td><td>/3/12/2-3/34/</td><td>/32/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213314692.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213314692.png" srcset="data:image/png;base64,666" alt="image-20201104213314692"></td><td>1-1/0-3/-1-2/3-4/-3/</td><td>/3/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213425561.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213425561.png" srcset="data:image/png;base64,666" alt="image-20201104213425561"></td><td>1-1/0-3/-1-2/3-2/3/</td><td>/-3/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221827619.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221827619.png" srcset="data:image/png;base64,666" alt="image-20201104221827619"></td><td>1-1/0-3/-1-2/0-4/-3/</td><td><strong><code>/3/04/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104222735067.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104222735067.png" srcset="data:image/png;base64,666" alt="image-20201104222735067"></td><td>/03/12/04/3/</td><td><strong><code>/-3/62/-12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233553524.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233553524.png" srcset="data:image/png;base64,666" alt="image-20201104233553524"></td><td>/33/1/-2/2/</td><td>/-2/2/-1/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104223119427.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104223119427.png" srcset="data:image/png;base64,666" alt="image-20201104223119427"></td><td>/33/-1-2/-2/1-2/</td><td><strong><code>/-12/2/12/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104224012377.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104224012377.png" srcset="data:image/png;base64,666" alt="image-20201104224012377"></td><td>/33/-1-2/02/2-1/</td><td><strong><code>/-21/0-2/12/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234024560.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234024560.png" srcset="data:image/png;base64,666" alt="image-20201104234024560"></td><td>1-1/3/21/2-3/2-1/</td><td>/-21/-23/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234520095.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234520095.png" srcset="data:image/png;base64,666" alt="image-20201104234520095"></td><td>1-1/3/21/4-3/-21/</td><td>/2-1/-43/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230509180.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230509180.png" srcset="data:image/png;base64,666" alt="image-20201104230509180" style="zoom:130%;" /></td><td>/0-3/0-1/1/32/</td><td><strong><code>/-3-2/-1/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230553088.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230553088.png" srcset="data:image/png;base64,666" alt="image-20201104230553088" style="zoom:130%;" /></td><td>1-1/0-3/-1/0-2/-3-2/</td><td><strong><code>/32/02/1/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104225944910.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104225944910.png" srcset="data:image/png;base64,666" alt="image-20201104225944910"></td><td>/33/-1-2/-2-4/-3/</td><td>/3/24/12/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104230030964.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104230030964.png" srcset="data:image/png;base64,666" alt="image-20201104230030964"></td><td>1-1/0-3/-1-2/0-4/-32/</td><td><strong><code>/3-2/04/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231503453.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231503453.png" srcset="data:image/png;base64,666" alt="image-20201104231503453"></td><td>1-1/-3/-1-2/4/-2/</td><td><strong><code>/2/-4/12/3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235201130.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235201130.png" srcset="data:image/png;base64,666" alt="image-20201104235201130"></td><td>/33/-1-2/0-4/02/</td><td>/0-2/04/12/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231611888.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231611888.png" srcset="data:image/png;base64,666" alt="image-20201104231611888"></td><td>1-1/3/21/2/0-1/</td><td><strong><code>/01/-2/-2-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232130549.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232130549.png" srcset="data:image/png;base64,666" alt="image-20201104232130549"></td><td>1-1/0-3/-1-2/02/0-1/</td><td><strong><code>/01/0-2/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232211689.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232211689.png" srcset="data:image/png;base64,666" alt="image-20201104232211689"></td><td>/3/12/-2/01/</td><td><strong><code>/0-1/2/-1-2/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232318699.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232318699.png" srcset="data:image/png;base64,666" alt="image-20201104232318699"></td><td>/03/12/02/3-2/</td><td><strong><code>/-32/0-2/-1-2/0-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232554844.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232554844.png" srcset="data:image/png;base64,666" alt="image-20201104232554844"></td><td>/3/1/-2/2/</td><td>/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232626895.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232626895.png" srcset="data:image/png;base64,666" alt="image-20201104232626895"></td><td>/3/1/-2-1/01/</td><td><strong><code>/0-1/21/-1/-3/</code></strong></td><td>三小角换风筝尾</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233425542.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233425542.png" srcset="data:image/png;base64,666" alt="image-20201104233425542"></td><td>/3/1/-2/0-1/</td><td><strong><code>/01/2/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235428645.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235428645.png" srcset="data:image/png;base64,666" alt="image-20201104235428645"></td><td>1-1/0-3/-1-2/3-4/32/</td><td>/-3-2/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235508229.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235508229.png" srcset="data:image/png;base64,666" alt="image-20201104235508229"></td><td>/3/12/-23/21/</td><td>/-2-1/2-3/-1-2/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235554034.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235554034.png" srcset="data:image/png;base64,666" alt="image-20201104235554034"></td><td>1-1/0-3/-1-2/3-2/-3/</td><td>/3/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235637927.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235637927.png" srcset="data:image/png;base64,666" alt="image-20201104235637927"></td><td>/03/12/-32/3/</td><td>/-3/3-2/-1-2/0-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235721071.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235721071.png" srcset="data:image/png;base64,666" alt="image-20201104235721071"></td><td>1-1/0-3/-1-2/3-2/0-2/</td><td>/02/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235832145.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235832145.png" srcset="data:image/png;base64,666" alt="image-20201104235832145"></td><td>/3/1-4/02/-1/</td><td>/1/0-2/-14/-3/</td><td>构造飞镖</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093024208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093024208.png" srcset="data:image/png;base64,666" alt="image-20201105093024208"></td><td>/3/1-4/02/0-2/</td><td><strong><code>/02/0-2/-14/-3/</code></strong></td><td>构造飞镖</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105000229881.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105000229881.png" srcset="data:image/png;base64,666" alt="image-20201105000229881"></td><td>1-1/3/21/2-3/0-1/</td><td>/01/-23/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105092327756.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105092327756.png" srcset="data:image/png;base64,666" alt="image-20201105092327756"></td><td>/33/-1-2/2/0-1/</td><td><strong><code>/01/-2/12/-3-3/</code></strong></td><td>三小角并一小角</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093823821.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093823821.png" srcset="data:image/png;base64,666" alt="image-20201105093823821"></td><td>/-3-3/01/-2-2/1-2/</td><td>\</td><td>合并六星</td></tr></tbody></table><h3 id="Depth-6">Depth 6</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th><th>Note</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094450515.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094450515.png" srcset="data:image/png;base64,666" alt="image-20201105094450515"></td><td>/0-3/-2-1/-32/-1-2/-4/</td><td><strong><code>/4/12/3-2/21/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094654340.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094654340.png" srcset="data:image/png;base64,666" alt="image-20201105094654340"></td><td>1-1/-3/-1-2/2-3/-2-1/0-4/</td><td>/04/21/-23/12/3/</td><td>待优化</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094819794.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094819794.png" srcset="data:image/png;base64,666" alt="image-20201105094819794"></td><td>1-1/0-3/-1-2/3-4/-1-2/-2/</td><td><strong><code>/2/12/ -34/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095130553.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095130553.png" srcset="data:image/png;base64,666" alt="image-20201105095130553"></td><td>1-1/3/21/4-3/21/02/</td><td><strong><code>/0-2/-2-1/-43/-2-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095323990.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095323990.png" srcset="data:image/png;base64,666" alt="image-20201105095323990"></td><td>/0-3/0-1/12/2/-1/</td><td><strong><code>/1/-2/-1-2/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095631429.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095631429.png" srcset="data:image/png;base64,666" alt="image-20201105095631429"></td><td>/3/1/-2-1/0-2/01/</td><td><strong><code>/0-1/02/21/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095654217.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095654217.png" srcset="data:image/png;base64,666" alt="image-20201105095654217"></td><td>/3/1/-2/2/03/</td><td>/0-3/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095830977.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095830977.png" srcset="data:image/png;base64,666" alt="image-20201105095830977"></td><td>/33/1/-2-2/21/-2-2/</td><td>\</td><td>两步变六星</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100045458.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100045458.png" srcset="data:image/png;base64,666" alt="image-20201105100045458"></td><td>/3/1/-2/0-1/2/</td><td>/-2/01/2/-1/-3/</td><td>两步后23动1</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100234945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100234945.png" srcset="data:image/png;base64,666" alt="image-20201105100234945"></td><td>/3/1/-2-1/01/-2/</td><td>/2/0-1/21/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100350400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100350400.png" srcset="data:image/png;base64,666" alt="image-20201105100350400"></td><td>/33/1/-2/2/-2-3/</td><td><strong><code>/23/-2/2/-1/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100619220.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100619220.png" srcset="data:image/png;base64,666" alt="image-20201105100619220"></td><td>/3/12/-2/01/2/</td><td><strong><code>/-2/0-1/2/-1-2/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101051905.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101051905.png" srcset="data:image/png;base64,666" alt="image-20201105101051905"></td><td>/3/12/-2/2-3/-2/</td><td><strong><code>/21/2-1/21/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101400605.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101400605.png" srcset="data:image/png;base64,666" alt="image-20201105101400605"></td><td>/3/1/-2/2/-23/</td><td>/2-3/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101539136.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101539136.png" srcset="data:image/png;base64,666" alt="image-20201105101539136"></td><td>/33/-1-2/-2/1/2/</td><td></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101705861.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101705861.png" srcset="data:image/png;base64,666" alt="image-20201105101705861"></td><td>/33/12/2/-1/-2/</td><td></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101757442.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101757442.png" srcset="data:image/png;base64,666" alt="image-20201105101757442"></td><td>1-1/3/2-5/2/0-1/-4/</td><td><strong><code>/4/01/-2/-25/-3/</code></strong></td><td>构造shield-paw</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105102105612.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105102105612.png" srcset="data:image/png;base64,666" alt="image-20201105102105612"></td><td>/3/1/-2/2/-2/</td><td>/2/-2/2/-1/-3/</td><td>构造shield-kite</td></tr></tbody></table><h3 id="Depth-7">Depth 7</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094216164.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094216164.png" srcset="data:image/png;base64,666" alt="image-20201105094216164"></td><td>/3/1/-2/2/-2/1/</td><td>/-1/2/-2/2/-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094250825.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094250825.png" srcset="data:image/png;base64,666" alt="image-20201105094250825"></td><td>/0-3/0-1/02/0-2/02/0-1/</td><td>/01/0-2/02/0-2/01/03/</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Cube </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sq1 </tag>
            
            <tag> cube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Volantis个人博客部署</title>
      <link href="2020/11/03/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
      <url>2020/11/03/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="配置部署Hexo">配置部署Hexo</h2><h3 id="配置流程">配置流程</h3><ul><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">参考链接</a></p><ul><li>安装<a href="https://www.cnblogs.com/lgx5/p/10732016.html">npm</a></li><li>安装<a href="https://blog.csdn.net/sinat_20177327/article/details/76062030">git</a></li><li>其中配置npm源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取npm源</span></span><br><span class="line">npm get registry</span><br><span class="line"><span class="comment"># 修改为淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 重置</span></span><br><span class="line"><span class="comment"># npm config set registry https://registry.npmjs.org/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常用命令">常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传至github</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地运行</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="Markdown公式显示问题">Markdown公式显示问题</h3><p>使用<a href="https://www.jianshu.com/p/588ab3d22eb8">hexo-renderer-markdown-it</a>插件</p><h2 id="处理Markdown图片问题">处理Markdown图片问题</h2><p>在最开始的尝试中遇到以下问题：</p><ul><li>直接将图片保存到github，在hexo编译生成的html网页中通过相对路径访问<strong>速度太慢</strong></li><li>将博客部署到gitee上，由于服务器在国内，图片加载速度确实比github快很多，但是问题在于部署在gitee上的博客会有各种奇怪<strong>显示问题</strong>，所以也放弃</li></ul><p>最终的解决办法：</p><ul><li>先在github新建一个仓库Source，专门用来存放博客文章用到的图片</li><li>使用jsdelivr提供的cdn加速<ul><li>在本地编写好markdown后，将图片文件夹复制到Source目录下并push到github仓库</li><li>在markdown文档中通过<code>ctrl+f</code>将所有图片的路径前缀改为<code>https://cdn.jsdelivr.net/gh/&lt;github用户名&gt;/Source@latest/&lt;文件夹名&gt;</code></li></ul></li></ul><h2 id="Volantis主题配置">Volantis主题配置</h2><h3 id="主题安装">主题安装</h3><ol><li><p>修改<code>./_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">volantis</span></span><br></pre></td></tr></table></figure></li><li><p>下载主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-volantis</span><br></pre></td></tr></table></figure></li><li><p>volantis主题会安装在<code>./node_modules/hexo-theme-volantis</code>中</p></li></ol><h3 id="主题个性化">主题个性化</h3><h4 id="搜索工具安装">搜索工具安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-json-content</span><br></pre></td></tr></table></figure><h4 id="字数统计工具安装">字数统计工具安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="主题配置文件">主题配置文件</h4><h5 id="顶部导航栏">顶部导航栏</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># choose [img] or [icon + title]</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/taiga.svg</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">主页</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-stack-overflow</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">Search...</span>   <span class="comment"># Search bar placeholder</span></span><br></pre></td></tr></table></figure><h5 id="封面">封面</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">layout_scheme:</span> <span class="string">dock</span> <span class="comment"># blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点)</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/interstellar.jpg</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&#x27;Schenk - Blog&#x27;</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;SJTUer | Cuber&#x27;</span></span><br><span class="line">  <span class="attr">features:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br></pre></td></tr></table></figure><h5 id="全局CSS">全局CSS</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="attr">navbar:</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">44px</span> </span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="comment"># auto, max</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">blur</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">    <span class="attr">highlight:</span></span><br><span class="line">      <span class="attr">language:</span> <span class="literal">true</span> <span class="comment"># show language of codeblock</span></span><br><span class="line">      <span class="attr">copy_btn:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">grayscale:</span> <span class="literal">false</span> <span class="comment"># Enable grayscale effect</span></span><br><span class="line">    <span class="attr">text_align:</span> <span class="comment"># left, right, justify, center</span></span><br><span class="line">      <span class="attr">h1:</span> <span class="string">center</span></span><br><span class="line">      <span class="attr">h2:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h3:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h4:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">p:</span> <span class="string">justify</span></span><br><span class="line">  <span class="attr">gap:</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="string">30px</span> <span class="comment"># Spacing above H2 (only px unit)</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="string">18px</span> <span class="comment"># Spacing above H3 (only px unit)</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="string">8px</span> <span class="comment"># Spacing above H4 (only px unit)</span></span><br><span class="line">    <span class="attr">p:</span> <span class="string">1em</span> <span class="comment"># Paragraph spacing between paragraphs</span></span><br><span class="line">    <span class="attr">line_height:</span> <span class="number">1.6</span> <span class="comment"># normal, 1.5, 1.75, 2 ...</span></span><br><span class="line">  <span class="attr">fontsize:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">16px</span></span><br><span class="line">    <span class="attr">h1:</span> <span class="number">1.</span><span class="string">5rem</span> <span class="comment"># 不推荐用在文章中</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="number">1.</span><span class="string">5rem</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="number">1.</span><span class="string">25rem</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="number">1.</span><span class="string">125rem</span></span><br><span class="line">    <span class="attr">h5:</span> <span class="string">1rem</span></span><br><span class="line">    <span class="attr">h6:</span> <span class="string">1rem</span></span><br><span class="line">    <span class="attr">list:</span> <span class="string">.9375rem</span></span><br><span class="line">    <span class="attr">meta:</span> <span class="string">.875rem</span></span><br><span class="line">    <span class="attr">code:</span> <span class="string">.875rem</span></span><br><span class="line">    <span class="attr">footnote:</span> <span class="string">.78125rem</span></span><br><span class="line">  <span class="attr">fontfamily:</span></span><br><span class="line">    <span class="attr">logofont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Microsoft Yahei&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">bodyfont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Microsoft Yahei&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">codefont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/UbuntuMono-Regular.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure><h5 id="页脚">页脚</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_footer:</span></span><br><span class="line">  <span class="comment"># layout of footer: [aplayer, social, license, info, copyright]</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">copyright</span>]</span><br><span class="line">  <span class="comment"># site copyright</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">&#x27;[Copyright © 2020 Schenk](https://github.com/Schenk75/Schenk75.github.io)&#x27;</span></span><br><span class="line">  <span class="comment"># You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;)</span></span><br><span class="line">  <span class="attr">br:</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="文章布局">文章布局</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">article:</span></span><br><span class="line">  <span class="comment"># 文章列表页面的文章卡片布局方案</span></span><br><span class="line">  <span class="attr">preview:</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">landscape</span> <span class="comment"># landscape</span></span><br><span class="line">    <span class="comment"># pin icon for post</span></span><br><span class="line">    <span class="attr">pin_icon:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg</span></span><br><span class="line">    <span class="comment"># auto generate title if not exist</span></span><br><span class="line">    <span class="attr">auto_title:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># auto generate excerpt if not exist</span></span><br><span class="line">    <span class="attr">auto_excerpt:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># show split line or not</span></span><br><span class="line">    <span class="attr">line_style:</span> <span class="string">solid</span> <span class="comment"># hidden, solid, dashed, dotted</span></span><br><span class="line">    <span class="comment"># show author</span></span><br><span class="line">    <span class="attr">author:</span> <span class="literal">false</span> <span class="comment"># true, false</span></span><br><span class="line">    <span class="comment"># show readmore button</span></span><br><span class="line">    <span class="attr">readmore:</span> <span class="string">always</span> <span class="comment"># auto, always</span></span><br><span class="line">  <span class="comment"># 文章详情页面的文章卡片本体布局方案</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="comment"># 文章顶部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">top_meta:</span> [<span class="string">author</span>, <span class="string">category</span>, <span class="string">date</span>, <span class="string">wordcount</span>, <span class="string">counter</span>]</span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="comment"># 文章页脚组件</span></span><br><span class="line">    <span class="attr">footer_widget:</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 参考资料、相关资料等 (for layout: post/docs)</span></span><br><span class="line">      <span class="attr">references:</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">参考资料</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-quote-left</span></span><br><span class="line">        <span class="comment"># 在 front-matter 中:</span></span><br><span class="line">        <span class="comment">#   references:</span></span><br><span class="line">        <span class="comment">#     - title: 某篇文章</span></span><br><span class="line">        <span class="comment">#       url: https://</span></span><br><span class="line">        <span class="comment"># 即可显示此组件。</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 相关文章，需要安装插件 (for layout: post)</span></span><br><span class="line">      <span class="comment"># npm i hexo-related-popular-posts</span></span><br><span class="line">      <span class="attr">related_posts:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">相关文章</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bookmark</span></span><br><span class="line">        <span class="attr">max_count:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># 设为空则不使用文章头图</span></span><br><span class="line">        <span class="attr">placeholder_img:</span> <span class="string">data:image/png;base64,666</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 打赏组件 (for layout: post)</span></span><br><span class="line">      <span class="attr">donate:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">height:</span> <span class="string">128px</span></span><br><span class="line">        <span class="attr">images:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png</span></span><br><span class="line">    <span class="comment"># 文章底部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">bottom_meta:</span> [<span class="string">updated</span>, <span class="string">tags</span>]</span><br><span class="line">    <span class="comment"># meta library</span></span><br><span class="line">    <span class="attr">meta_library:</span></span><br><span class="line">      <span class="comment"># 默认文章作者（可在 front-matter 中覆盖）</span></span><br><span class="line">      <span class="attr">author:</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Schenk</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">      <span class="comment"># 文章创建日期</span></span><br><span class="line">      <span class="attr">date:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-calendar-alt</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;发布于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章更新日期</span></span><br><span class="line">      <span class="attr">updated:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-edit</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;更新于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章分类</span></span><br><span class="line">      <span class="attr">category:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="comment"># 文章浏览计数</span></span><br><span class="line">      <span class="attr">counter:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-eye</span></span><br><span class="line">        <span class="attr">unit:</span> <span class="string">&#x27;次浏览&#x27;</span></span><br><span class="line">      <span class="comment"># 文章字数和阅读时长</span></span><br><span class="line">      <span class="attr">wordcount:</span></span><br><span class="line">        <span class="attr">icon_wordcount:</span> <span class="string">fas</span> <span class="string">fa-keyboard</span></span><br><span class="line">        <span class="attr">icon_duration:</span> <span class="string">fas</span> <span class="string">fa-hourglass-half</span></span><br><span class="line">      <span class="comment"># 文章标签</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-hashtag</span></span><br></pre></td></tr></table></figure><h5 id="侧边栏">侧边栏</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 主页、分类、归档等独立页面</span></span><br><span class="line">  <span class="attr">for_page:</span> [<span class="string">blogger</span>, <span class="string">category</span>, <span class="string">tagcloud</span>, <span class="string">webinfo</span>]</span><br><span class="line">  <span class="comment"># layout: docs/post 这类文章页面</span></span><br><span class="line">  <span class="attr">for_post:</span> [<span class="string">toc</span>]</span><br><span class="line">  <span class="comment"># 侧边栏组件库</span></span><br><span class="line">  <span class="attr">widget_library:</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># blogger info widget</span></span><br><span class="line">    <span class="attr">blogger:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">blogger</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg</span></span><br><span class="line">      <span class="attr">shape:</span> <span class="string">circle</span> <span class="comment"># circle, rectangle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/about/</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">Schenk</span></span><br><span class="line">      <span class="attr">subtitle:</span></span><br><span class="line">      <span class="attr">jinrishici:</span> <span class="literal">false</span> <span class="comment"># Poetry Today. You can set a string, and it will be displayed when loading fails.</span></span><br><span class="line">      <span class="attr">social:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/github-icon.svg</span></span><br><span class="line">          <span class="attr">size:</span> <span class="string">30px</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://github.com/Schenk75</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/struts.svg</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/logos/WCAlogo.svg</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://cubingchina.com/results/person/2018SHEN04</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># toc widget (valid only in articles)</span></span><br><span class="line">    <span class="attr">toc:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">本文目录</span></span><br><span class="line">      <span class="attr">list_number:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">min_depth:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">max_depth:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># category widget</span></span><br><span class="line">    <span class="attr">category:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">category</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># tagcloud widget</span></span><br><span class="line">    <span class="attr">tagcloud:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">tagcloud</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">热门标签</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">      <span class="attr">min_font:</span> <span class="number">14</span></span><br><span class="line">      <span class="attr">max_font:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">start_color:</span> <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      <span class="attr">end_color:</span> <span class="string">&#x27;#555&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># qrcode widget</span></span><br><span class="line">    <span class="attr">donate:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">qrcode</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">64px</span>  <span class="comment"># Automatic height if not set</span></span><br><span class="line">      <span class="attr">images:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># webinfo widget</span></span><br><span class="line">    <span class="attr">webinfo:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">webinfo</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>]</span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-award</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">站点信息</span></span><br><span class="line">      <span class="attr">type:</span></span><br><span class="line">        <span class="attr">article:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;文章数目：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;篇&#x27;</span></span><br><span class="line">        <span class="attr">runtime:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">data:</span> <span class="string">&#x27;2020/11/01&#x27;</span>    <span class="comment"># 填写建站日期</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;已运行时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;天&#x27;</span></span><br><span class="line">        <span class="attr">wordcount:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;本站总字数：&#x27;</span>   <span class="comment"># 需要启用 wordcount</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;字&#x27;</span></span><br><span class="line">        <span class="attr">visitcounter:</span></span><br><span class="line">          <span class="attr">service:</span> <span class="string">busuanzi</span>  <span class="comment"># busuanzi, leancloud</span></span><br><span class="line">          <span class="attr">siteuv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站访客数：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;人&#x27;</span></span><br><span class="line">          <span class="attr">sitepv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站总访问量：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;次&#x27;</span></span><br><span class="line">        <span class="attr">lastupd:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">friendlyShow:</span> <span class="literal">true</span>    <span class="comment"># 更友好的时间显示</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;最后活动时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;日&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="统计工具">统计工具</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">analytics:</span></span><br><span class="line">  <span class="attr">busuanzi:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/tools/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure><h5 id="关闭评论">关闭评论</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&lt;i</span> <span class="string">class=&#x27;fas</span> <span class="string">fa-comments&#x27;&gt;&lt;/i&gt;</span> <span class="string">评论</span></span><br><span class="line">  <span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="comment"># valine, minivaline, disqus, gitalk, vssue, livere, isso, hashover</span></span><br></pre></td></tr></table></figure><h5 id="插件">插件</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="comment">######## Plugins to optimize the experience:</span></span><br><span class="line">  <span class="comment"># Codeblock Copy Button</span></span><br><span class="line">  <span class="attr">clipboard:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">######## Plugins for SEO:</span></span><br><span class="line">  <span class="comment"># npm i hexo-wordcount</span></span><br><span class="line">  <span class="attr">wordcount:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="页面布局模板">页面布局模板</h4><p><a href="https://volantis.js.org/page-settings/layout/">参考链接</a></p><h4 id="front-matter设置">front-matter设置</h4><p><a href="https://volantis.js.org/page-settings/front-matter/">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internet安全协议与分析Notes</title>
      <link href="2020/11/02/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/"/>
      <url>2020/11/02/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/</url>
      
        <content type="html"><![CDATA[<h2 id="IPSec">IPSec</h2><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101110459619.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101110459619.png" srcset="data:image/png;base64,666" alt="image-20201101110459619"></p><h3 id="通信保护协议">通信保护协议</h3><h4 id="AH">AH</h4><ul><li>通信提供数据源认证、<strong>抗抵赖性</strong>、数据完整性和反重播保证，但不提供机密性保护</li></ul><p><strong>AH传输模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111305325.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111305325.png" srcset="data:image/png;base64,666" alt="image-20201101111305325" style="zoom:80%;" /><ul><li>源IP地址、目的IP地址是不能修改的，否则会被检测出来，因此AH在传输模式下和NAT冲突</li></ul><p><strong>AH隧道模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111704982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111704982.png" srcset="data:image/png;base64,666" alt="image-20201101111704982" style="zoom:80%;" /><ul><li>AH验证的范围也是整个IP包，因此AH和NAT的冲突在隧道模式下也存在</li></ul><h4 id="ESP">ESP</h4><ul><li>为IP提供<strong>机密性</strong>、数据源认证、抗重播以及数据完整性等安全服务，但不提供抗抵赖性</li><li>对IP头部不进行认证，因此不会和NAT冲突</li></ul><p><strong>ESP传输模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112035985.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112035985.png" srcset="data:image/png;base64,666" alt="image-20201101112035985"  /><p><strong>ESP隧道模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112141274.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112141274.png" srcset="data:image/png;base64,666" alt="image-20201101112141274" style="zoom:80%;" /><h3 id="密钥交换管理协议IKE">密钥交换管理协议IKE</h3><ul><li>安全机制<ul><li>前向安全性：一个密钥被破解不影响其他密钥的安全性</li><li>数据验证</li><li>DH交换和密钥分发</li></ul></li></ul><h4 id="阶段1">阶段1</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113424882.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113424882.png" srcset="data:image/png;base64,666" alt="image-20201101113424882" style="zoom:80%;" /><p><strong>主模式协商</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113221833.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113221833.png" srcset="data:image/png;base64,666" alt="image-20201101113221833" style="zoom:80%;" /><p><strong>野蛮模式协商</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113300883.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113300883.png" srcset="data:image/png;base64,666" alt="image-20201101113300883" style="zoom:80%;" /> <p><strong>两种模式对比</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113329111.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113329111.png" srcset="data:image/png;base64,666" alt="image-20201101113329111" style="zoom:80%;" /><h4 id="阶段2">阶段2</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113446458.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113446458.png" srcset="data:image/png;base64,666" alt="image-20201101113446458" style="zoom:80%;" /><h2 id="SSL">SSL</h2><ul><li>安全机制<ul><li>数据机密性：对称加密</li><li>身份验证机制：基于证书的数字签名</li><li>消息完整性：MAC算法</li></ul></li><li>SSL连接和会话<ul><li>连接是点对点的、暂时的</li><li>会话是客户端和服务器之间持久的关联</li></ul></li></ul><h3 id="SSL分层结构">SSL分层结构</h3><ul><li>上层协议<ul><li>SSL握手协议：协商加密套件，交换密钥，身份认证</li><li>SSL password变化协议：修改新的加密套件和密钥</li><li>SSL警告协议：当其他过程中出现错误或发送异常时，向对方报告告警信息</li></ul></li><li>下层协议<ul><li>SSL记录协议：对上层数据分块、压缩、加密、传输</li></ul></li></ul><h4 id="SSL握手协议">SSL握手协议</h4><p><strong>阶段1：建立安全能力</strong></p><ul><li>协商加密套件</li></ul><p><strong>阶段2：服务器鉴别与密钥交换</strong></p><p><strong>阶段3：客户端鉴别与密钥交换</strong></p><ul><li>服务器和客户端分别发送自己的证书并交换密钥信息以便进行身份认证</li></ul><p><strong>阶段4：完成</strong></p><ul><li>检验双方是否获得同样的安全参数</li></ul><h4 id="SSL记录协议">SSL记录协议</h4><p>为每个SSL连接提供：</p><ul><li>机密性</li><li>完整性</li></ul><h3 id="SSL协议安全性分析">SSL协议安全性分析</h3><ul><li>鉴别机制：公开密钥机制和数字证书</li><li>加密机制：混合密码体制</li><li>完整性机制：定义了共享的、可以用来形成报文鉴别码MAC的密钥</li><li>抗重放攻击：序列号，用随机数标记握手</li></ul><h3 id="SSL脆弱性分析">SSL脆弱性分析</h3><ul><li>客户端假冒</li><li>无法提供基于UDP的应用的安全保护</li><li>不能对抗通信流量分析：SSL只对数据进行保护，数据包的IP头和TCP头暴露在外</li><li>SSL进程存储空间中的主密钥泄露</li></ul><h2 id="SET">SET</h2><h3 id="双重数字签名">双重数字签名</h3><ul><li>订单信息OI：客户给商家</li><li>支付信息PI：客户给银行</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125501014.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125501014.png" srcset="data:image/png;base64,666" alt="image-20201101125501014" style="zoom:80%;" /><h3 id="SET电子支付流程">SET电子支付流程</h3><ol><li><p>支付初始化：持卡人选择商品，下订单，选择银行卡</p><ul><li>初始请求：持卡人发送请求指定交易环境</li><li>初始应答：商家回复交易环境信息，以及证书等，并附上签名</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125955162.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125955162.png" srcset="data:image/png;base64,666" alt="image-20201101125955162" style="zoom:80%;" /></li><li><p>购物请求：</p><ul><li>持卡人检查商家初始应答发送的签名信息，确保数据完整性</li><li>持卡人发送PReq</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130235811.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130235811.png" srcset="data:image/png;base64,666" alt="image-20201101130235811" style="zoom:80%;" /></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130805188.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130805188.png" srcset="data:image/png;base64,666" alt="image-20201101130805188" style="zoom:150%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131210287.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131210287.png" srcset="data:image/png;base64,666" alt="image-20201101131210287"></p><ol start="3"><li><p>商家验证持卡人的身份和授权</p><ul><li>商家将相关信息发送给支付网关</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131339258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131339258.png" srcset="data:image/png;base64,666" alt="image-20201101131339258" style="zoom:150%;" /></li><li><p>支付网关认证</p><ul><li>网关将信息发送给银行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101132850316.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101132850316.png" srcset="data:image/png;base64,666" alt="image-20201101132850316"></p></li><li><p>收单银行处理</p><ul><li><p>确保PI和AuthReq的一致性</p></li><li><p>校验持卡人和商家对于订购行为的一致性</p></li><li><p>发送AuthRes给商家</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133223907.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133223907.png" srcset="data:image/png;base64,666" alt="image-20201101133223907"></p></li><li><p>支付完成</p><ul><li>通过捕获令牌(Capture Token)完成支付</li></ul></li><li><p>下单回复</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133759144.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133759144.png" srcset="data:image/png;base64,666" alt="image-20201101133759144"></p></li></ol><h3 id="SET核心技术">SET核心技术</h3><ul><li>公开密钥加密</li><li>数字签名</li><li>数字信封：公钥算法加密对称密钥</li><li>电子安全证书</li></ul><h2 id="PGP">PGP</h2><ul><li>提供可用于电子邮件和文件存储应用的<strong>保密</strong>与<strong>鉴别</strong>服务</li></ul><h3 id="PGP数字签名与认证">PGP数字签名与认证</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101134921229.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101134921229.png" srcset="data:image/png;base64,666" alt="image-20201101134921229"></p><h3 id="PGP保密性">PGP保密性</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135128996.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135128996.png" srcset="data:image/png;base64,666" alt="image-20201101135128996"></p><ul><li>邮件的存储转发特性不适合用DH算法交换密钥</li><li>使用公钥算法对每个消息生成<strong>一次性</strong>会话密钥</li></ul><h3 id="PGP保密和认证结合">PGP保密和认证结合</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135448177.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135448177.png" srcset="data:image/png;base64,666" alt="image-20201101135448177"></p><h3 id="PGP压缩">PGP压缩</h3><ul><li>使用ZIP算法</li><li>先签名后压缩<ul><li>只需要存储原始报文和签名</li><li>易于更换压缩算法</li></ul></li></ul><h3 id="PGP密钥环">PGP密钥环</h3><ul><li>每个结点都有存储密钥的结构<ul><li>私钥环：存储该结点拥有的公/私钥对</li><li>公钥环：存储该结点拥有的其他所有用户的公钥</li></ul></li></ul><h3 id="PGP信任网">PGP信任网</h3><ul><li>PGP中没有认证机构，而是由用户互相对对方的公钥进行数字签名</li><li>确认是否信任<ul><li>通过自己的数字签名</li><li>通过自己完全信任的人的数字签名</li><li>通过自己有限信任的多个人的数字签名</li></ul></li></ul><h2 id="Kerberos">Kerberos</h2><ul><li>采用传统加密算法(非公钥算法)</li></ul><h3 id="基本概念">基本概念</h3><ul><li>Principle：安全个体，有名字和口令</li><li>KDC：网络服务，提供ticket和临时会话密钥</li><li>Ticket：客户用来向服务器证明身份的票据<ul><li>其大多数信息被服务器的密钥加密</li></ul></li><li>Authenticator：包含最近产生的信息的记录，需要用到会话密钥</li><li>Credentials：一个Ticket加上秘密的会话密钥</li><li>AS：Authentication Server<ul><li>通过long-term key认证用户</li><li>授予用户ticket granting ticket和short-term key</li><li>认证服务</li></ul></li><li>TGS：Ticket Granting Server<ul><li>通过ticket granting ticket和short-term key认证用户</li><li>发放service granting ticket给用户以访问其他服务器</li><li>授权和访问控制服务</li></ul></li></ul><h3 id="Kerberos工作流程">Kerberos工作流程</h3><h4 id="1-认证服务交换：获得票据许可票据-ticket-granting-ticket">1. 认证服务交换：获得票据许可票据(ticket granting ticket)</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101144837036.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101144837036.png" srcset="data:image/png;base64,666" alt="image-20201101144837036"></p><h4 id="2-票据许可服务交换：获得服务许可票据-service-granting-ticket">2. 票据许可服务交换：获得服务许可票据(service granting ticket)</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145139960.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145139960.png" srcset="data:image/png;base64,666" alt="image-20201101145139960"></p><h4 id="3-客户-服务器认证交换：获得服务image-20201101145321623">3. 客户/服务器认证交换：获得服务<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145321623.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145321623.png" srcset="data:image/png;base64,666" alt="image-20201101145321623"></h4><h3 id="Kerberos跨域认证">Kerberos跨域认证</h3><ol><li>获得本地TGS访问权</li><li>请求一张远程TGS的票据许可票据</li><li>向远程TGS请求其域内的服务</li></ol><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145413287.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145413287.png" srcset="data:image/png;base64,666" alt="image-20201101145413287" style="zoom: 50%;" /><h3 id="Kerberos优缺点">Kerberos优缺点</h3><h4 id="优点">优点</h4><ul><li>密码不在网上传输，不易被窃听，难以猜测</li><li>单点登录机制，只用输入一次口令</li><li>票据被盗之后难以使用，因为需要配合认证头来使用</li></ul><h4 id="缺点">缺点</h4><ul><li>缺乏撤销机制</li><li>密钥管理复杂</li><li>跨域认证复杂</li><li>需要始终同步</li><li>需要始终在线的AS和TGS</li></ul><h2 id="BAN">BAN</h2><h3 id="所用符号">所用符号</h3><ul><li><p>A, B, S：泛指参与协议的主体</p></li><li><p>P, Q, R：主体变量</p></li><li><p>X, Y: 公式变量</p></li><li><p>K: 密钥变量</p></li><li><p>K<sub>ab</sub>, K<sub>bs</sub>, K<sub>as</sub>: 主体之间的共享密钥</p></li><li><p>K<sub>a</sub>, K<sub>b</sub>, K<sub>s</sub>: 主体的公钥</p></li><li><p>K<sub>a</sub><sup>-1</sup>, K<sub>b</sub><sup>-1</sup>, K<sub>s</sub><sup>-1</sup>: 主体的私钥</p></li><li><p>N<sub>a</sub>, N<sub>b</sub>, N<sub>s</sub>：主体各自生成的用于确认新鲜性的随机数Nonce</p></li><li><p>{X}<sub>k</sub>：用密钥k加密X的结果</p></li><li><p>&lt;X&gt;Y：X和Y的组合</p></li><li><p>P-&gt;Q:(X)：P发送消息X给Q</p></li><li><p>bel(P,Q)：主体P相信X</p></li><li><p>sees(P,X)：P接收到X</p></li><li><p>said(P,X)：P发送X</p></li><li><p>cont(P,X)：P拥有对X正确与否的判决权</p></li><li><p>fresh(X)：X是新鲜的</p></li><li><p>skey(P,K,Q)：K是P,Q的共享密钥</p></li><li><p>goodkey(P,K,Q)：K是P,Q共享的良好密钥</p></li><li><p>pubkey(P,K)：K是P的公钥</p></li><li><p>secret(P,X,Q)：X是P和Q的共享秘密</p></li></ul><h3 id="推理规则">推理规则</h3><h4 id="消息意义规则">消息意义规则</h4><p>从加密消息所使用密钥以及消息中包含的秘密来推断消息发送者的身份</p><ul><li>例如对于共享密钥：bel(P,goodkey(P,K,Q)) and sees(P,{X}<sub>k</sub>) =&gt; bel(P,said(Q,X))</li></ul><h4 id="随机数验证规则">随机数验证规则</h4><p>如果P相信X是新鲜的，并且P相信Q曾经发送过X，那么P相信Q相信X</p><ul><li>bel(P,fresh(X)) and bel(P,said(Q,X)) =&gt; bel(P,bel(Q,X))</li></ul><h4 id="仲裁规则">仲裁规则</h4><p>如果P相信Q对X是有仲裁权的，并且P相信Q相信X，那么P相信X</p><ul><li>bel(P,cont(Q,X)) and bel(P,bel(Q,X)) =&gt; bel(P,X)</li></ul><h4 id="信仰规则">信仰规则</h4><ul><li><p>bel(P,X) and bel(P,Y) =&gt; bel(P,(X,Y))</p></li><li><p>bel(P,(X,Y)) =&gt; bel(P,X) or bel(P,Y)</p></li><li><p>bel(P,bel(Q,(X,Y))) =&gt; bel(P,bel(Q,X)) or bel(P,bel(Q,Y))</p></li></ul><h4 id="接收规则">接收规则</h4><ul><li>如果P接收到一个消息，那么P也接收到这个消息的一部分<ul><li>sees(P,(X,Y)) =&gt; sees(P,X)</li><li>sees(P,&lt;X&gt;Y) =&gt; sees(P,X)</li></ul></li><li>如果P收到加密消息，那么以下三种情况P可以读出消息原文<ul><li>bel(P,goodkey(P,K,Q)) and sees(P,{X}<sub>K</sub>) =&gt; sees(P,X)</li><li>bel(P,pubkey(P,K)) and sees(P,{X}<sub>K</sub>) =&gt; sees(P,X)</li><li>bel(P,pubkey(Q,K)) and sees(P,{X}<sub>K</sub><sup>-1</sup>) =&gt; sees(P,X)</li></ul></li></ul><h4 id="新鲜规则">新鲜规则</h4><p>如果消息的一部分是新鲜的，则整个消息是新鲜的</p><ul><li>bel(P,fresh(X)) =&gt; bel(P,fresh(X,Y))</li></ul><h4 id="传递规则">传递规则</h4><p>如果P相信Q曾经发送过整个消息，那么P相信Q曾经发送过消息的部分</p><ul><li>bel(P,said(Q,(X,Y))) =&gt; bel(P,said(Q,X))</li></ul>]]></content>
      
      
      <categories>
          
          <category> Course Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPSec </tag>
            
            <tag> SSL </tag>
            
            <tag> SET </tag>
            
            <tag> Kerberos </tag>
            
            <tag> PGP </tag>
            
            <tag> BAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/01/hello-world/"/>
      <url>2020/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git - Learn</title>
      <link href="2020/10/13/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/10/13/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制">版本控制</h2><h3 id="1-本地版本控制">1. 本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/1-1602592677643.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/1-1602592677643.webp" srcset="data:image/png;base64,666" alt="img"></p><h3 id="2-集中版本控制">2. 集中版本控制</h3><p>所有的版本数据都存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203819662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203819662.png" srcset="data:image/png;base64,666" alt="image-20201013203819662"></p><h3 id="3-分布式版本控制">3. 分布式版本控制</h3><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203824414.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203824414.png" srcset="data:image/png;base64,666" alt="image-20201013203824414"></p><h3 id="Git与SVN的主要区别">Git与SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h2 id="Git环境配置">Git环境配置</h2><h3 id="Git配置">Git配置</h3><p><strong>查看配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p><strong>查看不同级别的配置文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> Git\etc\gitconfig：Git安装目录下的gitconfig  </span></span><br><span class="line">　　</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> C:\Users\Administrator\.gitconfig    只适用于当前登录用户的配置 </span></span><br></pre></td></tr></table></figure><p><strong>设置用户名与邮箱（用户标识，必要）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;&lt;名称&gt;&quot;  # 名称</span><br><span class="line">git config --global user.email &lt;邮箱&gt;   # 邮箱</span><br></pre></td></tr></table></figure><h2 id="Git基本理论">Git基本理论</h2><h3 id="三个区域">三个区域</h3><p>Git本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/4.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/4.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/5.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/5.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h3 id="工作流程">工作流程</h3><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/6.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/6.png" srcset="data:image/png;base64,666" alt="img"></p><h2 id="Git项目搭建">Git项目搭建</h2><h3 id="创建工作目录与常用指令">创建工作目录与常用指令</h3><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/7.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/7.png" srcset="data:image/png;base64,666" alt="img"></p><h3 id="本地仓库搭建">本地仓库搭建</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p><strong>创建权限仓库</strong></p><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><p><strong>克隆远程仓库</strong></p><p>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Git文件操作">Git文件操作</h2><h3 id="文件的四种状态">文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h3 id="查看文件状态">查看文件状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看指定文件状态</span></span><br><span class="line">git status &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .                  添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br></pre></td></tr></table></figure><h3 id="忽略文件">忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     # 但lib.txt除外</span><br><span class="line">/temp        # 仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       # 忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h2 id="Git分支">Git分支</h2><p>git分支中常用指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker - Learn</title>
      <link href="2020/10/12/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/10/12/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="底层原理">底层原理</h2><p><strong>Docker是怎么工作的？</strong></p><p>Docker是一个C-S结构的系统，Docker的守护进程运行在服务主机上，通过Socket从客户端访问。</p><p>DockerServer接收到DockerClient的指令就会执行这个命令。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120921063.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120921063.png" srcset="data:image/png;base64,666" alt="image-20201013120921063"></p><p><strong>Docker为什么比VM快？</strong></p><ol><li>Docker有着比虚拟机更少的抽象层</li><li>Docker利用的是宿主机的内核，VM需要有Guest OS。所以新建一个容器的时候，docker不需要像VM一样重新加载一个操作系统内核，避免引导</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120834703.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120834703.png" srcset="data:image/png;base64,666" alt="image-20201013120834703"></p><h2 id="Docker常用命令">Docker常用命令</h2><h3 id="docker的默认工作路径">docker的默认工作路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker</span><br></pre></td></tr></table></figure><h3 id="帮助命令">帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version# 显示docker的版本信息</span><br><span class="line">docker info# 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker &lt;命令&gt; --help   # 查看帮助命令</span><br></pre></td></tr></table></figure><h3 id="镜像命令">镜像命令</h3><p><strong>docker images</strong> 查看所有本地的主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        9 months ago        13.3kB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释</span></span><br><span class="line">REPOSITORY镜像的仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的ID</span><br><span class="line">CREATED镜像的创建时间</span><br><span class="line">SIZE 镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令可选项</span></span><br><span class="line">-a, --all列出所有镜像</span><br><span class="line">-q, --quiet只显示镜像的id</span><br></pre></td></tr></table></figure><p><strong>docker search <image></strong> 搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search mysql</span><br><span class="line">NAME       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql      MySQL is a widely used, open-source relation…   10046     [OK]                </span><br><span class="line">mariadb    MariaDB is a community-developed fork of MyS…   3680      [OK]                </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项，通过收藏数过滤</span></span><br><span class="line">--filter=STAR=3000搜索出来的镜像是STARS大于3000的</span><br></pre></td></tr></table></figure><p><strong>docker pull <image>[:tag]</strong> 下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest# 如果不写tag，默认是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Pull complete # 分层下载，docker镜像的核心 联合文件系统</span><br><span class="line">f3cebc0b4691: Pull complete </span><br><span class="line">1862755a0b37: Pull complete </span><br><span class="line">489b44f3dbb4: Pull complete </span><br><span class="line">690874f836db: Pull complete </span><br><span class="line">baa8be383ffb: Pull complete </span><br><span class="line">55356608b4ac: Pull complete </span><br><span class="line">dd35ceccb6eb: Pull complete </span><br><span class="line">429b35712b19: Pull complete </span><br><span class="line">162d8291095c: Pull complete </span><br><span class="line">5e500ef7181b: Pull complete </span><br><span class="line">af7528e958b6: Pull complete </span><br><span class="line">Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest# 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载指定版本，共用的层会复用，不用重复下载</span></span><br><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Already exists </span><br><span class="line">f3cebc0b4691: Already exists </span><br><span class="line">1862755a0b37: Already exists </span><br><span class="line">489b44f3dbb4: Already exists </span><br><span class="line">690874f836db: Already exists </span><br><span class="line">baa8be383ffb: Already exists </span><br><span class="line">55356608b4ac: Already exists </span><br><span class="line">277d8f888368: Pull complete </span><br><span class="line">21f2da6feb67: Pull complete </span><br><span class="line">2c98f818bcb9: Pull complete </span><br><span class="line">031b0a770162: Pull complete </span><br><span class="line">Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>docker rmi</strong> 删除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;镜像id&gt; [&lt;镜像id&gt; &lt;镜像id&gt;]# 删除指定的镜像</span><br><span class="line">docker rmi -f $(docker images -aq)# 删除所有镜像</span><br></pre></td></tr></table></figure><h3 id="容器命令">容器命令</h3><p>**注：**有了镜像才可以创建容器，以centos镜像为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>docker run [可选参数] <image></strong>  新建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name=&quot;&lt;Name&gt;&quot;容器名字，自定义，用来区分容器</span><br><span class="line">-d 后台方式运行</span><br><span class="line">-it使用交互方式运行，进入容器查看内容</span><br><span class="line">-p指定容器的端口，配置端口转发</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 主机端口:容器端口（常用）</span><br><span class="line">-p 容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并进入容器</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器并关闭容器</span></span><br><span class="line">[root@bebbdced119e /]# exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器但不关闭容器</span></span><br><span class="line">Ctrl + p + q</span><br></pre></td></tr></table></figure><p><strong>docker ps [可选参数]</strong> 列出运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">-a列出所有运行过的容器</span><br><span class="line">-n=&lt;n&gt;列出最近创建的n个容器</span><br><span class="line">-q只显示容器编号</span><br></pre></td></tr></table></figure><p>**docker rm 删除容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器id&gt;删除指定容器，不能删除正在运行的容器，若要强制删除加参数-f</span><br><span class="line">docker rm -f $(docker ps -aq)  删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  删除所有的容器</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;容器id&gt;启动容器</span><br><span class="line">docker restart &lt;容器id&gt;重启容器</span><br><span class="line">docker stop &lt;容器id&gt;停止容器</span><br><span class="line">docker kill &lt;容器id&gt;强制停止容器</span><br></pre></td></tr></table></figure><h3 id="常用其他命令">常用其他命令</h3><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题：docker ps发现centos停止了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -ft &lt;容器id&gt;# 查看所有日志</span><br><span class="line">docker logs -ft --tail &lt;n&gt; &lt;容器id&gt;# 查看最新的n条日志</span><br></pre></td></tr></table></figure><p>**查看容器中的进程信息 **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器id&gt;</span><br></pre></td></tr></table></figure><p><strong>查看容器的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器id&gt;</span><br></pre></td></tr></table></figure><p><strong>进入正在后台运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法1</span></span><br><span class="line">docker exec -it &lt;容器id&gt; &lt;bashshell&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法2</span></span><br><span class="line">docker attach &lt;容器id&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><p><strong>从容器内拷贝文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;容器id&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux - Learn</title>
      <link href="2020/09/11/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/09/11/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="了解系统信息">了解系统信息</h2><h3 id="硬盘大小">硬盘大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">&#x2F;dev&#x2F;sda 操作系统中第一块硬盘的名称以及所在路径</span><br><span class="line">Linux操作系统一切皆文件 （文件名） sd (硬盘类型) a（第一块）</span><br></pre></td></tr></table></figure><h3 id="内存大小">内存大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure><h3 id="cpu大小">cpu大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><h3 id="收集系统信息">收集系统信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="Linux文件系统">Linux文件系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin    普通用户和管理员都可以执行的命令</span><br><span class="line">&#x2F;sbin   只有管理员才能执行的命令 eg.关机重启</span><br><span class="line">&#x2F;boot   引导 主引导目录 独立的分区 启动菜单 内核</span><br><span class="line">&#x2F;dev    device 设备文件存放目录</span><br><span class="line">&#x2F;etc    配置文件存放目录</span><br><span class="line">&#x2F;home   普通用户的家目录</span><br><span class="line">&#x2F;root   管理员的家</span><br><span class="line">&#x2F;media  光驱的挂载目录</span><br><span class="line">&#x2F;mnt    临时设备的挂载目录</span><br><span class="line">&#x2F;proc   里面的数据都在内存中，进程的所在目录</span><br><span class="line">&#x2F;tmp    临时文件存放目录</span><br><span class="line">&#x2F;usr    第三方软件的安装目录</span><br><span class="line">&#x2F;var    常变文件存放目录 eg.日志文件、邮件文件</span><br></pre></td></tr></table></figure><h3 id="挂载光驱">挂载光驱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弹出光驱：umount &#x2F;dev&#x2F;cdrom</span><br><span class="line">挂载光驱：mount &#x2F;dev&#x2F;cdrom &#x2F;media</span><br></pre></td></tr></table></figure><h2 id="Linux文件类型的显示颜色">Linux文件类型的显示颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">蓝色 目录</span><br><span class="line">黑色 普通文件</span><br><span class="line">浅蓝色 符号链接（快捷方式）</span><br><span class="line">黑底黄字 设备文件 硬盘 sda</span><br><span class="line">红色 压缩包</span><br><span class="line">绿色 带有执行权限的文件</span><br><span class="line">紫色 图片 模块文件</span><br></pre></td></tr></table></figure><h2 id="压缩和解压缩">压缩和解压缩</h2><h3 id="文件压缩和解压缩">文件压缩和解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip bigfile</span><br><span class="line">gunzip bigfile.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 bigfile</span><br><span class="line">bunzip2 bigfile.bz2</span><br></pre></td></tr></table></figure><h3 id="目录-文件夹-打包压缩">目录(文件夹)打包压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf &#x2F;tmp&#x2F;allfile.tar.gz &#x2F;tmp&#x2F;allfile</span><br><span class="line">tar -jcf &#x2F;tmp&#x2F;allfile.tar.bz2 &#x2F;tmp&#x2F;allfile</span><br></pre></td></tr></table></figure><h3 id="目录-文件夹-解压缩并解包">目录(文件夹)解压缩并解包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf &#x2F;tmp&#x2F;allfile.tar.gz -C &#x2F;tmp</span><br><span class="line">tar -jxf &#x2F;tmp&#x2F;allfile.tar.bz2 -C &#x2F;tmp</span><br><span class="line">-C 指定解包位置</span><br></pre></td></tr></table></figure><h2 id="vim">vim</h2><h3 id="模式切换">模式切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令模式 -&gt; 输入模式：i</span><br><span class="line">输入模式 -&gt; 命令模式：Esc</span><br><span class="line">命令模式 -&gt; 末行模式：:</span><br></pre></td></tr></table></figure><h3 id="末行模式命令">末行模式命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:wq   保存并退出</span><br><span class="line">:q!    不保存退出</span><br><span class="line">:set nu   显示行号</span><br><span class="line">:% s&#x2F;old&#x2F;new&#x2F;g   每一行中的old替换成new</span><br><span class="line">:50,56 d     删除50-56行的数据</span><br></pre></td></tr></table></figure><h3 id="命令模式命令">命令模式命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0       光标移动到当前行首</span><br><span class="line">$       光标移动到当前行末</span><br><span class="line">yy      复制当前行</span><br><span class="line">2yy     复制当前行以及后一行，其他数字以此类推</span><br><span class="line">p       粘贴到当前行下一行</span><br><span class="line">dd      删除当前行</span><br><span class="line">gg      回到第一行</span><br><span class="line">G       回到最后一行</span><br></pre></td></tr></table></figure><h2 id="Linux软件安装——封装后的软件包">Linux软件安装——封装后的软件包</h2><h3 id="后缀名">后缀名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm     red hat系统</span><br><span class="line">deb     debian系统</span><br><span class="line">源码包  不考虑系统版本</span><br></pre></td></tr></table></figure><h3 id="有关软件包安装的命令">有关软件包安装的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa             列出所有已经安装的rpm包</span><br><span class="line">查询特定的rpm包使用管道符：rpm -qa | grep &quot;tree&quot;</span><br><span class="line">rpm -qpi 软件名     确认该软件的作用</span><br><span class="line">rpm -qpl 软件名     确认该软件的安装路径(无法修改)</span><br><span class="line">rpm -ivh 软件名     安装软件</span><br><span class="line">rpm -e 软件名       软件卸载</span><br></pre></td></tr></table></figure><h2 id="Linux软件安装——yum">Linux软件安装——yum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install 软件名</span><br><span class="line">yum remove 软件名</span><br></pre></td></tr></table></figure><h2 id="用户和组">用户和组</h2><h3 id="三个重要文件">三个重要文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;passwd     保存操作系统中所有的用户信息</span><br><span class="line">root : x : 0 : 0 : root : &#x2F;root : &#x2F;bin&#x2F;bash</span><br><span class="line">每一条目共7个字段，用冒号隔开</span><br><span class="line">字段1：用户名</span><br><span class="line">字段2：密码占位符</span><br><span class="line">字段3：用户的UID</span><br><span class="line">    0 表示超级用户</span><br><span class="line">    500-60000 普通用户</span><br><span class="line">    1-499 程序用户</span><br><span class="line">字段4：基本组的GID，先有组才有用户</span><br><span class="line">字段5：用户信息记录字段</span><br><span class="line">字段6：用户的家目录</span><br><span class="line">字段7：用户登录系统后使用的命令解释器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadow     保存了用户密码信息</span><br><span class="line">root : $6$ME9wjPHAid5ds$PO&#x2F;GlBVEt1 : 18325 : 0 : 99999 : 7 :::</span><br><span class="line">字段1：用户名</span><br><span class="line">*字段2：用户的密码加盐并通过散列算法后的字符串（sha）</span><br><span class="line">字段3：距离1970&#x2F;1&#x2F;1密码最近一次修改的时间</span><br><span class="line">字段4：密码的最短有效期</span><br><span class="line">*字段5：密码的最长有效期（建议时间 90）</span><br><span class="line">字段6：密码过期前7天警告</span><br><span class="line">字段7：密码的不活跃期</span><br><span class="line">字段8：用户的失效时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group      记录了系统中所有组的信息</span><br></pre></td></tr></table></figure><h3 id="建立和调整用户属性">建立和调整用户属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1、建立一个名为class1的组ID为1000，class2的组ID为2000</span><br><span class="line">建立：</span><br><span class="line">groupadd class1</span><br><span class="line">groupadd -g 2000 class2</span><br><span class="line">修改gid：</span><br><span class="line">groupmod -g 1000 class1</span><br><span class="line">查看：</span><br><span class="line">vim &#x2F;etc&#x2F;group</span><br><span class="line"></span><br><span class="line">2、建立tom用户要求其基本组是class1,附加组为class2，tom用户的UID为600</span><br><span class="line">建立：</span><br><span class="line">useradd -g class1 -G class2 -u 600 tom</span><br><span class="line">修改：</span><br><span class="line">usermod</span><br><span class="line">查看：</span><br><span class="line">id tom</span><br><span class="line"></span><br><span class="line">3、建立一个程序用户UID为250,用户名为testuser，没有家目录（程序用户没有登录系统权限）</span><br><span class="line">useradd -u 250 -M -s &#x2F;sbin&#x2F;nologin testuser</span><br><span class="line">-M：没有家目录</span><br><span class="line">-s &#x2F;sbin&#x2F;nologin：不能登录</span><br><span class="line"></span><br><span class="line">4、为tom用户设定密码为123，并设定密码最长有效期为90天，将用户密码进行锁定使其无法登录</span><br><span class="line">passwd tom        设定密码</span><br><span class="line">chage -M 90 tom   设定密码最长有效期</span><br><span class="line">或者修改配置文件&#x2F;etc&#x2F;login.defs</span><br><span class="line">passwd -l tom     锁定</span><br><span class="line">passwd -u tom     解锁</span><br><span class="line">查看：</span><br><span class="line">passwd -S tom</span><br><span class="line">vim &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br><span class="line">5、删除tom用户和testuser用户，删除class1组和class2组</span><br><span class="line">userdel -r tom     （-r  连同用户的家目录一起删除）</span><br><span class="line">userdel -r testuser</span><br><span class="line">groupdel class1</span><br><span class="line">groupdel class1</span><br></pre></td></tr></table></figure><h2 id="文件目录权限">文件目录权限</h2><h3 id="列出文件信息">列出文件信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -a       列出所有文件，包括隐藏文件</span><br><span class="line">ls -l(ll)   列出文件详细信息</span><br><span class="line">文件：-rw-rw-r--.(权限) 1(链接数) centos(所属用户) centos(所属组)   12(文件大小，字节) Sep 12 10:07(最后修改时间) test.txt</span><br><span class="line">目录：drwxrwxr-x.(权限) 2(子目录数) centos(所属用户) centos(所属组)    6 Sep 12 10:06(最后修改时间) testdir</span><br><span class="line">ls -ld      列出某一目录的详细信息</span><br><span class="line">ls -h       用人能看懂的方式显示文件大小</span><br></pre></td></tr></table></figure><h3 id="权限详细">权限详细</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- rw- rw- r--.</span><br><span class="line">d rwx rwx r-x.</span><br><span class="line">共4个字段</span><br><span class="line">字段1：文件类型</span><br><span class="line">    -普通文件</span><br><span class="line">    d目录文件</span><br><span class="line">    l符号链接文件</span><br><span class="line">    b块设备</span><br><span class="line">字段2：文件所属者的权限</span><br><span class="line">            r               w           x</span><br><span class="line">    文件    读取            写入        可执行</span><br><span class="line">    目录    查看目录文件    增删文件    进入目录</span><br><span class="line">字段3：文件所属组的权限</span><br><span class="line">字段4：其他用户的权限</span><br></pre></td></tr></table></figure><h3 id="赋权限">赋权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：chmod 对象 算术运算符 权限 文件</span><br><span class="line">    对象：u-所属者 g-所属组 o-其他用户 a-所有用户</span><br><span class="line">    算术运算符：- + &#x3D;</span><br><span class="line">    权限：r w x</span><br><span class="line">方法2：chmod 777 文件</span><br></pre></td></tr></table></figure><h3 id="改变文件的所属者和所属组">改变文件的所属者和所属组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown 用户 文件</span><br><span class="line">chgrp 组 文件</span><br></pre></td></tr></table></figure><h3 id="粘滞位-sgid-suid权限">粘滞位 sgid suid权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">粘滞位针对目录赋权，目录中创建的文件只有建立者可以删除</span><br><span class="line">    chmod o+t 文件</span><br><span class="line">    chmod o-t 文件</span><br><span class="line">sgid 针对目录建立的权限，在该目录中建立的文件所属组继承父目录的所属组</span><br><span class="line">    chmod g+s 文件</span><br><span class="line">    chmod g-s 文件</span><br><span class="line">suid 对可执行文件建立。谁运行该文件，就具有该文件所属者的权限</span><br><span class="line">    chmod u+s 文件</span><br><span class="line">    chmod u-s 文件</span><br><span class="line">    eg. chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim</span><br></pre></td></tr></table></figure><h3 id="查找有异常权限的文件">查找有异常权限的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查找有suid权限的可执行文件</span><br><span class="line">find &#x2F;usr&#x2F;bin -perm 4755</span><br><span class="line">其中权限的第一个4表示suid权限，如果是2则表示sgid权限，如果是1则表示粘滞位</span><br><span class="line">权限的多一位也可以用于赋权限</span><br></pre></td></tr></table></figure><h3 id="不再允许添加新用户">不再允许添加新用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建用户时会更改的文件</span><br><span class="line">    &#x2F;etc&#x2F;group</span><br><span class="line">    &#x2F;etc&#x2F;passwd</span><br><span class="line">    &#x2F;etc&#x2F;shadow</span><br><span class="line">    home&#x2F;xxxx</span><br><span class="line">锁定文件从而不能添加新用户</span><br><span class="line">    chattr +i &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow</span><br><span class="line">查看文件是否被锁定</span><br><span class="line">    lsattr &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h3 id="umask">umask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般目录的最高权限是777</span><br><span class="line">一般文件的最高权限是666</span><br><span class="line">用户创建的文件通过umask来确定其权限</span><br><span class="line">root的umask是0022(第一位是特殊权限)</span><br><span class="line">普通用户并且uid&#x3D;sid的umask是0002</span><br><span class="line"></span><br><span class="line">umask的设置在&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc两个文件中</span><br></pre></td></tr></table></figure><h2 id="网络地址配置">网络地址配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 确认网卡信息：ip addr &#x2F; ifconfig</span><br><span class="line">2. 关闭NetworkManager服务：systemctl stop NetworkManager</span><br><span class="line">3. 网卡启用桥接模式，并配置网络地址：</span><br><span class="line">    ip addr add IP&#x2F;掩码长度 dev ens33</span><br><span class="line">4. 设置网关：</span><br><span class="line">    ip route add default via IP dev ens33</span><br><span class="line">5. 配置DNS：</span><br><span class="line">    vim &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">    nameserver 202.120.2.101</span><br><span class="line">6. 关闭防火墙：</span><br><span class="line">    systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h2 id="日志文件">日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">位置：&#x2F;var&#x2F;log</span><br><span class="line">日志记录的配置文件：&#x2F;etc&#x2F;rsyslog.conf</span><br><span class="line">    其中配置方式为 日志类型.日志级别 ，如authpriv.*表示记录所有级别的登录日志</span><br><span class="line">日志分类：</span><br><span class="line">    系统日志    &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">    登录日志    &#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line">    程序日志</span><br><span class="line">日志记录的日志级别：</span><br><span class="line">debug,  info,  notice, warning(warn), err(error), crit, alert, emerg(panic)</span><br><span class="line">最不严重  -&gt; 最严重</span><br><span class="line"></span><br><span class="line">配置日志备份服务器：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43252204&#x2F;article&#x2F;details&#x2F;105518163</span><br></pre></td></tr></table></figure><h2 id="WEB服务-apache">WEB服务-apache</h2><h3 id="开启并使用apache">开启并使用apache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 启动服务</span><br><span class="line">    service httpd start</span><br><span class="line">2. 验证服务是否开启</span><br><span class="line">    ss -antpl | grep 80</span><br><span class="line">3. 主页建立</span><br><span class="line">    vim &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><h3 id="httpd配置文件">httpd配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">默认会开启共享目录功能，这样会导致别人可以远程下载&#x2F;var&#x2F;www&#x2F;html中的内容，建议将其关闭：</span><br><span class="line">    Options Indexes FollowSymLinks改为Options FollowSymLinks</span><br><span class="line">限制访问，将Require all granted修改为以下语句：</span><br><span class="line">    &lt;RequireAll&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    Require not ip 192.168.1.10 192.168.2.0&#x2F;24</span><br><span class="line">        &#x2F;&#x2F;拒绝192.168.1.10和192.168.2.0网段客户机访问</span><br><span class="line">    &lt;&#x2F;RequireAll&gt;</span><br><span class="line">用户授权限制，只有通过指定的用户名密码才能访问网页：</span><br><span class="line">    设置用户名密码：htpasswd -c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser test   (-c表示新建文件)</span><br><span class="line">    设置该文件只有apache用户可读：</span><br><span class="line">        chown apache httpuser</span><br><span class="line">        chmod 400 httpuser</span><br><span class="line">    修改配置文件：</span><br><span class="line">        Authtype basic</span><br><span class="line">        Authname &quot;Input username and password&quot; &#x2F;&#x2F; 提示信息</span><br><span class="line">        Authuserfile &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser</span><br><span class="line">        Require valid-user</span><br></pre></td></tr></table></figure><h2 id="lamp平台搭建">lamp平台搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 安装apache</span><br><span class="line">2. 安装mysql</span><br><span class="line">    yum install mysql-server    &#x2F;&#x2F; 安装</span><br><span class="line">    service mysqld start        &#x2F;&#x2F; 启动</span><br><span class="line">    mysqladmin -u root -p password &quot;123.sck&quot;     &#x2F;&#x2F; 设置root密码</span><br><span class="line">    mysql -u root -p        &#x2F;&#x2F; 登录数据库</span><br><span class="line">3. 安装php</span><br><span class="line">    yum install php</span><br><span class="line">    yum install php-mysqlnd</span><br><span class="line">    yum install php-mbstring</span><br><span class="line">4. 配置php配置文件</span><br><span class="line">    vim &#x2F;etc&#x2F;php.ini</span><br><span class="line">    将short_open_tag从Off改为On</span><br><span class="line">5. 在&#x2F;var&#x2F;www&#x2F;html新建一个php文件</span><br></pre></td></tr></table></figure><h2 id="iptables防火墙">iptables防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四个表：</span><br><span class="line">    raw</span><br><span class="line">    mangle</span><br><span class="line">    nat     网络地址转换</span><br><span class="line">    filter  过滤</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
