<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT 6.824 Distributed Systems 学习笔记</title>
      <link href="2022/04/28/learning-notes/mit-6.824/"/>
      <url>2022/04/28/learning-notes/mit-6.824/</url>
      
        <content type="html"><![CDATA[<h2 id="Paper-Reading">Paper Reading</h2><h3 id="MapReduce">MapReduce</h3><p>一个编程模型，用于大规模并行计算，以及采用re-execution进行容错处理</p><ul><li>$Map$：输入键值对，输出一系列中间键值对，并将相同的中间键排在一起传递到 $Reduce$ 函数</li><li>$Reduce$：输入中间键 $I$ 以及其对应的一系列中间值，对其进行合并，最后输出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220411144645840.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220411144645840.png" srcset="data:image/png;base64,666" alt="image-20220411144645840"></p><h4 id="实现">实现</h4><h5 id="Master数据结构">Master数据结构</h5><p>Master存储：</p><ul><li>每个map和reduce任务的状态（idle, in-progress, completed）</li><li>各个worker的标识</li><li>每个已完成的map任务的R个中间文件的位置和大小</li></ul><h5 id="容错">容错</h5><ul><li>Worker Failure</li><li>Master Failure</li><li>Semantics in the Presence of Failures</li></ul><h5 id="本地优化">本地优化</h5><ul><li>输入文件被划分为64MB的块，每个块会冗余存放在多个机器上</li><li>Master会将map任务尽可能分配到一个保存了对应副本的机器或其周围的机器上</li></ul><h5 id="任务粒度">任务粒度</h5><p>M和R应该远大于worker机器的数量</p><h5 id="备份任务">备份任务</h5><p>为了解决单点效率瓶颈，在MapReduce任务快完成时，master将剩余in-progress机器仍在执行的任务作为备份任务分配给其他机器</p><h4 id="改进">改进</h4><ul><li>Partitioning Function（如何分配R个输出文件）</li><li>Ordering Guarantees</li><li>Combiner Function（对重复的中间结果合并）</li><li>Input and Output Types（自定义类型）</li><li>Side-effects</li><li>Skipping Bad Records（用户程序对特定的数据可能有bug）</li><li>Local Execution（方便Debug）</li><li>Status Information（日志）</li><li>Counters</li></ul><h3 id="Google-File-System">Google File System</h3><h4 id="Overview">Overview</h4><h5 id="假设">假设</h5><ul><li>系统组件经常故障，因此需要持续监控，错误检测，容错处理，自动恢复</li><li>存储大量文件，有几百万100MB或以上的文件，多GB的文件很常见，需要高效管理，小文件不需要优化</li><li>存在两种读：大规模连续读和小规模随机读</li><li>有很多大规模连续写（添加内容），也需要支持小规模随机写但不要求其性能</li><li>高效处理多用户同时向同一个文件添加内容，保证原子性并减少开销</li><li>高持续带宽比低延迟更重要</li></ul><h5 id="架构">架构</h5><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413140415697.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413140415697.png" srcset="data:image/png;base64,666" alt="image-20220413140415697"></p><ul><li>单个Master：必须最小化其参与的读和写，防止成为瓶颈</li><li>chunk大小：选择较大的64MB<ul><li>优势：<ol><li>减少client与master的交互</li><li>client更有可能在同一个chunk上进行大量操作，减少网络开销</li><li>减少master上存储的metadata</li></ol></li><li>劣势：若很多client访问同一个文件，则这个chunk会成为hot spot</li></ul></li><li>Metadata：存放在master的内存中（前两个还会记录在operation log中进行持久化存储）<ul><li>文件和chunk的命名空间</li><li>文件到chunk的映射</li><li>各个chunk副本的位置（通过启动时的轮询和之后的心跳消息获取）</li></ul></li><li>一致性模型：保证文件命名空间的改变是原子性的</li></ul><h4 id="系统交互">系统交互</h4><p>尽可能减少master的参与</p><p><strong>Leases</strong></p><p>为了保证各副本的一致性改变，master通过将chunk lease给其中一个副本使其成为primary，然后primary选择一个改变的顺序，并同步给其他副本</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413141855758.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413141855758.png" srcset="data:image/png;base64,666" alt="image-20220413141855758" style="zoom:60%;" /><p><strong>数据流</strong></p><p><strong>原子性record append</strong></p><p><strong>快照snapshot</strong></p><h4 id="Master操作">Master操作</h4><ul><li>命名空间管理和读写锁</li><li>副本放置<ul><li>最大化可靠性和可用性</li><li>最大化网络带宽利用率</li></ul></li><li>chunk的create、re-replicate、rebalance</li><li>垃圾回收机制：周期性扫描</li><li>过期副本探测：master维护chunk版本号</li></ul><h4 id="容错和诊断">容错和诊断</h4><ul><li>高可用性<ul><li>快速恢复</li><li>Chunk复制</li><li>Master复制</li></ul></li><li>数据完整性：chunk分为64KB的块，每个块对应32bit的checksum</li><li>诊断工具：诊断log记录重要的事件和所有RPC请求/回复</li></ul><h3 id="Fault-tolerant-virtual-machines">Fault-tolerant virtual machines</h3><h4 id="基本FT设计">基本FT设计</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413202709356.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413202709356.png" srcset="data:image/png;base64,666" alt="image-20220413202709356" style="zoom:50%;" /><h5 id="确定性重播实现">确定性重播实现</h5><p>写入log文件</p><ul><li><p>挑战：</p><ul><li><p>正确捕获所有输入和对确定执行必要的非确定因素</p></li><li><p>正确将输入和非确定因素应用到备份VM上</p></li><li><p>不造成性能损失</p></li></ul></li></ul><h5 id="FT协议">FT协议</h5><ul><li>**输出要求：**若备份VM接替了故障的主VM，则备份VM将继续与主VM完全一致地向外界输出</li><li>**输出规则：**在备份VM收到并确认与生成输出的操作相关的log之前，主VM不能向外部世界输出</li></ul><h5 id="检测和响应故障">检测和响应故障</h5><h4 id="FT的实际实现">FT的实际实现</h4><h5 id="启动和重启FT-VM">启动和重启FT VM</h5><p>关键是以相同状态启动备份VM的机制：FT VMotion</p><h5 id="管理Logging-Channel">管理Logging Channel</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413204105126.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/image-20220413204105126.png" srcset="data:image/png;base64,666" alt="image-20220413204105126" style="zoom:50%;" /><h5 id="其他重要实现">其他重要实现</h5><ul><li>FT VM上的操作</li><li>Disk IO的实现</li><li>Network IO的实现</li></ul><h2 id="Course-Notes">Course Notes</h2><h3 id="FT-VM">FT VM</h3><h4 id="复制状态机">复制状态机</h4><ul><li>复制状态机基于这个事实：我们想复制的大部分的服务或者计算机软件都有一些确定的内部操作，不确定的部分是外部的输入</li><li>如果有两台计算机，如果它们从相同的状态开始，并且它们以相同的顺序，在相同的时间，看到了相同的输入，那么它们会一直互为副本，并且一直保持一致</li><li>VMware FT论文讨论的都是复制状态机，并且只涉及了单核CPU</li><li>在多核的机器中，两个核交互处理指令的行为是不确定的，所以就算Primary和Backup执行相同的指令，在多核的机器中，它们也不一定产生相同的结果</li><li>如果我们要创建一个新的副本，我们别无选择，只能使用状态转移，因为新的副本需要有完整状态的拷贝。所以创建一个新的副本代价会很高</li></ul><h4 id="非确定性事件">非确定性事件</h4><p><strong>客户端输入：</strong></p><ul><li>当我们说输入的时候，我们实际上是指接收到了一个网络数据包<ul><li>数据包中的数据</li><li>提示数据包送达了的中断</li></ul></li><li>对于Primary和Backup，中断最好要在相同的时间，相同的位置触发，否则执行过程就是不一样的，进而会导致它们的状态产生偏差。所以，我们不仅关心网络数据包的内容，还关心中断的时间</li></ul><p><strong>怪异指令：</strong></p><ul><li>随机数生成器</li><li>获取当前时间的指令，在不同时间调用会得到不同的结果</li><li>获取计算机的唯一ID</li></ul><p><strong>多CPU并发：</strong></p><ul><li>当服务运行在多CPU上时，指令在不同的CPU上会交织在一起运行，进而产生的指令顺序是不可预期的</li></ul><h4 id="输出控制">输出控制</h4><ul><li>Primary和Backup虚机都会生成回复报文，之后通过模拟的网卡送出，但是只有Primary虚机才会真正的将回复送出，而Backup虚机只是将回复简单的丢弃掉</li><li>控制输出规则：直到Backup虚机确认收到了相应的Log条目，Primary虚机不允许生成任何输出</li><li>Primary会等到Backup已经有了最新的数据，才会将回复返回给客户端。这几乎是所有的复制方案中对于性能产生伤害的地方，在某个时间点，Primary必须要停下来等待Backup</li></ul><h4 id="Test-and-Set服务">Test-and-Set服务</h4><ul><li>Primary和Backup都在运行，但是它们之间的网络出现了问题，同时它们各自又能够与一些客户端通信，这样会产生Split Brain问题</li><li>Test-and-Set服务会在内存中保留一些标志位，当你向它发送一个Test-and-Set请求，它会设置标志位，并且返回旧的值，Primary和Backup都需要获取Test-and-Set标志位，类似锁</li><li>为了能够上线，Primary和Backup或许会同时发送一个Test-and-Set请求给Test-and-Set服务。当第一个请求送达时，Test-and-Set服务会说，这个标志位之前是0，现在是1。第二个请求送达时，Test-and-Set服务会说，标志位已经是1了，你不允许成为Primary</li></ul><h3 id="Raft">Raft</h3><h4 id="Majority-Vote">Majority Vote</h4><ul><li>在任何时候为了完成任何操作，你必须凑够过半的服务器来批准相应的操作</li><li>如果系统有 $2F+1$ 个服务器，那么系统最多可以接受 $F$ 个服务器出现故障，仍然可以正常工作</li></ul><h4 id="Raft初探">Raft初探</h4><ul><li>Raft会以库（Library）的形式存在于服务中：如果有一个基于Raft的多副本服务，那么每个服务的副本将会由两部分组成：应用程序代码和Raft库</li></ul><h4 id="日志">日志</h4><ul><li>Log是Leader用来对操作排序的一种手段，Log是一些按照数字编号的槽位（类似一个数组），槽位的数字表示了Leader选择的顺序</li><li>在一个Follower收到了操作，但是还没有执行操作时，需要将这个操作存放在某处，直到收到了Leader发送的新的commit号才执行，对于Raft的Follower来说，Log是用来存放临时操作的地方</li><li>Leader需要在它的Log中记录操作，因为这些操作可能需要重传给Follower，即使对那些已经commit的请求，为了能够向丢失了相应操作的副本重传，也需要存储在Leader的Log中</li><li>可以帮助重启的服务器恢复状态，每个Raft节点都需要将Log写入到它的磁盘中，这样它故障重启之后，Log还能保留</li><li>**注：**从Log上无法直接观察出某一条日志是否已经commit</li></ul><h4 id="应用层接口">应用层接口</h4><p>在Raft集群中，每一个副本上，这两层之间主要有两个接口</p><p>第一个接口是key-value层用来转发客户端请求的接口。如果客户端发送一个请求给key-value层，key-value层会将这个请求转发给Raft层，并说：请将这个请求存放在Log中的某处。这个接口实际上是个函数调用，称之为Start函数。这个函数只接收一个参数，就是客户端请求。key-value层说：我接到了这个请求，请把它存在Log中，并在committed之后告诉我</p><p>另一个接口是，随着时间的推移，Raft层会通知key-value层：你刚刚在Start函数中传给我的请求已经commit了。这个向上的接口以go channel中的一条消息的形式存在。Raft层会发出这个消息，key-value层要读取这个消息。所以这里有个叫做applyCh的channel，通过它你可以发送ApplyMsg消息</p><p>key-value层需要知道从applyCh中读取的消息，对应之前调用的哪个Start函数，所以Start函数需要返回这个请求将会存放在Log中的位置（index）以及当前的任期号（term number）和一些其它我们现在还不太关心的内容</p><p>在ApplyMsg中，将会包含请求（command）和对应的Log位置（index）。所有的副本都会收到这个ApplyMsg消息，它们都知道自己应该执行这个请求，弄清楚这个请求的具体含义，并将它应用在本地的状态中。所有的副本节点还会拿到Log的位置信息（index），但是这个位置信息只在Leader有用，因为Leader需要知道ApplyMsg中的请求究竟对应哪个客户端请求（进而响应客户端请求）</p><h4 id="Leader选举">Leader选举</h4><ul><li>Raft生命周期中可能会有不同的Leader，它使用任期号（term number）来区分不同的Leader</li><li>Followers（非Leader副本节点）不需要知道Leader的ID，它们只需要知道当前的任期号</li><li>每个Raft节点都有一个选举定时器（Election Timer），如果在这个定时器时间耗尽之前，当前节点没有收到任何当前Leader的消息，这个节点会认为Leader已经下线，并开始一次选举，当前服务器会增加任期号（term number），因为它想成为一个新的Leader</li><li>之后，当前服务器会发出请求投票（RequestVote）RPC，这个消息会发给所有的Raft节点</li><li>如果有一场新的选举，有可能之前的Leader仍然在运行，并认为自己还是Leader。我们也需要关心，在不知道有新的选举时，旧的Leader会有什么样的行为？</li><li><strong>确保每个任期最多只有一个Leader</strong>：为了能够当选，Raft要求一个候选人从过半服务器中获得认可投票。每个Raft节点，只会在一个任期内投出一个认可选票</li><li>如果你赢得了选举，你需要立刻发送一条AppendEntries消息给其他所有的服务器。除非是当前任期的Leader，没人可以发出AppendEntries消息</li></ul><h4 id="选举定时器">选举定时器</h4><ul><li>任何一条AppendEntries消息都会重置所有Raft节点的选举定时器：每一次一个节点重置自己的选举定时器时，都需要重新选择一个随机的超时时间</li><li>Raft不能完全避免分割选票（Split Vote），但是可以使得这个场景出现的概率大大降低。Raft通过为选举定时器随机的选择超时时间来达到这一点</li><li>选举定时器的超时时间需要至少大于Leader的心跳间隔，实际上由于网络可能丢包，这里你或许希望将下限设置为多个心跳间隔</li><li>超时时间的上限：<ul><li>最大超时时间影响了系统能多快从故障中恢复，这里的上限越大，系统的恢复时间也就越长</li><li>不同节点的选举定时器的超时时间差必须要足够长，使得第一个开始选举的节点能够完成一轮选举：至少需要大于发送一条RPC所需要的往返（Round-Trip）时间</li></ul></li></ul><h4 id="日志恢复">日志恢复</h4><ul><li>Leader使用一种备份机制来探测Followers的Log中，第一个与Leader的Log相同的位置</li><li>在获得位置之后，Leader会给Follower发送从这个位置开始的，剩余的全部Log</li></ul><h4 id="选举约束">选举约束</h4><ul><li>为了保证系统的正确性，并非任意节点都可以成为Leader</li><li>在处理别节点发来的RequestVote RPC时，需要做一些检查才能投出赞成票：<ul><li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号</li><li>或者，候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录的长度</li></ul></li></ul><h4 id="快速恢复">快速恢复</h4><ul><li><p>让Follower返回足够的信息给Leader，这样Leader可以以任期（Term）为单位来回退，而不用每次只回退一条Log条目</p><ul><li>XTerm：Follower中与Leader冲突的Log对应的任期号。Leader会在prevLogTerm中带上本地Log记录中，前一条Log的任期号。如果Follower在对应位置的任期号不匹配，它会拒绝Leader的AppendEntries消息，并将自己的任期号放在XTerm中。如果Follower在对应位置没有Log，那么这里会返回 -1</li><li>XIndex：Follower中，对应任期号为XTerm的第一条Log条目的槽位号</li><li>XLen：如果Follower在对应位置没有Log，那么XTerm会返回-1，XLen表示空白的Log槽位数</li></ul></li><li><p>case1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: 4 5 5</span><br><span class="line">S2: 4 6 6 6</span><br></pre></td></tr></table></figure><ul><li>Follower（S1）会返回XTerm=5，XIndex=2。Leader（S2）发现自己没有任期5的日志，它会将自己本地记录的，S1的nextIndex设置到XIndex，也就是S1中，任期5的第一条Log对应的槽位号。所以，如果Leader完全没有XTerm的任何Log，那么它应该回退到XIndex对应的位置（这样，Leader发出的下一条AppendEntries就可以一次覆盖S1中所有XTerm对应的Log）</li></ul></li><li><p>case2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: 4 4 4</span><br><span class="line">S2: 4 6 6 6</span><br></pre></td></tr></table></figure><ul><li>Follower（S1）会返回XTerm=4，XIndex=1。Leader（S2）发现自己其实有任期4的日志，它会将自己本地记录的S1的nextIndex设置到本地在XTerm位置的Log条目后面，也就是槽位2。下一次Leader发出下一条AppendEntries时，就可以一次覆盖S1中槽位2和槽位3对应的Log</li></ul></li><li><p>case3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: 4</span><br><span class="line">S2: 4 6 6 6</span><br></pre></td></tr></table></figure><ul><li>Follower（S1）会返回XTerm=-1，XLen=2。这表示S1中日志太短了，以至于在冲突的位置没有Log条目，Leader应该回退到Follower最后一条Log条目的下一条，也就是槽位2，并从这开始发送AppendEntries消息。槽位2可以从XLen中的数值计算得到</li></ul></li></ul><h4 id="持久化">持久化</h4><ul><li>Log需要被持久化存储的原因是，这是唯一记录了应用程序状态的地方</li><li>currentTerm和votedFor都是用来确保每个任期只有最多一个Leader<ul><li>如果一个服务器收到了一个RequestVote请求，并且为服务器1投票了，之后它故障。如果它没有存储它为哪个服务器投过票，当它故障重启之后，收到了来自服务器2的同一个任期的另一个RequestVote请求，那么它还是会投票给服务器2，因为它发现自己的votedFor是空的</li><li>存储currentTerm是为了防止任期回退</li></ul></li><li>安全的做法是每次你添加一个Log条目，更新currentTerm或者更新votedFor。可以通过一些批量操作来提升性能。例如，只在服务器回复一个RPC或者发送一个RPC时，服务器才进行持久化存储</li><li>如果Leader收到了一个客户端请求，在发送AppendEntries RPC给Followers之前，必须要先持久化存储在本地；在回复AppendEntries 消息之前，Followers也需要持久化存储这些Log条目到本地</li><li>服务器重启时，commitIndex、lastApplied、nextIndex、matchIndex可以被丢弃，因为Leader可以通过检查自己的Log和发送给Followers的AppendEntries的结果，来发现哪些内容已经commit了</li></ul><h4 id="日志快照">日志快照</h4><ul><li>快照背后的思想是，要求应用程序将其状态的拷贝作为一种特殊的Log条目存储下来<ul><li>对于大多数的应用程序来说，应用程序的状态远小于Log的大小（如KV数据库）</li></ul></li><li>如果Raft要求应用程序做一个快照，Raft会从Log中选取一个与快照对应的点，然后要求应用程序在那个点的位置做一个快照，然后我们可以安全的将那个点之前的Log丢弃；我们还需要为快照标注Log的槽位号<ul><li>只要Raft持久化存储了快照，快照对应的Log槽位号，以及Log槽位号之后的所有Log，那么快照对应槽位号之前的这部分Log可以被丢弃</li></ul></li><li>重启的时候，必须让Raft有方法知道磁盘中最近的快照和Log的组合，并将快照传递给应用程序。所以应用程序不仅需要有能力能生成一个快照，它还需要能够吸纳一个之前创建的快照，并通过它稳定的重建自己的内存</li><li>如果Leader发现有任何一个Follower的Log落后于Leader要做快照的点，Leader可以丢弃Follower需要的Log，但需要某种机制让AppendEntries能处理某些Follower Log的结尾到Leader Log开始之间丢失的这一段Log，即InstallSnapshot RPC<ul><li>当Leader回退到了自己Log的起点，将不能再回退。这时，Leader会将自己的快照发给Follower，之后立即通过AppendEntries将后面的Log发给Follower</li></ul></li></ul><h4 id="线性一致">线性一致</h4><ul><li>一个服务是线性一致的，那么它表现的就像只有一个服务器，并且服务器没有故障，这个服务器每次执行一个客户端请求，并且没什么奇怪的事情发生<ul><li>如果执行历史整体可以按照一个顺序排列，且排列顺序与客户端请求的实际时间相符合，那么它是线性一致的</li><li>一个线性一致的执行历史中的操作是非并发的，也就是时间上不重合的客户端请求与实际执行时间匹配</li></ul></li><li>确定执行顺序：<ul><li>如果一个操作在另一个操作开始前就结束了，那么这个操作必须在执行历史中出现在另一个操作前面</li><li>执行历史中，读操作，必须在相应的key的写操作之后</li></ul></li><li>对于读请求，线性一致系统只能返回最近一次完成的写请求写入的值</li></ul><h4 id="Client交互">Client交互</h4><p>源自Raft作者<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">博士论文Ch6</a></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/119603839-900e0180-be20-11eb-9f74-8b39705bc35e.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/mit-6824/119603839-900e0180-be20-11eb-9f74-8b39705bc35e.png" srcset="data:image/png;base64,666" alt="img"></p><p><strong>寻找Leader</strong></p><ul><li>Client发送请求到随机节点，节点有两种处理方式：<ol><li>节点可能通过Leader的AppendEntries RPC知道了LeaderId，从而可以将此信息传递给client；</li><li>节点作为代理，将请求转发给Leader。</li></ol></li><li>Raft必须防止过期的Leadership信息<ul><li>Leader：某个节点处于Leader的状态，但不是当前整个集群的Leader，若client将请求发送给此节点，将永远得不到回复，因为该节点不能得到大部分节点的同意。<strong>解决方案：</strong> 若Leader没有收到集群中大部分节点的心跳回复，则会自动退位，使得client能请求其他节点</li><li>Follower：当Follower开启一轮选举或任期改变时，不能回复client的请求，防止几个节点相互redirect</li><li>Client：若client与节点失去连接，需要随机请求另一个节点</li></ul></li></ul><p><strong>实现线性一致</strong></p><ul><li>Raft中，复制状态机可能会apply一条命令多次，为了实现线性一致，不能允许重复执行</li><li>节点保存client操作的结果，当client重发相同请求时，直接回复结果而不执行请求</li><li>给与每个client一个唯一标识，client为每条命令分配一个唯一序号</li><li>每个节点的状态机为每个client维护一个session，来跟踪client的最新命令序号以及响应的回复</li><li>当节点收到同一个client相同序号的命令时，直接回复session中的结果</li><li>在并发环境下，节点维护的session应该包含多个序号-回复pair，client在每个请求中包含其还未收到回复的最小的序号，节点根据此来丢弃更小的序号-回复pair</li><li>由于存储空间有限，在client session越来越多之后，节点必须丢弃一些client session<ul><li>所有节点必须对丢弃的session达成共识，因此session丢弃必须是确定性的，可选方案：<ul><li>设置session数量上限，根据LRU (Least Recently Used) 策略丢弃session</li><li>基于时间共识来丢弃session</li></ul></li><li>处理在session过期后仍不断发送请求的client，可选方案：<ul><li>为该client重新分配一个新的session，但这有命令重复执行的风险（在该client上一个session中可能已经执行过该命令）</li><li>节点区分新client和session过期的client：新client发送RegisterClient RPC来请求一个session，若节点收到的命令请求中包含过期的session，则返回error</li></ul></li></ul></li></ul><p><strong>更高效地执行只读请求</strong></p><ul><li><p>只读请求可以直接进行而不记录log (防止对磁盘的同步写) ，但是需要一些额外处理，否则可能回复过时数据</p><ol><li>若Leader还没将自己任期的log条目标记为committed，则等待标记完成。由于Leader刚上任时不知道自己的哪些log已经commit了，所以他需要在自己任期开始时往自己的log中添加一条空的 <em>no-op</em> 条目，当该条目commit之后，Leader的 <code>commitIndex</code> 至少和其他节点一样大；</li><li>Leader保存一个本地变量 <code>readIndex</code> 来记录当前的 <code>commitIndex</code> ，这将被用作是请求操作的状态的最低版本</li><li>Leader需要确保自己没有被更新的Leader取代，为此他发起一轮新的心跳消息，并等待大部分节点的确认，若得到大部分的确认，则Leader知道此时的 <code>readIndex</code> 是所有节点中最大的 <code>commitIndex</code></li><li>Leader等待其状态机执行到至少 <code>readIndex</code> ，至此所有操作都是线性一致的</li><li>最后，Leader直接查询状态机来获得client只读请求的结果，而不需要记录log</li></ol></li><li><p>进一步优化：Leader可以积累一定数量的只读请求，然后通过一轮心跳消息来同时执行</p></li><li><p>进进一步优化：Follower也可以处理只读请求，首先向Leader发送请求来获取 <code>readIndex</code> ，然后Leader执行1-3步并回复Follower，最后Follower执行4-5步</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Oblivious Database相关</title>
      <link href="2022/04/13/paper-reading/oblivious-db/"/>
      <url>2022/04/13/paper-reading/oblivious-db/</url>
      
        <content type="html"><![CDATA[<h2 id="不经意数据库相关研究">不经意数据库相关研究</h2><p>关键是隐藏访问模式：隐藏访问内容+访问时间/访问次数/访问顺序等</p><h3 id="ObliDB">ObliDB</h3><h4 id="威胁模型：">威胁模型：</h4><ul><li>读取并篡改不可信内存</li><li>暂停和恢复Enclave执行</li><li>观察到对不可信内存的访问模式</li><li>监听网络通信</li><li>了解存储的数据的辅助信息</li><li>无法突破SGX远程认证</li><li><strong>假设</strong>：不经意内存有限</li></ul><h4 id="安全保证：">安全保证：</h4><ul><li>探测到任何篡改数据的恶意行为</li><li>只泄露查询选择率（select行的比例），表的大小（包括输出表和中间表）和查询方案</li><li>可选的padding模式，可以隐藏表的大小和查询选择率</li><li>在enclave外的数据经过加密和MAC计算，仅泄露大小</li><li>数据库中表的数量 &amp; 查询了哪张表不作隐藏</li></ul><h4 id="Overview：">Overview：</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220404194724441.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220404194724441.png" srcset="data:image/png;base64,666" alt="image-20220404194724441" style="zoom:60%;" /><ul><li>不经意数据库引擎支持小规模查询和分析查询（需要遍历整张表）</li><li>表加密存储在不可信内存但是访问模式被隐藏</li><li>两种存储方案：线性表、不经意索引（用于单点查询）</li><li>Enclave用于存储密钥、元数据，不经意算子在Enclave中执行</li></ul><h4 id="存储方案">存储方案</h4><p><strong>扁平化存储</strong></p><p>数据存储在相邻的块中，每次读/写都需要访问所有块（整张表），用于存储：</p><ul><li>小的表</li><li>操作后返回表的大部分区域的表</li><li>涉及读取全部或大部分表的分析</li></ul><p>数据的插入、更新、删除需遍历整张表，对未受影响的块进行虚拟写（重新写一遍所有数据并重新加密）</p><p><strong>索引存储</strong></p><p>对B+树的插入/删除操作会泄露树的结构信息 =&gt; 使用虚拟ORAM访问，填充所有插入/删除操作，使其访问次数与最坏情况匹配</p><p>优化：</p><ul><li>懒写回：只在必要的时候写入ORAM，否则将节点保留在enclave中</li><li>移除指向父节点的指针</li></ul><h3 id="Opaque">Opaque</h3><blockquote><p>Opaque relies on oblivious sorts over the entire dataset. These systems are not efficient for more general workloads that may also include point queries.【ObliDB】(单点查询效率低)</p><p>仅达到了Level 1的不经意性，因为使用不经意内存池进行优化【O-Join】</p></blockquote><p>不经意分布式数据分析平台：</p><ul><li>引入一系列新的分布式关系运算符</li><li>新的查询规划技术，rule-based和cost-based</li><li>三种运行模式：加密模式、不经意模式、不经意填充模式</li></ul><h4 id="威胁模型">威胁模型</h4><ul><li>观察和修改网络通信</li><li>获取操作系统的root权限</li><li>观察enclave对不可信内存的访问模式</li><li>可以进行回滚攻击，将密封的数据恢复到之前的状态</li><li>不能破坏可信硬件</li><li>对Opaque源码的访问是不经意的</li></ul><h4 id="安全保证">安全保证</h4><p><strong>加密模式</strong></p><ul><li>数据加密和身份认证</li><li>self-verifying integrity</li></ul><p><strong>不经意模式</strong></p><ul><li>隐藏访问模式，但不隐藏访问的数据大小，以及Catalyst选择的查询方案</li></ul><p><strong>不经意填充模式</strong></p><ul><li>在不经意模式的基础上，进一步隐藏数据大小和查询方案</li></ul><h4 id="Overview">Overview</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220405165557918.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220405165557918.png" srcset="data:image/png;base64,666" alt="image-20220405165557918" style="zoom:60%;" /><h4 id="不经意执行">不经意执行</h4><ul><li>不经意排序（单机 &amp; 分布式）</li><li>不经意过滤（filter）</li><li>不经意聚合（group）</li><li>不经意连接（join）</li></ul><h4 id="查询规划">查询规划</h4><ul><li>成本模型：主要考虑不经意排序的次数</li><li>查询优化</li><li>混合敏感性：使用second path analysis来推断敏感表</li></ul><h3 id="OCQ">OCQ</h3><p>多方不经意竞争分析的解决方案，而不是设计一个数据库</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220408145702098.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220408145702098.png" srcset="data:image/png;base64,666" alt="image-20220408145702098" style="zoom:60%;" /><h4 id="主要贡献：">主要贡献：</h4><ul><li>不经意查询算法</li><li>schema-aware填充机制：防止两种数据泄露——enclave中的数据泄露和enclave外网络通信中的模式泄露</li><li>不经意规划器：决定在哪执行操作以及如何执行</li></ul><h4 id="不经意算法：">不经意算法：</h4><blockquote><p>Single-machine oblivious sorting can be done using sorting networks that perform a fixed sequence of compare-exchange operations. Asymptotically more compare-exchange operations are needed for oblivious sorting than for traditional sorting. An oblivious compare-exchange can be implemented via a comparison followed by a conditional swap of two equal-length buffers depending on the result of the comparison.</p><p>For data partitioned across multiple machines, oblivious sorting can be accomplished using a two-level sorting algorithm in which each partition is individually sorted using a sorting network, and records are sorted across partitions using an algorithm called column sort. Column sort consists of a fixed sequence of data exchange and intra-machine sorting<br>that uses only 4 shuffles, compared to O(nlog2n) shuffles for a sorting-network-based distributed sort.</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220408162528084.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220408162528084.png" srcset="data:image/png;base64,666" alt="image-20220408162528084" style="zoom:60%;" /><h4 id="Overview-v2">Overview</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220408163008436.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220408163008436.png" srcset="data:image/png;base64,666" alt="image-20220408163008436" style="zoom:60%;" /><h3 id="Oblivious-join">Oblivious join</h3><ul><li><p>提出时间复杂度为 $O(nlog^2n+mlogm)$ 的不经意equi-join算法，其中 $n$ 是输入表大小之和， $m$ 是输出表大小</p><ul><li>equi-join是指根据相等的条件来join两张表</li></ul></li><li><p>该算法只依赖于能够在加密数据上支持sorting network的计算模型</p></li><li><p>不隐藏输出大小和运行时间</p></li></ul><h4 id="在加密数据上进行计算">在加密数据上进行计算</h4><ul><li>Outsourced External Memory</li><li>Secure Cryptographic Coprocessors</li><li>TEE</li><li>Secure Multiparty Computation</li><li>Fully Homomorphic Encryption</li></ul><h4 id="不经意性划分">不经意性划分</h4><ul><li>Level 1：对公共内存的访问是不经意的，但需要非常数量的本地内存来执行non-oblivious计算</li><li>Level 2：对公共内存的访问是不经意的，且需要的本地内存大小是一个常数<ul><li>访问程序的数据是不经意的，但是基于控制流访问的字节码没有隐藏。例如分支语句，条件本身是不经意的，但是跳转到的分支的字节码位置没有隐藏</li></ul></li><li>Level 3：程序的控制流，甚至处理器执行的指令，都与输入无关</li></ul><p>将Level 2的程序转变为Level 3的程序需另外满足3条限制：</p><ol><li>循环次数必须是常数（因为若根据变量来定循环次数，会很难隐藏执行循环的时间）</li><li>任何变量执行的最大分支数是一个常数</li><li>若一个程序暴露输出长度 $m$ ，则这一定在分配了 $m_0\in\Omega(m)$ 的内存之后</li></ol><h4 id="Overview-v3">Overview</h4><ul><li>输入两张未排序的表 $T_1$ 和 $T_2$ ，分别包含 $n_1$ 和 $n_2$ 对 $(j,d)$ ，其中 $j$ 表示参与join条件判断的属性， $d$ 是其他属性。输出记为 $T_1\bowtie T_2={(d_1,d_2)|(j,d_1)\in T_1, (j,d_2)\in T_2}$</li><li>使用固定大小的本地内存来实现Level 2的不经意性</li></ul><h4 id="算法">算法</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220409170313852.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/oblivious-db/image-20220409170313852.png" srcset="data:image/png;base64,666" alt="image-20220409170313852" style="zoom:40%;" /><h3 id="ProDB">ProDB</h3><h3 id="Oblix">Oblix</h3><blockquote><p>POSUP [41] and Oblix [50] explore oblivious indexes over encrypted data using specialized ORAM constructions as building blocks, but do not support general queries.【ObliDB】</p></blockquote><h3 id="Obladi">Obladi</h3><blockquote><p>Obladi [28] considers concurrent ACID transactions but does not support indexes and only processes operations in batches over discrete time epochs.【ObliDB】</p></blockquote><p>提供ACID事务</p><h3 id="CODBS">CODBS</h3><h3 id="Practical-Oblivious-Join">Practical Oblivious Join</h3><h3 id="对比">对比</h3><table><thead><tr><th></th><th>数据库类型</th><th>支持</th><th>特点</th><th>实现</th></tr></thead><tbody><tr><td>ObliDB</td><td>关系型</td><td>索引</td><td></td><td>TEE+ORAM</td></tr><tr><td>Opaque</td><td>Spark SQL</td><td></td><td>分布式</td><td>TEE</td></tr><tr><td>OCQ</td><td>Opaque</td><td></td><td>分布式</td><td>TEE</td></tr><tr><td>O-Join</td><td>/</td><td></td><td>高效</td><td>TEE</td></tr><tr><td>ProDB</td><td></td><td></td><td></td><td>TEE+ORAM</td></tr><tr><td>Oblix</td><td></td><td>索引</td><td></td><td>ORAM</td></tr><tr><td>Obladi</td><td>kv数据库</td><td>事务</td><td></td><td>ORAM</td></tr><tr><td>CODBS</td><td>关系型(PostgresSQL)</td><td></td><td></td><td>ORAM</td></tr><tr><td>Practical O-Join</td><td></td><td></td><td></td><td>ORAM</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="POSUP">POSUP</h3><blockquote><p>POSUP [41] and Oblix [50] explore oblivious indexes over encrypted data using specialized ORAM constructions as building blocks, but do not support general queries.【ObliDB】</p></blockquote><p>使用Intel SGX开发不经意数据结构，在大数据集上提供实用的不经意搜索/更新操作（与可搜索加密相关，与数据库关系不大）</p><h2 id="不经意性验证">不经意性验证</h2><h3 id="Memory-trace-oblivious-program-execution">Memory trace oblivious program execution</h3><h2 id="KV数据库">KV数据库</h2><h3 id="EdgelessDB">EdgelessDB</h3>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction To Modern Cryptography笔记</title>
      <link href="2022/03/20/learning-notes/cryptography/"/>
      <url>2022/03/20/learning-notes/cryptography/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1-Introduction">Chapter 1: Introduction</h2><h3 id="1-2-对称加密Setting">1.2 对称加密Setting</h3><ul><li>Kerckhoffs’ principle：要求加密算法的安全性只依赖于密钥的安全性，而加解密算法都应当可以公开</li></ul><h3 id="1-3-古典加密算法">1.3 古典加密算法</h3><ul><li>恺撒加密、移位加密、单字母替换、多字母移位</li><li>密钥空间充分性原则：任何安全的加密方案必须拥有一个能够抵御穷举搜索的密钥空间</li></ul><h3 id="1-4-现代密码学原则">1.4 现代密码学原则</h3><p><strong>原则1 Formal Defination</strong></p><ul><li><p>安全性定义包含：</p><ul><li><p>security guarantee</p><blockquote><p>regardless of any information an attacker already has, a ciphertext should leak no additional information about the underlying plaintext</p></blockquote></li><li><p>threat model    敌手的目标是要解密密文，得到明文</p><ul><li>Ciphertext-only attack 唯密文攻击：敌手只能得到密文【被动攻击】</li><li>Known-plaintext attack 已知明文攻击：敌手能获得一个或多个明文-密文对【被动攻击】</li><li>Chosen-plaintext attack 选择明文攻击：敌手可以选择明文，并获得加密后的密文【主动攻击】</li><li>Chosen-ciphertext attack 选择密文攻击：敌手可以选择密文，并获得解密后的明文【主动攻击】</li></ul></li></ul></li></ul><p><strong>原则2 Precise Assumption</strong></p><p><strong>原则3 Proofs of Security</strong></p><h2 id="Chapter-2-Perfectly-Secret-Encryption">Chapter 2: Perfectly Secret Encryption</h2><h3 id="2-1-符号定义">2.1 符号定义</h3><ul><li>加密方案的元素：<ul><li>$\mathcal{M}$ ——有限消息空间，$|\mathcal{M}|&gt;1$<ul><li>令 $M$ 是一个随机的消息 ，对于任意 $m\in\mathcal{M}$ ，$Pr[M=m]$ 表示 $M$ 与 $m$ 一致的概率</li></ul></li><li>$\mathcal{K}$ ——有限密钥空间<ul><li>令 $K$ 是 $\mathsf{Gen}$ 随机生成的密钥，对于任意 $k\in\mathcal{K}$ ，$Pr[K=k]$ 表示 $\mathsf{Gen}$ 生成的密钥为 $k$ 的概率</li><li><strong>注</strong>：$K$ 和 $M$ 是独立的</li></ul></li><li>$\mathcal{C}$ ——密文空间<ul><li>令 $C$ 是一个随机变量，对于任意 $c\in\mathcal{C}$ ，$Pr[C=c]$ 表示 $\mathsf{Enc}$ 加密得到的密文为 $c$ 的概率</li><li>给定 $\mathsf{Enc}$ ，$\mathcal{C}$ 的分布完全取决于 $\mathcal{M}$ 和 $\mathcal{K}$ 的分布</li></ul></li></ul></li><li>加密方案包含三个算法：<ul><li>$\mathsf{Gen}$ ——密钥生成<ul><li>密钥生成算法从 $\mathcal{K}$ 中均匀地选择一个密钥 $k$</li></ul></li><li>$\mathsf{Enc}$ ——加密<ul><li>输入 $k\in\mathcal{K}, m\in\mathcal{M}$ ，输出密文 $c\in\mathcal{C}$<ul><li>对于概率性加密算法，记作 $c\leftarrow \mathsf{Enc}_{k}(m)$</li><li>对于确定性加密算法，记作 $c:=\mathsf{Enc}_{k}(m)$</li></ul></li></ul></li><li>$\mathsf{Dec}$ ——解密<ul><li>输入 $k\in\mathcal{K},c\in\mathcal{C}$ ，输出消息 $m\in\mathcal{M}$<ul><li>一般假设解密算法是确定性的，记作 $m:=\mathsf{Dec}_{k}©$</li></ul></li></ul></li></ul></li><li><strong>Perfect Secrecy</strong><ul><li>定义2.3：加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是perfectly secret，如果对 $\mathcal{M}$ 上任意概率分布，任意明文 $m\in\mathcal{M}$ ，任意密文 $c\in\mathcal{C}$ 且 $Pr[C=c]&gt;0$ 有：$Pr[M=m|C=c]=Pr[M=m]$<ul><li>等价定义：$Pr[C=c|M=m]=Pr[C=c]$</li></ul></li><li>引理2.4：加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是perfectly secret，当且仅当对所有 $m, m’\in\mathcal{M}$ 和所有 $c\in\mathcal{C}$ 有：$Pr[\mathsf{Enc}<em>{k}(m)=c]=Pr[\mathsf{Enc}</em>{k}(m’)=c]$<ul><li>说明密文不包含任何关于明文的信息，且不可能区分加密后的 $m$ 和 $m’$</li></ul></li></ul></li><li><strong>Perfect (adversarial) indistinguishability</strong><ul><li>定义敌手不可区分实验 $\mathsf{PrivK}^{eav}_{\mathcal{A},\Pi}$ (其中 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ )：<ol><li>敌手 $\mathcal{A}$ 输出一对消息 $m_0,m_1\in\mathcal{M}$</li><li>选择一个比特 $b\in{0,1}$ ，计算 $c\leftarrow \mathsf{Enc}_k(m_b)$ 并发送给 $\mathcal{A}$ 。称 $c$ 为挑战密文</li><li>$\mathcal{A}$ 输出一个比特 $b’$</li><li>若 $b=b’$ 则实验输出1，记作 $\mathsf{PrivK}^{eav}_{\mathcal{A},\Pi}=1$ ，此时 $\mathcal{A}$ 获胜；反之输出0</li></ol></li><li>定义2.5：加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是perfectly indistinguishable，如果对所有 $\mathcal{A}$ 有： $Pr[\mathsf{PrivK}^{eav}_{\mathcal{A},\Pi}=1]=\frac{1}{2}$</li><li>引理2.6：加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是perfectly secret，当且仅当它是perfectly indistinguishable</li></ul></li></ul><h3 id="2-2-一次一密">2.2 一次一密</h3><ul><li>定义：取定整数 $l&gt;0$ ， $\mathcal{M},\mathcal{C},\mathcal{K}$ 都是长度为 $l$ 的二进制串，即 ${0,1}^l$<ul><li>$\mathsf{Gen}$ ：根据均匀分布从 $\mathcal{K}={0,1}^l$ 中选择一个密钥</li><li>$\mathsf{Enc}$ ：给定密钥 $k\in{0,1}^l$ 和消息 $m\in{0,1}^l$ ，输出密文 $c:=k\oplus m$</li><li>$\mathsf{Dec}$ ：给定密钥 $k\in{0,1}^l$ 和密文 $c\in{0,1}^l$ ，输出消息 $m:=k\oplus c$</li></ul></li><li>定理2.9：一次一密方案是perfectly secret</li><li>局限性：<ul><li>密钥必须和消息等长</li><li>只有每次加密使用不同的密钥才安全</li></ul></li></ul><h3 id="2-3-Perfect-Secrecy的局限性">2.3 Perfect Secrecy的局限性</h3><ul><li>定理2.10： $(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是perfectly secret加密方案，则 $|\mathcal{K}|&gt;|\mathcal{M}|$ 【反证】<ul><li>Perfectly secret的加密方案中密钥空间必须大于消息空间</li></ul></li></ul><h3 id="2-4-香农定理">2.4 香农定理</h3><ul><li>定理2.11(香农定理)：对于 $|\mathcal{M}|=|\mathcal{K}|=|\mathcal{C}|$ 的加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是perfectly secret，当且仅当：<ol><li>每个密钥 $k\in\mathcal{K}$ 被 $\mathsf{Gen}$ 选择的概率为 $1/|\mathcal{K}|$</li><li>对每个 $m\in\mathcal{M}$ 和 $c\in\mathcal{C}$ ，存在唯一的密钥 $k\in\mathcal{K}$ 使得 $\mathsf{Enc}_k(m)$ 输出 $c$</li></ol></li></ul><h2 id="Chapter-3-Private-Key-Encryption">Chapter 3: Private-Key Encryption</h2><h3 id="3-1-计算安全">3.1 计算安全</h3><ul><li>放松perfect secrecy的限制：<ol><li>仅对可行时间内的敌手保证安全（敌手可能在足够多的时间内可以破解）</li><li>敌手有很小的概率破解</li></ol></li></ul><p><strong>形式化定义</strong></p><ul><li>具体定义<ul><li>一个方案是 $(t,\varepsilon)$-安全 的，如果任何敌手在时间 $t$ 内破解该方案的概率最大为 $\varepsilon$</li></ul></li><li>渐进定义<ul><li>诚实各方使用一个共享的安全参数 $n$ (或记为 $1^n$ ) 来初始化加密方案，从而敌手的攻击时间和攻击成功的概率都是 $n$ 的函数：<ul><li>敌手攻击时间：多项式时间，即存在多项式 $p$ ，对所有输入 $x\in{0,1}^*$ ，算法最多执行 $p(|x|)$ 步</li><li>敌手的攻击成功概率可忽略<ul><li>定义3.4：从自然数映射到非负实数的函数 $f$ 是可忽略(negligible)的，如果对所有正多项式 $p$ ，存在 $N$ ，使得对所有 $n&gt;N$ ，有 $f(n)&lt;\frac{1}{p(n)}$ 【将任意可忽略函数记作 $\mathsf{negl}$】</li><li>命题3.6：令 $\mathsf{negl_1}$ 和 $\mathsf{negl_2}$ 为可忽略函数，则<ol><li>$\mathsf{negl_3}(n)=\mathsf{negl_1}(n)+\mathsf{negl_2}(n)$ 是可忽略的</li><li>对任意正多项式 $p$ ，$\mathsf{negl_4}(n)=p(n)\cdot \mathsf{negl_1}(n)$ 是可忽略的</li></ol></li></ul></li></ul></li><li>一个方案是安全的，如果任何PPT (probabilistic polynomial-time概率多项式时间) 敌手破解该方案的概率可忽略</li></ul></li></ul><h3 id="3-2-定义计算安全的加密">3.2 定义计算安全的加密</h3><ul><li>定义3.7：一个对称加密方案是一个PPT算法元组 $(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ ，满足：<ol><li>$\mathsf{Gen}$ 的输入为 $1^n$ ，输出密钥 $k$ ，记作 $k\leftarrow \mathsf{Gen}(1^n)$ ，并假设任何 $k$ 满足 $|k|&gt;n$</li><li>$\mathsf{Enc}$ 的输入为 $k$ 和 $m\in{0,1}^*$ ，输出密文 $c$ ，记作 $c\leftarrow \mathsf{Enc}_k(m)$</li><li>$\mathsf{Dec}$ 的输入为 $k$ 和 $c$ ，输出消息 $m$ 或错误 $\bot$ (当输入为无效密文)，记作 $m:=\mathsf{Dec}_k©$</li></ol><ul><li>算法满足 $\mathsf{Dec}_k(\mathsf{Enc}_k(m))=m$</li></ul></li></ul><h4 id="安全的基本定义">安全的基本定义</h4><ul><li>关于敌手能力的假设：<ul><li>仅窃听信道（唯密文攻击）</li><li>多项式时间</li></ul></li><li>定义敌手不可区分实验 $\mathsf{PrivK}^\mathsf{eav}_{\mathcal{A},\Pi}(n)$ (其中 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ )：<ol><li>敌手 $\mathcal{A}$ 根据输入 $1^n$ 输出一对消息 $m_0,m_1$ ，且 $|m_0|=|m_1|$</li><li>计算 $k\leftarrow \mathsf{Gen}(1^n)$ ，选择一个比特 $b\in{0,1}$ ，计算 $c\leftarrow \mathsf{Enc}_k(m_b)$ 并发送给 $\mathcal{A}$ 。称 $c$ 为挑战密文</li><li>$\mathcal{A}$ 输出一个比特 $b’$</li><li>若 $b=b’$ 则实验输出1，记作 $\mathsf{PrivK}^\mathsf{eav}_{\mathcal{A},\Pi}(n)=1$ ，此时 $\mathcal{A}$ 获胜；反之输出0</li></ol></li><li>定义3.8(3.9)：对称加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是<strong>EAV-安全</strong>的（对窃听敌手不可区分），如果对所有PPT敌手 $\mathcal{A}$ 有一个可忽略函数 $\mathsf{negl}$ ，使得对所有n：<ol><li>$Pr[\mathsf{PrivK}^\mathsf{eav}_{\mathcal{A},\Pi}(n)=1]\leq \frac{1}{2}+\mathsf{negl}(n)$<ul><li>该式说明 $\mathcal{A}$ 正确判断加密的消息是 $m_0$ 还是 $m_1$ 的概率小于等于 $\frac{1}{2}+\mathsf{negl}(n)$</li></ul></li><li>$Pr[out_{\mathcal{A}}(\mathsf{PrivK}<sup>\mathsf{eav}_{\mathcal{A},\Pi}(n,0))=1]-Pr[out_{\mathcal{A}}(\mathsf{PrivK}</sup>\mathsf{eav}_{\mathcal{A},\Pi}(n,1))=1]\leq \mathsf{negl}(n)$<ul><li>其中 $\mathsf{PrivK}^\mathsf{eav}<em>{\mathcal{A},\Pi}(n,b)$ 表示实验选择了 $m_b$ 进行加密； $out</em>{\mathcal{A}}(\mathsf{PrivK}^\mathsf{eav}_{\mathcal{A},\Pi}(n,b))$ 表示 $\mathcal{A}$ 在实验中的输出，即 $b’$</li><li>该式说明 $\mathcal{A}$ 不能判断进行的实验是 $\mathsf{PrivK}^\mathsf{eav}<em>{\mathcal{A},\Pi}(n,0)$ 还是 $\mathsf{PrivK}^\mathsf{eav}</em>{\mathcal{A},\Pi}(n,1)$</li></ul></li></ol></li></ul><h4 id="语义安全">语义安全</h4><ul><li>不可区分意味着密文不会泄露任何一比特的明文<ul><li>定理3.10： $\Pi=(\mathsf{Enc},\mathsf{Dec})$ 是一个对长度为 $l$ 的消息的对称加密方案，并且是EAV-安全的。则对所有PPT敌手 $\mathcal{A}$ 和任何 $i\in{1,…,l}$ ，存在一个可忽略函数 $\mathsf{negl}$ 使得：【其中 $m^i$ 表示消息的第 $i$ 比特；$\mathcal{A}(1^n,\mathsf{Enc}_k(m))$ 表示 $\mathcal{A}$ 收到挑战密文后的输出 $b’$ 】<br>$$Pr[\mathcal{A}(1<sup>n,\mathsf{Enc}_k(m))=m</sup>i]\leq\frac{1}{2}+\mathsf{negl}(n)$$</li></ul></li><li>不可区分意味着没有敌手能从密文中学习到任何明文的函数<ul><li>定理3.11：$\Pi=(\mathsf{Enc},\mathsf{Dec})$ 是一个对长度为 $l$ 的消息的对称加密方案，并且是EAV-安全的。则对所有PPT敌手 $\mathcal{A}$ 存在一个PPT算法 $\mathcal{A’}$ ，使得对任何 $S\subseteq {0,1}^l$ 和任何函数 $f: {0,1}^l\rightarrow{0,1}$ ，存在一个可忽略函数 $negl$ 使得：<br>$$<br>|Pr[\mathcal{A}(1<sup>n,\mathsf{Enc}_k(m))=f(m)]-Pr[\mathcal{A’}(1</sup>n)=f(m)]|\leq \mathsf{negl}(n)<br>$$</li></ul></li></ul><h3 id="3-3-构建安全加密方案">3.3 构建安全加密方案</h3><h4 id="伪随机生成器">伪随机生成器</h4><p>伪随机生成器 $G$ 是一个高效、确定性的算法，用于将一个短的、均匀的字符串 (seed) 转变为一个长的、伪随机的字符串</p><ul><li>定义3.14：令 $l$ 为一个多项式，$G$ 为一个确定性多项式时间算法，使得对任何 $n$ 和输入 $s\in{0,1}^n$ ，输出 $G(s)$ 是一个长度为 $l(n)$ 的字符串。称 $G$ 是一个伪随机生成器，如果满足：<ol><li>扩展性：对任意 $n$ 满足 $l(n)&gt;n$</li><li>伪随机性：对任意PPT算法 $D$ ，存在一个可忽略函数使得：【其中 $r\in {0,1}^{l(n)}$】<br>$$<br>|Pr[D(G(s))=1]-Pr[D®=1]|\leq \mathsf{negl}(n)<br>$$</li></ol><ul><li>称 $l$ 为 $G$ 的扩展系数</li></ul></li><li>之所以生成的字符串是伪随机而不是均匀的，举例说明：$l(n)=2n$ 时，长度为 $2n$ 的字符串空间为 $2^{2n}$ ，选择任意一个 $r\in {0,1}^{2n}$ 的概率为 $1/2^{2n}$ ，是均匀的；但是由于 $s$ 的长度为 $n$ ，所以 $G(s)$ 的字符串空间为 $2^n$ ，选择到的概率为 $1/2^n$ ，不是均匀的</li></ul><h4 id="流密码">流密码</h4><p>流密码是一对确定性算法 $(\mathsf{Init}, \mathsf{GetBits})$</p><ul><li>$\mathsf{Init}$ 输入seed $s$ 和可选的初始化向量 $IV$ ，输出初始状态 $st_0$</li><li>$\mathsf{GetBits}$ 输入状态信息 $st_i$ ，输出一个比特 $y$ 并更新状态到 $st_{i+1}$</li></ul><p>算法3.16：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/qyC5GXi1vlcpYNf.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/qyC5GXi1vlcpYNf.png" srcset="data:image/png;base64,666" alt="image-20220301165707241" style="zoom: 60%;" /><h4 id="规约证明">规约证明</h4><p>将证明一个敌手 $\mathcal{A}$ 成功破解一个方案 转换为 证明一个算法 $\mathcal{A’}$ 解决一个难题，具体步骤如下：</p><ol><li>选定一个敌手 $\mathcal{A}$ 攻击 $\Pi$ ，攻击成功的概率为 $\varepsilon(n)$ ；</li><li>构建一个算法 $\mathcal{A’}$ ，它使用敌手 $\mathcal{A}$ 作为子程序来尝试解决问题 $X$ 。注意： $\mathcal{A’}$ 不知道 $\mathcal{A}$ 是如何工作的，它只知道 $\mathcal{A}$ 要攻击 $\Pi$ 。当输入一个问题 $X$ 的实例 $x$ 时， $\mathcal{A’}$ 为 $\mathcal{A}$ <strong>模拟</strong>一个 $\Pi$ 的实例，使得：<ol><li>$\mathcal{A}$ 无法区分自己是作为 $\mathcal{A’}$ 的子程序在运行还是其本身在攻击 $\Pi$ ；</li><li>如果 $\mathcal{A}$ 成功破解  $\mathcal{A’}$ 模拟的 $\Pi$ ，则  $\mathcal{A’}$ 能解决问题 $x$ ，其概率至少为 $1/p(n)$ ；</li></ol></li><li>根据上一点， $\mathcal{A’}$ 解决 $X$ 的概率为 $\varepsilon(n)/p(n)$ 。若 $\varepsilon(n)$ 不是可忽略的，则 $\varepsilon(n)/p(n)$ 也不是可忽略的，从而得到一个算法 $\mathcal{A’}$ 以不可忽略的概率解决 $X$ ，与假设（ $X$ 是一个计算难题，无法在多项式时间内解决）矛盾；</li><li>综上，如果 $X$ 确实是计算难题，则没有 $\mathcal{A}$ 能以不可忽略的概率破解 $\Pi$ 。换言之， $\Pi$ 是计算安全的。</li></ol><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301191556727.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301191556727.png" srcset="data:image/png;base64,666" alt="image-20220301191556727" style="zoom: 50%;" /><h4 id="安全的定长加密方案">安全的定长加密方案</h4><p>用生成器对密钥进行扩充，以达到一次一密的效果</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301195150132.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301195150132.png" srcset="data:image/png;base64,666" alt="image-20220301195150132" style="zoom: 50%;" /><p>具体构造3.17如下：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301195704054.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301195704054.png" srcset="data:image/png;base64,666" alt="image-20220301195704054" style="zoom:67%;" /><ul><li>定理3.18：如果 $G$ 是伪随机生成器，则上述构造的加密方案是EAV-安全的</li></ul><hr><p>规约证明3.18：</p><p>使用 $\mathcal{A}$ 来构造一个判别器 $D$ ，将 $\mathcal{A}$ 正确选择 $\Pi$ 加密的消息的能力规约到 $D$ 分辨 $G$ 的输出和均匀字符串的能力，从而由 $G$ 的安全性能推导出 $\Pi$ 的安全性。</p><p>$D$ 的构造如下，$D$ 的目标是分辨输入 $w$ 是随机串还是由伪随机生成器生成的：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301201750903.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220301201750903.png" srcset="data:image/png;base64,666" alt="image-20220301201750903" style="zoom:50%;" /><p>定义 $\widetilde{\Pi}=(\widetilde{\mathsf{Gen}},\widetilde{\mathsf{Enc}},\widetilde{\mathsf{Dec}})$ 为一次一密方案：</p><ul><li>$\widetilde{\mathsf{Gen}}(1^n)$ 输出长度为 $l(n)$ 的密钥 $k$ ；</li><li>$\widetilde{\mathsf{Enc}}$ 使用 $k$ 加密长度为 $l(n)$ 的消息：$c:=k\oplus m$ ；</li></ul><p>根据一次一密的perfect secrecy：<br>$$<br>Pr[\mathsf{PrivK}^{eav}_{\mathcal{A},\widetilde{\Pi}}(n)=1]=\frac{1}{2} \tag{3.3}<br>$$</p><p>对 $D$ 进行分析：</p><ol><li>若 $w$ 是从 ${0,1}^{l(n)}$ 中均匀选出的，则 $\mathcal{A}$ 作为 $D$ 的子程序运行的视图和在实验 $\mathsf{PrivK}^{eav}<em>{\mathcal{A},\widetilde{\Pi}}(n)$ 中的视图完全一致，即：<br>$$<br>Pr</em>{w\leftarrow {0,1}<sup>{l(n)}}[D(w)=1]=Pr[\mathsf{PrivK}</sup>{eav}_{\mathcal{A},\widetilde{\Pi}}(n)=1]=\frac{1}{2} \tag{3.4}<br>$$</li><li>若 $w$ 是通过 $w=G(k),,k\in {0,1}^n$ 生成的，则 $\mathcal{A}$ 作为 $D$ 的子程序运行的视图和在实验 $\mathsf{PrivK}^{eav}<em>{\mathcal{A},\Pi}(n)$ 中的视图完全一致，即<br>$$<br>Pr</em>{k\leftarrow {0,1}<sup>n}[D(G(k))=1]=Pr[\mathsf{PrivK}</sup>{eav}_{\mathcal{A},\Pi}(n)=1] \tag{3.5}<br>$$</li></ol><p>由于 $G$ 是伪随机生成器，所以存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>|Pr_{w\leftarrow {0,1}^{l(n)}}[D(w)=1]-Pr_{k\leftarrow {0,1}^n}[D(G(k))=1]|\leq \mathsf{negl}(n)<br>$$</p><p>根据公式 $(3.4),,(3.5)$ 得：<br>$$<br>|\frac{1}{2}-Pr[\mathsf{PrivK}^{eav}_{\mathcal{A},\Pi}(n)=1]|\leq \mathsf{negl}(n)<br>$$</p><p>即 $Pr[\mathsf{PrivK}^{eav}_{\mathcal{A},\Pi}(n)=1]\leq \frac{1}{2}+\mathsf{negl}(n)$ ，从而方案 $\Pi$ 是EAV-安全的。</p><hr><h3 id="3-4-更强的安全概念">3.4 更强的安全概念</h3><h4 id="多消息加密——修改安全目标">多消息加密——修改安全目标</h4><ul><li>多消息窃听实验 $\mathsf{PrivK}^\mathsf{mult}_{\mathcal{A},\Pi}(n)$ ：<ol><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ ，并输出一对相同长度的消息列表： $\vec{M_0}=(m_{0,1},…,m_{0,t})$ 和 $\vec{M_1}=(m_{1,1},…,m_{1,t})$ ，其中 $|m_{0,i}|=|m_{1,i}|$ ；</li><li>$k\leftarrow \mathsf{Gen(1^n)}$ ，并随机选择 $b\in{0,1}$ 。对所有 $i$ ，计算 $c_i\leftarrow \mathsf{Enc}<em>k(m</em>{b,i})$ ，将 $\vec{C}=(c_1,…,c_t)$ 发送给 $\mathcal{A}$ ；</li><li>$\mathcal{A}$ 输出一比特 $b’$ ；</li><li>若 $b=b’$ 则实验输出1，$\mathcal{A}$ 获胜，反之输出0。</li></ol></li><li>定义3.19：一个对称加密方案 $\Pi=(\mathsf{Gen,Enc,Dec})$ 是多消息EAV-安全的，如果对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{PrivK}^\mathsf{mult}_{\mathcal{A},\Pi}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$</li><li>命题3.20：存在一个对称加密算法是EAV-安全的，但不是多消息EAV-安全的。【eg. 一次一密】</li><li>定理3.21：如果 $\Pi$ 是一个无状态的加密方案且 $\mathsf{Enc}$ 是确定性算法，则 $\Pi$ 不可能是多消息EAV-安全的。</li></ul><h4 id="CPA-安全（选择明文攻击）——增强威胁模型">CPA-安全（选择明文攻击）——增强威胁模型</h4><ul><li>CPA不可区分实验 $\mathsf{PrivK}^\mathsf{cpa}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$k\leftarrow \mathsf{Gen(1^n)}$ ；</li><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\mathsf{Enc}_k(\cdot)$，输出一对相同长度的消息 $m_0$ 和 $m_1$ ；</li><li>随机选择 $b\in{0,1}$ ，计算 $c\leftarrow \mathsf{Enc}<em>k(m</em>{b})$ ，并发送给 $\mathcal{A}$ ；</li><li>$\mathcal{A}$ 输出一比特 $b’$ ；</li><li>若 $b=b’$ 则实验输出1，$\mathcal{A}$ 获胜，反之输出0。</li></ol></li><li>定义3.22：对称加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是<strong>CPA-安全</strong>的（对选择明文攻击不可区分），如果对所有PPT敌手 $\mathcal{A}$ 有一个可忽略函数 $\mathsf{negl}$ ，使得对所有n：<br>$$Pr[\mathsf{PrivK}^\mathsf{cpa}_{\mathcal{A},\Pi}(n)=1]\leq \frac{1}{2}+\mathsf{negl}(n)$$</li></ul><h4 id="多消息加密的CPA-安全">多消息加密的CPA-安全</h4><ul><li>定义oracle $\mathsf{LR}_{k,b}(\cdot,\cdot)$ ：输入两个等长的消息 $m_0$ ，$m_1$ ，若 $b=0$ 输出 $c\leftarrow \mathsf{Enc}_k(m_0)$ ；若 $b=1$ 输出 $c\leftarrow \mathsf{Enc}_k(m_1)$</li><li>LR-oracle实验 $\mathsf{PrivK}^\mathsf{LR-cpa}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$k\leftarrow \mathsf{Gen(1^n)}$ ；</li><li>随机选择 $b\in{0,1}$ ；</li><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\mathsf{LR}<em>{k,b}(\cdot,\cdot)$ 【 $\mathcal{A}$ 能通过请求 $\mathsf{LR}</em>{k,b}(m_{0,1},m_{1,1})$,…,$\mathsf{LR}<em>{k,b}(m</em>{0,t},m_{1,t})$ 来获取消息列表的加密结果，同时也可以通过请求 $\mathsf{LR}_{k,b}(m,m)$ 来获得 $\mathsf{Enc}_k(m)$ 】，输出一对相同长度的消息 $m_0$ 和 $m_1$ ；</li><li>计算 $c\leftarrow \mathsf{Enc}<em>k(m</em>{b})$ ，并发送给 $\mathcal{A}$ ；</li><li>$\mathcal{A}$ 输出一比特 $b’$ ；</li><li>若 $b=b’$ 则实验输出1，$\mathcal{A}$ 获胜，反之输出0。</li></ol></li><li>定义3.23：对称加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是多消息CPA-安全的，如果对所有PPT敌手 $\mathcal{A}$ 有一个可忽略函数 $\mathsf{negl}$ ，使得对所有n：<br>$$Pr[\mathsf{PrivK}^\mathsf{LR-cpa}_{\mathcal{A},\Pi}(n)=1]\leq \frac{1}{2}+\mathsf{negl}(n)$$</li><li>定理3.24：任何CPA-安全的对称加密方案都是多消息CPA-安全的</li></ul><h3 id="3-5-构造CPA-安全的加密方案">3.5 构造CPA-安全的加密方案</h3><h4 id="伪随机函数">伪随机函数</h4><ul><li>定义keyed函数 $F(k,x):{0,1}^<em>\times {0,1}^</em>\rightarrow {0,1}^<em>$ ，一般而言可以固定密钥 $k$ ，记作 $F_k(x)=F(k,x)$ ，而 $F_k(x):{0,1}^</em>\rightarrow {0,1}^*$ 。安全参数 $n$ 规定了密钥、输入、输出的长度，从而 $F_k(x)$ 是条件 $k\in{0,1}^n$ 下的一个将长度为 $n$ 的输入映射到长度为 $n$ 的输出的函数。<ul><li>称函数 $F$ 是伪随机的，如果 $F_k(x)$ 与 $f:{0,1}^n\rightarrow {0,1}^n$ 不可区分【所有 $f$ 的集合记作 $\mathsf{Func}_n$】<ul><li>可以将 $f$ 看作一个表，根据长度 $n$ 的输入查表得到长度 $n$ 的输出，输入可以固定顺序为 $0^n$ 到 $1^n$ ，则该表有 $2^n$ 行，每个输入对应的输出长度为 $n$ ，即每行长度为 $n$ ，因此函数 $f$ 可以看作一个长度为 $2^n\cdot n$ 的序列，从而 $f$ 的取值空间大小为 $2<sup>{2</sup>n\cdot n}$ 【$F_k$ 的取值空间为 $2^n$】</li></ul></li></ul></li><li>定义3.25：令 $F:{0,1}^<em>\times {0,1}^</em>\rightarrow {0,1}^*$ 为一个keyed函数。$F$ 是一个伪随机函数，如果对所有PPT判别器 $D$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>|Pr[D<sup>{F_k(\cdot)}(1</sup>n)=1]-Pr[D<sup>{f(\cdot)}(1</sup>n)=1]|\leq\mathsf{negl}(n)<br>$$<ul><li>注：$D$ 并不知道具体的 $k$</li></ul></li></ul><h4 id="伪随机排列">伪随机排列</h4><ul><li>令 $\mathsf{Perm}_n$ 是 ${0,1}^n$ 的全排列，大小为 $(2^n)!$<ul><li>若函数 $f\in\mathsf{Perm}_n$ ，说明不同输入映射到的输出是不同的</li><li>$F$ 是一个keyed排列，如果 $F_k$ 的值是全排列； $F$ 是efficient的，如果可以在多项式时间内计算 $F_k(x)$ 和 $F_k^{-1}(y)$</li><li>$F$ 是伪随机排列，如果 $F_k(x)$ 与 $f\in\mathsf{Perm}_n$ 不可区分</li></ul></li><li>命题3.27：如果 $F$ 是一个伪随机排列且 $l_{in}(n)\geq n$ ，则 $F$ 也是一个伪随机函数</li><li>定义3.28：令 $F:{0,1}^<em>\times {0,1}^</em>\rightarrow {0,1}^*$ 为一个keyed排列。$F$ 是一个强伪随机排列，如果对所有PPT判别器 $D$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>|Pr[D<sup>{F_k(\cdot),F_k</sup>{-1}(\cdot)}(1<sup>n)=1]-Pr[D</sup>{f(\cdot),f<sup>{-1}(\cdot)}(1</sup>n)=1]|\leq\mathsf{negl}(n)<br>$$</li></ul><h4 id="伪随机函数与伪随机生成器的关系">伪随机函数与伪随机生成器的关系</h4><ul><li>伪随机生成器 $G$ 可以由伪随机函数 $F$ 得到：$G(s)=F_s(1)||F_s(2)||…||F_s(l)$</li><li>根据伪随机函数构造流密码3.29：</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303095334545.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303095334545.png" srcset="data:image/png;base64,666" alt="image-20220303095334545" style="zoom:50%;" /><h4 id="伪随机函数构造的CPA-安全加密">伪随机函数构造的CPA-安全加密</h4><ul><li><strong>证明基于伪随机函数的构造的安全性</strong>：首先假设构造中的伪随机函数被以一个随机函数替换，再通过规约证明来说明这个改变不会影响敌手成功的概率，最后再证明修改后的构造是安全的</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303100249230.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303100249230.png" srcset="data:image/png;base64,666" alt="image-20220303100249230" style="zoom:50%;" /><ul><li>构造3.30：<ul><li>缺点在于生成的密文长度是明文的两倍</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303100951250.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303100951250.png" srcset="data:image/png;base64,666" alt="image-20220303100951250" style="zoom:50%;" /><ul><li>定理3.31：如果 $F$ 是一个伪随机函数，则上述构造是CPA-安全的【证明on P83】</li></ul><h3 id="3-6-工作模式">3.6 工作模式</h3><h4 id="流密码的工作模式">流密码的工作模式</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303152324480.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303152324480.png" srcset="data:image/png;base64,666" alt="image-20220303152324480" style="zoom:50%;" /><ul><li>同步模式：有状态，需要通信双方同步，基于算法3.16和构造3.17<ol><li>令发送方为A，接收方为B，双方计算 $\mathsf{st}_0:=\mathsf{Init}(k)$</li><li>发送第一条长度为 $l_1$ 的消息 $m_1$ ，A根据 $\mathsf{st}<em>0$ 运行 $l_1$ 次 $\mathsf{GetBits}$ ，得到 $\mathsf{pad}<em>1\overset{def}{=}y_1,…,y</em>{l_1}$ 并更新状态到 $\mathsf{st}</em>{l_1}$ ，然后发送 $c_1:=\mathsf{pad}_1 \oplus m_1$ ；而B解密通过 $m_1:=\mathsf{pad}_1 \oplus c_1$</li><li>发送第二条长度为 $l_2$ 的消息 $m_2$ ，A根据 $\mathsf{st}<em>{l_1}$ 运行 $l_2$ 次 $\mathsf{GetBits}$ ，得到 $\mathsf{pad}<em>2\overset{def}{=}y</em>{l_1+1},…,y</em>{l_1+l_2}$ 并更新状态到 $\mathsf{st}_{l_1+l_2}$ ，然后发送 $c_2:=\mathsf{pad}_2 \oplus m_2$ ；而B解密通过 $m_2:=\mathsf{pad}_2 \oplus c_2$ ，以此类推</li></ol></li><li>自同步模式：无状态CPA-安全，基于构造3.30，其中的 $F_k(IV)\overset{def}{=}G_\infty(k,IV,1^l)$</li></ul><h4 id="分组密码的工作模式">分组密码的工作模式</h4><p>使用分组密码构造CPA-安全的加密方案，改进构造3.30，使得密文长度减小。令 $F$ 为分组长度为 $n$ 的分组密码，需要加密的消息记为 $m=m_1,m_2,…,m_l$ 且 $m_i\in{0,1}^n$</p><ul><li>ECB模式（Electronic Code Book）：$c:=\langle F_k(m_1),…,F_k(m_l)\rangle$ ，它是确定性算法，因此不是CPA-安全的，同时它也不是EAV-安全的，因为每一个分组的block都相同</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303162800363.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303162800363.png" srcset="data:image/png;base64,666" alt="image-20220303162800363" style="zoom:50%;" /><ul><li><p>CBC模式（Cipher Block Chaining）：概率性算法，若 $F$ 是一个伪随机排列，则CBC-模式加密是CPA-安全的</p><ul><li><p>缺点：加解密只能串行，不能并行，因为后面的block依赖于前面block的输出</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303164215246.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303164215246.png" srcset="data:image/png;base64,666" alt="image-20220303164215246" style="zoom:50%;" /></li><li><p>链式CBC：对一种选择明文攻击不安全，构造攻击如下：</p><ul><li><p>假设敌手知道 $m_1\in{m_1<sup>0,m_1</sup>1}$ ，并且得到了密文 $IV,c_1,c_2,c_3$ ，接着构造 $m_4=IV\oplus m_1^0\oplus c_3$ ，得到输出 $c_4$ 。从而可以得出 $m_1=m_1^0$ 当且仅当 $c_4=c_1$ ，因此敌手可以从 ${m_1<sup>0,m_1</sup>1}$ 中选出正确的 $m_1$</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303165103210.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303165103210.png" srcset="data:image/png;base64,666" alt="image-20220303165103210" style="zoom:50%;" /></li></ul></li></ul></li><li><p>OFB模式（Output Feedback）：可以看作是自同步流密码，$F$ 不需要是一个伪随机排列，消息长度不需要进行填充，且每一步的状态都是保密的。若 $F$ 是一个伪随机函数，则OFB模式是CPA-安全的。虽然加解密都只能串行执行，但是加解密用的伪随机串可以提前计算</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303174616670.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303174616670.png" srcset="data:image/png;base64,666" alt="image-20220303174616670" style="zoom:50%;" /></li><li><p>CTR模式（Counter）：也可以看作自同步流密码，具体构造如下：</p><ul><li><p>选择一个随机值 $\mathsf{ctr}\in{0,1}^n$ ，计算伪随机串 $y_i:=F_k(\mathsf{ctr}+i)$ 【其中 $\mathsf{ctr}+i$ 是整数模 $2^n$ 相加】，从而第 $i$ 个密文块为 $c_i:=y_i\oplus m_i$</p></li><li><p>$F$ 不需要是一个伪随机排列，消息长度不需要进行填充，且每一步的状态都是保密的，加解密可以并行执行，且伪随机串可以提前计算</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303175738684.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220303175738684.png" srcset="data:image/png;base64,666" alt="image-20220303175738684" style="zoom:50%;" /></li><li><p>定理3.32：若 $F$ 是一个伪随机函数，则CRT模式是CPA-安全的。【证明on P93】</p></li></ul></li></ul><h3 id="3-7-选择密文攻击">3.7 选择密文攻击</h3><h4 id="CCA-安全">CCA-安全</h4><ul><li>CCA不可区分实验 $\mathsf{PrivK}^\mathsf{cca}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$k\leftarrow \mathsf{Gen(1^n)}$ ；</li><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\mathsf{Enc}_k(\cdot)$ 和 $\mathsf{Dec}_k(\cdot)$ ，输出一对相同长度的消息 $m_0$ 和 $m_1$ ；</li><li>随机选择 $b\in{0,1}$ ，计算 $c\leftarrow \mathsf{Enc}<em>k(m</em>{b})$ ，并发送给 $\mathcal{A}$ ；</li><li>$\mathcal{A}$ 可以继续使用 $\mathsf{Enc}_k(\cdot)$ 和 $\mathsf{Dec}_k(\cdot)$ ，但不能对挑战密文使用 $\mathsf{Dec}_k(\cdot)$。最终 $\mathcal{A}$ 输出一比特 $b’$ ；</li><li>若 $b=b’$ 则实验输出1，$\mathcal{A}$ 获胜，反之输出0。</li></ol></li><li>定义3.33：对称加密方案 $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是<strong>CCA-安全</strong>的（对选择密文攻击不可区分），如果对所有PPT敌手 $\mathcal{A}$ 有一个可忽略函数 $\mathsf{negl}$ ，使得对所有n：<br>$$Pr[\mathsf{PrivK}^\mathsf{cca}_{\mathcal{A},\Pi}(n)=1]\leq \frac{1}{2}+\mathsf{negl}(n)$$</li><li>注：任何CCA-安全的对称加密方案都是多消息CCA-安全的</li><li>之前所讨论的所有加密方案都不是CCA安全的，例如对于构造3.30：敌手选择 $m_0=0<sup>n,,m_1=1</sup>n$ ，在收到密文 $c=\langle r,s\rangle$ 之后，敌手反转 $s$ 的第一位，并将新的密文 $c’=\langle r,s’\rangle$ 发送到 $\mathsf{Dec}_k(\cdot)$ 进行解密，若结果是 $10^{n-1}$ 说明 $b=0$ ，若结果是 $01^{n-1}$ 说明 $b=1$<ul><li>CCA-安全的一个重要性质是non-malleability，即对于一个密文，若对其做一些修改，则解密要么无效要么结果与原本的结果毫无关系</li></ul></li></ul><h4 id="Padding-Oracle-Attacks">Padding-Oracle Attacks</h4><p>攻击者只需要知道修改后的密文是否能够有效解密，具体攻击方法见P98</p><h2 id="Chapter-4-Message-Authentication-Codes">Chapter 4: Message Authentication Codes</h2><h3 id="4-2-MAC（消息认证码）定义">4.2 MAC（消息认证码）定义</h3><ul><li>定义4.1：一个MAC包含三个PPT算法 $(\mathsf{Gen},\mathsf{Mac},\mathsf{Vrfy})$ ：满足 $\mathsf{Vrfy}_k(m,\mathsf{Mac}_k(m))=1$<ul><li>$\mathsf{Gen}$ 根据输入安全参数 $1^n$ ，输出密钥 $k,,|k|\geq n$</li><li>$\mathsf{Mac}$ 根据输入密钥 $k$ 和消息 $m\in{0,1}^*$ ，输出一个标签 $t$ ，即 $t\leftarrow \mathsf{Mac}_k(m)$</li><li>$\mathsf{Vrfy}$ 是确定性算法，根据输入密钥 $k$ 、消息 $m$ 和标签 $t$ ，输出一比特 $b$ ，即 $b:=\mathsf{Vrfy}_k(m,t)$ 。若 $b=1$ 说明验证通过</li></ul></li><li>消息认证实验 $\mathsf{Mac{-}forge}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$k\leftarrow \mathsf{Gen}(1^n)$</li><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\mathsf{Mac}_k(\cdot)$ 。敌手最终输出 $(m,t)$ 。令 $\mathcal{Q}$ 表示 $\mathcal{A}$ 对oracle的所有请求集合</li><li>$\mathcal{A}$ 成功当且仅当(1). $\mathsf{Vrfy}_k(m,t)=1$ 和(2). $m\notin \mathcal{Q}$ ，此时实验输出1</li></ol></li><li>定义4.2：MAC算法 $\Pi=(\mathsf{Gen},\mathsf{Mac},\mathsf{Vrfy})$ 是安全的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{Mac{-}forge}_{\mathcal{A},\Pi}(n)=1]\leq \mathsf{negl}(n)<br>$$<ul><li>以上定义的安全的MAC算法不能抵抗重放攻击，因为它不对消息的状态进行验证，只要 $(m,t)$ 是有效的就可以通过验证</li></ul></li><li>消息认证增强实验 $\mathsf{Mac{-}sforge}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$k\leftarrow \mathsf{Gen}(1^n)$</li><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ 并能够使用oracle $\mathsf{Mac}_k(\cdot)$ 。敌手最终输出 $(m,t)$ 。令 $\mathcal{Q}$ 表示所有的请求过的 $(m,t)$ 集合</li><li>$\mathcal{A}$ 成功当且仅当(1). $\mathsf{Vrfy}_k(m,t)=1$ 和(2). $(m,t)\notin \mathcal{Q}$ ，此时实验输出1</li></ol></li><li>定义4.3：MAC算法 $\Pi=(\mathsf{Gen},\mathsf{Mac},\mathsf{Vrfy})$ 是强安全的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{Mac{-}sforge}_{\mathcal{A},\Pi}(n)=1]\leq \mathsf{negl}(n)<br>$$</li><li>命题4.4：令 $\Pi=(\mathsf{Gen},\mathsf{Mac},\mathsf{Vrfy})$ 是一个安全的MAC算法，则它也是强安全的</li></ul><h3 id="4-3-构造安全MAC">4.3 构造安全MAC</h3><h4 id="固定长度MAC">固定长度MAC</h4><ul><li><p>构造4.5：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220309154102645.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220309154102645.png" srcset="data:image/png;base64,666" alt="image-20220309154102645" style="zoom:50%;" /></li><li><p>定理4.6：若 $F$ 是一个伪随机函数，则构造4.5对于长度为 $n$ 的消息是安全的MAC【证明on P117】</p></li></ul><h4 id="任意长度MAC">任意长度MAC</h4><ul><li><p>构造4.7：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220309192522010.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220309192522010.png" srcset="data:image/png;base64,666" alt="image-20220309192522010" style="zoom:50%;" /></li><li><p>定理4.8：如果 $\Pi’$ 是安全的定长MAC，则构造4.7也是安全MAC【证明on P120】</p></li></ul><h3 id="4-4-CBC-MAC">4.4 CBC-MAC</h3><ul><li><p>基本构造4.11（定长CBC-MAC）：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220309203451905.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220309203451905.png" srcset="data:image/png;base64,666" alt="image-20220309203451905" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220310102020862.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220310102020862.png" srcset="data:image/png;base64,666" alt="image-20220310102020862" style="zoom:50%;" /></li><li><p>定理4.12：令 $\ell$ 为多项式，若 $F$ 是伪随机函数，则构造4.11是对长度为 $\ell(n)\cdot n$ 的消息的安全MAC</p></li><li><p>构造任意长度的CBC-MAC</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220310102128970.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220310102128970.png" srcset="data:image/png;base64,666" alt="image-20220310102128970" style="zoom:50%;" /></li><li><p>*安全性证明on P125，包括：</p><ul><li>定理4.13</li><li>断言4.14</li><li>断言4.15</li></ul></li></ul><h3 id="4-5-认证加密">4.5 认证加密</h3><h4 id="定义">定义</h4><ul><li>不可伪造加密实验 $\mathsf{Enc{-}Forge}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$k\leftarrow \mathsf{Gen}(1^n)$</li><li>敌手 $\mathcal{A}$ 得到输入 $1^n$ 并能够使用加密oracle $\mathsf{Enc}_k(\cdot)$ 。敌手最终输出密文 $c$</li><li>令 $m:=\mathsf{Dec}_k©$ ，令 $\mathcal{Q}$ 表示 $\mathcal{A}$ 对加密oracle的所有请求集合。实验输出1当且仅当(1) $m\neq\perp$ 和(2) $m\notin \mathcal{Q}$</li></ol><ul><li>若敌手可以伪造一个密文，使其能够成功解密，则敌手获胜</li></ul></li><li>定义4.16：一个对称加密方案 $\Pi$ 是不可伪造的，如果对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{Enc{-}Forge}_{\mathcal{A},\Pi}(n)=1]\leq\mathsf{negl}(n)<br>$$</li><li>定义4.17：一个对称加密方案是一个认证加密方案，如果它既是CCA-安全的又是不可伪造的</li></ul><h4 id="一般构造">一般构造</h4><ul><li><p>Encrypt-and-authenticate：<br>$$<br>c\leftarrow\mathsf{Enc}<em>{k_E}(m),,and,,t\leftarrow\mathsf{Mac}</em>{k_E}(m)<br>$$</p><ul><li>不能保证基本的安全性，因为MAC并没有机密性要求，从而可能泄露关于 $m$ 的信息</li></ul></li><li><p>Authenticate-then-encrypt：<br>$$<br>t\leftarrow\mathsf{Mac}<em>{k_E}(m),,and,,c\leftarrow\mathsf{Enc}</em>{k_E}(m||t)<br>$$</p><ul><li>不能保证一定是认证加密方案，例如对于CBC模式加密，将 $t$ 看作是对消息 $m$ 的填充，则对于解密失败存在两种情况：填充错误或MAC验证失败，但只要攻击者能分辨两种错误，就可以正确解密，如3.7节最后的Padding-Oracle Attacks所示</li></ul></li><li><p>Encrypt-then-authenticate：<br>$$<br>c\leftarrow\mathsf{Enc}<em>{k_E}(m),,and,,t\leftarrow\mathsf{Mac}</em>{k_E}©<br>$$</p><ul><li><p>正式构造4.18如下：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220310214450995.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220310214450995.png" srcset="data:image/png;base64,666" alt="image-20220310214450995" style="zoom:50%;" /></li><li><p>定理4.19：令 $\Pi_E$ 是CPA-安全的对称加密方案， $\Pi_M$ 是强安全的MAC，则构造4.18是认证加密方案【证明on P136】</p></li></ul></li></ul><h2 id="Chapter-5-Hash-Functions-and-Applications">Chapter 5: Hash Functions and Applications</h2><h3 id="5-1-定义">5.1 定义</h3><h4 id="抗碰撞">抗碰撞</h4><ul><li>定义5.1：哈希函数是一对PPT算法 $(\mathsf{Gen},H)$ ，满足：<ul><li>$\mathsf{Gen}$ 是一个概率算法，输入安全参数 $1^n$ ，输出密钥 $s$ 。假设 $1^n$ 隐含在 $s$ 中</li><li>$H$ 根据输入密钥 $s$ 和字符串 $x\in{0,1}^*$ ，输出字符串 $H<sup>s(x)\in{0,1}</sup>{\ell(n)}$</li></ul></li><li>collision-finding实验 $\mathsf{Hash{-}coll}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$s\leftarrow\mathsf{Gen}(1^n)$</li><li>敌手 $\mathcal{A}$ 根据输入 $s$ 输出 $x,x’$</li><li>实验输出1当且仅当 $x\neq x’$ 且 $H<sup>s(x)=H</sup>s(x’)$ ，此时称 $\mathcal{A}$ 找到了碰撞</li></ol></li><li>定义5.2：哈希函数 $\Pi=(\mathsf{Gen},H)$ 是抗碰撞的，如果对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{Hash{-}coll}_{\mathcal{A},\Pi}(n)=1]\leq \mathsf{negl}(n)<br>$$</li><li>在实际应用中，哈希函数通常是unkeyed的，即 $H: {0,1}<sup>*\rightarrow{0,1}</sup>\ell$ ，从理论的角度这是不安全的，因为所有哈希函数在生成的时候就硬编码了碰撞对 $(x,x’)$ ，但是实践中找到这样的碰撞对是困难的，因此unkeyed哈希函数还是计算安全的</li></ul><h4 id="较弱的安全概念">较弱的安全概念</h4><ul><li>弱抗碰撞性（抗第一原像）：给定 $s,x$ ，PPT敌手找到 $x’\neq x$ 使得 $H<sup>s(x’)=H</sup>s(x)$ 是不可行的</li><li>单向性（抗第二原像）：给定 $s,y$ ，PPT敌手找到 $x$ 使得 $H^s(x)=y$ 是不可行的</li><li>抗碰撞 =&gt; 弱抗碰撞 =&gt; 单向</li></ul><h3 id="5-2-域扩张：Merkle-Damgard变换">5.2 域扩张：Merkle-Damgard变换</h3><p>用于将压缩函数扩展为完整的哈希函数，同时保持前者的抗碰撞性</p><ul><li><p>将定长输入的哈希函数通过Merkle-Damgard变换转换为任意长度输入的哈希函数，构造5.3：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220311200724075.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220311200724075.png" srcset="data:image/png;base64,666" alt="image-20220311200724075" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220311203720834.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220311203720834.png" srcset="data:image/png;base64,666" alt="image-20220311203720834" style="zoom:50%;" /></li><li><p>定理5.4：如果 $(\mathsf{Gen},h)$ 是抗碰撞的，则 $(\mathsf{Gen},H)$ 也是抗碰撞的【证明on P157】【形式化证明on 练习5.4】</p></li></ul><h3 id="5-3-使用哈希函数实现消息认证">5.3 使用哈希函数实现消息认证</h3><h4 id="Hash-and-MAC">Hash-and-MAC</h4><ul><li><p>构造5.5：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220312141612142.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220312141612142.png" srcset="data:image/png;base64,666" alt="image-20220312141612142" style="zoom:50%;" /></li><li><p>定理5.6：若 $\Pi$ 是对长 $\ell$ 的消息安全的MAC，且 $\Pi_H$ 是抗碰撞的，则构造5.5是对任意长消息安全的MAC【证明on P160】</p></li></ul><h4 id="HMAC">HMAC</h4><ul><li><p>构造5.7：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220312165332394.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220312165332394.png" srcset="data:image/png;base64,666" alt="image-20220312165332394" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220312165355002.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220312165355002.png" srcset="data:image/png;base64,666" alt="image-20220312165355002" style="zoom:50%;" /></li></ul><h3 id="5-5-Random-Oracle模型">5.5 Random-Oracle模型</h3><ul><li>向oracle查询 $x$ 并得到输出 $y$ ，$x$ 是保密的，甚至查询oracle这个事件本身也是保密的</li><li>一致性：若对特定的输入 $x$ ，oracle输出 $y$ ，则之后再输入相同的 $x$ ，oracle仍然输出 $y$</li><li>一些性质：<ul><li>若 $x$ 没有发送到 $H$ 进行查询，则 $H(x)$ 的值是均匀随机的<ul><li>即使 $x$ 不是随机的，甚至 $x$ 是已知的， $H(x)$ 的值也是均匀随机的</li></ul></li><li>若 $\mathcal{A}$ 向 $H$ 请求 $x$ ，则规约过程可以看到这个请求，也能知道 $x$</li><li>规约过程可以设置 $H(x)$ 的值，只要这个值是均匀随机分布的</li></ul></li></ul><h4 id="Random-Oracle实例">Random-Oracle实例</h4><p>假设Random-Oracle将 $\ell_{in}$ 比特输入映射为 $\ell_{out}$ 比特输出，且 $\ell_{in},\ell_{out}&gt;n$</p><ul><li>Random-Oracle作伪随机生成器（$\ell_{in}&lt;\ell_{out}$）<ul><li>$|Pr[\mathcal{A}<sup>{H(\cdot)}(y)=1]-Pr[\mathcal{A}</sup>{H(\cdot)}(H(x))=1]|\leq \mathsf{negl}(n)$ ，其中 $x\in{0,1}<sup>{\ell_{in}(n)},,y\in{0,1}</sup>{\ell{out}(n)}$</li></ul></li><li>Random-Oracle作抗碰撞哈希函数（$\ell_{in}&gt;\ell_{out}$）<ul><li>任何PPT敌手 $\mathcal{A}$ 成功进行如下实验的概率可忽略：<ol><li>选择随机函数 $F$</li><li>$\mathcal{A}$ 获胜，当他输出不同的 $x,x’$ 使得 $H(x)=H(x’)$</li></ol></li></ul></li></ul><h2 id="Chapter-7-Theoretical-Constructions-of-Symmetric-Key-Primitives">Chapter 7: Theoretical Constructions of Symmetric-Key Primitives</h2><h3 id="7-1-单向函数">7.1 单向函数</h3><h4 id="定义-v2">定义</h4><ul><li>逆转实验 $\mathsf{Invert}_{\mathcal{A},f}(n)$ ：<ol><li>随机均匀选择 $x\in{0,1}^n$ ，计算 $y:=f(x)$</li><li>$\mathcal{A}$ 根据输入 $1^n$ 和 $y$ ，得到输出 $x’$</li><li>当 $f(x’)=y$ 时，实验的输出为1，否则输出0</li></ol></li><li>定义7.1：函数 $f:{0,1}<sup>*\rightarrow{0,1}</sup>*$ 是单向函数，若满足：<ol><li>（计算简单）存在一个多项式时间算法 $M_f$ 来计算 $f$ ，即对所有 $x$ 有 $M_f(x)=f(x)$</li><li>（求逆困难）对所有PPT算法 $\mathcal{A}$ 存在一个可忽略函数使得：<br>$$<br>Pr[\mathsf{Invert}_{\mathcal{A},f}(n)=1]\leq\mathsf{negl}(n)<br>$$</li></ol><ul><li>对于2，可以将其简记为：<br>$$<br>\underset{x\leftarrow{0,1}<sup>n}{Pr}[\mathcal{A}(1</sup>n,f(x))\in f^{-1}(f(x))]\leq\mathsf{negl}(n)<br>$$</li></ul></li><li>定义7.2：PPT算法组成的元组 $\Pi=(\mathsf{Gen},\mathsf{Samp},f)$ 是一个<strong>函数族</strong>，若满足：<ol><li>参数生成算法 $\mathsf{Gen}$ 根据输入 $1^n$ ，输出参数 $I,,|I|\geq n$ 。$I$ 中的每一个值定义了函数 $f_I$ 的定义域 $\mathcal{D}_I$ 和值域 $\mathcal{R}_I$</li><li>采样算法 $\mathsf{Samp}$ 根据输入 $1^n$ ，输出 $\mathcal{D}_I$ 的一个均匀分布的元素</li><li>评估算法（确定性）$f$ 根据输入 $I$ 和 $x\in\mathcal{D}_I$ ，输出 $y\in\mathcal{R}_I$ ，记作 $y:=f_I(x)$</li></ol><ul><li>$\Pi$ 是一个<strong>排列族</strong>，若对所有 $\mathsf{Gen}(1^n)$ 输出的 $I$ 的值，满足 $\mathcal{D}_I=\mathcal{R}_I$ 且函数 $f_I:\mathcal{D}_I\rightarrow\mathcal{D}_I$ 是双射（单射且满射）</li></ul></li><li>对函数族定义逆转实验 $\mathsf{Invert}_{\mathcal{A},\Pi}(n)$ ：<ol><li>运行 $\mathsf{Gen}(1^n)$ 来获取 $I$ ，运行 $\mathsf{Samp}(I)$ 来获取随机均匀 $x\in\mathcal{D}_I$ ，最后计算 $y:=f_I(x)$</li><li>$\mathcal{A}$ 根据输入 $I,,y$，输出 $x’$</li><li>当 $f(x’)=y$ 时，实验的输出为1，否则输出0</li></ol></li><li>定义7.3：函数族/排列族 $\Pi=(\mathsf{Gen},\mathsf{Samp},f)$ 是单向的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{Invert}_{\mathcal{A},\Pi}(n)=1]\leq\mathsf{negl}(n)<br>$$</li></ul><h4 id="硬核谓词">硬核谓词</h4><ul><li>定义7.4：函数 $\mathsf{hc}:{0,1}^*\rightarrow{0,1}$ 是函数 $f$ 的硬核谓词，若 $\mathsf{hc}$ 可以在多项式时间内计算，并且对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>\underset{x\leftarrow{0,1}<sup>n}{Pr}[\mathcal{A}(1</sup>n,f(x))=\mathsf{hc}(x)]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$<ul><li>$\mathsf{hc}(x)$ 可以根据 $x$ 很容易算出，但很难根据 $f(x)$ 算出</li></ul></li></ul><h3 id="7-2-单向函数构造伪随机">7.2 单向函数构造伪随机</h3><p>Step1：说明任何单向函数都存在硬核谓词</p><ul><li>定理7.5（Goldreich–Levin定理）：假设单向函数存在，则存在一个单向函数 $g$ 和一个 $g$ 硬核谓词 $\mathsf{hc}$<ul><li>具体来说，令 $f$ 是一个单向函数，可以构造 $g(x,r)\overset{def}{=}(f(x),r),,|x|=|r|$ ，并定义：<br>$$<br>\mathsf{hc}(x,r)\overset{def}{=}\oplus^n_{i=1}x_i\cdot r_i<br>$$<br>Step2：说明单向排列的硬核谓词可以构造伪随机生成器</li></ul></li><li>定理7.6：令 $f$ 是一个单向排列，$\mathcal{hc}$ 是 $f$ 的硬核谓词，则 $G(s)\overset{def}{=}f(s)||\mathsf{hc}(s)$ 是扩张因子 $\ell(n)=n+1$ 的伪随机生成器</li><li>定理7.7：如果存在一个扩张因子 $\ell(n)=n+1$ 的伪随机生成器，则对任何多项式 $\mathsf{poly}$ 存在一个扩张因子为 $\mathsf{poly}(n)$ 伪随机生成器<br>Step3：根据伪随机生成器构造伪随机函数</li><li>定理7.8：如果存在一个扩张因子 $\ell(n)=2n$ 的伪随机生成器，则存在一个伪随机函数</li><li>定理7.9：如果存在一个伪随机函数，则存在一个强伪随机排列</li><li>推论7.10：假设存在单向函数，则存在任何扩张因子的伪随机生成器，伪随机函数，强伪随机排列</li><li>推论7.11：如果存在单向函数，则存在CCA-安全的对称加密方案以及安全的MAC</li></ul><h3 id="7-8-计算不可区分性">7.8 计算不可区分性</h3><ul><li>定义7.30：两个概率集合 $\mathcal{X}={X_n}<em>{n\in\mathbb{N}}$ 和 $\mathcal{Y}={Y_n}</em>{n\in\mathbb{N}}$ 是计算不可区分的，记作 $\mathcal{X}\overset{c}{\equiv}\mathcal{Y}$ ，若对所有PPT判别器 $D$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>|\underset{x\leftarrow X_n}{Pr}[D(1^n,x)=1]-\underset{y\leftarrow Y_n}{Pr}[D(1^n,y)=1]|\leq\mathsf{negl}(n)<br>$$<ul><li>概率集合是无穷多概率分布的序列</li><li>通常也会把 $\underset{x\leftarrow X_n}{Pr}[D(1^n,x)=1]$ 记作 $Pr[D(1^n,X_n)=1]$</li><li>计算不可区分具有传递性，即：若 $\mathcal{X}\overset{c}{\equiv}\mathcal{Y},,\mathcal{Y}\overset{c}{\equiv}\mathcal{Z}$ ，则 $\mathcal{X}\overset{c}{\equiv}\mathcal{Z}$</li></ul></li><li>使用计算不可区分定义伪随机生成器——定义7.31：令 $\ell(\cdot)$ 是一个多项式，令 $G$ 是一个确定性多项式时间算法，且对所有 $s$ 满足 $|G(s)|=\ell(|s|)$ 。$G$ 是伪随机生成器若满足：<ol><li>（扩张）对所有 $n$ 满足 $\ell(n)&gt;n$</li><li>（伪随机）集合 ${G(U_n)}<em>{n\in\mathbb{N}}$ 与 ${U</em>{\ell(n)}}_{n\in\mathbb{N}}$ 在计算上不可区分</li></ol><ul><li>其中 $U_n$ 代表在 ${0,1}^n$ 上的均匀分布</li></ul></li><li>令 $\mathcal{X}$ 和 $\mathcal{Y}$ 是计算不可区分的可采样概率集合，则对所有多项式 $p$ ，集合 $\overline{\mathcal{X}}={(X_n<sup>{(1)},…,X_n</sup>{p(n)})}<em>{n\in\mathbb{N}}$ 和 $\overline{\mathcal{Y}}={(Y_n<sup>{(1)},…,Y_n</sup>{p(n)})}</em>{n\in\mathbb{N}}$ 计算不可区分</li></ul><h2 id="Chapter-10-Key-Management-and-the-Public-Key-Revolution">Chapter 10: Key Management and the Public-Key Revolution</h2><h3 id="10-3-密钥交换和Diffie-Hellman协议">10.3 密钥交换和Diffie-Hellman协议</h3><ul><li><p>密钥交换实验 $\mathsf{KE}_{\mathcal{A},\Pi}^{\mathsf{eav}}(n)$ ：</p><ol><li>两个参与方使用 $1^n$ 来执行协议 $\Pi$ 。协议执行完会产生一个记录 $\mathsf{trans}$ ，包含双方交流的所有信息以及双方最终输出的密钥 $k$</li><li>随机均匀选择 $b\in{0,1}$ 。若 $b=0$ 则令 $\hat{k}:=k$ ，否则随机均匀选择 $\hat{k}\in{0,1}^n$</li><li>$\mathcal{A}$ 根据收到的 $\mathsf{trans}$ 和 $\hat{k}$ ，输出一比特 $b’$</li><li>若 $b=b’$ 则实验输出1，否则输出0</li></ol></li><li><p>定义10.1：密钥交换协议 $\Pi$ 对窃听者安全，若对所有PPT敌手存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{KE}_{\mathcal{A},\Pi}^{\mathsf{eav}}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$</p></li><li><p>构造10.2：（Diffie-Hellman协议）</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220315172030945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220315172030945.png" srcset="data:image/png;base64,666" alt="image-20220315172030945" style="zoom:50%;" /><ul><li>其中 $\mathbb{G}$ 是一个循环群，$q$ 是 $\mathbb{G}$ 的阶，$g$ 是  $\mathbb{G}$ 的生成元</li></ul></li><li><p>定理10.3：若 $\mathcal{G}$ 的决策Diffie-Hellman问题是困难的，则Diffie-Hellman协议对于窃听者是安全的【证明on P368】</p><ul><li>其中决策Diffie-Hellman问题指：任何敌手给定 $g,g<sup>x,g</sup>y$ 都不能将共享密钥 $g^{xy}$ 与随机均匀的值区分</li></ul></li></ul><h2 id="Chapter-11-Public-Key-Encryption">Chapter 11: Public-Key Encryption</h2><h3 id="11-2-定义">11.2 定义</h3><ul><li>定义11.1：公钥加密方案是一个PPT算法的三元组 $(\mathsf{Gen},\mathsf{Enc},\mathsf{Dec})$ ：<ol><li>$\mathsf{Gen}$ 根据输入的安全参数 $1^n$ ，输出一对密钥 $(pk,sk)$</li><li>$\mathsf{Enc}$ 根据输入的公钥 $pk$ 和消息 $m$ ，输出密文 $c$ ，记作 $c\leftarrow\mathsf{Enc}_{pk}(m)$</li><li>$\mathsf{Dec}$ 根据输入的私钥 $sk$ 和密文 $c$ ，输出消息 $m$ 或者失败 $\bot$ ，记作 $m:=\mathsf{Dec}_{sk}©$</li></ol></li></ul><h4 id="抵抗选择明文攻击">抵抗选择明文攻击</h4><ul><li>窃听不可区分实验 $\mathsf{PubK}^{\mathsf{eav}}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$(pk,sk)\leftarrow\mathsf{Gen}(1^n)$</li><li>敌手 $\mathcal{A}$ 获得公钥 $pk$ ，并输出一对等长的消息 $m_0,,m_1$</li><li>随机均匀选择 $b\in{0,1}$ ，计算 $c\leftarrow\mathsf{Enc}_{pk}(m_b)$ ，然后将挑战密文 $c$ 发送给 $\mathcal{A}$</li><li>$\mathcal{A}$ 输出 $b’$ ，若 $b=b’$ 则实验输出1（敌手成功），否则输出0</li></ol></li><li>定义11.2：一个公钥加密方案 $\Pi=(\mathsf{Gen},\mathsf{Enc},\mathsf{Dec})$ 对窃听攻击者不可区分，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{PubK}_{\mathcal{A},\Pi}^{\mathsf{eav}}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$</li><li>命题11.3：若一个公钥加密方案对窃听攻击者不可区分，则它也是CPA-安全的<ul><li>对于公钥加密而言，任何窃听敌手都可以获得公钥来加密明文</li></ul></li><li>定理11.4：确定性公钥加密方案都不是CPA安全的</li></ul><h4 id="多消息加密">多消息加密</h4><ul><li>LR-oracle实验 $\mathsf{PubK}^{\mathsf{LR-cpa}}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$(pk,sk)\leftarrow\mathsf{Gen}(1^n)$</li><li>随机均匀选择 $b\in{0,1}$</li><li>敌手 $\mathcal{A}$ 获得输入 $pk$ ，并且可以访问oracle $\mathsf{LR}_{pk,b}(\cdot,\cdot)$</li><li>敌手 $\mathcal{A}$ 输出一比特 $b’$</li><li>若 $b=b’$ 则实验输出1（敌手成功），否则输出0</li></ol><ul><li>其中oracle $\mathsf{LR}<em>{pk,b}(\cdot,\cdot)$ ：输入两个等长的消息 $m_0$ ，$m_1$ ，若 $b=0$ 输出 $c\leftarrow \mathsf{Enc}</em>{pk}(m_0)$ ；若 $b=1$ 输出 $c\leftarrow \mathsf{Enc}_{pk}(m_1)$</li></ul></li><li>定义11.5：一个公钥加密方案 $\Pi=(\mathsf{Gen},\mathsf{Enc},\mathsf{Dec})$ 对窃听攻击者是多消息不可区分的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{PubK}_{\mathcal{A},\Pi}^{\mathsf{LR-cpa}}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$</li><li>定理11.6：若一个公钥加密方案是CPA-安全的，则它也是多消息不可区分的【*证明on P383】</li><li>断言11.7：$\Pi=(\mathsf{Gen},\mathsf{Enc},\mathsf{Dec})$ 是对一比特消息进行加密的公钥加密方案，$\Pi’=(\mathsf{Gen’},\mathsf{Enc’},\mathsf{Dec’})$ 是对任意长消息进行加密的公钥加密方案，构造如下：$\mathsf{Enc’}<em>{pk}(m)=\mathsf{Enc}</em>{pk}(m_1),…,\mathsf{Enc}<em>{pk}(m</em>{\ell})$ ，其中 $m=m_1\cdot\cdot\cdot m_{\ell}$ 。则如果 $\Pi$ 是CPA-安全的，$\Pi’$ 也是</li></ul><h4 id="抵抗选择密文攻击">抵抗选择密文攻击</h4><ul><li>CCA不可区分实验 $\mathsf{PubK}^{\mathsf{cca}}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$(pk,sk)\leftarrow\mathsf{Gen}(1^n)$</li><li>敌手 $\mathcal{A}$ 获得 $pk$ ，并且可以访问解密oracle $\mathsf{Dec}_{sk}(\cdot)$ 。$\mathcal{A}$ 输出一对等长消息 $m_0,m_1$</li><li>随机均匀选择 $b\in{0,1}$ ，计算 $c\leftarrow\mathsf{Enc}_{pk}(m_b)$ 并发送给 $\mathcal{A}$</li><li>$\mathcal{A}$ 可以继续与解密oracle交互，但不能解密 $c$ 。最终 $\mathcal{A}$ 输出一比特 $b’$</li><li>若 $b=b’$ 则实验输出1（敌手成功），否则输出0</li></ol></li><li>定义11.8：一个公钥加密方案 $\Pi=(\mathsf{Gen},\mathsf{Enc},\mathsf{Dec})$ 是CCA-安全的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{PubK}_{\mathcal{A},\Pi}^{\mathsf{cca}}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$<ul><li>若一个公钥加密方案是CCA-安全的，则它也是多消息CCA-安全的</li></ul></li></ul><h3 id="11-3-混合加密和KEM-DEM范式">11.3 混合加密和KEM/DEM范式</h3><ul><li><p>定义11.9：一个密钥封装机制（KEM）是PPT算法的三元组 $(\mathsf{Gen},\mathsf{Encaps},\mathsf{Decaps})$ 使得：</p><ol><li>密钥生成算法 $\mathsf{Gen}$ 根据输入的安全参数 $1^n$ ，输出公私钥对 $(pk,sk)$</li><li>密封算法 $\mathsf{Encaps}$ 根据输入的安全参数 $1^n$ 和公钥 $pk$ ，输出密文 $c$ 和密钥 $k\in{0,1}^{\ell(n)}$ ，其中 $\ell$ 是密钥长度。记作 $(c,k)\leftarrow\mathsf{Encaps}_{pk}(1^n)$</li><li>确定性的解封算法 $\mathsf{Decaps}$ 根据输入的私钥 $sk$ 和密文 $c$ ，输出密钥 $k$ 或者一个特殊符号 $\bot$ 来表示解封失败。记作 $k:=\mathsf{Decaps}_{sk}©$</li></ol></li><li><p>构造11.10：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220316153355300.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220316153355300.png" srcset="data:image/png;base64,666" alt="image-20220316153355300" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220316151745275.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/cryptography/image-20220316151745275.png" srcset="data:image/png;base64,666" alt="image-20220316151745275" style="zoom:50%;" /></li></ul><h4 id="CPA-安全">CPA-安全</h4><ul><li>令 $\Pi=(\mathsf{Gen},\mathsf{Encaps},\mathsf{Decaps})$ 是KEM，定义CPA不可区分实验 $\mathsf{KEM}^{\mathsf{cpa}}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$(pk,sk)\leftarrow\mathsf{Gen}(1^n)$ ，然后 $(c,k)\leftarrow\mathsf{Encaps}_{pk}(1^n)$ ，其中 $k\in{0,1}^n$</li><li>随机均匀选择 $b\in{0,1}$ 。若 $b=0$ 则令 $\hat{k}:=k$ ，若 $b=1$ ，则随机均匀选择 $\hat{k}\in{0,1}^n$</li><li>$\mathcal{A}$ 获得 $(pk,c,\hat{k})$ ，并输出 $b’$ 。若 $b=b’$ 则实验输出1（敌手成功），否则输出0</li></ol></li><li>定义11.11：一个KEM $\Pi$ 是CPA-安全的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{KEM}_{\mathcal{A},\Pi}^{\mathsf{cpa}}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$</li><li>定理11.12：若 $\Pi$ 是一个CPA-安全的KEM，$\Pi’$ 是一个对窃听攻击不可区分的对称加密方案，则构造11.10中的 $\Pi^{\mathsf{hy}}$ 是CPA-安全的公钥加密方案【证明on P394】</li></ul><h4 id="CCA-安全-v2">CCA-安全</h4><ul><li>令 $\Pi=(\mathsf{Gen},\mathsf{Encaps},\mathsf{Decaps})$ 是KEM，定义CCA不可区分实验 $\mathsf{KEM}^{\mathsf{cca}}_{\mathcal{A},\Pi}(n)$ ：<ol><li>$(pk,sk)\leftarrow\mathsf{Gen}(1^n)$ ，然后 $(c,k)\leftarrow\mathsf{Encaps}_{pk}(1^n)$ ，其中 $k\in{0,1}^n$</li><li>随机均匀选择 $b\in{0,1}$ 。若 $b=0$ 则令 $\hat{k}:=k$ ，若 $b=1$ ，则随机均匀选择 $\hat{k}\in{0,1}^n$</li><li>$\mathcal{A}$ 获得 $(pk,c,\hat{k})$ 以及可以访问oracle $\mathsf{Decaps}_{sk}(\cdot)$ ，但不能请求解封挑战密文 $c$</li><li>$\mathcal{A}$ 输出 $b’$ 。若 $b=b’$ 则实验输出1（敌手成功），否则输出0</li></ol></li><li>定义11.13：一个KEM $\Pi$ 是CCA-安全的，若对所有PPT敌手 $\mathcal{A}$ 存在一个可忽略函数 $\mathsf{negl}$ 使得：<br>$$<br>Pr[\mathsf{KEM}_{\mathcal{A},\Pi}^{\mathsf{cca}}(n)=1]\leq\frac{1}{2}+\mathsf{negl}(n)<br>$$</li><li>定理11.14：若 $\Pi$ 是一个CCA-安全的KEM，$\Pi’$ 是一个CCA-安全的对称加密方案，则构造11.10中的 $\Pi^{\mathsf{hy}}$ 是CCA-安全的公钥加密方案</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown数学符号补充</title>
      <link href="2022/03/19/lookup/markdown-math/"/>
      <url>2022/03/19/lookup/markdown-math/</url>
      
        <content type="html"><![CDATA[<p>对<a href="https://blog.csdn.net/wait_for_eva/article/details/84307306">typora-数学符号</a>进行补充</p><ul><li>\overset{def}{=}    $\overset{def}{=}$</li><li>\underset{x\leftarrow{0,1}^n}{Pr}    $ \underset{x\leftarrow{0,1}^n}{Pr}$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lookup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="2022/02/19/lookup/linux-notes/"/>
      <url>2022/02/19/lookup/linux-notes/</url>
      
        <content type="html"><![CDATA[<h3 id="Debug命令">Debug命令</h3><h4 id="查找文件位置">查找文件位置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name &lt;file_name&gt;</span><br></pre></td></tr></table></figure><h4 id="查看程序依赖的动态链接库">查看程序依赖的动态链接库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd &lt;file_name&gt;</span><br></pre></td></tr></table></figure><h3 id="Setup命令">Setup命令</h3><h4 id="命令行工具">命令行工具</h4><p>使命令行工具在任意目录下都能直接使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/chainmaker/chainmaker-go/tools/cmc/cmc /usr/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Lookup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go实践经验</title>
      <link href="2022/02/01/instruction/go-notes/"/>
      <url>2022/02/01/instruction/go-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开发go程序过程中遇到的问题以及解决方法</p></blockquote><h3 id="hash">hash</h3><p>使用 <code>crypto.sha256</code> 可以获得文件哈希：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fileName := <span class="string">&quot;main.go&quot;</span></span><br><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">hash := sha256.New()</span><br><span class="line"><span class="keyword">if</span> _, err = io.Copy(hash, file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">sum := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sum: %x\n&quot;</span>, sum)</span><br></pre></td></tr></table></figure><p>最终得到的哈希值 <code>sum</code> 的类型是 <code>[]byte</code> ，若想要得到 <code>string</code> 类型的哈希值不能通过 <code>string(sum)</code> 的方式强制转换，而需要使用以下方法转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash := hex.EncodeToString(sum)</span><br></pre></td></tr></table></figure><h3 id="json">json</h3><p>使用 <code>json.Marshal</code> 方法可以将 <code>struct</code> 转换为字符串，但其中的特殊html字符会被转义成unicode，例如 <code>&amp;</code> 会被转义为 <code>\u0026</code> ，若不想被转义，则需要通过以下方法转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bf := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">jsonEncoder := json.NewEncoder(bf)</span><br><span class="line">jsonEncoder.SetEscapeHTML(<span class="literal">false</span>)</span><br><span class="line">jsonEncoder.Encode(fdata.Data)</span><br><span class="line">fileData := bf.String()</span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure><h3 id="slice">slice</h3><h4 id="拷贝">拷贝</h4><p>切片是底层数组的视图，实际指向一段地址</p><p>eg. 在将arr放入res，底层是将指向arr切片地址的指针放入res中。若不改变arr大小，仅改变arr中元素的值，会导致之前放入res中的arr产生变化（在递归中会碰到这样的问题）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, arr)</span><br><span class="line"><span class="comment">// 改变arr中的值，不做扩容</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">res = <span class="built_in">append</span>(res, arr)</span><br><span class="line"><span class="comment">// arr扩容</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">5</span>)</span><br><span class="line">res = <span class="built_in">append</span>(res, arr)</span><br><span class="line">fmt.Println(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[[1 2 4] [1 2 4] [1 2 4 5]]</span></span><br></pre></td></tr></table></figure><p>正确的做法是进行深拷贝：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="built_in">copy</span>(tmp, arr)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"><span class="comment">// 改变arr中的值，不做扩容</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">tmp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="built_in">copy</span>(tmp, arr)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"><span class="comment">// arr扩容</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">5</span>)</span><br><span class="line">tmp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="built_in">copy</span>(tmp, arr)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">fmt.Println(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[[1 2 3] [1 2 4] [1 2 4 5]]</span></span><br></pre></td></tr></table></figure><h4 id="垃圾回收">垃圾回收</h4><p>底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个slice的小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收</p><p>例如假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []*<span class="keyword">int</span>&#123; ... &#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]    <span class="comment">// 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍</span></span><br></pre></td></tr></table></figure><p>修复如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []*<span class="keyword">int</span>&#123; ... &#125;</span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// GC回收最后一个元素内存</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]  <span class="comment">// 从切片删除最后一个元素</span></span><br></pre></td></tr></table></figure><p>另外，若对于一个很大的临时数组，只需要读取其中的一小部分，读取后整个数组不再需要放在var内存中，则应该传值到一个新的数组，而不是直接使用slice引用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bigArr []<span class="keyword">int</span>&#123; ... &#125;</span><br><span class="line">a := <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, bigArr[<span class="number">1</span>:<span class="number">3</span>]...)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map">map</h3><h4 id="拷贝-v2">拷贝</h4><p>与slice类似，map也是一个指针，若要进行深拷贝，需要对逐个键值对进行拷贝：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">mCopy := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    mCopy[k] = v</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="number">4</span>] = <span class="string">&quot;d&quot;</span></span><br><span class="line">fmt.Println(m)</span><br><span class="line">fmt.Println(mCopy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：map[1:a 2:b 3:c 4:d]</span></span><br><span class="line"><span class="comment">//map[1:a 2:b 3:c]</span></span><br></pre></td></tr></table></figure><h3 id="package">package</h3><p>同一目录下的同级文件属于一个包，main.go可以直接调用其他文件中的函数，但是在运行的时候需要使用 <code>go run .</code></p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust实践经验</title>
      <link href="2022/02/01/instruction/rust-notes/"/>
      <url>2022/02/01/instruction/rust-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开发rust程序过程中遇到的问题以及解决方法</p></blockquote><h4 id="错误处理">错误处理</h4><ul><li><p>对于 <code>Result</code>、<code>Option</code>等类型，如果使用 <code>unwrap</code>、<code>expect</code>等方法，会直接导致panic</p></li><li><p>对于 <code>Result</code> 类型，如果遇到错误只需要返回 <code>None</code>，那么可以使用如下简单的语法来替代 <code>match</code> :</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_var = something_that_returns_result().ok()?;</span><br></pre></td></tr></table></figure><p>其中，<code>Result::ok()</code> 函数将 <code>Result</code> 转换为 <code>Option</code>：</p><ul><li>对于 <code>Ok(val)</code>，返回 <code>Some(val)</code>；</li><li>对于 <code>Err(some_error)</code>，返回 <code>None</code></li></ul><p><code>?</code> 提取 <code>Option</code> 中的内容，如果为 <code>None</code>，则返回 <code>None</code></p></li></ul><h4 id="slice复制">slice复制</h4><p>使用copy_from_slice将一个slice的内容复制到另外一个slice时，要求两个slice的长度相同，因此对于要将[u8]转为[u8; usize]的场景，需要使用以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> vs: &amp;[<span class="built_in">u8</span>] = v.as_slice();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vs2: [<span class="built_in">u8</span>; <span class="number">32</span>] = [<span class="number">0</span>; <span class="number">32</span>];</span><br><span class="line">vs2[..<span class="number">3</span>].copy_from_slice(vs);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chainmaker相关命令</title>
      <link href="2021/12/03/lookup/chainmaker-commands/"/>
      <url>2021/12/03/lookup/chainmaker-commands/</url>
      
        <content type="html"><![CDATA[<h4 id="启动、关闭链">启动、关闭链</h4><ul><li><p>启动链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/chainmaker/chainmaker-go/scripts</span><br><span class="line">./cluster_quick_start.sh normal</span><br></pre></td></tr></table></figure><ul><li><p>各节点的初始状态文件保存在 <code>~/chainmaker/chainmaker-go/buid/release</code> 中的压缩文件，启动脚本会将其解压，为了保证链的状态不被覆盖，将压缩文件备份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ../build/bak</span><br><span class="line">mv ../build/release/*.tar.gz ../build/bak</span><br></pre></td></tr></table></figure></li><li><p>若要重新初始化链，只用将备份的文件重新放回release目录，再启动链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ../build/release/*</span><br><span class="line">cp ../build/bak/* ../build/release</span><br><span class="line">./cluster_quick_start.sh normal</span><br><span class="line">rm ../build/release/*.tar.gz</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关闭链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cluster_quick_stop.sh</span><br></pre></td></tr></table></figure></li></ul><h4 id="查看节点启动使用正常">查看节点启动使用正常</h4><ul><li><p>查看进程是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep chainmaker | grep -v grep</span><br></pre></td></tr></table></figure></li><li><p>看端口是否监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lptn | grep <span class="string">&quot;1230\|1130&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>检查节点是否有<code>ERROR</code>日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="variable">$HOME</span>/chainmaker/chainmaker-go/build/release/chainmaker-v2.0.0-wx-org1.chainmaker.org/bin/panic.log</span><br><span class="line"></span><br><span class="line">tail -f <span class="variable">$HOME</span>/chainmaker/chainmaker-go/build/release/chainmaker-v2.0.0-wx-org1.chainmaker.org/<span class="built_in">log</span>/system.log</span><br><span class="line"></span><br><span class="line">tail -f <span class="variable">$HOME</span>/chainmaker/chainmaker-go/build/release/chainmaker-v2.0.0-wx-org1.chainmaker.org/<span class="built_in">log</span>/system.log|grep <span class="string">&quot;ERROR\|put block\|all necessary&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用Docker镜像进行合约开发">使用Docker镜像进行合约开发</h4><ul><li><p>后台启动docker镜像并进入容器内部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name chainmaker-rust-contract -v <span class="variable">$HOME</span>/chainmaker/contract:/home chainmakerofficial/chainmaker-rust-contract:2.1.0 bash</span><br></pre></td></tr></table></figure></li><li><p>关闭容器后再次进入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start chainmaker-rust-contract</span><br><span class="line"><span class="comment"># 进入容器命令行</span></span><br><span class="line">docker <span class="built_in">exec</span> -it chainmaker-rust-contract bash</span><br><span class="line"><span class="comment"># 关闭容器</span></span><br><span class="line">docker stop chainmaker-rust-contract</span><br></pre></td></tr></table></figure></li><li><p>命令行创建wasm合约</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmc client contract user create \</span><br><span class="line">--contract-name=fact \</span><br><span class="line">--runtime-type=WASMER \</span><br><span class="line">--byte-code-path=./testdata/contract/chainmaker_contract.wasm \</span><br><span class="line">--version=1.0 \</span><br><span class="line">--sdk-conf-path=./testdata/sdk_config.yml \</span><br><span class="line">--admin-key-file-paths=./testdata/crypto-config/wx-org1.chainmaker.org/user/admin1/admin1.tls.key,./testdata/crypto-config/wx-org2.chainmaker.org/user/admin1/admin1.tls.key,./testdata/crypto-config/wx-org3.chainmaker.org/user/admin1/admin1.tls.key \</span><br><span class="line">--admin-crt-file-paths=./testdata/crypto-config/wx-org1.chainmaker.org/user/admin1/admin1.tls.crt,./testdata/crypto-config/wx-org2.chainmaker.org/user/admin1/admin1.tls.crt,./testdata/crypto-config/wx-org3.chainmaker.org/user/admin1/admin1.tls.crt \</span><br><span class="line">--sync-result=<span class="literal">true</span> \</span><br><span class="line">--params=<span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>命令行调用wasm合约</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmc client contract user invoke \</span><br><span class="line">--contract-name=fact \</span><br><span class="line">--method=save \</span><br><span class="line">--sdk-conf-path=./testdata/sdk_config.yml \</span><br><span class="line">--params=<span class="string">&quot;&#123;\&quot;file_name\&quot;:\&quot;name007\&quot;,\&quot;file_hash\&quot;:\&quot;ab3456df5799b87c77e7f88\&quot;,\&quot;time\&quot;:\&quot;6543234\&quot;&#125;&quot;</span> \</span><br><span class="line">--sync-result=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lookup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp配置</title>
      <link href="2021/11/04/discard/frp-setup/"/>
      <url>2021/11/04/discard/frp-setup/</url>
      
        <content type="html"><![CDATA[<h4 id="frp安装">frp安装</h4><ul><li>下载：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></li></ul><h4 id="frp配置">frp配置</h4><ul><li><p>服务端 <code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span></span><br><span class="line"><span class="comment"># 可在本地通过 ServerIP:7500 查看服务端情况</span></span><br><span class="line"><span class="attr">dashboard_user</span> = root</span><br><span class="line"><span class="attr">dashboard_pwd</span> = root</span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br></pre></td></tr></table></figure></li><li><p>提供服务的内网机器 <code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ServerIP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="section">[secret_ssh]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="attr">sk</span> = schenk</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure></li><li><p>访问服务的机器 <code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ServerIP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="section">[secret_ssh_visitor]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="attr">server_name</span> = secret_ssh</span><br><span class="line"><span class="attr">sk</span> = schenk</span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="访问内网机器">访问内网机器</h4><ul><li><p>服务端 Debian (后台运行)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure></li><li><p>内网机器 Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure></li><li><p>访问Ubuntu的机器 Windows</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure></li><li><p>在Windows上使用ssh连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=6000 schenk@127.0.0.1</span><br></pre></td></tr></table></figure><ul><li><p>注：连接后需要手动使.bashrc生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>v2ray配置</title>
      <link href="2021/10/30/discard/v2ray/"/>
      <url>2021/10/30/discard/v2ray/</url>
      
        <content type="html"><![CDATA[<h3 id="Debian-9服务端配置">Debian 9服务端配置</h3><h4 id="安装v2ray">安装v2ray</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install ntp -y</span><br><span class="line">apt-get update -y &amp;&amp; apt-get install curl -y</span><br><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br><span class="line">v2ray url <span class="comment"># generate vmess url</span></span><br></pre></td></tr></table></figure><h4 id="放行端口">放行端口</h4><p>iptables</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport &lt;port&gt; -j ACCEPT</span><br><span class="line">iptables-save</span><br><span class="line">apt-get install iptables-persistent</span><br><span class="line">netfilter-persistent save</span><br><span class="line">netfilter-persistent reload</span><br></pre></td></tr></table></figure><p>ufw</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ufw status</span><br><span class="line">ufw allow &lt;port&gt;</span><br><span class="line">ufw reload</span><br></pre></td></tr></table></figure><h3 id="Windows客户端">Windows客户端</h3><p><a href="https://github.com/2dust/v2rayN/releases/latest">https://github.com/2dust/v2rayN/releases/latest</a></p><h3 id="Android客户端">Android客户端</h3><p><a href="https://github.com/2dust/v2rayNG/releases">https://github.com/2dust/v2rayNG/releases</a></p><h3 id="Linux客户端">Linux客户端</h3><p><a href="https://github.com/jiangxufeng/v2rayL">https://github.com/jiangxufeng/v2rayL</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SGX移植crate</title>
      <link href="2021/10/25/instruction/sgx%E7%A7%BB%E6%A4%8D/"/>
      <url>2021/10/25/instruction/sgx%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>总流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def 移植(self):</span><br><span class="line">    if self支持 no_std then</span><br><span class="line">        不用修改，直接在依赖处配置好 no_std 的 features</span><br><span class="line">        return</span><br><span class="line">    # 移植依赖项 (忽略dev-dependencies）</span><br><span class="line">    for each dep of self.dependencies</span><br><span class="line">        移植 dep</span><br><span class="line">    # 移植自身</span><br><span class="line">    (1) wget 库代码 &amp;&amp; tar xzf</span><br><span class="line">    (2) 编辑 Cargo.toml 修改每个依赖项为移植后的依赖项</span><br><span class="line">    (3) 编辑 src&#x2F;lib.rs 添加特定header（见后文）</span><br><span class="line">    (4) 编辑每个源文件 添加 use std::prelude::v1::*;</span><br><span class="line">    (5) 仔细review每个使用 fs&#x2F;path&#x2F;net&#x2F;time&#x2F;env 等不可信输入的地方，修正那里的逻辑</span><br><span class="line">    (6) 检查每个 platform dependent 的 feature，将其固定为只适用于 linux-x86_64 的逻辑（因为 linux-SGX 就只有这个环境）</span><br><span class="line">    (7) 测试 &#96;cargo build&#96; 是否通过</span><br><span class="line">    return</span><br></pre></td></tr></table></figure><p>下载crate</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://crates.io/api/v1/crates/&lt;库名&gt;/&lt;版本号&gt;/download</span><br><span class="line"></span><br><span class="line">https://crates.io/api/v1/crates/iter-enum/1.0.1/download</span><br><span class="line">https://crates.io/api/v1/crates/pin-project/1.0.8/download</span><br><span class="line">https://crates.io/api/v1/crates/strum_macros/0.21.1/download</span><br><span class="line">https://crates.io/api/v1/crates/thiserror/1.0.30/download</span><br></pre></td></tr></table></figure><p>查看依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo tree</span><br></pre></td></tr></table></figure><p>检查依赖关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -R &lt;lib&gt;</span><br></pre></td></tr></table></figure><p><em>cargo.toml</em></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[target.&#x27;cfg(not(target_env = &quot;sgx&quot;))&#x27;.dependencies]</span></span><br><span class="line"><span class="attr">sgx_tstd</span> = &#123; rev = <span class="string">&quot;v1.1.3&quot;</span>, git = <span class="string">&quot;https://github.com/apache/teaclave-sgx-sdk.git&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用已移植的crate</span></span><br><span class="line"><span class="attr">byteorder</span> = &#123; git = <span class="string">&quot;https://github.com/mesalock-linux/byteorder-sgx&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p><em><a href="http://lib.rs">lib.rs</a></em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(all(feature = <span class="meta-string">&quot;mesalock_sgx&quot;</span>, not(target_env = <span class="meta-string">&quot;sgx&quot;</span>)), no_std)]</span></span><br><span class="line"><span class="meta">#![cfg_attr(all(target_env = <span class="meta-string">&quot;sgx&quot;</span>, target_vendor = <span class="meta-string">&quot;mesalock&quot;</span>), feature(rustc_private))]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(all(feature = <span class="meta-string">&quot;mesalock_sgx&quot;</span>, not(target_env = <span class="meta-string">&quot;sgx&quot;</span>)))]</span></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> sgx_tstd <span class="keyword">as</span> std;</span><br></pre></td></tr></table></figure><p>每一个.rs文件添加 (<a href="http://xn--lib-k82e104e.rs">包括lib.rs</a>)，若编译时报Warning再对照着删除</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::prelude::v1::*;</span><br></pre></td></tr></table></figure><h4 id="常见错误">常见错误</h4><ul><li><p>编译时出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0432]: unresolved import `core::alloc::AllocRef`</span><br><span class="line">  --&gt; /home/schenk/.cargo/git/checkouts/teaclave-sgx-sdk-be25c2ad2f03718d/a6a172e/sgx_alloc/src/system.rs:26:17</span><br><span class="line">   |</span><br><span class="line">26 |     AllocError, AllocRef, GlobalAlloc, Layout,</span><br><span class="line">   |                 ^^^^^^^^ no `AllocRef` <span class="keyword">in</span> `alloc`</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure><p>说明rustup toolchain选择有问题，使用命令修改toolchain能通过编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup override <span class="built_in">set</span> nightly-2020-10-25-x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure></li><li><p>编译时出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: duplicate lang item <span class="keyword">in</span> crate `std`: `f32_runtime`.</span><br><span class="line">  |</span><br><span class="line">  = note: the lang item is first defined <span class="keyword">in</span> crate `sgx_tstd` (<span class="built_in">which</span> `helloworldsampleenclave` depends on)</span><br><span class="line">  = note: first definition <span class="keyword">in</span> `sgx_tstd` loaded from /home/schenk/sgx/workspace/sgx-test/enclave/target/release/deps/libsgx_tstd-c10171ffd7c558b5.rlib</span><br><span class="line">  = note: second definition <span class="keyword">in</span> `std` loaded from /home/schenk/.rustup/toolchains/nightly-2020-10-25-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-3010daceac92f8fa.so, /home/schenk/.rustup/toolchains/nightly-2020-10-25-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-3010daceac92f8fa.rlib</span><br></pre></td></tr></table></figure><p>很有可能是因为在这个错误之前出现了其他错误，例如变量未定义等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error[E0425]: cannot find value `sealed_log` <span class="keyword">in</span> this scope</span><br><span class="line">   --&gt; src/lib.rs:143:14</span><br><span class="line">    |</span><br><span class="line">143 |             &amp;sealed_log,</span><br><span class="line">    |              ^^^^^^^^^^ not found <span class="keyword">in</span> this scope</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应当先修复其他的错误</p></li></ul><h3 id="notes">notes</h3><ul><li><p>cfg</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件编译，如果同时满足feature是&quot;mesalock_sgx&quot; 和 target_env不是&quot;sgx&quot;，则编译</span></span><br><span class="line"><span class="meta">#[cfg(all(feature = <span class="meta-string">&quot;mesalock_sgx&quot;</span>, not(target_env = <span class="meta-string">&quot;sgx&quot;</span>)))]</span></span><br></pre></td></tr></table></figure></li><li><p>cfg_attr</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果满足all(feature = &quot;mesalock_sgx&quot;, not(target_env = &quot;sgx&quot;))，则相当于 ![cfg(no_std)]</span></span><br><span class="line"><span class="meta">#![cfg_attr(all(feature = <span class="meta-string">&quot;mesalock_sgx&quot;</span>, not(target_env = <span class="meta-string">&quot;sgx&quot;</span>)), no_std)]</span></span><br></pre></td></tr></table></figure></li><li><p>.toml</p><ul><li><p>features</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crate本来就没有features的话不用改</span></span><br><span class="line"><span class="comment"># 否则在default中加入&quot;mesalock_sgx&quot;，并添加feature mesalock_sgx，在其中加入在crate中引入的&quot;sgx_*&quot;</span></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;linkage&quot;</span>, <span class="string">&quot;mesalock_sgx&quot;</span>]</span><br><span class="line"><span class="attr">linkage</span> = [<span class="string">&quot;sqlite3-src&quot;</span>]</span><br><span class="line"><span class="attr">mesalock_sgx</span> = [<span class="string">&quot;sgx_tstd&quot;</span>, <span class="string">&quot;sgx_libc&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>target.xxx.dependencies：满足xxx条件时的依赖</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Rust </category>
          
          <category> SGX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> sgx </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu连接PEAP网络</title>
      <link href="2021/10/22/instruction/ubuntu-peap/"/>
      <url>2021/10/22/instruction/ubuntu-peap/</url>
      
        <content type="html"><![CDATA[<p>创建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/NetworkManager/system-connections</span><br><span class="line">sudo gedit SJTU</span><br></pre></td></tr></table></figure><p>在SJTU配置文件中添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">id&#x3D;SJTU</span><br><span class="line">uuid&#x3D;9e123fbc-0123-46e3-97b5-f3214e123456 # unique</span><br><span class="line">type&#x3D;802-11-wireless</span><br><span class="line"></span><br><span class="line">[802-11-wireless-security]</span><br><span class="line">key-mgmt&#x3D;wpa-eap</span><br><span class="line">auth-alg&#x3D;open</span><br><span class="line"></span><br><span class="line">[802-11-wireless]</span><br><span class="line">ssid&#x3D;SJTU</span><br><span class="line">mode&#x3D;infrastructure</span><br><span class="line">mac-address&#x3D;&lt;MAC address&gt;</span><br><span class="line">security&#x3D;802-11-wireless-security</span><br><span class="line"></span><br><span class="line">[802-1x]</span><br><span class="line">eap&#x3D;peap;</span><br><span class="line">identity&#x3D;&lt;username&gt;</span><br><span class="line">phase2-auth&#x3D;mschapv2</span><br><span class="line">password&#x3D;&lt;password&gt;</span><br><span class="line"></span><br><span class="line">[ipv6]</span><br><span class="line">method&#x3D;auto</span><br><span class="line"></span><br><span class="line">[ipv4]</span><br><span class="line">method&#x3D;auto</span><br></pre></td></tr></table></figure><p>连接SJTU网络：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/ubuntu-peap/image-20211022154431836.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/ubuntu-peap/image-20211022154431836.png" srcset="data:image/png;base64,666" alt="image-20211022154431836"></p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Secure Multiparty Computation from SGX</title>
      <link href="2021/08/16/paper-reading/paper-secure-mpc/"/>
      <url>2021/08/16/paper-reading/paper-secure-mpc/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction">1.Introduction</h2><p>使用可信硬件实现MPC协议需要克服：</p><ol><li>用户和远程机器之间缺乏专用通道</li><li>在异步通信以及仅有TEE介入的条件下对计算进行身份验证/达成一致</li><li>确保“正确”的各方参与计算</li><li>处理共存于同一TEE、共享内存空间的代码之间的交互，每段代码可能对应不同的用户</li><li>确保TEE内部运行的代码不会向外部泄露敏感信息</li></ol><h3 id="1-1-贡献">1.1 贡献</h3><h4 id="通用安全多方计算">通用安全多方计算</h4><p>一个高效的安全多方计算协议（非交互式）</p><p>加载进TEE的代码先执行密钥交换，再通过秘密信道执行任意函数 $F$</p><h4 id="标记验证计算LAC">标记验证计算LAC</h4><p>经过验证的输出为计算序列提供完整性保护，输出的完整性可以进行公开验证</p><ul><li>为输入添加标签，并将对应于特定标签的输入和输出绑定</li><li>对LAC进行正式建模，通过LAC原语将任意程序部署到TEE</li><li>LAC可用于更多的依赖TEE的安全协议的模块化分析</li></ul><h4 id="实现和实验">实现和实验</h4><p>两个实现：</p><ul><li><p><code>sgx-mpc-mbed</code> ：依赖TLS库，使用RSA进行密钥交换</p></li><li><p><code>sgx-mpc-nacl</code> ：依赖NaCl密码学库，使用椭圆曲线密码进行密钥交换和数字签名</p></li></ul><h2 id="3-TEE程序与机器">3.TEE程序与机器</h2><h3 id="TEE程序">TEE程序</h3><blockquote><p>抽象为编程语言 $L$ ，包含TEE系统调用</p></blockquote><p>TEE中的系统调用结果只能依赖于:</p><ul><li>程序加载时定义的初始共享状态</li><li>显式传递的输入</li><li>新鲜的随机硬币</li></ul>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-TZ4Fabric. Executing Smart Contracts with ARM TrustZone</title>
      <link href="2021/06/13/paper-reading/paper-TZ4Fabric/"/>
      <url>2021/06/13/paper-reading/paper-TZ4Fabric/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入">1.引入</h2><p>Hyperledger  Fabric私有链码（FPC）是一个开源项目，它使通道上的节点（区块链网络中节点的子集）在TEE内执行智能合约，特别是在Intel  SGX Enclave内。由于物联网设备大多体积小，可能由电池供电，并嵌入低功耗处理器，FPC不容易在这种情况下部署，这极大地阻碍了其在论文的目标部署场景中的适用性。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-TZ4Fabric/image-20210613153529814.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-TZ4Fabric/image-20210613153529814.png" srcset="data:image/png;base64,666" alt="image-20210613153529814" style="zoom:50%;" /><p>Fig1描述了论文预想的部署场景：一个异构的、可能分布的节点集合加入了区块链；智能合约必须跨通道执行，只有少数节点受到保护，免受攻击。例如，攻击者可以破坏一个通道，获得对其节点的访问权并收集敏感信息。为了遏制攻击并防止攻击传播到其他通道，某些通道的智能合约可以在TEE内执行。受到TEE保护的节点可以免受恶意攻击，特别是作为物联网设备部署在“野外”的节点更容易受到此类攻击。</p><p>本论文提出了结合ARM TZ的Hyperledger Fabric链码执行的原型系统TZ4Fabric。TZ4Fabric体系结构受到FPC的启发，但它隔离了TEE组件。该设计不仅可以利用ARM TZ，还可以TZ4Fabric扩展到未来的TEE。</p><h2 id="2-背景">2.背景</h2><h3 id="区块链和智能合约">区块链和智能合约</h3><p>在许可的区块链中(如Ripple和Hyperledger Fabric)，网络的访问是受限制的，实体是已知的。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-TZ4Fabric/image-20210613160859297.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-TZ4Fabric/image-20210613160859297.png" srcset="data:image/png;base64,666" alt="image-20210613160859297" style="zoom:50%;" /><p>Hyperledger Fabric (HF)是一个支持智能合约的许可区块链，在HF中，智能合约称为链码。Fig2给出了HF的高层架构和工作流程，在链码函数被调用之前，它必须被安装(存储在文件系统上)并在对等端实例化。</p><ul><li>1、2：客户端应用向对等端发送请求（交易提出），来调用链码函数；对等端执行链码函数</li><li>3：对等端向客户端发送交易响应，交易响应由对等端签名，并包含执行响应消息以及读集合和写集合，读集合代表对等端在执行期间通过 <code>GetState</code> 从账本中查询到的所有键值，写集合包含对等端通过 <code>PutState</code> 生成的所有键值对更新</li><li>4：当客户端收集了由认可策略定义的足够多的交易响应时，将它们发送给排序端，排序端将交易响应放入区块，并将它们分发给所有对等端，这是<strong>排序阶段</strong>。之后在<strong>验证阶段</strong>，每个对等端检查是否满足认可策略以及不同交易的读和写是否由冲突，然后就把交易写在账本上，账本包含两个促成部分：一个区块链和一个世界状态，世界状态是一个可插拔的数据库，用于存储和有效检索区块链中的键的当前值</li></ul><h3 id="ARM-TrustZone">ARM TrustZone</h3><p>提供硬件组件，用于在ARM处理器上启用TEE。OP-TEE是一个流行的开源运行时，支持ARM TZ。ARM TZ的安全世界和正常世界的切换是通过安全监控呼叫(SMC)进行的。系统资源是严格隔离的：正常世界不能访问安全世界的资源(如内存、外设等)。在安全世界的引导过程中，将建立信任链，并对安全世界的软件映像进行完整性检查——这个过程称为安全引导。</p><h2 id="3-威胁模型">3.威胁模型</h2><p>考虑一个强大的攻击者，他拥有管理权限，并且可以物理访问所有支持ARM TZ的节点。进一步假设操作系统和用户空间在正常情况下是不可信的。但是假定TEE(包括引导加载程序、固件、OP-TEE和安全监视器)是可信的。</p><p>由于ARM  TZ本身并不支持远程认证机制，因此攻击者可能会在协议执行之前试图破坏它。链码在正常情况下作为可信应用程序(TA)存储，并使用构建密钥进行签名。ARM  TZ在运行时不提供完整性保护。本论文不考虑侧信道攻击。</p><h2 id="4-TZ4Fabric架构">4.TZ4Fabric架构</h2><p>支持ARM TZ的设备通常是低功耗嵌入式设备，其中许多都是由电池供电的，它们资源（存储和内存）有限。TZ4Fabric依赖于Go编程语言环境、HF、OP-TEE以及gRPC等包，这些包不仅需要几百兆的持久存储，而且在运行时也需要几百兆的内存，因此论文提出通过代理将大型系统组件(如HF和Docker)与轻量级安全相关组件(如链码)解耦。</p><p>在设计中，链码操作及其响应中可以包含敏感信息，必须保护这些信息免受恶意攻击。因此，将链码存放到一个支持TEE的嵌入式设备。将TZ4Fabric分为三大组件：作为链码驻留在对等端上的包装器、代理、链码本身。包装器通过gRPC和代理通信，代理和链码运行在基于ARM的环境中，并使用TrustZone，其中代理在正常世界，链码在安全世界。论文的设计利用OP-TEE框架来进行代理和链码之间的交互。</p><p><strong>包装器</strong>被安装和实例化为链码，并被用作对等端和账本的接口。它将来自客户端的输入调用转发到安全世界中的链码，处理与账本的通信，并将交易响应发送回对等端。</p><p><strong>代理</strong>充当中介，在包装器和链码之间转发调用。它负责从正常世界到安全世界的上下文切换。</p><p><strong>链码</strong>实现了区块链应用程序逻辑，并由客户端通过包装器调用。在执行过程中，链码可以使用代理通过 <code>getState</code> 和 <code>putState</code> 命令访问账本。</p><p>论文的设计允许在一个单一的安全世界中实例化和运行多个链码。</p><p>论文的原型侧重于在HF中包含ARM TZ，而没有实现一个机制在网络中复制链码。链码在原型中作为OP-TEE中的TAs执行，链码使用与机器上运行的OP-TEE相同的构建系统进行编译，TA使用原始的构建密钥进行签名，并可选地加密。因此，在调用链码之前，必须将每个链码编译到TA并在目标机器上安装，然后，链码可以在目标机器上复制并直接调用，而不必经过生成TA的过程。在原型中，为链码生成了一个TA，并将其部署在所有启用ARM  TZ的代理上。</p>]]></content>
      
      
      <categories>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Ekiden. A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts</title>
      <link href="2021/06/13/paper-reading/paper-Ekiden/"/>
      <url>2021/06/13/paper-reading/paper-Ekiden/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入">1.引入</h2><p>现有的智能合约系统因此缺乏保密性和隐私性，它们不能安全地存储或计算敏感数据；区块链共识需求也使得智能合约在计算能力、存储容量和事务吞吐量方面的性能低下。</p><p>区块链和TEE有互补特性：</p><ul><li>区块链可以保证强可用性和持久性，而TEE不能保证可用性（因为宿主可以自行决定终止TEE），也不能可靠地访问网络或持久性存储</li><li>区块链的计算能力非常有限，必须公开其整个状态以供公共验证，而TEE与本地计算相比产生的开销很小，并通过远程认证提供具有机密性的可验证计算</li></ul><p>区块链和TEE结合会产生新的安全问题：由于TEE的基本限制是恶意主机可以任意操纵它的调度和I/O，TEE可能在任意时间中止，导致区块链上丢失和冲突的状态。TEE缺少可信时钟，因此很难更新到区块链的最新状态。可能存在的攻击例如针对区块链的完整性攻击危及TEE保护内容的机密性（如，攻击者可以通过提供一个伪造的区块链来绕过TEE强制执行的隐私计算，以退回到执行前并向其请求任意多个查询）</p><p>Ekiden采用计算与共识分离的架构。Ekiden在链下的TEE中使用计算节点执行私有数据的智能合约计算（避免了链上计算负担），然后验证它们在链上的正确执行，而区块链上的共识节点不需要使用TEE。Ekiden与共识机制无关，只需要一个能够验证来自计算节点的远程认证的区块链。</p><p>为了解决TEE的可用性和网络安全限制，Ekiden支持链上检查和合约状态存储。</p><h3 id="主要贡献">主要贡献</h3><ul><li>正式安全建模：使用一个理想的功能$F_{Ekiden}$来表达Ekiden的全部安全需求，在通用可组合性(UC)框架中概述安全性证明，表明Ekiden协议在并发组合下与$F_{Ekiden}$匹配；</li><li>TEE-区块链结合方案：系统地列举了区块链和TEE融合产生的基本缺陷，并提供了克服这些缺陷的通用技术；</li><li>性能：区块链可能是TEE-区块链混合系统的性能瓶颈。论文提供了优化，在不降低安全性的情况下最小化区块链的使用。</li></ul><h2 id="2-背景">2.背景</h2><h3 id="智能合约">智能合约</h3><p>智能合约系统的限制：</p><ul><li>对每个节点都完全复制的智能合约进行链上计算很昂贵</li><li>传统的智能合约系统不提供隐私保护，用户由假名区别，但是假名只提供很弱的隐私保护</li><li>合约状态和用户输入必须是公开的，以便矿工验证正确的计算，缺乏隐私</li></ul><h3 id="可信硬件">可信硬件</h3><ul><li>SGX生成的认证是不可伪造的</li><li>单单SGX不能保证可用性（恶意主机可以任意终止Enclave或丢弃消息）</li><li>SGX容易遭受侧信道攻击</li></ul><h2 id="3-TEE-区块链系统的技术挑战">3.TEE-区块链系统的技术挑战</h2><h3 id="容忍TEE故障">容忍TEE故障</h3><h4 id="可用性故障">可用性故障</h4><p>在SGX中，恶意主机可以终止Enclave，即使是诚实主机也可能在电源循环中丢失Enclave。TEE-区块链系统必须能够容忍这样的主机故障，确保崩溃的TEE可以延迟执行。</p><p>论文将TEE视为可消耗和可互换的，依赖区块链来解决并发性导致的任何冲突。为了确保任何特定的TEE很容易被替换，TEE是<strong>无状态的</strong>，并且任何持久状态都由区块链存储。</p><h4 id="侧信道">侧信道</h4><p>为了对付SGX的侧信道攻击，论文采用的方法是在空间和时间上进行划分，针对强敌手模型设计Ekiden中的关键组件，如密钥管理器，允许攻击者打破一小部分TEE的机密性，并限制其他组件对密钥管理器的访问。另外还采用了主动密钥旋转来限制泄漏密钥的权限。</p><h4 id="时钟故障">时钟故障</h4><p>SGX的时钟不可信，一个TEE-区块链混合协议必须尽量减少对TEE时钟的依赖。</p><p>在论文的设计中，不需要TEE拥有当前区块链的状态。具体来说，不需要TEE来区分陈旧状态和当前状态，而依赖于区块链主动拒绝任何陈旧输入状态的更新。</p><h3 id="PoW区块链的发布证明">PoW区块链的发布证明</h3><p>为了利用区块链作为持久存储，TEE必须能够有效地验证一个项目已经存储在区块链中，同时TEE也需要能够验证新块。这就需要一个可信时钟来防止敌手隔离Enclave而提供一个无效的子链。</p><p>论文利用了TEE的保密性，这样延迟时钟响应的攻击者就不能阻止Enclave成功验证区块链内容。</p><h3 id="TEE中的密钥管理">TEE中的密钥管理</h3><p>使用区块链持久化TEE状态的一个基本限制是缺乏保密性。通常可以通过在多个TEE中保存相同的密钥副本来实现密钥存储，虽然这种方法能很好地抵抗状态丢失，但是会造成更大的攻击面，在可用性和暴露风险之间需要权衡。</p><p>论文针对强敌手模型设计密钥管理器，允许攻击者打破一小部分TEE的机密性，并限制其他组件对密钥管理器的访问。</p><h3 id="执行结果的原子性交付">执行结果的原子性交付</h3><p>通常，对于有状态的TEE-区块链协议，TEE的执行产生两个消息：</p><ul><li>$m_1$：向调用者发送输出结果</li><li>$m_2$：向区块链发送状态更新</li></ul><p>这两个消息必须原子性交付，要么都交付成功，有一个交付失败则系统不可用：$m_1$ 在调用者收到时交付成功，$m_2$ 在区块链接受时交付成功，被拒绝的状态更新不是交付成功。</p><p>若不要求两个消息的原子性交付，可能产生的攻击有：</p><ul><li>如果只有 $m_1$ 被交付，可能会产生倒回攻击，由于TEE不能判断输入状态是否为新状态，因此攻击者可以提供旧状态以从旧状态恢复TEE的执行，直到获得想要的结果（公平性）；</li><li>如果只有 $m_2$ 被交付，用户可能永久丢失输出，因为一般不可能根据更新后的状态来重新产生相同的输出</li></ul><h2 id="4-Ekiden概述">4.Ekiden概述</h2><p>为了支持像信用评分这样的大规模隐私敏感应用程序，智能合约系统满足数据机密性保护以及高性能的同时要保持区块链提供的完整性和可用性。</p><h3 id="Ekiden概述">Ekiden概述</h3><p>Ekiden实现了用户自定义智能合约的安全执行环境，Ekiden合约是一个确定性的有状态程序。将合约程序的形式定义为 $(outp,st_{new}):=Contract(st_{old},inp)$ ，其中合约的输入是 $st_{old}$（前一个状态）和 $inp$（用户输入），生成输出 $outp$ 和新状态 $st_{new}$。</p><p>一旦部署在Ekiden上，智能合约就有了强大的保密性、完整性和可用性保证。在Ekiden中，有三种实体：</p><ul><li><strong>客户</strong>是智能合约的用户，在Ekiden中，客户可以通过秘密输入创建合同或执行现有的合同。无论哪种情况，客户机都将计算委托给计算节点；</li><li><strong>计算节点</strong>在合约TEE中执行合约并且生成用于证明状态更新正确性的证明，从而处理客户的请求。一组计算节点组成一个密钥管理委员会，并运行一个分布式协议来管理合约TEE使用的密钥，合约TEE通过密钥管理委员会来创建或恢复密钥；</li><li><strong>共识节点</strong>构成区块链，合约状态和认证都保存在这个区块链上。共识节点负责使用TEE检查状态更新的有效性。</li></ul><h3 id="工作流程">工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210609121506911.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210609121506911.png" srcset="data:image/png;base64,666" alt="image-20210609121506911"></p><p>简单起见，假设客户拥有使用的计算节点的优先级列表，客户记为 $P$ ，计算节点记为 $Comp$。</p><h4 id="合约创建">合约创建</h4><p>创建合约时，$P$ 将合约代码 $contract$ 发送给 $Comp$，$Comp$ 将 $Contract$ 加载到合约TEE中，合约TEE创建一个新鲜的合约id $cid$，从密钥管理委员会获取新鲜的 $(pk<sup>{in}_{cid},sk</sup>{in}<em>{cid})$ 对和 $k</em>{cid}^{state}$ 并生成加密的初始状态 $Enc(k^{state}<em>{cid},\vec{0})$ 和一个证明 $\sigma</em>{TEE}$（用于证明TEE初始化的正确性以及 $pk_{cid}^{in}$ 是对应于合约 $cid$ 的公钥）。</p><p>最后，$Comp$ 从认证服务获取 $\sigma_{TEE}$ 的正确性证明，该证明和 $\sigma_{TEE}$ 绑定到一个“certified”证明 $\pi$ 中。$Comp$ 接着发送 $(Contract,pk<sup>{in}_{cid},Enc(k</sup>{state}_{cid},\vec{0}),\pi)$ 到共识节点。</p><p>合约创建的完整协议由Fig2的 $Prot_{Ekiden}$ 中的 <em>create</em> 表示。</p><h4 id="请求执行">请求执行</h4><p>描述Fig1的过程：</p><p>(1) 为了使用输入 $inp$ 来执行合约 $cid$ ，$P$ 首先从区块链获取与合约 $cid$ 相关联的 $pk_{cid}^{in}$ ，计算 $inp_{ct}=Enc(pk^{in}<em>{cid},inp)$ ，并将消息 $(cid,inp</em>{ct})$ 发送给 $Comp$ 。如 $Prot_{Ekiden}$ 的Line8-11所示。</p><p>(2) $Comp$ 从区块链取出合约代码，以及合约 $cid$ 的加密过去状态 $st_{ct}=Enc(k^{state}<em>{cid},st</em>{old})$ ，并将 $st_{ct}$ 和 $inp_{ct}$ 加载到TEE中执行。 如 $Prot_{Ekiden}$ 的Line30-33所示。</p><p>(3-4) 合约TEE从密钥管理委员会获取 $k_{cid}^{state}$ 和 $sk^{in}<em>{cid}$ ，并使用它们解密 $st</em>{ct}$ 和 $inp_{ct}$ 。从而生成输出 $outp$ ，一个新的加密状态 $st<sup>{'}_{ct}=Enc(k_{cid}</sup>{state},st_{new})$ 和一个用于证明计算正确的签名 $\pi$ 。如 $Prot_{Ekiden}$ 的Line7-13所示。</p><p>(5a, 5b) 最后，$Comp$ 和 $P$ 执行一个原子交付协议，将 $outp$ 交付给 $P$ ，并将 $(st^{'}<em>{ct},\pi)$ 交付给共识节点。共识节点先验证 $\pi$ 再接受新状态 $st^{'}</em>{ct}$ 并将其存放在区块链上，只有在这之后，$P$ 才能接收到 $outp$ 。</p><p>Ekiden<strong>将请求执行与共识解耦</strong>。在以太坊中，请求执行被网络中的所有节点复制以达成共识，使得整个网络的速度和单个节点一样慢。而在Ekiden中，请求只被K个计算节点执行，K通常比较小，共识节点只需要验证K个正确执行的证明。</p><p>论文的实现中，<strong>使用签名 $\pi$ 来作为TEE正确执行的证明</strong>。一个计算节点 $Comp$ 通过如下方式获得签名 $\pi$ 。假设 $Comp$ 执行结果为一个输出 $st^{‘}<em>{ct}$ 和一个证明 $\sigma</em>{TEE}$（对合约代码和 $st^{’}<em>{ct}$ 的签名），$Comp$ 将 $\sigma</em>{TEE}$ 发送到IAS，IAS验证 $\sigma_{TEE}$ 并回复 $\pi=(b,\sigma_{TEE},\sigma_{IAS})$ ，其中 $b\in{0,1}$ 表明 $\sigma_{TEE}$ 的有效性，$\sigma_{IAS}$ 是IAS对 $b$ 和 $\sigma_{TEE}$ 的签名。然后 $\pi$ 被提交到共识节点作为 $st^{'}_{ct}$ 正确性的证明。</p><h3 id="Ekiden安全目标">Ekiden安全目标</h3><ul><li><strong>正确执行</strong>：合约状态转换反映了合约代码在给定状态和输入上的正确执行；</li><li><strong>一致性</strong>：在任何时候，区块链都存储与每个计算节点一致的单一状态转换序列；</li><li><strong>保密</strong>：Ekiden保证合约状态和来自诚实客户的输入对所有其他各方保密，另外Ekiden也能抵御一些密钥管理TEE的背叛；</li><li><strong>优雅的机密性降级</strong>：如果有计算节点违反机密性，Ekiden提供前向保密，并与受影响的TEE进行合理隔离。假设机密性违反发生在 $t$ ，攻击者最多能够获取 $t-\Delta$ 的历史。</li></ul><p>Ekiden不对合约级别的隐私泄露进行防御，如合约中的隐蔽信道、bug或侧信道。</p><h3 id="假设和威胁模型">假设和威胁模型</h3><h4 id="TEE">TEE</h4><p>假设SGX是正确实现和安全制造的，但由于SGX存在侧信道攻击，假设敌手可以危及一小部分TEE的机密性。</p><h4 id="区块链">区块链</h4><p>Ekiden对底层共识协议不可知。假设区块链正确执行规定的计算，并且总是可用的。Ekiden依赖共识节点来进行认证，进一步假设区块链提供发布证明，可以证明区块链上包含一些内容。</p><h4 id="威胁模型">威胁模型</h4><ul><li>系统中的各方都必须信任Ekiden和TEE</li><li>假设敌手可以控制除了一个计算节点之外的所有操作系统和网络堆栈，在受控节点上，敌手可以任意排序消息和调度进程</li><li>敌手可以操控任意数量的客户</li><li>客户不需要自己执行合约，也不需要可信硬件</li><li>诚实用户信任自己的代码和平台，但不相信其他客户</li><li>每个合约都有一个明确的策略来规定如何处理数据和服务请求</li><li>Ekiden不能防止合约有意或无意地通过软件漏洞泄露机密</li></ul><h2 id="5-Ekiden重要模块">5.Ekiden重要模块</h2><h3 id="发布证明">发布证明</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210609184625962.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210609184625962.png" srcset="data:image/png;base64,666" alt="image-20210609184625962"></p><p>为permissionless的区块链提出发布证明协议：</p><p>发布证明是一种在验证者 $\varepsilon$ 、合约TEE和不可信证明提供者 $P$ 之间的交互式证明。总的来说，只给 $P$ 有限的时间在足够困难的子链的块上发布消息，从而敌手很难伪造。</p><p>$\varepsilon$ 存储最近的一个checkpoint块 $CB$，可以通过 $CB$ 计算难度系数 $\delta(CB)$ ， $\varepsilon$ 向任何请求客户发出 $CB$ 版本，使客户能够验证 $CB$ 的新鲜度。给定一个有效的最近的 $CB$ ， $\varepsilon$ 可以通过 $\delta(CB)$ 来验证新的块。为了方便分析，论文中的难度系数是恒定的。</p><p>为了初始化 $m$ 的发布，$\varepsilon$ 获取时间戳 $t_1$ ， $\varepsilon$ 可能需要经过一段延时才能收到 $t_1$ 。收到 $t_1$ 之后，$\varepsilon$ 生成一个随机数 $r$ 并要求 $P$ 发布 $(m,r)$ 。$\varepsilon$ 收到 $P$ 发送的证明 $\pi_{(m,r)}$ 之后，获取时间戳 $t_2$ 。令 $n_c$ 为发布 $(m,r)$ 所需要的确认次数，$\tau$ 为期望的块间隔时间（区块链中的定值），$\epsilon$ 为一个乘法松弛因子，代表块产生的时间变化。例如，$\epsilon=1.5$ 表示 $\pi_{(m,r)}$ 的产生可以比预期在主链上的速度慢1.5倍。$\varepsilon$ 只有当 $t_2-t_1&lt;n_c\times\tau\times\epsilon$ 时才接受 $\pi_{(m,r)}$。</p><p>将 $\epsilon$ 设置为一个大的值可以降低错误拒绝的概率（拒绝诚实用户 $P$ 的证明会导致区块链增长速度减慢），然而大的 $\epsilon$ 值也会导致错误接受的概率增大。对于 $\epsilon&gt;1$ ，需要一个足够大的 $n_c$ 来使成功攻击的概率可忽略，然而大的 $n_c$ 意味着诚实用户 $P$ 需要等待很长时间才能获得输出，影响用户体验。</p><p>例如，假设攻击者有25%的算力，设置 $n_c=80$ 以及 $\epsilon=1.6$ 意味着攻击者需要预期2<sup>112</sup>次哈希才能伪造一个发布证明，而诚实的证明只有2<sup>-19</sup>的几率被拒绝。攻击者的伪造时间只有 $t_2-t_1$ ，而若 $\varepsilon$ 经过一段延时才收到 $t_1$ ，则 $t_2-t_1$ 就更短，对攻击者不利。</p><p>一旦一条消息在一个TEE中发布，其他TEE可以通过经认证的安全信道获取该消息及其证明，从而节省重复协议的成本。</p><h3 id="密钥管理">密钥管理</h3><p>每个Ekiden合约都和一系列密钥相关联，包括一个用于状态加密的对称密钥和用于加密客户输入的密钥对。</p><h4 id="敌手模型">敌手模型</h4><ul><li>假设敌手可以打破一定比例（$f%$）的TEE的机密性</li><li>假设参与主体有抵御女巫攻击的身份（交押金才能参与协议）</li><li>假设随时有足够多（$2f%$）的用户在线，从而密钥的可用性得到保证（通过经济奖惩来激励参与）</li></ul><h4 id="所需属性">所需属性</h4><p>由于解密密钥最终会暴露给合约TEE，而合约TEE本身也可能受到威胁，因此采用的密钥必须是短期的，来自暴露机会更低的的长期主密钥。密钥管理协议应满足的属性：</p><ul><li><strong>机密性</strong>：敌手无法窃取长期主密钥</li><li><strong>可用性</strong>：诚实的合约TEE能获取解密密钥</li><li><strong>前向保密</strong>：如果一个短期密钥被窃取，它不能用于解密早于 $t-\Delta$ 时间的加密消息</li></ul><h4 id="初步准备">初步准备</h4><ul><li><p><strong>分布式密钥生成（DKG）</strong>：DKG协议允许N个团体生成随机密钥，DKG协议允许的结果是一个秘密，通过秘密共享方案在各方之间共享；</p></li><li><p><strong>分布式伪随机函数（PRF）</strong>：PRF是函数 $F={f_s}<em>{s\in{S}}$ 的集合，并且对于随机索引 $s\leftarrow</em>$S$，$f_s(·)$ 于一个随机函数不能区分。</p><p>令 $G$ 是一个Schnorr group，$g$ 是一个生成器，$H:{0,1}^*\rightarrow G$ 是一个哈希函数，则 $f_s(x)=H(x)^s$ 是PRF族。</p><p>假设 $s$ 被多方采用 $(k,n)$-秘密分享方案分享，为了评估 $f_s(x)$ ，团体 $i$ 计算并输出 $y_i=H(x)^{s_i}$ ，在收集了至少 $k+1$ 的 ${y_i}$ 之后，可以通过多项式插值得到 $f_s(x)$：$f(x)=H(x)<sup>S=H(x)</sup>{\sum_{i\in A}{S_i\lambda_i}}=\prod_{i\in A}{y_i^{\lambda_i}}$ ，其中 $\lambda_i$ 是拉格朗日系数 $\lambda_i=\prod_{j\neq i}{\frac{-i}{i-j}}$ 。</p></li></ul><h4 id="协议">协议</h4><ul><li><strong>密钥管理委员会和长期密钥</strong>：对于抵抗女巫攻击的身份，可以抽取N 个节点来形成密钥管理委员会（KMC），其中N是系统参数。初始化一个合约 $c$ 时，KMC运行DKG协议来生成一个长期密钥 $k_c$ ，从而 $k_c$ 通过 $(\lceil fN\rceil,N)$-秘密分享方案在KMC成员之间秘密分享。</li><li><strong>生成短期密钥</strong>：假设短期密钥在每一轮都过期，为了在第 $t$ 轮获得合约 $c$ 的短期密钥，一个计算节点 $Comp$ 首先建立安全信道并与KMC成员认证身份。一旦验证了 $Comp$ 确实在执行 $c$ ，每个KMC成员 $i$ 计算 $k_{c,t,i}=H(t)<sup>{k_c</sup>i}$ ，并将 $k_{c,t,i}$ 发送给 $Comp$ 。在从 $A\subseteq$ KMC 收集了 $f+1$ 个结果之后，$Comp$ 可以生成第 $t$ 轮的短期密钥 $k_{c,t}=\prod_{i\in A}{k_{c,t,i}^{\lambda_i}}$ ，其中 $\lambda_i$ 是拉格朗日系数 。</li><li><strong>违规隔离</strong>：通过为每个计算节点强制执行隐私预算，主动隔离违反机密性的行为。为此，假设每个合约TEE有不可伪造的身份，密钥管理节点为每个计算节点 $Comp$ 维护一个计数器 $K_{Comp}$ 来记录请求次数。计数器会随着轮次增加而清零。只有当 $K_{Comp}&lt;K$ 时密钥管理节点才满足计算节点的请求，其中 $K$ 是一个系统参数。这样，无论一个被破坏的计算节点产生多少个TEE，它最多只能获得 $K$ 个密钥。</li></ul><h3 id="原子性交付">原子性交付</h3><p>假设TEE和调用客户 $P$ 之间有一个安全信道，通过以下协议实现 $m_1$ 和 $m_2$ 的原子交付：</p><ol><li>TEE从密钥管理器获取新鲜的密钥 $k$ ，并将加密的认证消息 $m_1^c=Enc(k,m_1)$ 发送给 $P$ ;</li><li>一旦 $P$ 确认收到 $m_1^c$ ，TEE将 $m_2$ 发送给区块链；</li><li>TEE得到 $m_2$ 的发布证明 $\pi_{m_2}$ 之后，将 $k$ 发送给 $P$。</li></ol><h2 id="6-协议细节和安全证明">6.协议细节和安全证明</h2><p>$Prot_{Ekiden}$ 的目的是实现一个通用可组合性(UC)理想功能 $F_{Ekiden}$ 。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210609235608407.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210609235608407.png" srcset="data:image/png;base64,666" alt="image-20210609235608407"></p><h3 id="初步准备和符号说明">初步准备和符号说明</h3><h4 id="认证执行">认证执行</h4><p>使用 $G_{att}$ 正式定义可信硬件上经过验证的执行。一个party首先将程序 $prog$ 通过 <em>install</em> 消息加载进TEE中，通过 <em>resume</em> 调用，程序根据给定输入运行，生成输出 $outp$ 以及一个硬件密钥 $sk_{TEE}$ 下的签名认证 $\sigma_{TEE}=\sum_{TEE}.Sig(sk_{TEE},(prog,outp))$ ，其中 $sk_{TEE}$ 可以通过 $G_{att}.getpk()$ 获取。</p><p>如果一个TEE程序产生一对输出 $(outp_1,outp_2)$ ，认证只对 $outp_1$ 签名，即 $\sigma_{TEE}=\sum_{TEE}.Sig(sk_{TEE},(prog,outp_1))$ ，在 $outp_1$ 中包含 $outp_2$ 的哈希。</p><p>使用合约包装器来抽象例行常用功能，如状态加密，密钥管理等。被包装器扩充的合约 $c$ 称为 $\widehat{c}$ 。</p><h4 id="区块链-v2">区块链</h4><p>$F_{blockchain}[succ]$ 定义了区块链，参数 $succ$ 指定添加到存储中的新item的条件，对交易有效性的概念进行建模。</p><p>除了读写接口，$F_{blockchain}$ 提供了一个接口使得客户可以确定一个item是否包含在区块链内，这个接口避免了提前下载整个区块链。</p><h4 id="参数化-F-blockchain">参数化 $F_{blockchain}$</h4><p>在Ekiden中，存储的内容被解析为<strong>状态转换</strong>的有序数组，定义为 $trans_i=(H(st_{i-1}),st_i,\sigma_i)$ ，包含之前状态的哈希，新状态和对状态转换的正确性的TEE证明。存储可以被解释为一种特殊的初始状态，随后是一系列状态转换：$Storage=((Contract,st_0,\sigma_0),{trans_i}_{i\geq1})$ 。</p><p>状态转换必须扩展最新的状态，并且认证经过验证，它才是有效的。有效性验证是通过使用函数 $succ(·,·)$ 参数化 $F_{blockchain}$ 来实现的：当且仅当 $h=H(st_{old})$ 其中 $st_{old}$ 是 $Storage$ 中的最新状态，同时满足 $\sum_{TEE}.Vf(pk_{TEE},\sigma_{TEE},(h,st_{new}))$ 时，$succ(Storage,(h,st_{new},\sigma_{TEE}))=true$ 。这保证了状态转换链不会分叉。</p><h3 id="协议的正式规范">协议的正式规范</h3><p>$Prot_{Ekiden}$ 是Ekiden协议的正式规范，依赖 $G_{att}$ 和 $F_{blockchain}$ 作为认证执行和区块链的理想功能。$Prot_{Ekiden}$ 使用电子签名方案 $\sum(KGen,Sig,Vf)$ ，对称加密方案 $S\varepsilon(KGen,Enc,Dec)$ 以及非对称加密方案 $A\varepsilon(KGen,Enc,Dec)$。</p><h4 id="状态密钥分享">状态密钥分享</h4><p>每个合约都和一系列密钥绑定，合约TEE将管理密钥的工作委托给密钥管理TEE。在 $Prot_{Ekiden}$ 中，密钥管理的通信由 $keyManager$ 函数进行抽象。</p><h4 id="合约创建-v2">合约创建</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210613112729134.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210613112729134.png" srcset="data:image/png;base64,666" alt="image-20210613112729134" style="zoom:67%;" /><p>创建Ekiden中的合约时，客户 $P_i$ 输入合约代码 $Contract$ ，并调用计算节点 $Comp$ 的 <code>create</code> 子程序。$Comp$ 将 $\widehat{Contract}$ 加载进TEE中，并调用 <em>create</em> 进行初始化。如Fig9所示，合约TEE创建一个新鲜的合约 $cid$ ，从密钥管理器获得新鲜的 $(pk_{cid}<sup>{in},sk</sup>{in}<em>{cid})$ 和 $k</em>{cid}^{state}$ ，并生成加密初始状态 $st_0$ 和一个证明 $\sigma_{TEE}$ ，$\sigma_{TEE}$ 证明了 $st_0$ 被正确初始化以及 $pk_{cid}^{in}$ 是合约 $cid$ 的对应公钥。计算节点 $Comp$ 将 $(Contract,cid,st_0,pk_{cid}^{in},\sigma_{TEE})$ 发送到 $F_{blockchain}$ 并等待回复。$Comp$ 将合约 $cid$ 返回给 $P_i$ ，然后 $P_i$ 验证合约 $cid$ 确实存储在 $F_{blockchain}$ 上。</p><h4 id="请求执行-v2">请求执行</h4><p>为了执行合约 $cid$ ，客户 $P_i$ 首先从 $F_{blockchain}$ 获得输入加密密钥 $pk_{cid}^{in}$ 。然后 $P_i$ 输入 $(cid,inp_{ct})$ 其中 $inp_{ct}$ 是经过 $pk^{in}<em>{cid}$ 加密和经过 $spk_i$ 认证的 $P_i$ 的输入，并调用 $Comp$ 的 <code>request</code> 子程序。$Comp$ 从 $F</em>{blockchain}$ 获取加密的之前状态 $st_{ct}$ ，并使用 $\widehat{Contract}$ 代码和输入 $(cid,inp_{ct},st_{ct})$ 启动一个合约TEE。</p><p>如Fig9所示，如果 $\sigma_{P_i}$ 验证通过，合约TEE使用从密钥管理器获得的密钥解密 $st_{ct}$ 和 $inp_{ct}$ ，并且执行合约 $Contract$ 得到结果 $(st_{new},outp)$ 。为了确保新状态和输出的原子性交付，$Comp$ 和 $P_i$ 执行第5章中描述的原子交付协议：</p><ul><li>首先合约TEE计算 $outp_{ct}=Enc(k^{out}<em>{cid},outp)$ 以及 $st</em>{ct}<sup>{'}=Enc(k</sup>{state}<em>{cid},st</em>{new})$ ，并且通过 $epk_i$ 建立的安全信道发送两个结果的认证给 $P_i$ ；</li><li>$P_i$ 通过调用 $Comp$ 的 <code>claim-output</code> 子程序来确认接收，该子程序使得合约TEE发送 $m_1=(st_{ct}^{'},outp_{ct},\sigma)$ 到 $F_{blockchain}$ 。$\sigma$ 保护 $m_1$ 的完整性，并以加密方式将新状态和输出绑定到以前的状态和输入，从而恶意的 $Comp$ 无法篡改它；</li><li>一旦 $m_1$ 被 $F_{blockchain}$ 接受，合约TEE通过安全信道将解密后的 $outp_{ct}$ 发送给 $P_i$ 。</li></ul><h3 id="Prot-Ekiden-的安全">$Prot_{Ekiden}$ 的安全</h3><p>定理1的证明在附录B</p><blockquote><p>定理1（$Prot_{Ekiden}$ 的安全性）：</p><p>假设 $G_{att}$ 的认证方案 $\sum_{TEE}$ 和数字签名 $\sum$ 在选择消息攻击（EU-CMA）下不可伪造，$H$ 是弱抗碰撞性的，$A\varepsilon$ 和 $S\varepsilon$ 是IND-CPA安全的。则 $Prot_{Ekiden}$ 在 $(G_{att}, F_{blockchain})$-结合模型中安全地实现了对静态敌手的 $F_{Ediden}$ 。</p></blockquote><h3 id="减轻应用程序级别泄露">减轻应用程序级别泄露</h3><p>Ekiden通过启用持久化的应用程序状态来减少应用程序级的隐私泄露（由于智能合约编写的问题导致的隐私泄露等）。</p><h2 id="7-实现">7.实现</h2><p>使用Rust SGX SDK实现了一个编译器，它可以自动将合约构建为可执行文件，并加载到计算节点中。</p><p>Ekiden与许多现有的区块链兼容。</p><h3 id="应用">应用</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210613142330692.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-Ekiden/image-20210613142330692.png" srcset="data:image/png;base64,666" alt="image-20210613142330692"></p><h4 id="机器学习合约">机器学习合约</h4><p>为了演示对秘密数据的共享学习，论文实现了两个示例合约：</p><ul><li>基于财务记录的信用评分</li><li>根据医疗记录预测心脏病的可能性</li></ul><p>提供给这些示例合约的训练数据被视为敏感数据，不会在合约外作为明文公开。</p><h4 id="智能建筑热力学模型">智能建筑热力学模型</h4><p>论文移植了一个非线性最小二乘的实现，用于基于智能建筑提供的时间序列热力学数据来预测温度。Ekiden允许合约运行其模型，同时对传感器数据和模型保密，这表明Ekiden对高度交互的工作负载具有足够的响应能力。</p><h4 id="代币">代币</h4><p>最流行的以太坊合约是ERC20代币标准。论文实现了一个直接用Rust编写的代币合约，Ekiden会自动提供隐私和匿名性，而这是智能合约在以太坊主网上无法实现的。代币中每个用户的帐户余额是保密的。</p><h4 id="扑克">扑克</h4><p>论文实现了一个扑克合约，其中用户轮流向合约提交他们的行动，智能合约包含了洗牌和(有选择地)显示牌的所有游戏逻辑。扑克是区块链系统和安全多方计算的通用基准测试应用程序。Ekiden在每次行动后都将保存状态到区块链，并且可以从任何Enclave访问，所以如果玩家中止行动，秘密纸牌仍然能够被显示出来。</p><h4 id="加密猫">加密猫</h4><p>加密猫是一款以太坊游戏，允许用户繁殖虚拟猫，虚拟猫以ERC721代币的形式存储在链上。每只猫都有一组独特的基因，这些基因决定了它的外观和价值。后代的特征是由一个混合了父母基因的智能合约决定的。基因混合合约的源代码并不公开：游戏开发者的目标是让繁殖过程变得不可预测。</p><p>论文从以太坊区块链获取了基因混合合约的字节码，并使用Ekiden EVM端口执行。论文通过从以太坊网络复制真实交易来验证正确性。这个例子展示了Ekiden可以执行以太坊合约，即使源代码不可用。</p><p>加密猫的基因混合算法经过了逆向工程，这使得玩家能够优化自己繁殖出具有罕见特征的猫的机会，从而破坏游戏的生态系统。相比之下，Ekiden合约可以访问硬件中的随机性来源，并允许加密存储游戏算法。</p><h4 id="Origin">Origin</h4><p>Origin是一个在以太坊之上建立在线市场平台，论文移植了一个demo，允许用户使用Ether列出和购买道具。该应用进一步证明了以太坊的开发框架可以很容易地被Ekiden使用：在demo中使用的智能合约无需修改。基于Ekiden，区块链中的用户交易历史保持隐私，交易确认速度比以太坊更快。</p><h2 id="8-评估">8.评估</h2><p>与以太坊主网上的ERC20合约相比，Ekiden-BT可以支持吞吐量提高600倍、延迟降低400倍、货币成本降低1000倍的代币合约。虽然论文预计在使用更大规模区块链部署时，会出现一些轻微的性能下降，但性能优化显著降低了区块链速度的影响。</p><p>此外，论文证明Ekiden可以有效地支持计算密集型工作，如机器学习应用程序，这在以太坊上是成本高昂的。</p><h3 id="端到端延迟">端到端延迟</h3><h3 id="吞吐量">吞吐量</h3><h3 id="共识对吞吐量的影响">共识对吞吐量的影响</h3><p>to be continued</p>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Hawk.The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts</title>
      <link href="2021/06/06/paper-reading/paper-hawk/"/>
      <url>2021/06/06/paper-reading/paper-hawk/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入">1.引入</h2><p>区块链上的可信时钟的存在对于协议中实现公平交易至关重要：恶意用户可能会过早地中止协议以避免资金支付，但是有了可信时钟，过早地中止协议会被判定为超时，这样区块链就可以将恶意用户的抵押存款重新分配给诚实用户，以此来惩罚恶意用户。</p><p>尽管区块链和智能合约具有表现力和强大功能，但这些技术目前缺乏交易隐私：尽管各方可以创建匿名公钥以增加其匿名性，但每个匿名公钥的所有交易和余额都是公开可见的。缺乏隐私是去中心化智能合约广泛应用的主要障碍，因为一些金融交易，如保险合同或股票交易，被许多个人和组织视为高度机密。</p><h3 id="Hawk概览">Hawk概览</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210603123101742.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210603123101742.png" srcset="data:image/png;base64,666" alt="image-20210603123101742"></p><p>Hawk编译器负责将程序编译成区块链和用户之间的加密协议，一个Hawk程序包括两个部分：</p><ul><li>隐私部分 $\phi_{priv}$ ： 用于接收各方的输入数据和货币等，并执行计算来分配收益。$\phi_{priv}$用于保护参与者的数据和资金交换；</li><li>公开部分 $\phi_{pub}$ ：不涉及隐私数据和资金的部分。</li></ul><p>Hawk编译器把Hawk程序编译成以下几个部分，这些部分共同定义了用户、管理员和区块链之间的加密协议：</p><ul><li>被所有共识节点执行的区块链程序</li><li>由用户执行的程序</li><li>由管理员（一个特别协助方）执行的程序</li></ul><h4 id="安全保证">安全保证</h4><ol><li><strong>链上隐私</strong>：只有合约双方自愿公开信息，区块链才会将交易隐私向公众公布，$\phi_{priv}$以加密形式展现在公众眼前。非正式地讲，链上隐私的实现通过向区块链发送“加密”信息，并依靠零知识证明来确保合同执行和资金保存的正确性。</li><li><strong>合约安全</strong>：保护同一合约协议中的各方互不侵犯，不仅包括机密性和真实性等密码学概念，还包括存在欺骗和中止行为时的公平交易</li></ol><h4 id="最低限度信任管理员">最低限度信任管理员</h4><p>Hawk合约的执行由管理员推动，管理员可以看到用户的输入，并被信任不会泄露用户的隐私数据。</p><ul><li>管理员不是可信第三方：即使管理员可以任意偏离协议或与当事人串通，管理员也不能影响合约的正确执行，如果管理员中止了协议，就会受到经济上的惩罚，而用户则会得到相应的补偿；</li><li>管理人员不需要被信任来维护基础货币的安全性或隐私，如防止双花攻击等；</li><li>如果多个合约实例同时运行，则每个合约可以指定不同的管理员，而恶意管理员只会影响该实例；</li><li>可以用可信计算硬件实例化管理员，或使用用户自己之间的多方计算代替。</li></ul><h3 id="实例：密封拍卖">实例：密封拍卖</h3><p>该实例用于实现一个密封的、第二价格的拍卖，其中出价最高的竞标者获胜，但支付第二高的价格，且竞标者在不知道其他人的出价的情况下提交出价。</p><p>该实例中$\phi_{priv}$决定中标者和支付金额；$\phi_{pub}$使用公共存款来防止管理员通过中止协议来损害竞标者利益。</p><h4 id="合约的安全需求">合约的安全需求</h4><p>前提：</p><ul><li>Hawk的安全建立在区块链本身的安全特性上：假设区块链的共识协议在对手不拥有大量计算能力的情况下是安全的；</li><li>在Hawk中，为了减少链上执行代码产生的费用，设计的协议在链下执行大部分计算</li></ul><p>安全需求：</p><ul><li><strong>独立隐私输入</strong>：各用户在提交自己的投注资金之前无法查看其他用户的投注金额，即使与恶意管理员串通也无法查看；</li><li><strong>交易后隐私保护</strong>：只要管理员不公布信息，即使在拍卖之后各用户的出价也不会公布；</li><li><strong>公平交易</strong>：拍卖参与者可能试图提早退出协议，以避免付款或影响资金再分配。如果一方中止或拍卖管理员中止，中止方将受到经济惩罚，而其余方则获得补偿。Hawk在特定超时后强制执行退款；</li><li><strong>防范不诚实管理员</strong>：除了中止协议外，不诚实的管理员不能影响拍卖结果和资金再分配。对于中止协议的管理员，对其进行罚款。</li></ul><h4 id="中止和超时">中止和超时</h4><p>该实例定义了三种超时 $T_1&lt;T_2&lt;T_3$：</p><ul><li>$T_1$：Hawk合约在$T_1$之后停止招标；</li><li>$T_2$：所有用户都需要在$T_2$内向管理员公布自己的出价，否则将视作0；</li><li>$T_3$：如果管理员中止协议，用户可以在$T_3$后收回投标资金。</li></ul><p>$\phi_{pub}$实现额外的激励机制，本实例中如果管理员提前中止拍卖，将重新分配管理员的公共存款。</p><h3 id="本文贡献">本文贡献</h3><p>Hawk是第一个在去中心化加密货币系统中同时提供隐私交易和可编程性的系统：</p><ul><li><strong>去中心化智能合约的正式模型</strong>：针对密码学的区块链模型，提出了一种形式化的通用可组合性(UC)模型，这种形式模型是独立的，并且在区块链模型中定义协议的安全性时通常是有用的；</li><li><strong>新的加密套件</strong>：实现了一个新的加密套件，它将私有事务与可编程逻辑绑定在一起，包含三个基本原语 <em>freeze</em>，<em>compute</em> 和 <em>finalize</em> ：<ul><li><em>freeze</em>原语允许各方提交正常数据以及货币，提交的货币在合约中冻结，支付分配在之后由$\phi_{priv}$确定；</li><li><em>compute</em>的过程中，各方将提交的数据和货币向管理员公开，以便管理员计算$\phi_{priv}$函数，根据$\phi_{priv}$的结果，管理员构造新的私有货币支付给各用户。然后，管理员向区块链提交新的私有货币以及它们的零知识证明。此时之前冻结的货币在用户中重新分配。</li></ul></li><li><strong>实现和评估</strong>：创建Hawk原型，实现一些应用来评估性能。提出协议优化，得到10倍性能。在约有100个参与方时，管理员使用四核进行密码计算（协议中最昂贵的部分），时间在2.85分钟内；所有的链上计算（由矿工执行）都十分便宜，都在20毫秒以内。</li></ul><h2 id="2-密码学的区块链模型">2.密码学的区块链模型</h2><h3 id="区块链模型">区块链模型</h3><p>区块链在正确性和可用性方面受到信任，但在隐私方面不受信任。区块链不仅维护一个存储每个假名账户余额的全局账本，而且还执行用户定义的程序。论文给出了区块链的通用模型，可以运行任意图灵完备程序：</p><ul><li>区块链的时钟是离散的，每一轮用 <code>round</code> 或 <code>epoch</code> 表示</li><li>所有链上用户都可以观察到区块链的状态，包括公共账本和任何用户定义的程序</li><li>发送到区块链的消息将在下一轮开始时到达。在同一轮中，敌手可以任意重新排序发送到区块链的消息，但不能丢弃消息，然而敌手可以在链下丢弃各方之间传递的消息。这意味着敌手可能会尝试抢先攻击（例如当观察到一个诚实用户正在交易一只股票时，对手会通过发送交易同一只股票的竞争交易来抢占先机）</li><li>用户在区块链上可以创建任意多的假名账户</li><li>假设区块链将正确执行任何规定好的计算</li></ul><h3 id="区块链正式建模">区块链正式建模</h3><p>论文提供了正式的、精确的功能规范和安全性规范，并且设计的协议在通用可组合性(UC)框架下正式证明是安全的。</p><p>建模的程序分为理想程序（记为$IdealP$）、区块链程序（记为$B$）和用户/管理员程序（记为$UserP$）。同时论文定义包装器来将伪代码程序转换为UC框架下的程序：</p><ul><li>理想包装器$F(·)$将理想程序$IdealP$转换为理想函数$F(IdealP)$</li><li>区块链包装器$G(·)$将区块链程序$B$转换为区块链函数$G(B)$，可以延迟区块链上的消息在下一轮开始到达</li><li>协议包装器$\Pi(·)$将用户/管理员程序$UserP$转换为用户端或管理员端的协议$\Pi(UserP)$</li></ul><p>包装器还实现了智能合约应用的一些共同特征，包括时间、公共账本、假名和敌手对消息重新排序，这样就不需要为每个区块链应用重复这些符号。</p><h4 id="正式UC建模及证明">正式UC建模及证明</h4><p>附录B</p><h3 id="编程约定">编程约定</h3><ul><li><strong>Timer激活点</strong>：理想函数包装器$F(·)$和区块链包装器$G(·)$实现了逐轮递增的时钟，并且每次时钟增加，包装器就会调用<strong>Timer</strong>激活点。因此理想程序和区块链程序可以定义<strong>Timer</strong>激活点来实现超时操作；</li><li><strong>理想程序中的延迟处理</strong>：在灰色背景中编写的程序指令表示的是不会立即进行的计算，而是推迟到下一轮开始时执行。这是一种简写，因为在实际协议中，区块链函数完成的任何计算都将被延迟；</li><li><strong>假名</strong>：在理想程序、区块链程序和用户端程序中出现的所有表示用户的标识符默认情况下都指假名；</li><li><strong>账本和转账</strong>：$符号仅用于可读性（用于区分与货币相关的变量和其他变量），并没有特殊含义。</li></ul><h2 id="3-密码学抽象">3.密码学抽象</h2><p>论文使用理想程序的形式来描述密码学抽象。Hawk实现了以下规范：</p><ul><li>私人账本和转账：定义理想程序$IdealP_{cash}$来描述私人账本的需求；</li><li>Hawk-specific原语：定义 <em>freeze</em>、<em>compute</em> 和 <em>finalize</em> 三种Hawk-specific原语来同时满足交易隐私性和可编程性。</li></ul><h3 id="隐私资金规范-IdealP-cash">隐私资金规范$IdealP_{cash}$</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210604135946524.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210604135946524.png" srcset="data:image/png;base64,666" alt="image-20210604135946524" style="zoom:80%;" /><h4 id="Mint">Mint</h4><p><code>mint</code> 操作允许用户 $P$ 将资金从他的公共总账 $ledger[P]$ 转移到私有货币池 $Coins[P]$ ，每次转账后用户 $P$ 的私有货币被创建，并与一个值 $val$ 关联。</p><p>为保证安全性，$IdealP_{cash}$ 在用户 $P$ 创建私有货币之前检查他的公共总账 $ledger[P]$ 中的余额是否足够。</p><h4 id="Pour">Pour</h4><p><code>pour</code> 操作允许用户 $P$ 私下在其私人货币池花钱。简单起见，采用两种输入货币和两种输出货币来模拟货币交换。</p><p>为保证安全性，$IdealP_{cash}$ 会检查：</p><ul><li>对于两种输入货币，用户 $P$ 确实拥有其声明的量那么多的私有货币</li><li>两种输入货币的总价值和两种输出货币的总价值相等</li></ul><h4 id="隐私">隐私</h4><p>当诚实用户 $P$ 执行 <code>mint</code> 操作时，敌手 $A$ 能获得 $(P, val)$。对于公共货币池的任何操作都会被敌手 $A$ 获得。</p><p>当诚实用户 $P$ 执行 <code>pour</code> 操作时，敌手 $A$ 只能获得动态生成的输出假名 $P_1$ 和 $P_2$ ，而不知道哪种在私人池的货币被花了，也不知道花钱的人是谁。如果恶意用户是 <code>pour</code> 操作的接收方，那他会额外获得货币的金额。</p><h4 id="额外的微妙之处">额外的微妙之处</h4><ul><li>诚实用户会跟踪一个装有不同货币的钱包，每当诚实用户执行 <code>pour</code> 操作时，首先会检查本地钱包中是否有相同的货币，如果有，会立即将货币从钱包中取出，通过这种方式，如果诚实用户在一轮中进行了多次 <code>pour</code> 操作，将为每次 <code>pour</code> 操作选择不同的货币；</li><li>诚实用户在下一轮之前是不能花掉同一轮中自己获得的货币的，但是恶意用户可以（因为任何消息都立即被敌手获得，敌手也可以为区块链在同一轮中收到的所有消息选择排序方式）</li><li>诚实用户总会 <code>pour</code> 给存在的假名，但敌手可以 <code>pour</code> 给不存在的假名 $\bot$ ，这种情况下私人货币实际上进入了一个黑洞，并且无法取回。</li></ul><h3 id="Hawk规范-IdealP-Hawk">Hawk规范$IdealP_{Hawk}$</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210604151820907.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210604151820907.png" srcset="data:image/png;base64,666" alt="image-20210604151820907" style="zoom:70%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210604151900011.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210604151900011.png" srcset="data:image/png;base64,666" alt="image-20210604151900011" style="zoom:70%;" /><h4 id="Freeze">Freeze</h4><p>用户 $P$ 从私有货币池 $Coins$ 中移除一种货币，并将其添加到 $FrozenCoins$ 中进行冻结，用户的私有输入 $in$ 也会记录在 $FrozenCoins$ 中。$IdealP_{Hawk}$ 检查 $P$ 之前没有调用过 <em>freeze</em>，并且货币 $(P, val)$ 存在在 $Coins$ 中。</p><h4 id="Compute">Compute</h4><p>用户 $P$ 调用 <em>compute​</em> 时，其私有输入 $in$ 和冻结的货币 $val$ 将公开给管理员 $P_M$</p><h4 id="Finalize">Finalize</h4><p>管理员 $P_M$ 提交一个公共输入 $in_M$ 到 $IdealP_{Hawk}$ ，$IdealP_{Hawk}$ 根据所有用户的输入和冻结的货币价值计算 $\phi_{priv}$ 的结果，并根据这个结果重新分配 $FrozenCoins$ 。为了保证安全，$IdealP_{Hawk}$ 检查冻结货币的总价值等于输出货币的总价值。</p><h4 id="与公共合约交互">与公共合约交互</h4><p>$IdealP_{Hawk}$ 的功能由公共Hawk合约 $\phi_{pub}$ 参数化，在 <em>finalize</em> 过程中，$IdealP_{Hawk}$ 调用 $\phi_{pub}.check$ 。$\phi_{pub}$ 的作用如下：</p><ul><li>检查管理员的输入 $in_M$ 的格式是否正确</li><li>重新分配公共存款：如果用户或管理员提前中止协议，或者用户提供了无效的资金投入（例如少于最低赌注），$\phi_{pub}$ 可以重新分配用户的公开存款</li></ul><h4 id="安全和隐私需求">安全和隐私需求</h4><ul><li>当诚实用户 $P$ <em>freeze</em> 冻结一笔金额时，敌手不能看到该金额，但能看到诚实用户的假名 $P$ 。这不会损害诚实用户的隐私，因为他可以随时创建新的假名；</li><li>当诚实用户调用 <em>compute</em> 时，只有管理员 $P_M$ 能看到用户的输入 和冻结的金额，其他用户不能看到；</li><li>在 <em>finalize</em> 操作期间，输出 $out$ 会公开该所有用户，如果不希望公开，$out$ 可以为空。</li></ul><h4 id="时间和中止">时间和中止</h4><p><em>freeze</em> 操作在 $T_1$ 内完成，$compute$ 操作在 $T_2$ 内完成，如果用户冻结了货币但是在 $T_2$ 内没有公布，则这些冻结的货币会丢失，即 $(in_i, val_i):=(0, \bot)$</p><h4 id="简化的假设">简化的假设</h4><ul><li>论文实现的协议不支持管理员中止协议时冻结货币的退款</li><li>假设参与合约的假名集和超时 $T_1, T_2$ 硬编码在程序中</li></ul><h2 id="4-加密协议">4.加密协议</h2><p>协议分为两部分：</p><h3 id="隐私资金转移">隐私资金转移</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210605154609219.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210605154609219.png" srcset="data:image/png;base64,666" alt="image-20210605154609219"></p><p>区块链程序 $Blockchain_{cash}$ 维护一系列私有货币 $Coins$ ，每一种货币的形式为 $(P, coin:=Comm_s($val))$ ，其中 $P$ 是用户假名，$coin$ 是根据随机数 $s$ 生成的货币值 $$val$ 的承诺。</p><p>在 <code>pour</code> 操作期间，用户 $P$ 选择两种 $Coins$ 中的货币来花费，分别为 $(P, coin_1)$ 和 $(P, coin_2)$ 。<code>pour</code> 操作将 $val^{‘}_1$ 和 $val^{’}_2$ 分别付给两个输出假名 $P_1$ 和 $P_2$ ，并且保证 $val_1+val_2=val<sup>{'}_1+val</sup>{‘}<em>2$ 。支付用户选择新的随机数 $s_i^{'}(i\in{1,2})$ 并计算输出货币 $(P_i,coin_i:=Comm</em>{s<sup>{'}_i}($val_i</sup>{’}))$ ，支付用户将 $s_i^{‘}$ 和 $val_i^{’}$ 发送给收款用户 $P_i$ 。发送者计算一个零知识证明来证明输出的货币是适当构造的，其中正确性涉及以下方面：</p><ul><li>货币的存在性：$(P, coin_1)$ 和 $(P, coin_2)$ 确实是私有货币池 $Coins$ 的一部分，这里使用零知识证明可以确保支付用户隐藏其花费的货币种类。为了提高效率，$Blockchain_{cash}$ 维护一个 $Coins$ 的Merkle树 $MT$ 来证明货币的存在性；</li><li>不会双重支付：每一个货币 $(P, coin)$ 都有一个唯一的序列号 $sn$ ，在 <code>pour</code> 货币时，必须提供货币的 $sn$ 以及其零知识证明来证明 $sn$ 的正确性，$Blockchain_{cash}$ 确保 $sn$ 不会被用两次；</li><li>保护金额：零知识证明确保输入的货币和输出的货币的总价值相等。</li></ul><p>当诚实用户向诚实用户 <code>pour</code> 时，敌手 $A$ 不会知道承诺方案 $Comm$ 隐藏的输出货币的值，敌手 $A$ 可以看到接收两种输出货币的用户假名；</p><p>当不诚实用户 $P^<em>$ 向诚实用户 $P$ <code>pour</code> 时，尽管敌手知道 $coin$ 公开，然而一旦交易在$Blockchain_{cash}$生效，敌手就不能使用 $(P,coin)$，因为 $P^</em>$ 不知道 $P$ 的密钥。</p><blockquote><p>PRF：伪随机函数</p><p>ENC：加密</p><p>DEC：解密</p></blockquote><h3 id="同时实现隐私和可编程逻辑">同时实现隐私和可编程逻辑</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210605154651192.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/paper-hawk/image-20210605154651192.png" srcset="data:image/png;base64,666" alt="image-20210605154651192" style="zoom:70%;" /><h4 id="Freeze-v2">Freeze</h4><p><em>freeze</em> 操作不直接向用户支出，而是将资金以及附带的隐私输入提交给智能合约，这是使用类似<code>pour​</code>的协议完成的：</p><ul><li>用户 $P$ 选择一个私有货币 $(P,coin)\in Coins$，其中 $coin:=Comm_s($val)$。$P$使用自己的密钥计算 $coin$ 的序列号 $sn$ 并公开，用于防止双重支付；</li><li>用户 $P$ 计算承诺 $(val||in||k)$ ，其中 $in$ 是用户输入，$k$ 是一个对称加密密钥（用于实际优化）；</li><li>用户 $P$ 进行零知识证明，类似 <code>pour</code> 操作。</li></ul><h4 id="Compute-v2">Compute</h4><p><em>compute</em> 操作在链下计算 ${val_i^{‘}}_{i\in[n]}$以及进行正确性证明。Hawk依赖管理员 $P_M$ 来进行计算，所有用户将自己的输入经过管理员的公钥加密后发送给管理员：$ct:=ENC(P_M.epk,r,($val||in||k||s^{’}))$ ，其中 $ct$ 是密文， $P_M.epk$ 是管理员的公钥。</p><p>在获取用户的公开信息后，管理员通过私有合约 $\phi_{priv}$ 计算 ${val_i^{'}}_{i\in[n]}$ 以及公开输出 $out$。管理员同时也会构建一个零知识证明来证明结果。</p><h4 id="Finalize-v2">Finalize</h4><p>管理员提交$\phi_{priv}$的结果以及零知识证明到$Blockchain_{cash}$之后，$Blockchain_{cash}$验证证明并重新分配冻结的资金，与此同时还将管理员的公开输入 $in_M$ 和公开输出 $out$ 发送给公开Hawk合约 $\phi_{pub}$。</p><h4 id="定理1">定理1</h4><p>假设Merkle树使用的哈希算法是抗碰撞的，承诺方案 $Comm$ 是 perfectly binding 和计算隐藏的，零知识证明的NIZK方案满足零知识需求，加密方案ENC和SENC是正确并且安全的，PRF方案是安全的，则协议 $UserP_{cash}$ 和 $UserP_{hawk}$ 安全地模拟了静态模型中抵抗恶意对手的理想功能$F(IdealP_{hawk})$ 。</p><blockquote><p>证明在文献[37]:<br>A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk:<br>The blockchain model of cryptography and privacy-preserving smart<br>contracts. <a href="http://ia.cr/2015/675">http://ia.cr/2015/675</a>.</p></blockquote><h3 id="扩展和讨论">扩展和讨论</h3><h4 id="使用可信硬件实例化管理员">使用可信硬件实例化管理员</h4><p>使用可信硬件SGX实例化管理员从而在安全秘密地进行链下计算。但是<strong>任何不与区块链交互的链下协议都不能在中止的情况下提供公平交易——即使使用了可信硬件</strong>。</p><h2 id="5-在UC协议中采用SNARKS以及实际优化">5.在UC协议中采用SNARKS以及实际优化</h2><h3 id="在UC协议中采用SNARKS">在UC协议中采用SNARKS</h3><p>简洁非交互式知识论证（Succinct Non-interactive ARguments of Knowledge）对一般计算任务进行了简洁的证明，并已在多个系统中实现。</p><p>论文的UC协议实现采用高效的SNARK-lifting转换。</p><h3 id="实际考虑">实际考虑</h3><h4 id="高效SNARK电路">高效SNARK电路</h4><p>一个SNARK证明器的性能主要取决于代数电路中乘法门的数量，为了更高效，论文通过两种方式设计优化电路：</p><ol><li>使用SNARK友好的密码原语</li><li>构建定制的电路生成器来友好地实现SNARK，而不是依赖编译器来编译更高级别的实现</li></ol><p>Hawk中在主要的密码学构造块包括：针对Merkle树的抗碰撞哈希函数、伪随机函数、承诺和加密。在实现中，模数q被设置为底层SNARK实现的254位素数，维数d在80位的安全级别下设置为3，在112位的安全级别下设置为4。</p><p>更多性能优化略。。。</p><h2 id="6-实现和评估">6.实现和评估</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Substrate入门</title>
      <link href="2021/04/15/learning-notes/substrate%E5%85%A5%E9%97%A8/"/>
      <url>2021/04/15/learning-notes/substrate%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Start">Start</h2><h3 id="架构">架构</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/substrate%E5%85%A5%E9%97%A8/image-20210415151111761.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/substrate%E5%85%A5%E9%97%A8/image-20210415151111761.png" srcset="data:image/png;base64,666" alt="image-20210415151111761"></p><p>substrate客户端的基本构成：</p><ul><li>存储(storage)：存储区块链的状态，使用简单而高效的键值对存储机制</li><li>运行时(Runtime)：定义处理块的逻辑，包括状态转换逻辑。运行时代码的编译方式有两种：<ul><li>编译为wasm并且存储在区块链上（使得forkless运行时升级成为可能）</li><li>使用本机运行时编译为客户端的本机代码</li></ul></li><li>点对点网络(peer-to-peer network)：使用rust的 <code>libp2p</code> 实现</li><li>共识(consensus)：substrate可以定制共识引擎，也提供一些建立在Web3 Foundation研究之上的共识机制</li><li>RPC(remote procedure call)：使区块链用户可以与网络交互，substrate提供HTTP和WebSocket RPC服务器</li><li>Telemetry：由嵌入式Prometheus服务器公开的客户端度量</li></ul><h2 id="基本概念">基本概念</h2><h3 id="Extrinsics">Extrinsics</h3><p>extrinsic指来自链外的信息，并且会被纳入区块中。分为三类：</p><ul><li>inherents</li><li>签名交易</li><li>无签名交易</li></ul><p><strong>注：</strong> 执行函数时触发的事件不属于extrinsic</p><h4 id="区块结构">区块结构</h4><p>substrate的每一个区块都是由一个区块头和一组extrinsic组成的，区块头包含区块高度、父区块哈希值、extrinsic根哈希值、链上状态根哈希值，以及摘要等信息。</p><p>Extrinsics 被打包到当前区块中并会被执行，每个extrinsic都在runtime进行了定义。  Extrinsic根哈希值主要有两个用途：</p><ul><li>它可以在区块头构建和分发完成之后，防止任何人对该区块头中所含extrinsic内容进行篡改</li><li>它提供了一种方法，在只有区块头信息的条件下，可以帮助轻客户端快速地验证某一区块中存在某笔交易</li></ul><h4 id="Inherents">Inherents</h4><p>Inherent指的是那些仅能由区块创建者插入到区块当中的无签名信息，他们不会在网络上传播或存储在交易队列中</p><p>只要足够多的区块验证人认可该Inherent的合理性，那么这条Inherent就是有效的</p><h4 id="签名交易">签名交易</h4><p>签名交易包含了签发该交易的账户私钥签名，这意味着此账户同意承担相应的区块打包费用</p><p>由于签名交易打包上链的费用在交易执行前就可以被识别，所以在网络节点中传播此类交易造成信息泛滥的风险很小</p><h4 id="无签名交易">无签名交易</h4><p>无签名交易意味着无人支付交易费用，这使得交易队列无法用有效的手段来防止其被滥用</p><p>无签名交易里缺失nonce字段来辅助识别交易执行顺序，从而难以防止重放攻击</p><p>少数交易能够安全使用不具签名的形式，前提是它们需要提供 <code>SignedExtension</code> 的自定义实现，来防止垃圾交易</p><h4 id="Signed-Extension">Signed Extension</h4><p><code>SignedExtension</code> 是一个trait ，通过它可以使用额外的数据或逻辑来扩展交易</p><p>在交易执行之前，任何时候需要获取某笔特定交易信息时，都可以使用 <code>SignedExtension</code> 来实现。 因此<code>SignedExtension</code> 在交易队列中被大量使用</p><p>Runtime会使用 <code>SignedExtension</code> 提供的一些数据，比如用来计算可调用函数<code>Call</code>的交易费用</p><p><code>SignedExtension</code> 还包含一个名为<code>AdditionalSigned</code>的字段，这个字段可存放任意可编码数据，因而能够在打包或者发送交易之前，被用来执行自定义逻辑</p><p>为了避免将可能失败的交易打包进区块中，交易队列还会定期调用 <code>SignedExtension</code> 的函数来验证即将进入区块的交易</p><p><code>SignedExtension</code> 也可以用于验证无签名交易：通过实现<code>*_unsigned</code> 的一系列方法，来封装信息核验、防垃圾信息和重放保护等逻辑，供交易池使用</p><h3 id="交易池">交易池</h3><p>交易池包含所有在网络广播的，已被本地节点接收和验证的交易（签名和未签名的）</p><blockquote><p>有效性</p></blockquote><p>交易池检查交易是否有效（由Runtime决定）：</p><ul><li>检查交易索引 (nonce) 是否正确</li><li>检查帐户是否有足够的资金来支付相关费用</li><li>检查签名是否有效</li></ul><p>交易池还定期检查池内现有交易的有效性： 如果发现无效或过期的普通交易，该交易将被交易池删除</p><blockquote><p>排序</p></blockquote><p>如果交易是有效的，交易队列会将交易分为两组：</p><ul><li>就绪队列：包含所有可放到新的待处理区块中的交易。 对于随 <code>FRAME</code> 构建的 Runtime，所有交易必须严格遵循就绪队列中的顺序</li><li>未来队列：包含所有可能在未来变成有效的交易。例如，一个交易可能有一个对其账户来说过高的 nonce 值，此交易将在未来队列中等待，直到之前的交易上传至区块链上</li></ul><h4 id="交易依赖关系">交易依赖关系</h4><p><code>ValidTransaction</code> 结构体定义了 <code>requires</code> 、 <code>provides</code> 和 <code>priority</code> 参数来构建交易的依赖关系。 这个依赖关系允许交易池产生有效线性顺序的交易</p><p>对于用 <code>FRAME</code> 构建的 Runtime，节点基于不同账户对交易进行排序。 所有签名交易都需要包含一个交易索引 (nonce)，该索引值在每次进行新的交易时都会递增1</p><p><code>FRAME</code> 交易包括一个 <code>provides</code> 标签（值为 <code>encode(sender ++ nonce)</code> ），和 <code>requires</code> 标签（值为 <code>encode(sender ++ (nonce -1)) if nonce &gt; 1</code> ）。来自单一发送人的所有交易将形成一个序列。</p><h4 id="交易优先级">交易优先级</h4><p><code>ValidTransaction</code> 结构体中的 <code>priority</code> 决定了就绪队列中的交易顺序，<code>priority</code> 定义了当一个交易可解锁多个依赖交易时，所应有的线性排序</p><p>当某个节点成为下一个区块生成者时，它将在下一个区块把交易按优先级别从高到低排序，直到达到区块的长度限制</p><p>对于用 <code>FRAME</code> 构建的 Runtime，<code>priority</code> 定义为交易要支付的 <code>fee</code> (费用)。 例如：</p><ul><li>如果我们从不同的发送者那里收到 2 个交易（而且 <code>nonce=0</code> 时），我们通过 <code>priority</code> 来确定哪个交易更为重要，并优先把它打包进区块中</li><li>如果我们从同一个发送方收到 2 个相同 <code>nonce</code> 的交易，那么只会有一个交易会被打包到链上。 我们使用 <code>priority</code> 来选择 <code>fee</code> 较高的交易，并把它储存到交易池中。</li></ul><blockquote><p>注意：交易池并不知道费用、账户、或签名，它只处理交易的有效性和 <code>priority</code>、<code>requires</code> 和 <code>provides</code> 参数这些抽象概念。 所有其他详细信息都是由 Runtime 通过 <code>validate_transaction</code> 函数定义的。</p></blockquote><h4 id="交易的流程">交易的流程</h4><p>交易可以遵循两条路径：</p><h5 id="我们的节点生成的区块">我们的节点生成的区块</h5><ol><li>我们的节点会监听网络上的交易</li><li>每一笔交易都要经过验证，而有效的交易会被放入交易池</li><li>交易池负责对交易进行排序，并返回可被纳入区块的交易。在就绪队列中的交易将被用来打包到区块内</li><li>交易会被执行，而状态变化会存在本地内存中。来自就绪队列的交易也会在网络上传播给其他节点</li><li>构建好的区块会被发布到网络上，而网络上其他所有节点都会接收并执行该区块</li></ol><blockquote><p>注意：交易在区块生成时不会从就绪队列中被删除，只有在区块导入时才被删除，这是因为最新生成的区块有可能进不了规范链里</p></blockquote><h5 id="从网络接收的区块">从网络接收的区块</h5><p>该区块被执行后，整个区块要么成功，要么失败</p><h4 id="交易有效性">交易有效性</h4><p><code>validate_transaction</code> 是在 Runtime 里被调用的，检查有效的签名和 nonce 并返回一个 <code>Result</code></p><p><code>validate_transaction</code> 只会个别地检查交易，所以它不会捡测到类似同一输出被使用两次的错误。</p><p><code>validate_transaction</code> 并不会检查对模块的调用是否成功</p><p><code>validate_transaction</code> 函数应专注于为交易池提供必要的信息，以便对交易进行排序和优先处理，并快速拒绝所有无效或过时的交易</p><h3 id="账户">账户</h3><p>substrate用公私钥对来表示网络参与者</p><h4 id="账户密钥">账户密钥</h4><ul><li><p>密钥对代表一个账户，并可以控制资金</p></li><li><p>账户密钥是通过泛型定义的，在 Runtime 中进行实例化</p></li></ul><h4 id="Stash密钥">Stash密钥</h4><p>Stash 账户的公私钥对，这个账户就像一个 “储蓄账户”，不应该用它进行频繁的交易。因此，应以最安全的方式来保存其私钥</p><h4 id="Controller密钥">Controller密钥</h4><p>Controller 帐户的公私钥对，在 Substrate 的 NPOS 模型中，Controller 密钥会代表某个账户进行验证或提名</p><p>Controller 账户只需要支付交易费用，所以它只需要最少量的资金</p><h3 id="会话密钥">会话密钥</h3><ul><li>会话密钥是验证者用来签署和共识相关消息的 “热密钥”</li><li>更改会话密钥的方式：通过Controller账户对会话公钥签名并创建一个证书，再将证书通过 extrinsic 广播</li><li>会话密钥是通过泛型定义的，在 Runtime 中进行实例化</li></ul><h3 id="交易权重">交易权重</h3><ul><li>链可用的资源是有限的，包括内存、存储 I/O、算力、交易/区块大小和状态数据库的大小</li><li>权重用于管理<strong>验证一个区块所用的时间</strong>，常用于限制存储I/O和算力</li><li>区块中可包含的权重总量是有限的，并且可用的权重消耗通常也会受到交易费的限制</li><li>最大区块权重应等于目标区块时间的三分之一，为区块构造分配、网络传播、导入和验证各分配三分之一</li></ul><h4 id="权重基础">权重基础</h4><p>对权重的计算应该满足：</p><ul><li>在被调用之前可计算。区块创建者在实际决定是否接受某个交易之前应该能够检查其权重</li><li>本身消耗很少的资源。 如果计算交易的权重会消耗与执行交易消耗相似的资源，那这样就没有意义了。因此，权重计算应该比执行交易更轻量级</li><li>无需访问链上状态即可确定使用的资源。权重有利于表示固定的度量或仅基于少量 I/O 的可调用函数参数的测量</li></ul><p>如果权重十分依赖于链上状态，则可以：</p><ul><li>强制使用可调用函数可能消耗的权重上限。 如果可调用函数使用的强制权重上限与其下限差别只是很少，则可直接使用其权重上限而无需访问链上状态。 但是如果两者差别巨大，那么即使进行很少的交易，其经济成本也可能很大，这将破坏激励措施，并降低链上吞吐量</li><li>要求有效权重作为参数传递到可调用函数中。 消耗的权量应基于这些参数，同时也应包含在调用时验证它们所花费的时间。 必须经过这一验证过程以确保权重参数准确对应于链上状态，如果对应不上，则报错</li></ul><h3 id="链下功能">链下功能</h3><p>使用预言机(Oracle)先对链下的数据作查询或处理，然后才将其提交到链上</p><p>预言机是一种外部服务，通常用于监听区块链事件，并根据条件触发任务。 当这些任务执行完毕，执行结果会以交易的形式提交至区块链上。 虽然这种方法可行，但在安全性、可扩展性，和效率方面仍然存在一些缺陷</p><p>因此substrate提供一些链下特性：</p><ul><li>Off-Chain Worker (OCW) 执行长时间运行的和可能不确定的任务（如web请求、加解密、数据签名、随机数生成、cpu密集型计算、链上数据枚举/聚合等）</li><li>Off-Chain Storage 为substrate节点提供本地存储</li><li>Off-Chain Indexing 允许Runtime独立于OCW直接写入链下存储</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/substrate%E5%85%A5%E9%97%A8/image-20210415193130034.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/substrate%E5%85%A5%E9%97%A8/image-20210415193130034.png" srcset="data:image/png;base64,666" alt="image-20210415193130034"></p><h2 id="Runtime">Runtime</h2><ul><li><p>Runtime 用于定义区块链的业务逻辑</p></li><li><p>在 Runtime 中定义了用于表示区块链状态的存储项，同时也定义了允许区块链用户对该状态进行更改的函数</p></li><li><p>为了能够提供无须分叉的升级功能，Substrate采用了可编译成 WebAssembly (Wasm)字节码的 Runtime 形式</p></li><li><p>FRAME 是Parity 的 Substrate runtime 开发系统， FRAME 定义了额外的 runtime 基础类型，并提供了一个框架，使得通过编写模块 (称为 “pallets”) 来构建 runtime 变得十分容易，每个 pallet 用于封装特定于该域的逻辑，这些逻辑可表示为一组存储项、事件、错误和可调用函数的集合</p></li></ul><h3 id="Runtime基本类型">Runtime基本类型</h3><h4 id="核心原语">核心原语</h4><p>runtime必须提供给substrate其他层的最小化内容：</p><ul><li><code>Hash</code>：数据摘要， 通常是一个256位的数值</li><li><code>DigestItem</code></li><li><code>Digest</code>：一系列 <code>DigestItem</code> 的组合， 它对当前区块中轻客户端所需知晓的所有信息进行了编码</li><li><code>Extrinsic</code>：这种类型代表着一段来自链外、且被区块链认可的数据。 它通常包括一个或多个签名，以及某种编码指令(例如转移资金所有权或调用智能合约)</li><li><code>Header</code>：包含了单个区块所有信息 (以加密或其它形式) 的类型。 它包括父区块哈希、存储根哈希和 extrinsic 根哈希、区块摘要及区块号</li><li><code>Block</code>：基本上就是 <code>Header</code> 和一系列 <code>Extrinsics</code> 的组合，以及所使用的哈希算法说明</li><li><code>BlockNumber</code>：一种类型，代表一个有效区块的祖先区块的总数量。 通常是32字节数值</li></ul><h4 id="FRAME原语">FRAME原语</h4><p>如果是通过Substrate FRAME搭建的runtime，还可以使用如下的FRAME原语：</p><ul><li><code>Call</code>: 通过extrinsic调用的可调用函数类型</li><li><code>Origin</code>: 代表着函数调用方，例如可以是签名消息(交易)、无签名消息(区块链内生数据)，或者runtime本身(根调用)</li><li><code>Index</code>: 帐户的交易索引 (nonce) 类型， 存储交易发送方账户曾经发出的交易总数</li><li><code>Hashing</code>：在runtime中使用的哈希系统 (算法)</li><li><code>AccountId</code>： 用于在runtime中识别用户账户的类型</li><li><code>Event</code>：代表runtime发出的事件类型</li><li><code>Version</code>：代表runtime版本的类型</li></ul><h3 id="FRAME">FRAME</h3><p><strong>Framework for Runtime Aggregation of Modularized Entities (FRAME)</strong> 是一组可简化 runtime 开发的模块（pallet）和支持库</p><p>FRAME 提供了一些与 Substrate Primitives 交互的帮助模块，而 Substrate Primitives 则提供了与核心客户端的交互接口</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/substrate%E5%85%A5%E9%97%A8/image-20210415195250082.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/substrate%E5%85%A5%E9%97%A8/image-20210415195250082.png" srcset="data:image/png;base64,666" alt="image-20210415195250082"></p><h3 id="Pallet">Pallet</h3><p>Pallets是一种可组合成为Substrate runtime的特殊Rust模块。每个pallet都拥有独立的逻辑，可修改相应区块链状态转换函数的特征和功能</p><h4 id="Pallet架构">Pallet架构</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入库和依赖项</span></span><br><span class="line"><span class="comment">// 此pallet支持使用任何带有`no_std`标志编译的Rust库。</span></span><br><span class="line"><span class="keyword">use</span> support::&#123;decl_module, decl_event, decl_storage, ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Runtime配置Trait </span></span><br><span class="line"><span class="comment">// 所有runtime类型和常量都放在这里。</span></span><br><span class="line"><span class="comment">// 如果此pallet依赖于其他特定的pallet，则应将依赖pallet的配置trait添加到继承的trait列表中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Config</span></span>: system::Config &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Runtime事件</span></span><br><span class="line"><span class="comment">// 事件是一种用于报告特定条件和情况发生的简单手段，用户、Dapp和区块链浏览器都可能对事件的感兴趣。没有它就很难发现。</span></span><br><span class="line">decl_event!&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Runtime存储</span></span><br><span class="line"><span class="comment">// Runtime存储允许在保证“类型安全“前提下使用Substrate存储数据库，因而可在块与块之间留存内容。</span></span><br><span class="line">decl_storage!&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Pallet声明 </span></span><br><span class="line"><span class="comment">// 此模块定义了最终从此pallet导出的&quot;Module&quot;结构体</span></span><br><span class="line"><span class="comment">// 它定义了该pallet公开的可调用函数，并在区块执行时协调该pallet行为</span></span><br><span class="line">decl_module! &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="Substrate内置模块">Substrate内置模块</h4><p><a href="https://substrate.dev/docs/en/knowledgebase/runtime/frame">汇总链接</a></p><h3 id="Runtime宏">Runtime宏</h3><h4 id="decl-storage">decl_storage!</h4><p>在 pallet 中定义一个存储项目，存储项目的定义包括：</p><ul><li>数据类型，为下列其中一种：<ul><li><code>StorageValue</code>类型: <code>rust-type</code></li><li><code>StorageMap</code>类型: <code>map hasher($hasher) rust_type =&gt; rust_type</code></li><li><code>StorageDoubleMap</code>类型: <code>doublemap hasher($hasher) rust_type, hasher($hasher) rust_type =&gt; rust_type</code></li></ul></li><li>getter函数</li><li>键类型及其哈希函数 (如果是map或double-map类型)</li><li>存储的名称</li><li>默认值</li></ul><p>这些存储值可通过其后的<code>add_extra_genesis</code>模块在其创世区块中进行初始化</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Storage</span></span> <span class="keyword">for</span> Module&lt;T: Config&gt; <span class="keyword">as</span> MyModule &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  add_extra_genesis &#123;</span><br><span class="line">    build (|config| &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.decl_storage.html">API文档</a></p><h4 id="decl-event">decl_event!</h4><p>通过实现 <code>Event</code>枚举类型来定义pallet事件，而宏中的每个事件类型都是<code>Event</code>枚举类型内的一个成员</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.decl_event.html">API 文档</a></p><h4 id="decl-error">decl_error!</h4><p>定义 pallet 在可调用函数中可能返回的错误类型 <code>DispatchError</code> 。宏自动为<code>DispatchError</code> 实现了 <code>From&lt;Error&lt;T&gt;&gt;</code> trait， 因此，<code>DispatchError</code> 能为特定的错误类型返回正确的模块索引、错误代码、错误字符串</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.decl_error.html">API 文档</a></p><h4 id="decl-module">decl_module!</h4><p>定义pallet中的可调用函数，在此宏中，pallet声明了一个名为 <code>Module</code>的结构体，以及一个名为 <code>Call</code> 的枚举类型。除了为 <code>Module</code> 和 <code>Call</code>实现了各种辅助trait，如 <code>Copy</code>、<code>StructuralEq</code>、 <code>Debug</code>以外，该宏还为<code>Module</code>实现了生命周期trait，如 <code>frame_support::traits::OnInitialize</code>， <code>frame_support::traits::OnFinalize</code>， <code>frame_support::traits::OnRuntimeUpgrade</code>，和<code>frame_support::traits::OffchainWorker</code></p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.decl_module.html">API 文档</a></p><h4 id="construct-runtime">construct_runtime!</h4><p>用于构造Substrate runtime，将各个pallets集成到runtime。该宏声明及实现了各种不同的结构体和枚举类型，如<code>Runtime</code>、<code>Event</code>、<code>Origin</code>、 <code>Call</code>、<code>GenesisConfig</code> 等，同时也为这些结构体类型实现了不同的辅助trait</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.construct_runtime.html">API 文档</a></p><ul><li><code>Runtime</code> 结构类型是为Substrate runtime而定义的</li><li><code>Event</code> 枚举类型的成员变量是所有可发出事件的pallets，并且实现了辅助trait和编码/解码trait。<code>Event</code> 实现了<code>TryInto&lt;pallets::Event&lt;Runtime&gt;&gt;</code> trait，以从枚举类型中提取事件</li><li><code>Origin</code>枚举类型是通过实现辅助traits来定义的，如 <code>PartialEq</code>、<code>Clone</code>、 <code>Debug</code>等trait。 此枚举类型定义了是谁调用了extrinsic：<code>NONE</code>、 <code>ROOT</code>还是由特定帐户签名调用</li><li><code>Call</code>枚举类型由所有的集成pallet作为成员变量来定义的。 它包含每个集成pallet的数据和元数据，并通过实现<code>frame_support::traits::UnfilteredDispatchable</code> trait将调用重定向到特定pallet</li><li>该宏定义了<code>GenesisConfig</code> 结构类型，并实现了<code>sp_runtime:: BuildStorage</code> trait以建立存储的创世配置</li><li>该宏收集每一个pallet对 <code>frame_support::unsigned::ValidateUnsigned</code> 这个trait的实现， 如果没有任何一个pallet实现了 <code>ValidateUnsigned</code> trait，则所有的无签名交易都将被拒绝</li></ul><h4 id="parameter-types">parameter_types!</h4><p>用于在构造runtime时声明参数类型，这些参数类型将赋值给各pallet的可配置trait关联类型。该宏使用<code>get()</code>函数返回的具体值，来替换掉结构体中指定的类型。 每个参数的结构体类型还实现了 <code>frame_support::traits::Get&lt;I&gt;</code> 这个trait，以将类型转换为其指定的值</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.parameter_types.html">API 文档</a></p><h4 id="impl-runtime-apis">impl_runtime_apis!</h4><p>通过<code>RuntimeApi</code>和<code>RuntimeApiImpl</code>这两个结构体类型为客户端实现API</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/sp_api/macro.impl_runtime_apis.html">API 文档</a></p><h4 id="add-crypto">add_crypto!</h4><p>指定交给pallet管理的密钥对及其签名算法。该宏声明了三种结构体类型: <code>Public</code>、<code>Signature</code>和<code>Pair</code></p><ul><li><code>Public</code> 类型用于生成密钥对、签名和验证签名</li><li><code>Signature</code> 类型用于在确定了签名加密方法情况下保存签名属性</li><li><code>Pair</code> 类型用于使用种子生成一个公私密钥对</li></ul><p><a href="https://substrate.dev/rustdocs/v3.0.0/sp_application_crypto/macro.app_crypto.html">API 文档</a></p><h4 id="impl-outer-origin">impl_outer_origin!</h4><p>用于为runtime构造一个 <code>Origin</code>结构体类型，它通常由<code>construct_runtime!</code>自动调用</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.impl_outer_origin.html">API 文档</a></p><h4 id="impl-outer-event">impl_outer_event!</h4><p>用于在runtime时构造一个 <code>Event</code> 结构体类型， 它通常由 <code>construct_runtime!</code>宏自动调用</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.impl_outer_event.html">API 文档</a></p><h4 id="impl-outer-dispatch">impl_outer_dispatch!</h4><p>用于实现一个元调用模块，以把调用分派给其它调用者，它通常是由 <code>construct_runtime!</code>自动调用的</p><p><a href="https://substrate.dev/rustdocs/v3.0.0/frame_support/macro.impl_outer_dispatch.html">API 文档</a></p><h3 id="Runtime元数据">Runtime元数据</h3><p>建立在 Substrate 上的区块链会暴露出元数据，以便能轻松与其交互。 元数据根据不同的 pallets来源被分隔成不同模块，对于每个模块，元数据都提供该模块对外暴露的 存储项、extrinsic 调用、事件、常量和错误的相关信息。 Substrate 会自动生成这些元数据，并通过 RPC 函数使它可被调用</p><p>可使用特定语言库或者与语言无关的HTTP和WebSocket API这两种渠道，来从Substrate节点中获取元数据</p><p><a href="https://substrate.dev/docs/en/knowledgebase/runtime/metadata">具体参考</a></p><h3 id="Runtime执行流程">Runtime执行流程</h3><p>Substrate runtime的执行由Executive模块来协调，它负责调用区块链中包含的各种runtime模块</p><p>Executive模块对外暴露了 <code>execute_block</code> 函数，以实现如下功能：</p><ul><li>初始化区块</li><li>执行extrinsics</li><li>完结区块</li></ul><h4 id="验证交易">验证交易</h4><p>在区块开始执行前，检查签名交易的有效性</p><h4 id="执行区块">执行区块</h4><p>只要有效交易的队列不为空，Executive模块就开始执行区块</p><h5 id="初始化区块">初始化区块</h5><p>区块初始化时，System模块和其他runtime模块都会首先调用其<code>on_initialize</code> 函数，把由模块定义的、需要前置的业务逻辑在交易执行前全部处理掉。 除System模块总是优先处理外，其余模块均按照在<code>construct_runtime!</code>宏里定义的顺序来执行</p><p>接下来是初始检查，该步骤将验证区块头中的父哈希是否正确，以及extrinsics trie的根是否囊括了所有的extrinsics</p><h5 id="执行Extrinsics">执行Extrinsics</h5><p>按照交易优先级顺序执行每一个有效的extrinsic。 Extrinsics一定不能在rutnime逻辑中引起程序崩溃，否则系统将很容易受到用户攻击，而通过这种攻击，用户可不受任何惩罚地消耗计算资源</p><p>当extrinsic执行时，原有存储状态不会提前被缓存下来，修改将直接应用到存储上。 因此，在更改存储状态之前，runtime开发人员应进行所有必要检查，以确保extrinsic能执行成功。 一旦extrinsic在执行过程中失败了，存储更改将不能回滚</p><p>extrinsic执行时触发的事件也会写入存储。 因此，在完成所有待执行动作之前，不应该触发相关事件。 否则，倘若extrinsic在事件触发后才执行失败的话，该事件将不能回滚</p><h5 id="完结区块">完结区块</h5><p>执行完所有队列中的extrinsic之后，Executive模块调用各模块的 <code>on_idle</code> 和 <code>on_finalize</code> 函数来执行区块的最后业务逻辑</p><h2 id="智能合约">智能合约</h2><h3 id="概述">概述</h3><h4 id="智能合约与Runtime开发的关系">智能合约与Runtime开发的关系</h4><p>Substrate Runtime 开发和 Substrate 智能合约是使用 Substrate 框架来构建 “去中心化应用” 的两种不同途径</p><h5 id="智能合约-v2">智能合约</h5><p>传统的智能合约平台允许用户在核心区块链逻辑之上发布额外的逻辑，为保证安全性，智能合约平台内建了一些安全防护手段，包括：</p><ul><li>Fees：确保合约开发者在使用了区块链的计算和存储资源来执行智能合约之后付费，这样出块节点的资源就不会被他们滥用</li><li>沙箱：一个合约无法直接修改核心区块链存储或其他合约的存储</li><li>状态租赁：合约会因为占用了区块链的空间而需要为其付费</li><li>回滚：合约可能有导致逻辑错误的情况，我们对合约开发者开发能力的期望很低，因此增加了额外的开销，以支持在交易失败时回滚整个交易</li></ul><h5 id="Runtime开发">Runtime开发</h5><p>Runtime 开发不向开发者提供智能合约所提供的那些保护或安全措施，相反，可以完全控制网络上每个节点运行的基本逻辑，也拥有修改和控制所有模块的每一个存储条目的完整权限</p><p>Substrate Runtime 开发的目的是为区块链提供精炼、高性能、和快速的节点。 它不提供任何保护，不提供交易回退的开销， 也不隐式地引入区块链上节点运行的收费系统</p><h5 id="两者对比">两者对比</h5><table><thead><tr><th>智能合约</th><th>Runtime</th></tr></thead><tbody><tr><td>对网络来说是天生安全</td><td>提供对整个区块链的底层访问权限</td></tr><tr><td>通过经济激励来防止滥用</td><td>没有任何原生的经济激励机制来抵御作恶</td></tr><tr><td>通过额外的计算开销来支持错误处理</td><td>没有内置安全措施带来的性能开销</td></tr><tr><td>开发门槛更低</td><td>开发者需要逾越一定的门槛</td></tr></tbody></table><h3 id="ink-智能合约">ink!智能合约</h3><p>Substrate使用ink!作为其智能合约的语言，ink!是一个基于 Rust 的嵌入式领域专用语言（eDSL），专用于编写Contracts模块的 Wasm 智能合约，其设计宗旨是正确性、简洁性、高效性</p><p>ink! 设计上尽可能接近 Rust 编程语言，使用属性宏将标准的 Rust 结构标记为可理解的合约组件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[ink(...)]</span></span><br></pre></td></tr></table></figure><p>ink!的合约开发组件包括：</p><ul><li>事件 (Events)</li><li>事件主题 (Event Topics)</li><li>存储 (Storage)</li><li>构造函数 (Constructor Functions)</li><li>消息函数 (Message Functions)</li></ul><p>因为是采用 Rust 编写，ink! 可以提供编译时的溢出/下溢安全保护</p><h3 id="ink-语言基础">ink!语言基础</h3><h3 id="合约-Contracts-模块">合约(Contracts)模块</h3><p>合约模块为 Runtime 提供部署和执行wasm智能合约的能力</p><h4 id="Wasm引擎">Wasm引擎</h4><p>合约模块依赖于 Wasm 的沙盒接口，它定义了 Runtime 内可用的 Wasm 执行引擎（<code>wasmi</code>）</p><h4 id="功能">功能</h4><p>合约模块在智能合约的部署和执行上有许多合约开发者熟悉的功能以及一些新功能</p><h5 id="合约账户">合约账户</h5><p>对 Substrate Runtime 来说，合约账户就像普通的用户账户一样；但是，除了普通账户所拥有的 <code>AccountID</code> 和 <code>Balance</code> 之外，合约账户还有相关的合约代码和一些持久的合约存储</p><h5 id="部署合约">部署合约</h5><p>用 Contracts 模块部署合约需要两个步骤：</p><ol><li>在区块链上存储 Wasm 合约</li><li>开启一个由新存储空间的新账户，与该智能合约挂勾</li></ol><p>这意味着可以使用同一个 Wasm 代码初始化多个具有不同的构造参数的合约实例，从而减少区块链上 Contracts 模块所需的存储空间</p><h5 id="合约调用">合约调用</h5><p>调用合约可以改变合约内的储存、创建新合约，或调用其他合约。 由于可以编写自定义 Runtime 模块，Contracts 模块也可以用合约账户直接异步调用那些 Runtime 函数</p><h5 id="沙箱保护">沙箱保护</h5><p>Contracts 模块旨在供公共网络上的所有用户使， 这意味着合约只能直接修改他们自己所拥有的存储。 为了给底层区块链状态提供安全保障，合约模块实现了可逆交易，可回滚那些对存储进行改动而没有成功完成的合约调用</p><h5 id="手续费">手续费</h5><p>为了限制一次交易可使用的计算资源，合约调用需要收取手续费 (gas fee)，在构造合约交易时，需要指定 gas 限额。随着合约的执行，gas 根据计算的复杂性逐步被消耗。如果在合约执行完成前达到 gas 限额，则交易失败，合约存储被还原，gas 费用 <strong>并不会</strong> 退还给用户；如果合约执行完成时还有剩余 gas，则在交易结束时退还给用户</p><h5 id="存储租金">存储租金</h5><p>与 gas 限制了交易的计算资源类似，存储租金限制了合约在区块链存储中的占用率，合约账户按其使用的存储量所占的比例支付租金。 当合约可用余额低于某个限额时，合约账户会变成一个 “墓碑”，其存储被清空。 墓碑合约可通过提供能激活它的最少资金和被清除的数据，来重新激活合约</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-TWINE An Embedded Trusted Runtime</title>
      <link href="2021/04/12/paper-reading/paper-twine/"/>
      <url>2021/04/12/paper-reading/paper-twine/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction">1.Introduction</h2><p>TWINE（Trusted Wasm in Enclave）</p><ul><li>使用标准Intel工具链实现</li><li>允许本地执行遗留Wasm应用程序，而无需重新编译</li><li>动态地将WASI操作转换为系统调用或安全库函数</li><li>将文件操作映射到英特尔的受保护文件系统，持久的数据是透明加密的，并且永远不会以明文的形式从enclave之外访问</li><li>实现了完整的安全SQLite嵌入</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/image-20210411191134381.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/image-20210411191134381.png" srcset="data:image/png;base64,666" alt="image-20210411191134381"></p><blockquote><p>Contributions</p></blockquote><ul><li>通用的Enclave内wasm运行时环境，支持文件系统加密</li><li>广泛评估性能和瓶颈</li><li>改进英特尔受保护文件系统的建议</li></ul><h2 id="3-Background">3.Background</h2><h4 id="LLVM">LLVM</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/3008243-b517c768f5a97607.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/3008243-b517c768f5a97607.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</li><li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li><li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li><li>优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</li></ul><h4 id="WASI">WASI</h4><ul><li>让 WebAssembly 也可以运行在非浏览器环境中</li><li>需要实现可移植的二进制文件（.wasm）和一个跨平台的运行时（runtime）</li><li>实现细粒度的权限控制：<ul><li>先定义一套标准的系统调用接口：<strong><a href="https://github.com/bytecodealliance/wasmtime/blob/master/docs/WASI-api.md">wasi-core</a></strong></li><li>各个平台（windows、unix）对标准接口进行平台实现</li><li>对于一个具体的 wasm 程序，需要把其允许调用的接口在运行的时候传入，比如对于一个 wasm 模块，我只传入“__wasi_path_open”这样一个接口，因此 wasm 中就只能用这样一个接口</li><li>同样的，对于文件路径也是，只允许对传入的文件路径进行操作，例如只传入 /tmp 路径，wasm 模块就没有办法对 /usr 路径下的文件进行操作</li></ul></li></ul><blockquote><p>wasm代表抽象的虚拟机，wasi代表其抽象的OS</p></blockquote><h4 id="WASM运行时">WASM运行时</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/image-20210412100626250.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/image-20210412100626250.png" srcset="data:image/png;base64,666" alt="image-20210412100626250"></p><p>使用WAMR作为底层运行时：</p><ul><li>支持两种解释执行模式，一种慢但内存占用少，另一种快但内存占用多</li><li>支持两种二进制执行模式，AoT和JIT，都使用LLVM</li><li>使用C语言实现，外部依赖很少</li></ul><h2 id="4-Trusted-Runtime-for-WebAssembly">4.Trusted Runtime for WebAssembly</h2><blockquote><p>TWINE由两大模块组成：Wasm运行时和WASI接口</p></blockquote><ul><li>Wasm运行时完全在TEE中运行，而WASI作为可信环境和不可信环境之间的桥梁与OS通信（相当于OCALL）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/image-20210412124151475.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master//notes/paper-twine/image-20210412124151475.png" srcset="data:image/png;base64,666" alt="image-20210412124151475"></p><blockquote><p>WASI的优势在于提供三种抽象：</p></blockquote><ul><li>开发者可以自由选择开发语言，只要能够被LLVM等编译器编译为WASI</li><li>TEE从应用程序中抽象出来：只要TEE能够解释或执行Wasm(由WASI支持)，应用程序就可以安全执行</li><li>WASI与系统无耦合，只要OS提供WASI需要的API就可以使用</li></ul><blockquote><p>安全性</p></blockquote><ul><li><p>WASI可以通过沙箱的方式控制安全性（权限控制）</p></li><li><p>SGX和WASI组成双向沙箱</p><ul><li>系统（Enclave认为untrusted）不能损害enclave代码的完整性或是内存中的数据的机密性</li><li>Wasm应用（OS认为untrusted）不能直接与OS交互，除非WASI给与权限</li></ul></li></ul><h4 id="威胁模型">威胁模型</h4><ul><li>没有物理攻击，且TEE提供了指定的保护级别，并且标准加密不能被破坏</li><li>对于SGX Enclave：enclave内的代码和数据是可信的，而来自外部的任何东西都是不可信的<ul><li>外部只能读取经过加密的enclave内存</li><li>侧信道攻击和拒绝服务攻击可能存在，需要enclave中的应用程序解决</li></ul></li><li>对于OS：遵循honest-but-curious模型</li></ul><h4 id="WASI-v2">WASI</h4><p>WASI是Wasm应用程序与外部世界通信的接口</p><p>WAMR的工具包提供了一个预先编译器，能够在Wasm应用程序到达TWINE的enclave之前，使用LLVM将其编译为本地代码（native code）。因此，<strong>TWINE不包含Wasm解释器，只能执行预先编译的应用程序</strong>（执行本地代码比代码编译更快）</p><p>Wasm运行时比代码解释器占用的内存更小</p><blockquote><p>WASI实现细节</p></blockquote><ol><li><p>大部分WASI调用被直接转换为OCALL</p></li><li><p>TWINE为WAMR实现了一个不同的WASI接口，更适合SGX使用：</p></li></ol><ul><li>保留其沙箱实现</li><li>将剩下部分分为两层：一层用于特定功能实现，一层用于一般调用<ul><li>一般调用通过在enclave外调用类POSIX库来处理，同时提供额外的安全措施和健全性检查；一般调用只有某个功能没有可信实现时才会使用</li></ul></li></ul><ol start="3"><li>TWINE包含一个编译标志，可以全局禁用enclave中的不受信任的POSIX实现（接口可能泄漏主机调用中的敏感数据，例如使用模式和参数）</li></ol><h4 id="IPFS（Intel-Protected-File-System）">IPFS（Intel Protected File System）</h4><p>IPFS分为两部分：<br>1.可信库，在enclave中运行，为文件管理提供了类似POSIX的API<br>2.不可信库，与enclave之外的POSIX函数交互，这些函数进行实际文件读写</p><ul><li>写操作：先由可信库对内容加密，再由不可信库写到存储介质（加密后的文件以Merkle树的结构存在）<br>读操作：由可信库进行完整性校验</li></ul><blockquote><p>IPFS实现细节</p></blockquote><p>IPFS自动创建用于加密文件的密钥，这些密钥由enclave签名和处理器的密钥导出</p><p><strong>TWINE持久化的文件在enclave之外被视为密文，而在Wasm应用程序处理之前会透明地解密并进行完整性检查</strong></p>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
            <tag> wasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOS入门</title>
      <link href="2021/04/09/learning-notes/eos%E5%85%A5%E9%97%A8/"/>
      <url>2021/04/09/learning-notes/eos%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/eos%E5%85%A5%E9%97%A8/1-1Z11115143O34.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/eos%E5%85%A5%E9%97%A8/1-1Z11115143O34.gif" srcset="data:image/png;base64,666" alt="比特币、以太坊、EOS的对比"></p><h2 id="简介">简介</h2><h3 id="平台和工具链">平台和工具链</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/eos%E5%85%A5%E9%97%A8/EOSIO-Overview-dev.svg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/eos%E5%85%A5%E9%97%A8/EOSIO-Overview-dev.svg" srcset="data:image/png;base64,666" alt="EOSIO Development Lifecycle"></p><h4 id="Nodeos">Nodeos</h4><ul><li>EOSIO节点守护进程的核心</li><li>处理区块链数据持久层、点对点网络和智能合约调度</li><li>在开发环境中，可以使用nodeos建立单节点区块链网络</li></ul><h4 id="Cleos">Cleos</h4><ul><li>命令行工具，调用nodeos暴露的接口API</li><li>部署和测试EOSIO智能合约</li></ul><h4 id="Keosd">Keosd</h4><ul><li>密钥管理器守护进程，用于存储私钥和对消息签名</li><li>keosd为要在相关钱包文件中加密的密钥提供安全密钥存储介质</li><li>keosd守护进程还定义了一个安全的enclave，用于对cleos或第三方库创建的交易进行签名</li></ul><h4 id="EOSIO-CDT">EOSIO.CDT</h4><ul><li>WASM工具链</li><li>对EOSIO智能合约的编译进行EOSIO-specfic优化</li></ul><h4 id="EOSJS">EOSJS</h4><ul><li>JavaScript API SDK，集成基于EOSIO的区块链</li></ul><h3 id="核心概念">核心概念</h3><h4 id="账户">账户</h4><ul><li>存储在区块链上的人类可读的名字</li><li>用于转移或提交有效的交易到区块链上</li></ul><h4 id="钱包">钱包</h4><ul><li>存储密钥的客户端</li><li>理想情况下，钱包有一个加密状态和一个解密状态</li></ul><h4 id="授权和权限">授权和权限</h4><ul><li>定义交易的需求，通过linking authorization或linkauth来为特殊合约分配权限</li></ul><h4 id="智能合约">智能合约</h4><ul><li>在链上执行，一旦执行就永久留存在链上且不可变</li></ul><h4 id="DPOS共识">DPOS共识</h4><ul><li>Delegated Proof of Stake 委托权益证明</li><li>若在链上持有token，可以通过投票系统选择block producer</li><li>任何人都可以参与block producer的竞选</li></ul><h4 id="RAM">RAM</h4><ul><li>被视为永久存储，用于存放账户名、权限、代币余额等需要快速访问的链上数据</li><li>RAM需要购买，并且不是基于权益分配，因为RAM是一个有限的持久性资源</li></ul><h4 id="CPU">CPU</h4><ul><li>代表区块链上一个动作的执行时间</li><li>在cleos的 <code>get account</code> 命令的输出中，CPU被称为 <code>cpu bandwidth</code>，代表一个账户在将动作提交到合约时可以支配的处理时间</li><li>CPU是一个瞬态系统资源，属于EOSIO的权益机制</li></ul><h4 id="NET">NET</h4><ul><li>NET是交易的网络带宽，单位为byte</li><li>在cleos的 <code>get account</code> 命令的输出中，NET被称为 <code>net bandwidth</code></li><li>NET是一个瞬态系统资源，属于EOSIO的权益机制</li></ul><h3 id="技术特征">技术特征</h3><h4 id="WebAssembly-C-编译">WebAssembly C++编译</h4><ul><li>EOSIO使用C++编写智能合约</li><li>在EOSIO核心层的顶端是一个Wasm虚拟机：<code>EOS VM</code> ，用于执行智能合约（它是为区块链应用的高要求而设计的，对WebAssembly引擎的要求远远高于为web浏览器标准开发而设计的引擎）</li><li>使用Wasm标准有利于将其他语言移植到EOSIO平台</li></ul><h4 id="高吞吐量、更快的确认、低延迟">高吞吐量、更快的确认、低延迟</h4><h4 id="通过智能合约分配和管理资源">通过智能合约分配和管理资源</h4><h4 id="权益机制">权益机制</h4><ul><li>通过权益机制来获取系统资源（CPU和NET）</li><li>用户使用权益token换取CPU和NET的使用，按照占所有用户的token比例分配</li></ul><h4 id="商业模型灵活性">商业模型灵活性</h4><h4 id="综合的权限架构">综合的权限架构</h4><h4 id="可升级">可升级</h4><h4 id="高效能源消耗">高效能源消耗</h4><h2 id="环境配置">环境配置</h2><h3 id="安装EOSIO和CDT">安装EOSIO和CDT</h3><p>根据<a href="https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/index">官网指示</a>安装<a href="https://github.com/EOSIO/eos/releases">EOSIO</a>和<a href="https://github.com/eosio/eosio.cdt/releases">CDT</a>，在Ubuntu20.04上，下载github上对应的Pre-release包</p><h3 id="创建开发钱包">创建开发钱包</h3><h4 id="创建钱包">创建钱包</h4><p>注意保存密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet create --to-console</span><br></pre></td></tr></table></figure><h4 id="打开钱包">打开钱包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet open</span><br></pre></td></tr></table></figure><p>查看钱包列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet list</span><br></pre></td></tr></table></figure><h4 id="解锁钱包">解锁钱包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet unlock</span><br></pre></td></tr></table></figure><h4 id="向钱包导入密钥">向钱包导入密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet create_key</span><br></pre></td></tr></table></figure><h4 id="导入开发密钥">导入开发密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet import</span><br></pre></td></tr></table></figure><p>输入如下私钥（所有新的EOSIO链都有相同的开发密钥）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3</span><br></pre></td></tr></table></figure><p>对应的开发公钥为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br></pre></td></tr></table></figure><h3 id="开启keosd和nodeos">开启keosd和nodeos</h3><h4 id="开启keosd">开启keosd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keosd &amp;</span><br></pre></td></tr></table></figure><p>若遇到报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;3120000 wallet_exception: Wallet exception Failed to lock access to wallet directory; is another keosd running?&quot;</span></span><br></pre></td></tr></table></figure><p>先使用命令 <code>pkill keosd</code> 再重新开启</p><h4 id="开启nodeos">开启nodeos</h4><p>运行Nodeos，加载所有基本插件，设置服务器地址，开启CORS，添加合约debug和日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nodeos -e -p eosio \</span><br><span class="line">--plugin eosio::producer_plugin \</span><br><span class="line">--plugin eosio::producer_api_plugin \</span><br><span class="line">--plugin eosio::chain_api_plugin \</span><br><span class="line">--plugin eosio::http_plugin \</span><br><span class="line">--plugin eosio::history_plugin \</span><br><span class="line">--plugin eosio::history_api_plugin \</span><br><span class="line">--filter-on=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">--access-control-allow-origin=<span class="string">&#x27;*&#x27;</span> \</span><br><span class="line">--contracts-console \</span><br><span class="line">--http-validate-host=<span class="literal">false</span> \</span><br><span class="line">--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h4 id="查看日志">查看日志</h4><p>查看Nodeos是否正在出块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f nodeos.log</span><br></pre></td></tr></table></figure><p>如果报错 <code>Database dirty flag set (likely due to unclean shutdown): replay required</code> ，先使用命令 <code>pkill nodeos</code> 安全关闭nodeos，再重新开启</p><h4 id="确保RPC-API正常运行">确保RPC API正常运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8888/v1/chain/get_info</span><br></pre></td></tr></table></figure><h3 id="创建开发账户">创建开发账户</h3><ul><li>账户是授权的集合，保存在区块链上</li><li>账户可以标识一个用户，也可以标识智能合约（一个账户只能有一个智能合约）</li><li>账户可以由一个用户或一组用户控制</li></ul><h4 id="创建测试账户">创建测试账户</h4><p>每个EOSIO账户都和一个公钥绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio bob EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br><span class="line"></span><br><span class="line">cleos create account eosio alice EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br></pre></td></tr></table></figure><h4 id="查看账户信息">查看账户信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get account alice</span><br></pre></td></tr></table></figure><p>得到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">permissions: </span><br><span class="line">     owner     1:    1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br><span class="line">        active     1:    1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br><span class="line">memory: </span><br><span class="line">     quota:       unlimited  used:      2.66 KiB  </span><br><span class="line"></span><br><span class="line">net bandwidth: </span><br><span class="line">     used:               unlimited</span><br><span class="line">     available:          unlimited</span><br><span class="line">     <span class="built_in">limit</span>:              unlimited</span><br><span class="line"></span><br><span class="line">cpu bandwidth:</span><br><span class="line">     used:               unlimited</span><br><span class="line">     available:          unlimited</span><br><span class="line">     <span class="built_in">limit</span>:              unlimited</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用户可以暴露active公钥，自己保存owner公钥，这样，如果active公钥被泄露，用户可以使用owner公钥取回账户控制权（所以建议使用不同的active公钥和owner公钥）</p><h2 id="智能合约编写">智能合约编写</h2><h3 id="Hello-World">Hello World</h3><ol><li><p>创建hello目录并编写hello.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract]] hello : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> eosio::contract::contract;</span><br><span class="line">    [[eosio::action]] <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">(eosio::name user)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;Hello, &quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>编译cpp，会产生两个文件：hello.wasm和hello.abi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp -abigen -o hello.wasm hello.cpp</span><br></pre></td></tr></table></figure></li><li><p>部署智能合约</p><ul><li><p>首先创建一个新的hello账户，在hello目录下生成hello账户的公私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create key --file hello_key</span><br></pre></td></tr></table></figure></li><li><p>使用生成的公钥创建hello账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio hello &lt;public key&gt;</span><br></pre></td></tr></table></figure></li><li><p>向钱包导入hello私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet import</span><br></pre></td></tr></table></figure></li><li><p>部署hello智能合约到hello账户（先cd到contracts目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos <span class="built_in">set</span> contract hello ./hello -p hello@active</span><br></pre></td></tr></table></figure></li></ul></li><li><p>调用智能合约</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action hello hi <span class="string">&#x27;[&quot;bob&quot;]&#x27;</span> -p bob@active</span><br></pre></td></tr></table></figure></li><li><p>设置智能合约调用权限</p><ul><li><p>修改hello.cpp并重新编译以及部署</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract]] hello : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> eosio::contract::contract;</span><br><span class="line">    [[eosio::action]] <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">(eosio::name user)</span> </span>&#123;</span><br><span class="line">        require_auth(user);</span><br><span class="line">        print(<span class="string">&quot;Hello, &quot;</span>, eosio::name&#123; user &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>测试：bob说hi，但交易由alice签名（失败）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cleos push action hello hi <span class="string">&#x27;[&quot;bob&quot;]&#x27;</span> -p alice@active</span><br><span class="line"></span><br><span class="line">Error 3090004: Missing required authority</span><br><span class="line">Ensure that you have the related authority inside your transaction!;</span><br></pre></td></tr></table></figure></li><li><p>测试：bob说hi，交易由bob签名（成功）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cleos push action hello hi <span class="string">&#x27;[&quot;bob&quot;]&#x27;</span> -p bob@active</span><br><span class="line"></span><br><span class="line">executed transaction: 033b54bd4a79a9bc868910087bd769e108ffe6f0db29b2b51c61007b03880f51  104 bytes  116 us</span><br><span class="line"><span class="comment">#         hello &lt;= hello::hi                    &#123;&quot;user&quot;:&quot;bob&quot;&#125;</span></span><br><span class="line">&gt;&gt; Hello, bob</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Tokens">Tokens</h3><ol><li><p>获取源代码，在contracts目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/EOSIO/eosio.contracts --branch v1.7.0 --single-branch</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> eosio.contracts/contracts/eosio.token</span><br></pre></td></tr></table></figure></li><li><p>创建一个账户来部署token合约（公钥是EOSIO开发公钥）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br></pre></td></tr></table></figure></li><li><p>编译智能合约</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp -I include -o eosio.token.wasm src/eosio.token.cpp --abigen</span><br></pre></td></tr></table></figure></li><li><p>部署智能合约（cd到 <em>eosio.token/…/</em> 目录下）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos <span class="built_in">set</span> contract eosio.token ./eosio.token --abi eosio.token.abi -p eosio.token@active</span><br></pre></td></tr></table></figure></li><li><p>创建token：需要指定一个颁发者和token名称以及最大供应量；同时为了创建token，需要eosio.token账户的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token create <span class="string">&#x27;[ &quot;alice&quot;, &quot;1000000000.0000 SYS&quot;]&#x27;</span> -p eosio.token@active</span><br></pre></td></tr></table></figure></li><li><p>颁发token：拥有颁发权的alice颁发100个token（可以加上 <code>-d -j</code> 参数来debug）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token issue <span class="string">&#x27;[ &quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot; ]&#x27;</span> -p alice@active</span><br></pre></td></tr></table></figure></li><li><p>交易token：alice转了25个token给bob</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token transfer <span class="string">&#x27;[ &quot;alice&quot;, &quot;bob&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot; ]&#x27;</span> -p alice@active</span><br></pre></td></tr></table></figure><ul><li><p>查看bob以及alice的账户余额</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleos get currency balance eosio.token bob SYS</span><br><span class="line"></span><br><span class="line">cleos get currency balance eosio.token alice SYS</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="ABI文件">ABI文件</h3><p>Application Binary Interface（ABI）用来描述如何将用户操作在JSON格式和二进制格式之间转换</p><blockquote><p>ABI文件结构</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;eosio::abi/1.0&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;types&quot;</span>: [],</span><br><span class="line">   <span class="attr">&quot;structs&quot;</span>: [],</span><br><span class="line">   <span class="attr">&quot;actions&quot;</span>: [],</span><br><span class="line">   <span class="attr">&quot;tables&quot;</span>: [],</span><br><span class="line">   <span class="attr">&quot;ricardian_clauses&quot;</span>: [],</span><br><span class="line">   <span class="attr">&quot;abi_extensions&quot;</span>: [],</span><br><span class="line">   <span class="attr">&quot;___comment&quot;</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="types">types</h4><p><strong>自定义数据类型</strong>需要在ABI文件中进行描述，但是对于EOS.IO的内建类型，无需在ABI文件中说明，之前的<code>hello</code>和<code>eos.token</code>合约的ABI文件中，<code>types</code>都是<code>[]</code>，因为没有自定义类型</p><p>如下，给<code>account_name</code>建立一个笔名，在ABI文件里用<code>name</code>可以代替<code>account_name</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;types&quot;: [&#123;</span><br><span class="line">    &quot;new_type_name&quot;: &quot;account_name&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;name&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="structs">structs</h4><p>声明各个<code>action</code>需要传入的参数，系统根据<code>actions</code>部分中声明的<code>type</code>，在<code>structs</code>部分寻找对应的数据结构，也就是说，函数声明部分并没包含具体内容，具体数据需要到<code>structs</code>中寻找</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;issue&quot;</span>,  <span class="comment">// 数据结构名</span></span><br><span class="line">   <span class="attr">&quot;base&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 继承的父结构名</span></span><br><span class="line">   <span class="attr">&quot;fields&quot;</span>: [<span class="comment">// 参数数组，包含参数名和类型</span></span><br><span class="line">       &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;&quot;</span>, <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;structs&quot;: [&#123;</span><br><span class="line">      &quot;name&quot;: &quot;transfer&quot;,</span><br><span class="line">      &quot;base&quot;: &quot;&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &#123;&quot;name&quot;:&quot;from&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;to&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;quantity&quot;, &quot;type&quot;:&quot;asset&quot;&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;memo&quot;</span>, <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">     &quot;name&quot;: &quot;create&quot;,</span><br><span class="line">     &quot;base&quot;: &quot;&quot;,</span><br><span class="line">     &quot;fields&quot;: [</span><br><span class="line">        &#123;&quot;name&quot;:&quot;issuer&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;maximum_supply&quot;, &quot;type&quot;:&quot;asset&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;can_freeze&quot;, &quot;type&quot;:&quot;uint8&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;can_recall&quot;, &quot;type&quot;:&quot;uint8&quot;&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;can_whitelist&quot;</span>, <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;uint8&quot;</span>&#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">     &quot;name&quot;: &quot;issue&quot;,</span><br><span class="line">     &quot;base&quot;: &quot;&quot;,</span><br><span class="line">     &quot;fields&quot;: [</span><br><span class="line">        &#123;&quot;name&quot;:&quot;to&quot;, &quot;type&quot;:&quot;account_name&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;:&quot;quantity&quot;, &quot;type&quot;:&quot;asset&quot;&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;memo&quot;</span>, <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>&#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="actions">actions</h4><p>用于声明智能合约有哪些可以调用的<code>action</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;transfer&quot;</span>, <span class="comment">// 在智能合约中定义的函数名</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;transfer&quot;</span>, <span class="comment">// 在structs中声明的数据结构名</span></span><br><span class="line">  <span class="attr">&quot;ricardian_contract&quot;</span>: <span class="string">&quot;&quot;</span> <span class="comment">// 可选参数，开发中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tables">tables</h4><p>列出智能合约需要建立的<strong>数据表的名称</strong>以及数据表中存储的结构体名称</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;&quot;</span>,       <span class="comment">// 数据表的名称</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&quot;</span>,       <span class="comment">// 数据表对应的struct</span></span><br><span class="line">  <span class="attr">&quot;index_type&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 主键类型</span></span><br><span class="line">  <span class="attr">&quot;key_names&quot;</span> : [], <span class="comment">// 键名列表，长度与key_types相同</span></span><br><span class="line">  <span class="attr">&quot;key_types&quot;</span> : []  <span class="comment">// 键的类型列表，长度与key_names相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;account&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;index_type&quot;</span>: <span class="string">&quot;i64&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;key_names&quot;</span> : [<span class="string">&quot;primary_key&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;key_types&quot;</span> : [<span class="string">&quot;uint64&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> eos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-SGX容器相关</title>
      <link href="2021/03/24/paper-reading/SGX-Container-LibOS/"/>
      <url>2021/03/24/paper-reading/SGX-Container-LibOS/</url>
      
        <content type="html"><![CDATA[<h2 id="LibOS概念">LibOS概念</h2><p>库操作系统 (Library OS) 的思想是，将应用程序所依赖的操作系统个性（操作系统个性是操作系统的应用程序编程接口(api)和应用程序可见语义的实现，用于构建应用程序的OS服务）作为库在应用程序的地址空间中运行。一个小的、固定的抽象集将库OS连接到主机OS内核，提供了更好的系统安全性和更快速的OS组件独立演化的可能性。</p><h2 id="SCONE-Secure-Linux-Containers-with-Intel-SGX">SCONE: Secure Linux Containers with Intel SGX</h2><blockquote><p>SCONE是一个屏蔽的执行框架，它使未经修改的应用程序能够利用SGX提供的隔离。使用SCONE，程序会根据修改后的标准C库(SCONE libc)重新编译，这有助于系统调用的执行。应用程序的地址空间仅被限定为enclave内存，而不受信任的内存只能通过系统调用接口访问。特殊的包装器复制enclave内部和外部的系统调用参数，并提供以透明的加密方式保护任何数据的功能，否则这些数据可能会以明文形式离开enclave边界(所谓的shield)。</p></blockquote><p>SCONE是一种Docker的安全容器机制，它使用Intel CPU的SGX可信执行支持来保护容器进程免受外部攻击。</p><p>SCONE的特征：</p><ul><li>支持安全策略和透明认证</li><li>原生应用程序支持：不过仍然建议将已有的应用进行重新编译再放入SCONE</li><li>不仅支持静态链接，也支持动态链接：共享库可以在应用程序开始运行后被加载，共享库被SCONE文件系统shield保护</li><li>支持fork</li></ul><h3 id="威胁模型">威胁模型</h3><p>我们假设有一个强大而活跃的对手，他拥有对系统和物理硬件的超级用户访问权。它们可以控制整个软件栈，包括特权代码，如容器引擎、操作系统内核和其他系统软件。这使对手能够重播、记录、修改和删除任何网络数据包或文件系统访问。</p><h3 id="设计权衡">设计权衡</h3><ul><li><p>为了在容器中安全执行Linux进程，应该在enclave中放置怎么样的系统支持?</p></li><li><p>不同的设计方案会影响：</p><ul><li>容器的安全属性，包括TCB的大小和对外公开的接口</li><li>SGX固有限制对性能的影响</li></ul></li></ul><h4 id="可选设计方案">可选设计方案</h4><h5 id="外部容器接口">外部容器接口</h5><p><img src="SGX-Container-LibOS.assets%5Cimage-20201221170158242.png" class="lazyload" data-srcset="SGX-Container-LibOS.assets%5Cimage-20201221170158242.png" srcset="data:image/png;base64,666" alt="image-20201221170158242"></p><p>要在安全容器中执行未修改的进程，容器必须支持C标准库(libc)接口，从而必须使用系统调用，这不能在enclave内部执行，因此安全容器必须向主机OS公开外部接口。关键的决策变成了(a)外部接口和(b)在enclave中实现接口所需的TCB的大小。</p><p>图1a显示了一个先前的设计方案，它通过在enclave中放置一个完整的Windows library OS来最小化外部接口。这种方法的一个好处是，它只公开一个包含22个调用的小外部接口，因为一个进程的大部分系统支持可以由库操作系统提供。然而，库OS增加了enclave内部的TCB大小。此外，由于库OS引入了额外的抽象(例如，执行I/O时)，它可能会增加性能开销。</p><p>图1b的设计是外部接口用于执行应用程序发出的所有libc库调用。这对接口的安全性要求很高。这种方法的一个好处是，它在enclave内部产生了最小的TCB—只有一个很小的shim C库需要将libc调用中继到enclave外部的宿主libc库。</p><p>图1c的设计是前两者取中值，在libc实现执行的系统调用级别上定义了外部接口</p><h5 id="系统调用的开销">系统调用的开销</h5><p>有效的系统调用支持是安全容器的关键需求。因此，安全容器设计不能仅仅简单的使用线程转换来支持系统调用。</p><h5 id="内存访问开销">内存访问开销</h5><p>出于性能原因，安全容器设计应该减少对enclave内存的访问。理想情况下，它应该尽可能多地使用不可信的非enclave内存，而不损害提供的安全保证。</p><h3 id="SCONE设计">SCONE设计</h3><p><img src="SGX-Container-LibOS.assets%5Cimage-20201221182902149.png" class="lazyload" data-srcset="SGX-Container-LibOS.assets%5Cimage-20201221182902149.png" srcset="data:image/png;base64,666" alt="image-20201221182902149"></p><ul><li>SCONE将一个基于系统调用的外部接口暴露给OS，在将参数传递给应用程序之前，执行完整性检查并将所有基于内存的返回值复制到enclave内部</li><li>SCONE支持M:N线程来避免不必要的enclave转换，当应用程序线程发出系统调用时，SCONE检查是否有另一个应用程序线程可以唤醒并执行，直到系统调用的结果可用为止</li><li>SCONE为容器提供了一个到主机OS的异步系统调用接口，使用共享内存来传递系统调用的参数和返回值，并发出执行系统调用的信号，系统调用由SCONE内核模块中运行的独立线程执行，因此在执行系统调用时，enclave中的线程不需要退出</li><li>SCONE集成了现有的Docker容器环境，并确保安全的容器与标准Linux容器兼容</li></ul><h4 id="外部接口防护">外部接口防护</h4><p><strong>文件系统防护</strong></p><p>保护文件的完整性和机密性。容器映像创建者定义三组不相交的文件路径前缀：</p><ol><li><p>未受保护的文件的前缀</p></li><li><p>加密和经过身份验证的文件的前缀</p></li><li><p>经过身份验证的文件的前缀</p></li></ol><p>当文件被打开时，防护层确定文件名的最长匹配前缀。根据匹配情况，对文件进行身份验证、加密或直接传递给主机操作系统。</p><p>SCONE还通过其文件系统防护支持专用的安全临时文件系统。防护层保证了临时文件的完整性和机密性：临时文件系统维护非enclave内存中被修改的文件的状态。</p><p><strong>网络防护</strong></p><p>使用TLS为容器服务建立安全通道，封装了所有的套接字操作，并将它们重定向到一个网络防护层。在建立新连接时，网络防护层将执行TLS握手并对通过套接字传输的任何数据进行加/解密。</p><p>这种方法不需要客户端或服务端更改，私钥和证书是从容器的文件系统中读取的，因此，它们受到文件系统防护层的保护。</p><p><strong>控制台防护</strong></p><p>容器环境允许授权的进程附加到stdin、stdout和stderr控制台流。为了确保发送到这些流的应用程序数据的机密性，SCONE支持对它们进行透明加密。控制台流是单向的，这意味着它们无法受到网络防护层的保护，因为网络防护层的底层TLS实现需要双向流。控制台防护通过基于刷新模式将流分割成可变大小的块来加密流。通过为每个块分配一个唯一的标识符（由授权的SCONE客户端检查)，可以保护流免受重播和重新排序攻击。</p><h4 id="异步系统调用">异步系统调用</h4><p>同步系统调用的缺点：由于SGX不允许系统调用从一个enclave内部发出，必须通过对enclave之外的函数的调用来实现。这意味着执行线程必须将基于内存的参数复制到非enclave内存，退出enclave并执行外部函数来发出系统调用。当系统调用返回时，线程必须重新进入enclave，并将基于内存的结果复制回enclave。效率很低</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20210207121202437.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20210207121202437.png" srcset="data:image/png;base64,666" alt="image-20210207121202437"></p><p>因此，SCONE提供了一个异步系统调用接口。该接口由两个无锁的、多生产者-多消费者队列组成：一个请求队列和一个响应队列。系统调用是通过将请求放入请求队列来发出的。SCONE内核模块中的一个操作系统线程接收并处理这些请求。当系统调用返回时，操作系统线程将结果放入响应队列。</p><h2 id="Ryoan-A-Distributed-Sandbox-for-Untrusted-Computation-on-Secret-Data">Ryoan: A Distributed Sandbox for Untrusted Computation on Secret Data</h2><p>Ryoan提供了一个安全的分布式沙箱，利用SGX来保护沙箱实例免受潜在恶意计算平台的攻击，受保护的沙箱实例限制了不可信的数据处理模块，允许用户在数据处理服务中对数据保密，而不需要信任提供服务的第三方平台</p><h2 id="Graphene-SGX-A-Practical-Library-OS-for-Unmodified-Applications-on-SGX">Graphene-SGX: A Practical Library OS for Unmodified Applications on SGX</h2><p>Graphene-SGX为SGX提供一个端口来增强SGX的功能，如对动态加载库的完整性支持和安全多线程的支持</p><p>将LibOS进程实现为Enclave-Isolated进程（EIP），每个EIP由一个Enclave内的一个LibOS实例托管，即n个EIP需要n个LibOS实例和n个Enclave。</p><p>不足（Occlum中提出）：</p><ul><li>由于Enclave创建的成本很高，进程创建非常昂贵</li><li>EIP之间的进程间通信（IPC）很昂贵，因为EIP完全被Enclave边界隔离，必须通过不可信内存来传输加密的消息来彼此通信</li><li>在多个LibOS实例之间同步时困难的，因为多个LibOS会存在于多个Enclave中</li></ul><h3 id="设计考量">设计考量</h3><p><strong>功能性</strong></p><p>在一个极端，像Haven这样的LibOS将操作系统的大多数应用程序支持代码拖到enclave中。在另一个极端，只有薄薄一层shim，如SCONE和Panoply封装了一个API层(系统调用表)。在enclave中添加更多代码会增加TCB的大小，但可以减少enclave和不受信任的OS之间的接口和攻击面的大小和复杂性。</p><p>在设计时需要考虑：</p><ol><li>进出enclave十分消耗资源</li><li>EPC的大小有限</li></ol><p><strong>防护层的复杂性</strong></p><p>SGX硬件可以将应用程序与不受信任的操作系统隔离，但SGX本身无法保护需要从操作系统获得功能的应用程序。Iago攻击是来自不受信任的操作系统对应用程序的语义攻击，通过未经检查的系统调用返回值损害SGX应用程序。</p><p>因此，任何SGX框架都必须提供一些防护支持，以验证或拒绝来自不受信任的操作系统的输入。防护层的复杂性与接口的复杂性直接相关：由于一个LibOS或shim可以减少enclave  API的大小或复杂性，Iago攻击成功的概率就降低了。</p><p><strong>应用程序代码的复杂性</strong></p><p>将应用程序运行在Enclave中，可以有以下方法：</p><ol><li>修改应用程序，以减少运行时所需的时间</li><li>对不受信任的操作系统开放和屏蔽更多接口</li><li>将更多的功能引入到shim或LibOS中</li></ol><h3 id="设计大纲">设计大纲</h3><h4 id="威胁模型-v2">威胁模型</h4><p>不可信的组件包括：</p><ol><li>英特尔CPU之外的硬件</li><li>操作系统、hypervisor和其他系统软件</li><li>在同一主机上执行的其他应用程序，包括不相关的enclave</li><li>驻留在应用程序进程中但enclave之外的用户空间组件</li></ol><p>可信组件包括：</p><ol><li>英特尔CPU</li><li>Enclave中的代码，包括LibOS、未经修改的应用程序及其支持库</li><li>Intel SGX SDK提供的enclave：aesmd。它用来验证enclave签名中的属性并批准enclave创建。除了aesmd和驱动，不信任Intel SGX SDK</li></ol><h4 id="多进程应用">多进程应用</h4><p>在每个进程中运行一个单独的LibOS实例来支持多进程应用程序。每个LibOS实例通过消息传递来协调状态。例如，通过fork创建第二个enclave，并通过消息传递复制父enclave的内容</p><h3 id="屏蔽Linux抽象">屏蔽Linux抽象</h3><h4 id="动态加载">动态加载</h4><p>为了运行未经修改的Linux二进制文件，Graphene-SGX实现了动态加载和运行时链接。在Linux系统中二进制文件大都是动态链接的，但静态链接在SGX框架中很流行，因为它很简单，便于使用硬件enclave度量。动态链接需要动态加载器中的根信任，然后动态加载器必须度量库。对于Haven，enclave度量仅验证Haven本身的完整性，并且同样的度量适用于在相同的Haven二进制文件上运行的任何应用程序。</p><p>Graphene-SGX扩展了Haven模型，为任何可执行库和动态链接库的组合生成唯一签名。下图显示了一个enclave的结构和动态加载过程。Graphene-SGX从一个不受信任的平台适配层(pal-sgx)开始，该层调用SGX驱动程序来初始化enclave。enclave的初始状态决定了CPU随后验证的度量结果，它包括一个屏蔽库(<a href="http://libshield.so">libshield.so</a>)、要运行的可执行文件和一个清单文件（指定了enclave中的属性和可加载二进制文件）。然后屏蔽库加载一个Linux LibOS (<a href="http://libLinux.so">libLinux.so</a>)和标准C库(<a href="http://ld-linux-x86-64.xn--solibc-j76j.so">ld-linux-x86-64.so和libc.so</a>)。在enclave初始化之后，加载程序继续加载其他库，这些库由屏蔽库检查。如果SHA-256哈希值与清单不匹配，屏蔽层将拒绝打开库。</p><p>清单包括所有组件的完整性度量以及签名，这个清单对于每个应用程序都是唯一的，并作为enclave初始化的一部分进行度量。这种策略需要信任Graphene-SGX(in-enclave)引导加载程序和屏蔽模块，从而能够根据清单正确加载二进制文件，并拒绝OS提供的任何错误二进制文件。这并不比放置在Haven的动态加载器中的信任级别差，但不同点在于Graphene能区分不同的应用程序，甚至相同应用程序的使用不同库的实例。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20210207213328332.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20210207213328332.png" srcset="data:image/png;base64,666" alt="image-20210207213328332"></p><p><strong>存储权限</strong></p><p>默认情况下，Linux链接器格式(ELF)经常将代码和链接数据(例如跳转目标)放在同一个页面中。库在链接期间将可执行页面临时标记为可写，然后将该页面保护为仅执行页面。这种行为在当前的Linux共享库中普遍存在，但是可以在编译时更改，将可写的部分填充到单独的页面上。</p><p>SGX1不能在enclave初始化之后更改页面权限。为了支持这种ELF行为，我们目前将所有enclave页面映射为可读、可写和可执行。这可能会导致一些安全风险，例如enclave中的代码注入攻击。在一些情况下，这也会损害功能，例如，一些JVM实现使用页面错误来同步线程。</p><p><strong>依赖位置的可执行文件</strong></p><p>SGX要求所有的enclave大小都是2的幂，并且起始地址从与enclave大小对齐的虚拟地址开始。大多数Linux可执行文件被编译成依赖于位置的，通常从地址0x400000开始。挑战在于，要创建包含此地址且大于4MB的enclave将必须包含地址0。</p><p>我们认为在enclave中包含地址0是一个正面的结果，但并不是严格必要的，因为我们不愿意在空指针后面的代码中进行强声明。Graphene-SGX仍然可以在enclave中将该地址标记为未映射。因此，空指针仍然会导致页面错误。另一方面，如果地址0在enclave之外，则存在不受信任的OS将该地址映射到危险数据的风险，从而破坏enclave的完整性。</p><h2 id="Occlum-Secure-and-Efficient-Multitasking-Inside-a-Single-Enclave-of-Intel-SGX">Occlum: Secure and Efficient Multitasking Inside a Single Enclave of Intel SGX</h2><p>Occlum设计了一种新的软件故障隔离技术（SFI Software Fault Isolation）用于沙箱不可信模块的软件检测，通过SFI隔离流程（SIP）实现LibOS，从而能够安全共享Enclave的单个地址空间，并且实现既安全又高效的多任务处理</p><p><strong>在SGX中添加LibOS的目的在于</strong>：</p><blockquote><p>SGX开发人员需要将SGX保护的应用程序分成enclave和非enclave两部分，这导致了需要大量的工作来重构SGX的遗留代码。最近的工作试图通过在enclave中引入库操作系统(LibOSes)来尽量减少工作量。通过LibOS提供系统调用，遗留代码可以在enclave中运行，而不需要修改。</p></blockquote><h2 id="AccTEE-A-WebAssembly-based-Two-way-Sandbox-for-Trusted-Resource-Accounting">AccTEE: A WebAssembly-based Two-way Sandbox for Trusted Resource Accounting</h2><p>远程计算通常在沙箱环境中进行：</p><ul><li>隔离执行以保护主机环境免受未经授权的访问</li><li>控制和限制资源使用</li></ul><p>数据所有者和计算提供者存在相互的不信任，因为：</p><ul><li>数据所有者会失去对代码和数据的控制权</li><li>不能确定代码执行环境的完整性</li><li>资源使用审计缺少双方信任</li></ul><p>AccTEE结合SGX和WebAssembly实现一个双向沙箱，在保证代码和数据的机密性和完整性的同时，进行<strong>细粒度地资源核算</strong>（通过计算WebAssembly指令，内存分配以及I/O操作）。</p><ul><li>SGX：保护代码和数据不被计算提供者未经授权访问</li><li>WebAssembly：防止数据所有者未经授权访问计算提供者的机器</li></ul><h3 id="背景">背景</h3><h4 id="使用场景">使用场景</h4><ul><li><p>志愿计算 缺点：</p><ul><li>通过计量捐赠的CPU时间来决定贡献，而不考虑内存、IO或CPU性能</li><li>多次执行每个任务来保证结果的完整性，浪费资源</li><li>志愿者可以获得数据和代码</li></ul><p>通过AccTEE可以保护结果的完整性，避免多次执行浪费资源；也可以跟踪资源使用情况，防止有作弊行为。</p></li><li><p>补偿计算：参与者提供他们私有机器的空闲资源，并以此获得奖励，例如加密货币。但计算资源提供者和基础设施提供者相互不信任，可能存在基础设施提供者恶意修改计算资源提供者的贡献值。<br>通过AccTEE，计算资源提供者可以保护自己的贡献不被恶意修改。</p></li><li><p>无服务计算：由功能即服务（Function-as-a-Service FaaS）驱动，开发人员不需要管理服务器，只需要编写和提交函数代码，由云提供商来设置函数的执行上下文，衡量并行函数实例的数量，连接函数的输入输出。但会存在代码所有者和计算提供者间的不信任。</p></li><li><p>Pay-by-Computation：网络内容提供者主要依靠在线广告获得运营资金，但是用户想方设法删除广告，浏览器也有了拦截广告的技术，因此需要一种替代的，侵入性较小的机制来补充网络内容提供者。<br>通过AccTEE，用户通过使用空闲资源在后台运行短期任务来换取网站的访问权，由双向沙箱来保护任务的机密性和完整性。</p></li></ul><h4 id="WebAssembly">WebAssembly</h4><p>WASM是一种新型的、平台无关的二进制指令格式，其目标是一种安全、快速和可移植的低级代码格式。</p><p>在技术层面，WebAssembly代表了一个基于软件故障隔离的单向沙箱，WebAssembly模块通过不相邻的内存空间相互隔离：代码的内存空间、执行栈、执行环境数据结构和堆是分开的，从而防止任意代码执行以及WebAssembly模块自身数据之外的数据损坏。</p><p>除了内存隔离之外WASM还提供一个受保护的调用堆栈，它只包含固定大小的变量，更复杂的结构存放在线性存储器的栈中，以防止缓冲区溢出。</p><p>WASM提供人类可读的格式WAT，等同于二进制格式。</p><p>AccTEE构建在WASM的内置软件故障隔离之上，以防止程序干扰核算系统。</p><h4 id="威胁模型-v3">威胁模型</h4><p>假设代码数据所有者和计算提供者都是强大的攻击者，可以进行任意行为，所有参与的执行平台都是不可信的。但是信任Intel和SGX。</p><h3 id="AccTEE设计">AccTEE设计</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224124309585.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224124309585.png" srcset="data:image/png;base64,666" alt="image-20201224124309585" style="zoom:80%;" /><h4 id="系统需求">系统需求</h4><ul><li>系统支持各种高级编程语言</li><li>平台独立性：核算的结果独立于平台，平台只需要将workload代码转换为可执行指令</li><li>双向隔离：workload隔离于平台环境，平台提供者不能干涉代码执行</li><li>可信资源核算：双方都不能干预核算机制</li><li>代码和数据的完整性和机密性</li><li>低性能开销</li></ul><h4 id="资源核算方法">资源核算方法</h4><p>AccTEE使用中间代码来获得平台独立性，具体来说，使用WebAssembly来支持更多的语言：对于相同的(确定性的)任务和输入参数，在不同的硬件平台，甚至不同的WebAssembly运行时，执行的WebAssembly指令的数量是相同的。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224143822466.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224143822466.png" srcset="data:image/png;base64,666" alt="image-20201224143822466" style="zoom:80%;" /><ul><li><p>execution sandbox防止不可信的数据和代码访问主机或干预资源核算</p></li><li><p>accounting enclave(AE)防止不可信主机窃听数据代码或操控资源核算</p><ul><li>accounting enclave基于WASM提供的基于语言的隔离实现</li></ul></li><li><p>instrumentation enclave(IE)和AE通过Enclave度量来确保代码正确执行</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224150147495.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224150147495.png" srcset="data:image/png;base64,666" alt="image-20201224150147495" style="zoom:80%;" /><p>总体工作流程：</p><ul><li>将应用程序编译为WebAssembly</li><li>度量WebAssembly代码（在IE中），并输出度量后的WebAssembly代码和一个认证（确保输出是由该IE生成）</li><li>IE的输出作为AE的输入，AE在认证通过后执行代码，并生成资源核算日志</li></ul><h4 id="I-O操作">I/O操作</h4><p>wasm没有为I/O操作指定接口，因此wasm代码被嵌入到运行时系统中，该系统将必要的原语暴露为wasm代码可以调用的函数。</p><p>SGX Enclave中不允许系统调用，必须退出Enclave后才能执行不可信的I/O操作。AccTEE依赖SGX-LKL来执行遗留二进制文件，SGX-LKL处理Enclave内部的系统调用，但是直接访问外部资源的系统调用（如I/O）是不受信任的。</p><h4 id="Accounting-Enclave">Accounting Enclave</h4><p>AccTEE跟踪三种资源类型，其衡量方式如下：</p><ul><li>CPU使用：执行的WASM指令的数量</li><li>内存</li><li>I/O使用：各种I/O通道发送和接收的字节数</li></ul><h5 id="CPU">CPU</h5><p>通过维护一个计数器（指令计数器）来跟踪CPU的使用情况，每执行一条wasm指令就递增。</p><p>AccTEE将一个全局计数器变量添加到原始wasm代码中，初始化为0，同时也在每个代码块的最后添加wasm指令来增加计数器的值。</p><p>wasm指令有不同的复杂度，在计数时需要加权。指令访问内存的成本取决于内存访问模式和访问范围：线性访问便宜而随机访问昂贵，但由于访问内存的指令的成本是无法预测的，所以AccTEE采用峰值内存来估计内存访问的成本。</p><p>指令计数器的<strong>优化</strong>：</p><ul><li>flow-based（基于数据流）：不用每个代码块都进行计数，当一个代码块有多个父节点时，可以在这个代码块加上所有父节点计数的最小值，在父节点上只要加上差值即可，如下图所示</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224205520524.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224205520524.png" srcset="data:image/png;base64,666" alt="image-20201224205520524" style="zoom:80%;" /><ul><li>loop-based（基于循环）：将指令计数器的增量移出循环，不要在每个循环中都增加，而是退出循环之后增加一次。</li></ul><h5 id="内存">内存</h5><p>每个wasm模块都可以访问一块线性内存（连续的一段内存，使用模块定义的大小初始化，但可以动态增长到某个最大值，并且只能增长不能减小），因此AccTEE使用线性内存的大小来计算workload消耗的内存，包含两个策略：</p><ul><li>在代码执行结束时将所有线性内存相加得到内存使用峰值</li><li>将指令计数器和线性内存大小相结合，实现细粒度的内存计算</li></ul><h5 id="I-O">I/O</h5><p>在AccTEE上下文中，wasm运行时时受信任的部分，因此可以通过检测运行时的I/O函数流入和流出wasm模块的字节数来测定。</p><h3 id="AccTEE实现">AccTEE实现</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224212307674.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201224212307674.png" srcset="data:image/png;base64,666" alt="image-20201224212307674" style="zoom:80%;" /><ul><li><p>使用SGX-LKL来在Enclave中运行未修改的二进制文件。<strong>【创新点：可以进行修改？】</strong></p></li><li><p>关于wasm的执行环境，采用Node.js JavaScript运行时，底层使用Chrome的JavaScript引擎V8来执行JavaScript和WebAssembly。<strong>【可替代方案：WAVM、wasmi】</strong></p><ul><li>V8引擎需要“粘合代码”来在JavaScript和wasm执行上下文之间架起桥梁，粘合代码通常是专门为相应的WebAssembly代码定制的，并与之一起生成</li><li>基于Emscripten提供的主模块和副模块的分离。main模块提供了一个接口，包含了它导入的所有标准库函数，并生成所有必要的JavaScript粘合代码。每个附加模块(也称为side模块)只从main模块中导入所需的标准库函数。加载side模块时不需要额外的粘合代码。在我们的框架中，我们只是静态地包含了一个提供所有标准库函数及其粘合代码的main模块，而每个动态加载的模块都是一个从main模块中导入所需功能的side模块。编译和实例化每个side模块的代码直接集成到框架中</li></ul></li></ul><h3 id="AccTEE评估">AccTEE评估</h3><p>SGX HW模式开销比SIM模式和SGX-LKL模式下大得多？（是由于EPC页切换带来的开销？）<br>表现为当workload超过可用的EPC内存（93MB）时，性能显著下降。</p><h2 id="A-Practical-Intel-SGX-Setting-for-Linux-Containers-in-the-Cloud">A Practical Intel SGX Setting for Linux Containers in the Cloud</h2><p>将SGX部署到云环境应该满足：</p><ul><li><p>对远程认证的有限支持：SGX的一个非常重要的特性是能够向第三方(如云用户)证明SGX应用程序的身份和完整性，但原生的Haven和SCONE都没有提供对CPU远程认证的支持；</p></li><li><p>SGX的应用安全：将整个应用包含在一个安全的enclave中的那些解决方案 (Haven, Graphene-SGX, SCONE) 都不一定保证安全，因为它们都扩大TCB，并且可能包含现存的应用或库中的漏洞；</p></li><li><p>限制EPC内存：当前最大的EPC大小是128MB，用户可用的大约是93MB。虽然Linux上支持EPC页面交换，但这会导致相当大的性能损失。EPC限制还意味着云提供商需要保护EPC免受(恶意的)过度使用，这是现有解决方案没有考虑到的一个因素。SGX2甚至允许在enclave运行时期间动态地分配EPC页面，从而加剧了EPC内存消耗；</p></li><li><p>对应用程序的支持：为了减小enclave内部的TCB(可信计算基), Intel强制要求对程序进行分区，这使得SGX的编程变得困难。</p></li></ul><p>提出lxcsgx：</p><ul><li>为容器化应用程序启用SGX远程认证</li><li>在Linux内核中强制每个容器的EPC内存使用进行控制，以防止(恶意的)资源过度使用</li><li>实现一个GCC插件来帮助程序分区，以减少enclave中的TCB，并更好地支持可伸缩性</li><li>使用SGX实现软件TPM，为遗留应用程序提供快速的硬件TPM替换以及套接字api</li><li>基于lxcsgx改进并评估Nginx/OpenSSL和Memcached</li></ul><h3 id="Motivation">Motivation</h3><p>Haven、Graphene-SGX、SCONE等提供一种方案来使用户不需要仔细划分SGX程序，但代价是增加了PCB和Enclave大小，忽视远程认证、EPC大小的硬件限制。</p><h4 id="非官方SDK的不足">非官方SDK的不足</h4><ul><li>不提供远程认证，就不能像远程用户提供保证（应用程序是否确实在Enclave中运行以及Enclave是否具有正确的度量）</li><li>Enclave中的运行时存在安全问题：Enclave内部使用的传统加密库（如OpenSSL）会受到侧信道攻击，Graphene-SGX和SCONE直接将glibc和musl放入Enclave中，存在包含不安全的函数的问题；相比而言，所有危险的函数都从Intel的可信C库中移除，对于敏感的函数则使用硬件指令完成</li></ul><h4 id="程序分区">程序分区</h4><p>程序分区要求开发人员找出代码中最安全敏感的部分，放入SGX的可信区域，从而减小TCB。由于系统调用不允许在Enclave内部进行，所以任何不需要分区的方案都依赖于额外的中间层（如LibOS）来模拟系统调用，然而这样会增大TCB。</p><p>程序分区的另一个好处是在加载时和运行时都可以减少EPC内存的消耗。</p><h4 id="EPC内存控制">EPC内存控制</h4><p>在一台云服务器上只能使用128MB的EPC内存来支持多用户，可能存在的内存泄露会导致SGX内核驱动程序交换其他用户的Enclave，并且也有可能存在恶意用户对EPC内存发起DoS攻击。</p><p>lxcsgx强制对每个容器的EPC内存使用进行控制以防止以上问题。</p><h4 id="软件TPM">软件TPM</h4><p>Enclave不能由不同的进程共享从而减少EPC内存消耗，每个进程都需要分配一个新的虚拟地址区域来加载相同的Enclave，会映射到不同的EPC页面，即EPC页面是不能共享的。</p><p>SGX所需的功能（加密、随机数生成、安全存储等）通常在多个应用之间共享，因此可以在通用平台服务上创建一个单一的Enclave，同时为不同的应用程序服务。</p><p>lxcsgx使用了tpmsgx将SGX通用加密服务实例化为软件tpm，提供给开发者套接字api。</p><h3 id="设计实现">设计实现</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201225115620945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Container-LibOS/image-20201225115620945.png" srcset="data:image/png;base64,666" alt="image-20201225115620945"></p><h4 id="威胁模型-v4">威胁模型</h4><ul><li><p>我们并不一定信任云提供商，它可能对破坏其客户的托管容器的机密性感兴趣。恶意的云提供商还可能主动尝试破坏托管容器的机密性和完整性；</p></li><li><p>Linux内核和运行在云服务器上的LXC程序都不受信任；</p></li><li><p>我们不认为DoS攻击是由ring 0攻击者发起的(例如，防止用户使用Intel SGX)</p></li><li><p>不考虑来自ring 0攻击者的控制通道攻击或来自ring 3攻击者的侧通道攻击</p></li></ul><h4 id="LXC应用的远程认证">LXC应用的远程认证</h4><p>由于LXC/Docker无法挂载非filebackend的套接字，所以容器化应用程序无法直接使用SGX提供的使用QE的远程认证。</p><p>解决方案：</p><ul><li>为Linux内核添加一个新特性以支持容器的抽象UNIX套接字传递</li><li>为了使LXC能够使用内核提供的抽象UNIX套接字直通特性，我们向LXC添加了一个名为lxcsgx.sgx.sock的新配置</li></ul><h4 id="控制EPC内存使用">控制EPC内存使用</h4><p>计算每个容器分配的EPC页面数量，如果请求超过EPC额度的页面，则拒绝分配。然而，找到负责每个EPC分配请求的相应容器并非易事，因为容器对底层Linux内核是透明的，内核只看到进程。</p><p>我们使用<strong>网络名称空间</strong>作为容器的唯一标识符，因为它由在容器内运行的所有应用程序共享。在大多数情况下，容器配置了不同的虚拟网卡(LXC中的veth)，因此具有不同的网络名称空间。当一个网络名称空间被多个容器共享时，EPC控制将应用于名称空间中的每个容器。</p><ul><li>SGX内核驱动程序实现：SGX内核驱动程序负责EPC内存管理，包括分配、交换和回收。在每次尝试EPC页面分配(EADD)时，我们使用SGX驱动程序维护的enclave所有者信息找到请求进程的PID。给定PID，我们找到相应的网络名称空间并检索EPC控制记录。如果激活了记录，并且请求的EPC使用在限制内，则允许分配，并增加使用计数。类似地，对于EPC页回收，我们减少相应EPC控制记录的当前使用计数。</li><li>LXC实现：为了利用EPC控制机制，将另外两个新配置(lxyz .sgx. EPC . limitandlxyz .sgx. EPC .control)添加到LXC中</li></ul><h4 id="tpmsgx：软件TPM">tpmsgx：软件TPM</h4><h2 id="MPTEE-Bringing-Flexible-and-Efficient-Memory-Protection-to-Intel-SGX">MPTEE: Bringing Flexible and Efficient Memory Protection to Intel SGX</h2><blockquote><p>内存保护扩展（MPX）现在在Linux上已失效。如果使用GCC 9.1及更高版本，它实际上已经无效，因为去年删除了编译器端支持，而现在在Linux 5.6中取消了内核支持。</p><p>内存保护扩展是英特尔设计的，用于在运行时检查指针引用，以避免缓冲区溢出以及Skylake和更新的处理器的其他潜在相关漏洞。但是，英特尔一直没有保持对MPX软件的支持，他们表示，未来的英特尔CPU可能会删除MPX功能。 MPX从未真正与基于编译器的消毒器一起真正起飞，它更优雅地解决了相同领域的问题，不需要专门的硬件支持。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust高级特性</title>
      <link href="2021/03/24/learning-notes/rust-advance/"/>
      <url>2021/03/24/learning-notes/rust-advance/</url>
      
        <content type="html"><![CDATA[<h3 id="闭包">闭包</h3><p>在函数中返回闭包：</p><ul><li><p>为了从函数返回一些东西，Rust 需要知道返回类型的大小，而不能直接返回一个trait，因此可以返回一个Box指针</p></li><li><p>在函数中定义的变量放入闭包中返回，会因为移出作用域而失效，因此采用move关键字使得闭包获得它环境的所有权</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">factory</span></span>() -&gt; <span class="built_in">Box</span>&lt;<span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">Box</span>::new(<span class="keyword">move</span> |x| x + num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = factory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = f(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">6</span>, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用函数调用">通用函数调用</h3><p>不同的trait中有同名函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Bar</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Baz</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Foo <span class="keyword">for</span> Baz &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>) &#123; <span class="built_in">println!</span>(<span class="string">&quot;Baz’s impl of Foo&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Bar <span class="keyword">for</span> Baz &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(&amp;<span class="keyword">self</span>) &#123; <span class="built_in">println!</span>(<span class="string">&quot;Baz’s impl of Bar&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = Baz;</span><br><span class="line"><span class="comment">// b.f();// 产生歧义，不能执行</span></span><br><span class="line">Foo::f(&amp;b);</span><br><span class="line">Bar::f(&amp;b);</span><br></pre></td></tr></table></figure><p>结构体本身和trait中有同名函数，使用 <code>&lt;Type as Trait&gt;</code> 指明用的是哪个trait中的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Bar &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Foo <span class="keyword">for</span> Bar &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">10</span>, &lt;Bar <span class="keyword">as</span> Foo&gt;::foo());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">20</span>, Bar::foo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包-crate-和模块-module">包(crate)和模块(module)</h3><p>基本调用：</p><ul><li><p>结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── aaa.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></li><li><p><code>aaa.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_aaa</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>main.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> aaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::aaa::print_aaa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">    print_aaa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多层模块">多层模块</h4><ol><li>优先查找 <code>xxx.rs</code> 文件<ol><li><code>main.rs</code>、<code>lib.rs</code>、<code>mod.rs</code>中的<code>mod xxx</code> ： 默认优先查找同级目录下的 <code>xxx.rs</code> 文件；</li><li>其他文件<code>yyy.rs</code>中的<code>mod xxx</code> ：默认优先查找同级目录的<code>yyy</code>目录下的 <code>xxx.rs</code> 文件；</li></ol></li><li>如果 <code>xxx.rs</code> 不存在，则查找 <code>xxx/mod.rs</code> 文件，即 <code>xxx</code> 目录下的 <code>mod.rs</code> 文件。</li></ol><p><strong>例子</strong>：</p><ul><li><p>结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── a</span><br><span class="line">│   ├── b</span><br><span class="line">│   │   ├── c</span><br><span class="line">│   │   │   ├── d.rs</span><br><span class="line">│   │   │   └── mod.rs</span><br><span class="line">│   │   └── mod.rs</span><br><span class="line">│   └── mod.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure></li><li><p><code>a/b/c/d.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_ddd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i am ddd.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>a/b/c/mod.rs</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> d;</span><br></pre></td></tr></table></figure></li><li><p><code>a/b/mod.rs</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> c;</span><br></pre></td></tr></table></figure></li><li><p><code>a/mod.rs</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> b;</span><br></pre></td></tr></table></figure></li><li><p><code>main.rs</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::a::b::c::d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    d::print_ddd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>**注：**若在 <code>a/mod.rs</code> 中进行重导出(Re-exporting)，即：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> b;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> b::c::d;</span><br></pre></td></tr></table></figure><p>则可以直接在 <code>main.rs</code> 中使用 <code>use a::d;</code> 来调用</p><h4 id="路径">路径</h4><p><code>self</code> 的含义：</p><ol><li><code>use self::xxx</code> 表示，加载当前模块中的 <code>xxx</code>。此时 self 可省略；</li><li><code>use xxx::&#123;self, yyy&#125;</code>，表示，加载当前路径下模块 <code>xxx</code> 本身，以及模块 <code>xxx</code> 下的 <code>yyy</code>；</li></ol><p><code>super</code> 表示父模块：<code>use super::xxx;</code> 表示引用父模块中的 <code>xxx</code></p><h3 id="数组转基本类型">数组转基本类型</h3><p>将包含4个u8的数组转换为u32类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>];</span><br><span class="line">    <span class="keyword">let</span> b = mem::transmute::&lt;[<span class="built_in">u8</span>; <span class="number">4</span>], <span class="built_in">u32</span>&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联类型">关联类型</h3><p>将多个类型归为一类，如下，构建一个图(Graph)，需要的类型包括点(Node)和边(Edge)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</span><br><span class="line">        <span class="built_in">Vec</span>::new()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> graph = MyGraph;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(graph) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</span><br></pre></td></tr></table></figure><h3 id="宏">宏</h3><p>$开头的变量是语法元素，指示符用于限定愈发元素的类型，包括：</p><ul><li>ident: 标识符，用来表示函数或变量名</li><li>expr: 表达式</li><li>block: 代码块，用花括号包起来的多个语句</li><li>pat: 模式，普通模式匹配（非宏本身的模式）中的模式，例如 <code>Some(t)</code>, <code>(3, 'a', _)</code></li><li>path: 路径，注意这里不是操作系统中的文件路径，而是用双冒号分隔的限定名(qualified name)，如 <code>std::cmp::PartialOrd</code></li><li>tt: 单个语法树</li><li>ty: 类型，语义层面的类型，如 <code>i32</code>, <code>char</code></li><li>item: 条目，</li><li>meta: 元条目</li><li>stmt: 单条语句，如 <code>let a = 42;</code></li></ul><h4 id="重复">重复</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vector &#123;</span><br><span class="line">    ($($x:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(temp_vec.push($x);)*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = vector![<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归">递归</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> find_min &#123;</span><br><span class="line">    ($x:expr) =&gt; ($x);</span><br><span class="line">    ($x:expr, $($y:expr),+) =&gt; (</span><br><span class="line">        std::cmp::min($x, find_min!($($y),+))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="number">1u32</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="number">1u32</span> + <span class="number">2</span> , <span class="number">2u32</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="number">5u32</span>, <span class="number">2u32</span> * <span class="number">3</span>, <span class="number">4u32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导入和导出">导入和导出</h4><p>宏导入导出用 <code>#[macro_use]</code> 和 <code>#[macro_export]</code>。父模块中定义的宏对其下的子模块是可见的，要想子模块中定义的宏在其后面的父模块中可用，需要使用 <code>#[macro_use]</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> m1 &#123; () =&gt; (()) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏 m1 在这里可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> foo &#123;</span><br><span class="line">    <span class="comment">// 宏 m1 在这里可用</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[macro_export]</span></span><br><span class="line">    <span class="built_in">macro_rules!</span> m2 &#123; () =&gt; (()) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏 m1 和 m2 在这里可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏 m1 在这里可用</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> m3 &#123; () =&gt; (()) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏 m1 和 m3 在这里可用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">mod</span> bar &#123;</span><br><span class="line">    <span class="comment">// 宏 m1 和 m3 在这里可用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">macro_rules!</span> m4 &#123; () =&gt; (()) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏 m1, m3, m4 在这里均可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏 m1, m3, m4 均可用</span></span><br></pre></td></tr></table></figure><p>crate 之间只有被标为 <code>#[macro_export]</code> 的宏可以被其它 crate 导入。假设上面例子是 <code>foo</code> crate 中的部分代码，则只有 <code>m2</code> 和 <code>m3</code> 可以被其它 crate 导入。导入方式是在 <code>extern crate foo;</code> 前面加上 <code>#[macro_use]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> foo;</span><br><span class="line"><span class="comment">// foo 中 m2, m3 都被导入</span></span><br></pre></td></tr></table></figure><p>如果只想导入 <code>foo</code> crate 中某个宏，比如 <code>m3</code>，就给 <code>#[macro_use]</code> 加上参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use(m3)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> foo;</span><br><span class="line"><span class="comment">// foo 中只有 m3 被导入</span></span><br></pre></td></tr></table></figure><h3 id="unsafe">unsafe</h3><ul><li>解引用一个裸指针<code>*const T</code>和<code>*mut T</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> raw = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line"><span class="keyword">let</span> points_at = <span class="keyword">unsafe</span> &#123; *raw &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;raw points at &#123;&#125;&quot;</span>, points_at);</span><br></pre></td></tr></table></figure><ul><li>读写一个可变的静态变量<code>static mut</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> N: <span class="built_in">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    N += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;N: &#123;&#125;&quot;</span>, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用一个不安全函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="comment">//实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器">迭代器</h3><h4 id="消费者">消费者</h4><ul><li><p>collect()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one_to_one_hundred = (<span class="number">1</span>..<span class="number">101</span>).collect::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>find()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greater_than_forty_two = (<span class="number">0</span>..<span class="number">100</span>).find(|x| *x &gt; <span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p>fold()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从迭代器的第0个元素开始，所有元素的累加</span></span><br><span class="line"><span class="keyword">let</span> sum = (<span class="number">1</span>..<span class="number">4</span>).fold(<span class="number">0</span>, |sum, x| sum + x);</span><br></pre></td></tr></table></figure></li></ul><h4 id="迭代适配器">迭代适配器</h4><ul><li><p>map</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">100</span>).map(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br></pre></td></tr></table></figure></li><li><p>take</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..).take(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>filter</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">100</span>).filter(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="FFI">FFI</h3><h4 id="调用ffi函数">调用ffi函数</h4><h5 id="引入libc库">引入libc库</h5><p><code>Cargo.toml</code>:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">libc</span> = <span class="string">&quot;0.2.86&quot;</span></span><br></pre></td></tr></table></figure><p>rs文件：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> libc</span><br></pre></td></tr></table></figure><h5 id="声明ffi函数">声明ffi函数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> libc::c_int;</span><br><span class="line"><span class="keyword">use</span> libc::c_void;</span><br><span class="line"><span class="keyword">use</span> libc::size_t;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link(name = <span class="meta-string">&quot;yourlib&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">your_func</span></span>(arg1: c_int, arg2: *<span class="keyword">mut</span> c_void) -&gt; size_t; <span class="comment">// 声明ffi函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">your_func2</span></span>(arg1: c_int, arg2: *<span class="keyword">mut</span> c_void) -&gt; size_t;</span><br><span class="line">    <span class="keyword">static</span> ffi_global: c_int; <span class="comment">// 声明ffi全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用ffi函数-v2">调用ffi函数</h5><p>由于此函数来自外部的c库，所以rust并不能保证该函数的安全性。因此，调用任何一个<code>ffi</code>函数需要一个<code>unsafe</code>块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result: size_t = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    your_func(<span class="number">1</span> <span class="keyword">as</span> c_int, <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(<span class="number">3</span>)) <span class="keyword">as</span> *<span class="keyword">mut</span> c_void)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="封装unsafe，暴露安全接口">封装unsafe，暴露安全接口</h5><p>在一个叫<code>ffi.rs</code>之类的文件中写上所有的<code>extern块</code>用以声明ffi函数。在一个叫<code>wrapper.rs</code>之类的文件中进行包装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ffi.rs</span></span><br><span class="line"><span class="meta">#[link(name = <span class="meta-string">&quot;yourlib&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">your_func</span></span>(arg1: c_int, arg2: *<span class="keyword">mut</span> c_void) -&gt; size_t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrapper.rs</span></span><br><span class="line"><span class="comment">// 对外暴露(pub use)your_func_wrapper函数即可</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">your_func_wrapper</span></span>(arg1: <span class="built_in">i32</span>, arg2: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; your_func(<span class="number">1</span> <span class="keyword">as</span> c_int, <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(<span class="number">3</span>)) <span class="keyword">as</span> *<span class="keyword">mut</span> c_void) &#125; <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据结构对应">数据结构对应</h4><h5 id="结构体-Enum">结构体/Enum</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="comment">// 如果使用#[repr(C, packed)]将不为此结构体填充空位用以对齐</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RustObject</span></span> &#123;</span><br><span class="line">    a: c_int,</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnum</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="回调函数">回调函数</h5><p>将一个rust函数转变成c可执行的回调函数非常简单：在函数前面加上<code>extern &quot;C&quot;</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">callback</span></span>(a: c_int) &#123; <span class="comment">// 这个函数是传给c调用的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link(name = <span class="meta-string">&quot;yourlib&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">run_callback</span></span>(data: <span class="built_in">i32</span>, cb: <span class="keyword">extern</span> <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 调用c库中定义的run_callback函数，而run_callback函数中的回调函数callback则是在rust中定义的</span></span><br><span class="line">        run_callback(<span class="number">1</span> <span class="keyword">as</span> <span class="built_in">i32</span>, callback); <span class="comment">// 打印 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应c库代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*rust_callback)</span><span class="params">(<span class="keyword">int32_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_callback</span><span class="params">(<span class="keyword">int32_t</span> data, rust_callback callback)</span> </span>&#123;</span><br><span class="line">    callback(data); <span class="comment">// 调用传过来的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符串">字符串</h5><p><strong>CStr</strong></p><p>对于产生于c的字符串(如在c程序中使用<code>malloc</code>产生)，rust使用<code>CStr</code>来表示，和<code>str</code>类型对应，表明我们并不拥有这个字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CStr;</span><br><span class="line"><span class="keyword">use</span> libc::c_char;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link(name = <span class="meta-string">&quot;yourlib&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">char_func</span></span>() -&gt; *<span class="keyword">mut</span> c_char;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_string</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> raw_string: *<span class="keyword">mut</span> c_char = char_func();</span><br><span class="line">        <span class="keyword">let</span> cstr = CStr::from_ptr(my_string());</span><br><span class="line">        cstr.to_string_lossy().into_owned()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里<code>get_string</code>使用<code>CStr::from_ptr</code>从c的<code>char*</code>获取一个字符串，并且转化成了一个String.</p><ul><li>注意to_string_lossy()的使用：因为在rust中一切字符都是采用utf8表示的而c不是， 因此如果要将c的字符串转换到rust字符串的话，需要检查是否都为有效<code>utf-8</code>字节。<code>to_string_lossy</code>将返回一个<code>Cow&lt;str&gt;</code>类型， 即如果c字符串都为有效<code>utf-8</code>字节，则将其0开销地转换成一个<code>&amp;str</code>类型，若不是，rust会将其拷贝一份并且将非法字节用<code>U+FFFD</code>填充。</li></ul><p><strong>CString</strong></p><p>和<code>CStr</code>表示从c中来，rust不拥有归属权的字符串相反，<code>CString</code>表示由rust分配，用以传给c程序的字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_printer</span></span>(s: *<span class="keyword">const</span> c_char);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c_to_print = CString::new(<span class="string">&quot;Hello, world!&quot;</span>).unwrap();</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    my_printer(c_to_print.as_ptr()); <span class="comment">// 使用 as_ptr 将CString转化成char指针传给c函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意c字符串中并不能包含<code>\0</code>字节(因为<code>\0</code>用来表示c字符串的结束符),因此<code>CString::new</code>将返回一个<code>Result</code>， 如果输入有<code>\0</code>的话则为<code>Error(NulError)</code>。</p><h5 id="空指针">空指针</h5><p>另一种很常见的情况是需要一个空指针。请使用<code>0 as *const _</code> 或者 <code>std::ptr::null()</code>来生产一个空指针。</p><h3 id="将Rust编译成库">将Rust编译成库</h3><h4 id="调用约定和mangle">调用约定和mangle</h4><p>由于rust支持重载，所以函数名会被编译器进行混淆，就像c++一样。因此当你的函数被编译完毕后，函数名会带上一串表明函数签名的字符串。</p><p>比如：<code>fn test() &#123;&#125;</code>会变成<code>_ZN4test20hf06ae59e934e5641haaE</code>. 这样的函数名为ffi调用带来了困难，因此，rust提供了<code>#[no_mangle]</code>属性为函数修饰。 对于带有<code>#[no_mangle]</code>属性的函数，rust编译器不会为它进行函数名混淆。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Any">使用Any</h4><p>由于在跨越<code>ffi</code>过程中，<code>rust</code>类型信息会丢失，比如当用<code>rust</code>提供一个<code>OpaqueStruct</code>给别的语言时：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::transmute;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&lt;T&gt; &#123;</span><br><span class="line">  t: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_foo_vec</span></span>() -&gt; *<span class="keyword">const</span> c_void &#123;</span><br><span class="line">    <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(Foo &#123;t: <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)) <span class="keyword">as</span> *<span class="keyword">const</span> c_void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_foo_int</span></span>() -&gt; *<span class="keyword">const</span> c_void &#123;</span><br><span class="line">    <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(Foo &#123;t: <span class="number">1</span>&#125;)) <span class="keyword">as</span> *<span class="keyword">const</span> c_void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push_foo_element</span></span>(t: &amp;<span class="keyword">mut</span> Foo&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;) &#123;</span><br><span class="line">    t.t.push(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_foo_element_c</span></span>(foo: *<span class="keyword">mut</span> c_void)&#123;</span><br><span class="line">    <span class="keyword">let</span> foo2 = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> *(foo <span class="keyword">as</span> *<span class="keyword">mut</span> Foo&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;) <span class="comment">// 这么确定是Foo&lt;Vec&lt;i32&gt;&gt;? 万一foo是Foo&lt;i32&gt;怎么办？</span></span><br><span class="line">    &#125;;</span><br><span class="line">    push_foo_element(foo3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中完全不知道<code>foo</code>是一个什么东西。安全也无从说起了，只能靠文档。 因此在<code>ffi</code>调用时往往会丧失掉<code>rust</code>类型系统带来的方便和安全。在这里提供一个小技巧:使用<code>Box&lt;Box&lt;Any&gt;&gt;</code>来包装你的类型。</p><p><code>rust</code>的<code>Any</code>类型为<code>rust</code>带来了运行时反射的能力，使用<code>Any</code>跨越<code>ffi</code>边界将极大提高程序安全性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::Any;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&lt;T&gt; &#123;</span><br><span class="line">  t: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_foo_vec</span></span>() -&gt; *<span class="keyword">const</span> c_void &#123;</span><br><span class="line">    <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(<span class="built_in">Box</span>::new(Foo &#123;t: <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Any&gt;)) <span class="keyword">as</span> *<span class="keyword">const</span> c_void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_foo_int</span></span>() -&gt; *<span class="keyword">const</span> c_void &#123;</span><br><span class="line">    <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(<span class="built_in">Box</span>::new(Foo &#123;t: <span class="number">1</span>&#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Any&gt;)) <span class="keyword">as</span> *<span class="keyword">const</span> c_void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push_foo_element</span></span>(t: &amp;<span class="keyword">mut</span> Foo&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;) &#123;</span><br><span class="line">    t.t.push(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_foo_element_c</span></span>(foo: *<span class="keyword">mut</span> c_void)&#123;</span><br><span class="line">    <span class="keyword">let</span> foo2 = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> *(foo <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">Box</span>&lt;Any&gt;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> foo3: <span class="built_in">Option</span>&lt;&amp;<span class="keyword">mut</span> Foo&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;&gt; = foo2.downcast_mut(); <span class="comment">// 如果foo2不是*const Box&lt;Foo&lt;Vec&lt;i32&gt;&gt;&gt;, 则foo3将会是None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(value) = foo3 &#123;</span><br><span class="line">      push_foo_element(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，就非常不容易出错了。</p><h3 id="属性">属性</h3><p>属性只能应用于Item（元素、项）， 例如 <code>use</code> 声明、模块、函数等。</p><p>在Rust中，Item是Crate（库）的一个组成部分。它包括</p><ul><li><code>extern crate</code>声明</li><li><code>use</code>声明</li><li>模块（模块是一个Item的容器）</li><li>函数</li><li><code>type</code>定义</li><li>结构体定义</li><li>枚举类型定义</li><li>常量定义</li><li>静态变量定义</li><li>Trait定义</li><li>实现（Impl）</li></ul><p>这些Item是可以互相嵌套的，比如在一个函数中定义一个静态变量、在一个模块中使用<code>use</code>声明或定义一个结构体。这些定义在某个作用域里面的Item跟你把 它写到最外层作用域所实现的功能是一样的，只不过你要访问这些嵌套的Item就必须使用路径（Path），如<code>a::b::c</code>。但一些外层的Item不允许你使用路径去访问它的子Item，比如函数，在函数中定义的静态变量、结构体等，是不可以通过路径来访问的。</p><h4 id="属性语法">属性语法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[name(arg1, arg2 = <span class="meta-string">&quot;param&quot;</span>)]</span></span><br></pre></td></tr></table></figure><p>它是由一个<code>#</code>开启，后面紧接着一个<code>[]</code>，里面便是属性的具体内容，它可以有如下几种写法：</p><ul><li>单个标识符代表的属性名，如<code>#[unix]</code></li><li>单个标识符代表属性名，后面紧跟着一个<code>=</code>，然后再跟着一个字面量（Literal），组成一个键值对，如<code>#[link(name = &quot;openssl&quot;)]</code></li><li>单个标识符代表属性名，后面跟着一个逗号隔开的子属性的列表，如<code>#[cfg(and(unix, not(windows)))]</code></li></ul><p>在<code>#</code>后面还可以紧跟一个<code>!</code>，比如<code>#![feature(box_syntax)]</code>，这表示这个属性是应用于它所在的这个Item。而如果没有<code>!</code>则表示这个属性仅应用于紧接着的那个Item。</p><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为这个crate开启box_syntax这个新特性</span></span><br><span class="line"><span class="meta">#![feature(box_syntax)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个单元测试函数</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_foo</span></span>() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件编译，只会在编译目标为Linux时才会生效</span></span><br><span class="line"><span class="meta">#[cfg(target_os=<span class="meta-string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">mod</span> bar &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为以下的这个type定义关掉non_camel_case_types的编译警告</span></span><br><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">int8_t</span></span> = <span class="built_in">i8</span>;</span><br></pre></td></tr></table></figure><h4 id="Crate的属性">Crate的属性</h4><ul><li><p><code>crate_name</code> - 指定Crate的名字。如<code>#[crate_name = &quot;my_crate&quot;]</code>则可以让编译出的库名字为<code>libmy_crate.rlib</code>。</p></li><li><p><code>crate_type</code> - 指定Crate的类型，有以下几种选择</p><ul><li><code>&quot;bin&quot;</code> - 编译为可执行文件；</li><li><code>&quot;lib&quot;</code> - 编译为库；</li><li><code>&quot;dylib&quot;</code> - 编译为动态链接库；</li><li><code>&quot;staticlib&quot;</code> - 编译为静态链接库；</li><li><code>&quot;rlib&quot;</code> - 编译为Rust特有的库文件，它是一种特殊的静态链接库格式，它里面会含有一些元数据供编译器使用，最终会静态链接到目标文件之中。</li></ul><p>例<code>#![crate_type = &quot;dylib&quot;]</code>。</p></li><li><p><code>feature</code> - 可以开启一些不稳定特性，只可在nightly版的编译器中使用。</p></li><li><p><code>no_builtins</code> - 去掉内建函数。</p></li><li><p><code>no_main</code>- 不生成<code>main</code>这个符号，当你需要链接的库中已经定义了<code>main</code>函数时会用到。</p></li><li><p><code>no_start</code> - 不链接自带的<code>native</code>库。</p></li><li><p><code>no_std</code> - 不链接自带的<code>std</code>库。</p></li><li><p><code>plugin</code> - 加载编译器插件，一般用于加载自定义的编译器插件库。用法是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载foo, bar两个插件</span></span><br><span class="line"><span class="meta">#![plugin(foo, bar)]</span></span><br><span class="line"><span class="comment">// 或者给插件传入必要的初始化参数</span></span><br><span class="line"><span class="meta">#![plugin(foo(arg1, arg2))]</span></span><br></pre></td></tr></table></figure></li><li><p><code>recursive_limit</code> - 设置在编译期最大的递归层级。比如自动解引用、递归定义的宏等。默认设置是<code>#![recursive_limit = &quot;64&quot;]</code></p></li></ul><h4 id="模块的属性">模块的属性</h4><ul><li><p><code>no_implicit_prelude</code> - 取消自动插入<code>use std::prelude::*</code>。</p></li><li><p><code>path</code> - 设置此<code>mod</code>的文件路径。</p><p>如声明<code>mod a;</code>，则寻找</p><ul><li>本文件夹下的<code>a.rs</code>文件</li><li>本文件夹下的<code>a/mod.rs</code>文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(unix)]</span></span><br><span class="line"><span class="meta">#[path = <span class="meta-string">&quot;sys/unix.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> sys;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(windows)]</span></span><br><span class="line"><span class="meta">#[path = <span class="meta-string">&quot;sys/windows.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> sys;</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数的属性">函数的属性</h4><ul><li><code>main</code> - 把这个函数作为入口函数，替代<code>fn main</code>，会被入口函数（Entry Point）调用。</li><li><code>plugin_registrar</code> - 编写编译器插件时用，用于定义编译器插件的入口函数。</li><li><code>start</code> - 把这个函数作为入口函数（Entry Point），改写 <code>start</code> language item。</li><li><code>test</code> - 指明这个函数为单元测试函数，在非测试环境下不会被编译。</li><li><code>should_panic</code> - 指明这个单元测试函数必然会panic。</li><li><code>cold</code> - 指明这个函数很可能是不会被执行的，因此优化的时候特别对待它。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把`my_main`作为主函数</span></span><br><span class="line"><span class="meta">#[main]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把`plugin_registrar`作为此编译器插件的入口函数</span></span><br><span class="line"><span class="meta">#[plugin_registrar]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">plugin_registrar</span></span>(reg: &amp;<span class="keyword">mut</span> Registry) &#123;</span><br><span class="line">    reg.register_macro(<span class="string">&quot;rn&quot;</span>, expand_rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把`entry_point`作为入口函数，不再执行标准库中的初始化流程</span></span><br><span class="line"><span class="meta">#[start]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">entry_point</span></span>(argc: <span class="built_in">isize</span>, argv: *<span class="keyword">const</span> *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个单元测试</span></span><br><span class="line"><span class="comment">// 这个单元测试一定会panic</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_test</span></span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;I expected to be panicked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数很可能是不会执行的，</span></span><br><span class="line"><span class="comment">// 所以优化的时候就换种方式</span></span><br><span class="line"><span class="meta">#[cold]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlikely_to_be_executed</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局静态变量的属性">全局静态变量的属性</h4><ul><li><code>thread_local</code> - 只可用于<code>static mut</code>，表示这个变量是thread local的。</li></ul><h4 id="FFI的属性">FFI的属性</h4><p><code>extern</code>块可以应用以下属性</p><ul><li><p><code>link_args</code> - 指定链接时给链接器的参数，平台和实现相关。</p></li><li><p><code>link</code> - 说明这个块需要链接一个native库，它有以下参数：</p><ul><li><code>name</code> - 库的名字，比如<code>libname.a</code>的名字是<code>name</code>；</li><li><code>kind</code> - 库的类型，它包括<ul><li><code>dylib</code> - 动态链接库</li><li><code>static</code> - 静态库</li><li><code>framework</code> - OS X里的Framework</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[link(name = <span class="meta-string">&quot;readline&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link(name = <span class="meta-string">&quot;CoreFoundation&quot;</span>, kind = <span class="meta-string">&quot;framework&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在<code>extern</code>块里面，可以使用</p><ul><li><code>link_name</code> - 指定这个链接的外部函数的名字或全局变量的名字；</li><li><code>linkage</code> - 对于全局变量，可以指定一些LLVM的链接类型（ <a href="http://llvm.org/docs/LangRef.html#linkage-types">http://llvm.org/docs/LangRef.html#linkage-types</a> ）。</li></ul><p>对于<code>enum</code>类型，可以使用</p><ul><li><code>repr</code> - 目前接受<code>C</code>，<code>C</code>表示兼容C ABI。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">eType</span></span> &#123;</span><br><span class="line">    Operator,</span><br><span class="line">    Indicator,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>struct</code>类型，可以使用</p><ul><li><code>repr</code> - 目前只接受<code>C</code>和<code>packed</code>，<code>C</code>表示结构体兼容C ABI，<code>packed</code>表示移除字段间的padding。</li></ul><h4 id="宏的属性">宏的属性</h4><ul><li><p><code>macro_use</code> - 把模块或库中定义的宏导出来</p><ul><li><p>应用于<code>mod</code>上，则把此模块内定义的宏导出到它的父模块中</p></li><li><p>应用于<code>extern crate</code>上，则可以接受一个列表，如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use(debug, trace)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log;</span><br></pre></td></tr></table></figure><p>则可以只导入列表中指定的宏，若不指定则导入所有的宏。</p></li></ul></li><li><p><code>macro_reexport</code> - 应用于<code>extern crate</code>上，可以再把这些导入的宏再输出出去给别的库使用。</p></li><li><p><code>macro_export</code> - 应于在宏上，可以使这个宏可以被导出给别的库使用。</p></li><li><p><code>no_link</code> - 应用于<code>extern crate</code>上，表示即使我们把它里面的库导入进来了，但是不要把这个库链接到目标文件中。</p></li></ul><h4 id="其他属性">其他属性</h4><ul><li><p><code>export_function</code> - 用于静态变量或函数，指定它们在目标文件中的符号名。</p></li><li><p><code>link_section</code> - 用于静态变量或函数，表示应该把它们放到哪个段中去。</p></li><li><p><code>no_mangle</code> - 可以应用于任意的Item，表示取消对它们进行命名混淆，直接把它们的名字作为符号写到目标文件中。</p></li><li><p><code>simd</code> - 可以用于元组结构体上，并自动实现了数值运算符，这些操作会生成相应的SIMD指令。</p></li><li><p><code>doc</code> - 为这个Item绑定文档，跟<code>///</code>的功能一样，用法是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[doc = <span class="meta-string">&quot;This is a doc&quot;</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="条件编译属性">条件编译属性</h4><p>有时候，我们想针对不同的编译目标来生成不同的代码，比如在编写跨平台模块时，针对Linux和Windows分别使用不同的代码逻辑。</p><p>条件编译基本上就是使用<code>cfg</code>这个属性，直接看例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="meta-string">&quot;macos&quot;</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">cross_platform</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Will only be compiled on Mac OS, including Mac OS X</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="meta-string">&quot;windows&quot;</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">cross_platform</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Will only be compiled on Windows</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若条件`foo`或`bar`任意一个成立，则编译以下的Item</span></span><br><span class="line"><span class="meta">#[cfg(any(foo, bar))]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">need_foo_or_bar</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对32位的Unix系统</span></span><br><span class="line"><span class="meta">#[cfg(all(unix, target_pointer_width = <span class="meta-string">&quot;32&quot;</span>))]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">on_32bit_unix</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若`foo`不成立时编译</span></span><br><span class="line"><span class="meta">#[cfg(not(foo))]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">needs_not_foo</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>cfg</code>可接受的条件有</p><ul><li><code>debug_assertions</code> - 若没有开启编译优化时就会成立。</li><li><code>target_arch = &quot;...&quot;</code> - 目标平台的CPU架构，包括但不限于<code>x86</code>, <code>x86_64</code>, <code>mips</code>, <code>powerpc</code>, <code>arm</code>或<code>aarch64</code>。</li><li><code>target_endian = &quot;...&quot;</code> - 目标平台的大小端，包括<code>big</code>和<code>little</code>。</li><li><code>target_env = &quot;...&quot;</code> - 表示使用的运行库，比如<code>musl</code>表示使用的是MUSL的libc实现, <code>msvc</code>表示使用微软的MSVC，<code>gnu</code>表示使用GNU的实现。 但在部分平台这个数据是空的。</li><li><code>target_family = &quot;...&quot;</code> - 表示目标操作系统的类别，比如<code>windows</code>和<code>unix</code>。这个属性可以直接作为条件使用，如<code>#[unix]</code>，<code>#[cfg(unix)]</code>。</li><li><code>target_os = &quot;...&quot;</code> - 目标操作系统，包括但不限于<code>windows</code>, <code>macos</code>, <code>ios</code>, <code>linux</code>, <code>android</code>, <code>freebsd</code>, <code>dragonfly</code>, <code>bitrig</code>, <code>openbsd</code>, <code>netbsd</code>。</li><li><code>target_pointer_width = &quot;...&quot;</code> - 目标平台的指针宽度，一般就是<code>32</code>或<code>64</code>。</li><li><code>target_vendor = &quot;...&quot;</code> - 生产商，例如<code>apple</code>, <code>pc</code>或大多数Linux系统的<code>unknown</code>。</li><li><code>test</code> - 当启动了单元测试时（即编译时加了<code>--test</code>参数，或使用<code>cargo test</code>）。</li></ul><p>还可以根据一个条件去设置另一个条件，使用<code>cfg_attr</code>，如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg_attr(a, b)]</span></span><br></pre></td></tr></table></figure><p>这表示若<code>a</code>成立，则这个就相当于<code>#[cfg(b)]</code>。</p><p>条件编译属性只可以应用于Item，如果想应用在非Item中怎么办呢？可以使用<code>cfg!</code>宏，如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">cfg!</span>(target_arch = <span class="string">&quot;x86&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">cfg!</span>(target_arch = <span class="string">&quot;x86_64&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">cfg!</span>(target_arch = <span class="string">&quot;mips&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式不会产生任何运行时开销，因为不成立的条件相当于里面的代码根本不可能被执行，编译时会直接被优化掉。</p><h4 id="内联参数">内联参数</h4><p>内联函数即建议编译器可以考虑把整个函数拷贝到调用者的函数体中，而不是生成一个<code>call</code>指令调用过去。这种优化对于短函数非常有用，有利于提高性能。</p><p>编译器自己会根据一些默认的条件来判断一个函数是不是应该内联，若一个不应该被内联的函数被内联了，实际上会导致整个程序更慢。</p><p>可选的属性有：</p><ul><li><code>#[inline]</code> - 建议编译器内联这个函数</li><li><code>#[inline(always)]</code> - 要求编译器必须内联这个函数</li><li><code>#[inline(never)]</code> - 要求编译器不要内联这个函数</li></ul><p>内联会导致在一个库里面的代码被插入到另一个库中去。</p><h4 id="自动实现Trait">自动实现Trait</h4><p>编译器提供一个编译器插件叫作<code>derive</code>，它可以帮你去生成一些代码去实现（impl）一些特定的Trait，如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&lt;T&gt; &#123;</span><br><span class="line">    a: <span class="built_in">i32</span>,</span><br><span class="line">    b: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会自动为你生成以下的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">PartialEq</span>&gt; <span class="built_in">PartialEq</span> <span class="keyword">for</span> Foo&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">eq</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Foo&lt;T&gt;) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.a == other.a &amp;&amp; <span class="keyword">self</span>.b == other.b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">ne</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Foo&lt;T&gt;) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.a != other.a || <span class="keyword">self</span>.b != other.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Clone</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> Foo&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; Foo&lt;T&gt; &#123;</span><br><span class="line">        Foo &#123;</span><br><span class="line">            a: <span class="keyword">self</span>.a.clone(),</span><br><span class="line">            b: <span class="keyword">self</span>.b.clone(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前<code>derive</code>仅支持标准库中部分的Trait。</p><h3 id="编译器rustc参数">编译器rustc参数</h3><p>Rust编译器程序的名字是<code>rustc</code>，使用它的方法很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc [OPTIONS] INPUT</span><br></pre></td></tr></table></figure><p>其中，<code>[OPTIONS]</code>表示编译参数，而<code>INPUT</code>则表示输入文件。而编译参数有以下可选：</p><ul><li><p><code>-h, --help</code> - 输出帮助信息到标准输出；</p></li><li><p><code>--cfg SPEC</code> - 传入自定义的条件编译参数，使用方法如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cfg!</span>(hello) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，若<code>cfg!(hello)</code>成立，则运行程序就会输出<code>&quot;world&quot;</code>到标准输出。我们把这个文件保存为<code>hello.rs</code>然后编译它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --cfg hello hello.rs</span><br></pre></td></tr></table></figure><p>运行它就会看到屏幕中输出了<code>world!</code>。</p></li><li><p><code>-L [KIND=]PATH</code> - 往链接路径中加入一个文件夹，并且可以指定这个路径的类型（Kind），这些类型包括</p><ul><li><code>dependency</code> - 在这个路径下找依赖的文件，比如说<code>mod</code>；</li><li><code>crate</code> - 只在这个路径下找<code>extern crate</code>中定义的库；</li><li><code>native</code> - 只在这个路径下找Native库；</li><li><code>framework</code> - 只在OS X下有用，只在这个路径下找Framework；</li><li><code>all</code> - 默认选项。</li></ul></li><li><p><code>-l [KIND=]NAME</code> - 链接一个库，这个库可以指定类型（Kind）</p><ul><li><code>static</code> - 静态库；</li><li><code>dylib</code> - 动态库；</li><li><code>framework</code> - OS X的Framework。</li></ul><p>如果不传，默认为<code>dylib</code>。</p><p>此处举一个例子如何手动链接一个库，我们先创建一个文件叫<code>myhello.rs</code>，在里面写一个函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhello.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个函数仅仅向标签输出打印 Hello World!</span></span><br><span class="line"><span class="comment">/// 不要忘记要把它标记为 pub 哦。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_hello</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个文件编译成一个静态库，<code>libmyhello.a</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --crate-type staticlib myhello.rs</span><br></pre></td></tr></table></figure><p>然后再创建一个<code>main.rs</code>，链接这个库并打印出&quot;Hello World!&quot;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定链接库 myhello</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> myhello;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 调用库函数</span></span><br><span class="line">    myhello::print_hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>main.rs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc -L. -lmyhello main.rs</span><br></pre></td></tr></table></figure><p>运行<code>main</code>，就会看到屏幕输出&quot;Hello World!&quot;啦。</p></li><li><p><code>--crate-type</code> - 指定编译输出类型，它的参数包括</p><ul><li><code>bin</code> - 二进行可执行文件</li><li><code>lib</code> - 编译为库</li><li><code>rlib</code> - Rust库</li><li><code>dylib</code> - 动态链接库</li><li><code>staticlib</code> - 静态链接库</li></ul></li><li><p><code>--crate-name</code> - 指定这个Crate的名字，默认是文件名，如<code>main.rs</code>编译成可执行文件时默认是<code>main</code>，但你可以指定它为<code>foo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --crate-name foo main.rs</span><br></pre></td></tr></table></figure><p>则会输出<code>foo</code>可执行文件。</p></li><li><p><code>--emit</code> - 指定编译器的输出。编译器默认是输出一个可执行文件或库文件，但你可以选择输出一些其它的东西用于Debug</p><ul><li><code>asm</code> - 输出汇编</li><li><code>llvm-bc</code> - <a href="http://llvm.org/docs/BitCodeFormat.html">LLVM Bitcode</a>；</li><li><code>llvm-ir</code> - <a href="http://llvm.org/docs/LangRef.html">LLVM IR</a>，即LLVM中间码（LLVM Intermediate Representation）；</li><li><code>obj</code> - Object File（就是<code>*.o</code>文件）；</li><li><code>link</code> - 这个是要结合其它<code>--emit</code>参数使用，会执行Linker再输出结果；</li><li><code>dep-info</code> - 文件依赖关系（Debug用，类似于Makefile一样的依赖）。</li></ul><p>以上参数可以同时使用，使用逗号分割，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --emit asm,llvm-ir,obj main.rs</span><br></pre></td></tr></table></figure><p>同时，在最后可以加一个<code>=PATH</code>来指定输出到一个特定文件，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --emit asm=output.S,llvm-ir=output.ir main.rs</span><br></pre></td></tr></table></figure><p>这样会把汇编生成到<code>output.S</code>文件中，把LLVM中间码输出到<code>output.ir</code>中。</p></li><li><p><code>--print</code> - 打印一些信息，参数有</p><ul><li><code>crate-name</code> - 编译目标名；</li><li><code>file-names</code> - 编译的文件名；</li><li><code>sysroot</code> - 打印Rust工具链的根目录地址。</li></ul></li><li><p><code>-g</code> - 在目标文件中保存符号，这个参数等同于<code>-C debuginfo=2</code>。</p></li><li><p><code>-O</code> - 开启优化，这个参数等同于<code>-C opt-level=2</code>。</p></li><li><p><code>-o FILENAME</code> - 指定输出文件名，同样适用于<code>--emit</code>的输出。</p></li><li><p><code>--out-dir DIR</code> - 指定输出的文件夹，默认是当前文件夹，且会忽略<code>-o</code>配置。</p></li><li><p><code>--explain OPT</code> - 解释某一个编译错误，比如</p><p>若你写了一个<code>main.rs</code>，使用了一个未定义变量<code>f</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译它时编译器会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main.rs:2:5: 2:6 error: unresolved name &#96;f&#96; [E0425]</span><br><span class="line">main.rs:2     f</span><br><span class="line">              ^</span><br><span class="line">main.rs:2:5: 2:6 help: run &#96;rustc --explain E0425&#96; to see a detailed explanation</span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure><p>虽然错误已经很明显，但是你也可以让编译器解释一下，什么是<code>E0425</code>错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --explain E0425</span><br><span class="line">// 编译器打印的说明</span><br></pre></td></tr></table></figure></li><li><p><code>--test</code> - 编译成一个单元测试可执行文件</p></li><li><p><code>--target TRIPLE</code> - 指定目标平台，基本格式是<code>cpu-manufacturer-kernel[-os]</code>，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 64位OS X</span></span><br><span class="line">$ rustc --target x86_64-apple-darwin</span><br></pre></td></tr></table></figure></li><li><p><code>-W help</code> - 打印Linter的所有可配置选项和默认值。</p></li><li><p><code>-W OPT, --warn OPT</code> - 设置某一个Linter选项为Warning。</p></li><li><p><code>-A OPT, --allow OPT</code> - 设置某一个Linter选项为Allow。</p></li><li><p><code>-D OPT, --deny OPT</code> - 设置某一个Linter选项为Deny。</p></li><li><p><code>-F OPT, --forbit OPT</code> - 设置某一个Linter选项为Forbit。</p></li><li><p><code>-C FLAG[=VAL], --codegen FLAG[=VAL]</code> - 目标代码生成的的相关参数，可以用<code>-C help</code>来查看配置，值得关注的几个是</p><ul><li><code>linker=val</code> - 指定链接器；</li><li><code>linker-args=val</code> - 指定链接器的参数；</li><li><code>prefer-dynamic</code> - 默认Rust编译是静态链接，选择这个配置将改为动态链接；</li><li><code>debug-info=level</code> - Debug信息级数，<code>0</code> = 不生成，<code>1</code> = 只生成文件行号表，<code>2</code> = 全部生成；</li><li><code>opt-level=val</code> - 优化级数，可选<code>0-3</code>；</li><li><code>debug_assertion</code> - 显式开启<code>cfg(debug_assertion)</code>条件。</li></ul></li><li><p><code>-V, --version</code> - 打印编译器版本号。</p></li><li><p><code>-v, --verbose</code> - 开启啰嗦模式（打印编译器执行的日志）。</p></li><li><p><code>--extern NAME=PATH</code> - 用来指定外部的Rust库（<code>*.rlib</code>）名字和路径，名字应该与<code>extern crate</code>中指定的一样。</p></li><li><p><code>--sysroot PATH</code> - 指定工具链根目录。</p></li><li><p><code>-Z flag</code> - 编译器Debug用的参数，可以用<code>-Z help</code>来查看可用参数。</p></li><li><p><code>--color auto|always|never</code> - 输出时对日志加颜色</p><ul><li><code>auto</code> - 自动选择加还是不加，如果输出目标是虚拟终端（TTY）的话就加，否则就不加；</li><li><code>always</code> - 给我加！</li><li><code>never</code> - 你敢加？</li></ul></li></ul><h3 id="Cargo-toml参数配置">Cargo.toml参数配置</h3><h4 id="package-段落">[package]段落</h4><p>啥也不多说了，直接上例子，大家注意我在例子中的中文解释，个人觉得这样比较一目了然：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"> <span class="comment"># 软件包名称，如果需要在别的地方引用此软件包，请用此名称。</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前版本号，这里遵循semver标准，也就是语义化版本控制标准。</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span>    <span class="comment"># the current version, obeying semver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 软件所有作者列表</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;you@example.com&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非常有用的一个字段，如果要自定义自己的构建工作流，</span></span><br><span class="line"><span class="comment"># 尤其是要调用外部工具来构建其他本地语言（C、C++、D等）开发的软件包时。</span></span><br><span class="line"><span class="comment"># 这时，自定义的构建流程可以使用rust语言，写在&quot;build.rs&quot;文件中。</span></span><br><span class="line"><span class="attr">build</span> = <span class="string">&quot;build.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式声明软件包文件夹内哪些文件被排除在项目的构建流程之外，</span></span><br><span class="line"><span class="comment"># 哪些文件包含在项目的构建流程中</span></span><br><span class="line"><span class="attr">exclude</span> = [<span class="string">&quot;build/**/*.o&quot;</span>, <span class="string">&quot;doc/**/*.html&quot;</span>]</span><br><span class="line"><span class="attr">include</span> = [<span class="string">&quot;src/**/*&quot;</span>, <span class="string">&quot;Cargo.toml&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当软件包在向公共仓库发布时出现错误时，使能此字段可以阻止此错误。</span></span><br><span class="line"><span class="attr">publish</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于软件包的一个简短介绍。</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这些字段标明了软件包仓库的更多信息</span></span><br><span class="line"><span class="attr">documentation</span> = <span class="string">&quot;...&quot;</span></span><br><span class="line"><span class="attr">homepage</span> = <span class="string">&quot;...&quot;</span></span><br><span class="line"><span class="attr">repository</span> = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顾名思义，此字段指向的文件就是传说中的ReadMe，</span></span><br><span class="line"><span class="comment"># 并且，此文件的内容最终会保存在注册表数据库中。</span></span><br><span class="line"><span class="attr">readme</span> = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于分类和检索的关键词。</span></span><br><span class="line"><span class="attr">keywords</span> = [<span class="string">&quot;...&quot;</span>, <span class="string">&quot;...&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软件包的许可证，必须是cargo仓库已列出的已知的标准许可证。</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 软件包的非标许可证书对应的文件路径。</span></span><br><span class="line"><span class="attr">license-file</span> = <span class="string">&quot;...&quot;</span></span><br></pre></td></tr></table></figure><h4 id="依赖的详细配置">依赖的详细配置</h4><p>最直接的方式：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hammer</span> = <span class="string">&quot;0.5.0&quot;</span></span><br><span class="line"><span class="attr">color</span> = <span class="string">&quot;&gt; 0.6.0, &lt; 0.8.0&quot;</span></span><br></pre></td></tr></table></figure><p>与平台相关的依赖定义格式不变，不同的是需要定义在[target]字段下。例如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此处的cfg可以使用not、any、all等操作符任意组合键值对。</span></span><br><span class="line"><span class="comment"># 并且此用法仅支持cargo 0.9.0（rust 1.8.0）以上版本。</span></span><br><span class="line"><span class="comment"># 如果是windows平台，则需要此依赖。</span></span><br><span class="line"><span class="section">[target.&#x27;cfg(windows)&#x27;.dependencies]</span></span><br><span class="line"><span class="attr">winhttp</span> = <span class="string">&quot;0.4.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.&#x27;cfg(unix)&#x27;.dependencies]</span></span><br><span class="line"><span class="attr">openssl</span> = <span class="string">&quot;1.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果是32位平台，则需要此依赖。</span></span><br><span class="line"><span class="section">[target.&#x27;cfg(target_pointer_width = &quot;32&quot;)&#x27;.dependencies]</span></span><br><span class="line"><span class="attr">native</span> = &#123; path = <span class="string">&quot;native/i686&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[target.&#x27;cfg(target_pointer_width = &quot;64&quot;)&#x27;.dependencies]</span></span><br><span class="line"><span class="attr">native</span> = &#123; path = <span class="string">&quot;native/i686&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种写法就是列出平台的全称描述</span></span><br><span class="line"><span class="section">[target.x86_64-pc-windows-gnu.dependencies]</span></span><br><span class="line"><span class="attr">winhttp</span> = <span class="string">&quot;0.4.0&quot;</span></span><br><span class="line"><span class="section">[target.i686-unknown-linux-gnu.dependencies]</span></span><br><span class="line"><span class="attr">openssl</span> = <span class="string">&quot;1.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用自定义平台，请将自定义平台文件的完整路径用双引号包含</span></span><br><span class="line"><span class="section">[target.&quot;x86_64/windows.json&quot;.dependencies]</span></span><br><span class="line"><span class="attr">winhttp</span> = <span class="string">&quot;0.4.0&quot;</span></span><br><span class="line"><span class="section">[target.&quot;i686/linux.json&quot;.dependencies]</span></span><br><span class="line"><span class="attr">openssl</span> = <span class="string">&quot;1.0.1&quot;</span></span><br><span class="line"><span class="attr">native</span> = &#123; path = <span class="string">&quot;native/i686&quot;</span> &#125;</span><br><span class="line"><span class="attr">openssl</span> = <span class="string">&quot;1.0.1&quot;</span></span><br><span class="line"><span class="attr">native</span> = &#123; path = <span class="string">&quot;native/x86_64&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># [dev-dependencies]段落的格式等同于[dependencies]段落，</span></span><br><span class="line"><span class="comment"># 不同之处在于，[dependencies]段落声明的依赖用于构建软件包，</span></span><br><span class="line"><span class="comment"># 而[dev-dependencies]段落声明的依赖仅用于构建测试和性能评估。</span></span><br><span class="line"><span class="comment"># 此外，[dev-dependencies]段落声明的依赖不会传递给其他依赖本软件包的项目</span></span><br><span class="line"><span class="section">[dev-dependencies]</span></span><br><span class="line"><span class="attr">iron</span> = <span class="string">&quot;0.2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="自定义编译器调用方式模板详细参数">自定义编译器调用方式模板详细参数</h4><p>cargo内置五种编译器调用模板，分别为dev、release、test、bench、doc，分别用于定义不同类型生成目标时的编译器参数，如果我们自己想改变这些编译模板，可以自己定义相应字段的值，例如（注意：下述例子中列出的值均为此模板字段对应的系统默认值）：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发模板, 对应`cargo build`命令</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span>  <span class="comment"># 控制编译器的 --opt-level 参数，也就是优化参数</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">true</span>   <span class="comment"># 控制编译器是否开启 `-g` 参数</span></span><br><span class="line"><span class="attr">rpath</span> = <span class="literal">false</span>  <span class="comment"># 控制编译器的 `-C rpath` 参数</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">false</span>    <span class="comment"># 控制`-C lto` 参数，此参数影响可执行文件和静态库的生成，</span></span><br><span class="line"><span class="attr">debug-assertions</span> = <span class="literal">true</span>  <span class="comment"># 控制调试断言是否开启</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span> <span class="comment"># 控制编译器的 `-C codegen-units` 参数。注意，当`lto = true`时，此字段值被忽略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布模板, 对应`cargo build --release`命令</span></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">rpath</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">debug-assertions</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试模板，对应`cargo test`命令</span></span><br><span class="line"><span class="section">[profile.test]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">rpath</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">debug-assertions</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能评估模板，对应`cargo bench`命令</span></span><br><span class="line"><span class="section">[profile.bench]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">rpath</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">debug-assertions</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档模板，对应`cargo doc`命令</span></span><br><span class="line"><span class="section">[profile.doc]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">rpath</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">debug-assertions</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>需要注意的是，当调用编译器时，只有位于调用最顶层的软件包的模板文件有效，其他的子软件包或者依赖软件包的模板定义将被顶层软件包的模板覆盖。</p><h4 id="features-段落">[features]段落</h4><p>[features]段落中的字段被用于条件编译选项或者是可选依赖。例如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;awesome&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="comment"># 此字段设置了可选依赖的默认选择列表，</span></span><br><span class="line"><span class="comment"># 注意这里的&quot;session&quot;并非一个软件包名称，</span></span><br><span class="line"><span class="comment"># 而是另一个featrue字段session</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;jquery&quot;</span>, <span class="string">&quot;uglifier&quot;</span>, <span class="string">&quot;session&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似这样的值为空的feature一般用于条件编译，</span></span><br><span class="line"><span class="comment"># 类似于`#[cfg(feature = &quot;go-faster&quot;)]`。</span></span><br><span class="line"><span class="attr">go-faster</span> = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此feature依赖于bcrypt软件包，</span></span><br><span class="line"><span class="comment"># 这样封装的好处是未来可以对secure-password此feature增加可选项目。</span></span><br><span class="line"><span class="attr">secure-password</span> = [<span class="string">&quot;bcrypt&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处的session字段导入了cookie软件包中的feature段落中的session字段</span></span><br><span class="line"><span class="attr">session</span> = [<span class="string">&quot;cookie/session&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># 必要的依赖</span></span><br><span class="line"><span class="attr">cookie</span> = <span class="string">&quot;1.2.0&quot;</span></span><br><span class="line"><span class="attr">oauth</span> = <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line"><span class="attr">route-recognizer</span> = <span class="string">&quot;=2.1.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选依赖</span></span><br><span class="line"><span class="attr">jquery</span> = &#123; version = <span class="string">&quot;1.0.2&quot;</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="attr">uglifier</span> = &#123; version = <span class="string">&quot;1.5.3&quot;</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="attr">bcrypt</span> = &#123; version = <span class="string">&quot;*&quot;</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="attr">civet</span> = &#123; version = <span class="string">&quot;*&quot;</span>, optional = <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>如果其他软件包要依赖使用上述awesome软件包，可以在其描述文件中这样写：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.awesome]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;1.3.5&quot;</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span> <span class="comment"># 禁用awesome 的默认features</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">&quot;secure-password&quot;</span>, <span class="string">&quot;civet&quot;</span>] <span class="comment"># 使用此处列举的各项features</span></span><br></pre></td></tr></table></figure><p>使用features时需要遵循以下规则：</p><ul><li>feature名称在本描述文件中不能与出现的软件包名称冲突</li><li>除了default feature，其他所有的features均是可选的</li><li>features不能相互循环包含</li><li>开发依赖包不能包含在内</li><li>features组只能依赖于可选软件包</li></ul><p>features的一个重要用途就是，当开发者需要对软件包进行最终的发布时，在进行构建时可以声明暴露给终端用户的features，这可以通过下述命令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release --features &quot;shumway pdf&quot;</span><br></pre></td></tr></table></figure><h4 id="关于测试">关于测试</h4><p>当运行cargo test命令时，cargo将会按做以下事情：</p><ul><li>编译并运行软件包源代码中被#[cfg(test)] 所标志的单元测试</li><li>编译并运行文档测试</li><li>编译并运行集成测试</li><li>编译examples</li></ul><h4 id="配置构建目标">配置构建目标</h4><p>所有的诸如[[bin]], [lib], [[bench]], [[test]]以及 [[example]]等字段，均提供了类似的配置，以说明构建目标应该怎样被构建。例如（下述例子中[lib]段落中各字段值均为默认值）：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="comment"># 库名称，默认与项目名称相同</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此选项仅用于[lib]段落，其决定构建目标的构建方式，</span></span><br><span class="line"><span class="comment"># 可以取dylib, rlib, staticlib 三种值之一，表示生成动态库、r库或者静态库。</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;dylib&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># path字段声明了此构建目标相对于cargo.toml文件的相对路径</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/lib.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单元测试开关选项</span></span><br><span class="line"><span class="attr">test</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档测试开关选项</span></span><br><span class="line"><span class="attr">doctest</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能评估开关选项</span></span><br><span class="line"><span class="attr">bench</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档生成开关选项</span></span><br><span class="line"><span class="attr">doc</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否构建为编译器插件的开关选项</span></span><br><span class="line"><span class="attr">plugin</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置为false，`cargo test`将会忽略传递给rustc的--test参数。</span></span><br><span class="line"><span class="attr">harness</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="no-std">no_std</h3><p>OS提供系统调用来支持IO、网络、文件系统等的操作，Rust利用OS的特性来实现如发送消息到控制台、读取文件、打开URL等标准库（std）的操作。</p><p>若OS不提供这些系统调用，则这种特性被称为no_std，对于Rust的no_std我们只能使用不依赖OS的特性，如<code>core crate</code></p><p>no_std与std的区别在于：</p><ul><li>no_std下，不能使用std crate，但能使用大部分core crate中的模块</li><li>不能使用与堆相关的模块(box, collections, string等)，因为Rust内存分配机制默认依赖于OS系统调用实现堆的分配</li><li>如果写一个二进制crate，则必须实现一些lang items（rustc允许用户通过lang item来定制语言特性，而不是将所有操作都嵌入到编译器中）</li></ul><p><a href="https://justjjy.com/Rust-no-std">https://justjjy.com/Rust-no-std</a></p><h3 id="外部crate">外部crate</h3><h4 id="lazy-static">lazy_static</h4><p>给静态变量延迟赋值的宏。</p><p>使用这个宏,所有 <code>static</code>类型的变量可在执行的代码在运行时被初始化。 这包括任何需要堆分配,如<code>vector</code>或<code>hash map</code>,以及任何非常量函数调用。</p><p>由于<code>const</code>和<code>static</code>在初始化时，必须赋予一个常量表达式的值，如果想要初始化动态的数组，vector，map，结果是编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VEC:<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0x18u8</span>, <span class="number">0x11u8</span>];</span><br><span class="line"><span class="keyword">static</span> MAP: HashMap&lt;<span class="built_in">u32</span>, <span class="built_in">String</span>&gt; = HashMap::new();</span><br></pre></td></tr></table></figure><p>使用 lazy_static 消除上面所有问题，在使用时需要解引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> VEC:<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0x18u8</span>, <span class="number">0x11u8</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MAP: HashMap&lt;<span class="built_in">u32</span>, <span class="built_in">String</span>&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">        map.insert(<span class="number">18</span>, <span class="string">&quot;hury&quot;</span>.to_owned());</span><br><span class="line">        map</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> PAGE:<span class="built_in">u32</span> = mulit(<span class="number">18</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mulit</span></span>(i: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *PAGE);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *VEC);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *MAP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建全局静态可变变量">创建全局静态可变变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, sync::Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"></span><br><span class="line">lazy_static!&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> ENCLAVE_ID_MAP: Mutex&lt;HashMap&lt;sgx_enclave_id_t, <span class="built_in">u32</span>&gt;&gt; = Mutex::new(HashMap::new());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENCLAVE_ID_MAP.lock().unwrap().insert(eid1, <span class="number">1</span>);</span><br><span class="line">ENCLAVE_ID_MAP.lock().unwrap().insert(eid2, <span class="number">2</span>);</span><br><span class="line">ENCLAVE_ID_MAP.lock().unwrap().insert(eid3, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, ENCLAVE_ID_MAP.lock().unwrap());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="2021/03/09/instruction/makefile/"/>
      <url>2021/03/09/instruction/makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="makefile概览">makefile概览</h2><h3 id="规则的基本形式">规则的基本形式</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>target：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）</li><li>prerequisites：生成该target所依赖的文件</li><li>command：该target要执行的命令（任意的shell命令）</li></ul><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p><blockquote><p>prerequisites中如果有一个以上的文件比target文件要新 (比较修改日期) 的话，command所定义的命令就会被执行</p></blockquote><h3 id="一个简单的例子">一个简单的例子</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><ul><li><code>clean</code> 不是一个文件，它只不过是一个label，其冒号后什么也没有，make不会自动去找它的依赖性，也就不会自动执行其后所定义的命令；要执行其后的命令，就要在make命令后明显得指出这个label的名字</li></ul><h3 id="make的工作方式">make的工作方式</h3><p>只输入 <code>make</code> 命令：</p><ol><li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li><li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li><li>如果edit文件不存在，或是edit所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</li><li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么make会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。</li></ol><h3 id="使用变量">使用变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o</span><br><span class="line"><span class="section">edit: <span class="variable">$(objects)</span></span></span><br><span class="line">cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="makefile自动推导">makefile自动推导</h3><p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，因此上述makefile可简化为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><ul><li><code>.PHONY</code> 表示 <code>clean</code> 是个伪目标文件</li><li><code>rm</code> 前的 <code>-</code> 表示也许某些文件出现问题，但不要管，继续做后面的事</li></ul><p>依赖关系也可以合并，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h3 id="makefile文件名">makefile文件名</h3><p>默认使用 <code>makefile</code> 或 <code>Makefile</code> ，如果使用其他名称，如 <code>make.linux</code> ，那么需使用命令 <code>make -f make.linux</code></p><h3 id="引用其他makefile">引用其他makefile</h3><p>你有这样几个Makefile： <code>a.mk</code> 、 <code>b.mk</code> 、 <code>c.mk</code> ，还有一个文件叫 <code>foo.make</code> ，以及一个变量 <code>$(bar)</code> ，其包含了 <code>e.mk</code> 和 <code>f.mk</code> ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure><p>如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><ol><li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>如果目录 <code>&lt;prefix&gt;/include</code> （一般是： <code>/usr/local/bin</code> 或 <code>/usr/include</code> ）存在的话，make也会去找。</li></ol><h3 id="make的执行步骤">make的执行步骤</h3><ol><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol><h2 id="书写规则">书写规则</h2><h3 id="通配符">通配符</h3><p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code></p><ul><li><code>*</code> : 匹配0个或多个字符</li><li><code>?</code> : 匹配一个字符</li><li><code>~</code> : home目录？</li></ul><p><strong>在变量中使用通配符</strong>有所不同：</p><ul><li><code>objects = *.o</code> 表示 <code>objects</code> 的值就是 <code>*.o</code> ，而不会展开</li><li><code>objects := $(wildcard *.o)</code> 表示所有以 <code>.o</code> 结尾的文件</li></ul><h3 id="文件搜索">文件搜索</h3><h4 id="特殊变量-VPATH">特殊变量 <code>VPATH</code></h4><p>如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件；如果定义了这个变量，那么make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure><ul><li>多个目录使用冒号隔开，依次搜索</li></ul><h4 id="关键字vpath">关键字vpath</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;</span></span><br><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除符合模式&lt;pattern&gt;的文件的搜索目录</span></span><br><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除所有已被设置好了的文件搜索目录</span></span><br><span class="line"><span class="keyword">vpath</span></span><br></pre></td></tr></table></figure><ul><li>&lt;pattern&gt;需要包含 <code>%</code> 字符，表示匹配零或若干字符，例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br></pre></td></tr></table></figure><ul><li>表示搜索 <code>.c</code> 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录</li></ul><h3 id="伪目标">伪目标</h3><p>为了避免和文件重名，使用特殊标记 <code>.PHONY</code> 来显式地指明一个目标是伪目标，不管是否有这个文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure><p>伪目标也可以指定所依赖的文件，可以用来在一个Makefile文件生成若干个可执行文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure><h4 id="伪目标的命名">伪目标的命名</h4><ul><li>all：所有目标的目标，其功能一般是编译所有的目标</li><li>clean：删除所有被make创建的文件</li><li>install：安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去</li><li>print：列出改变过的源文件</li><li>tar：把源程序打包备份，也就是一个tar文件</li><li>dist：创建一个压缩文件，一般是把tar文件压成Z文件，或是gz文件。</li><li>TAGS：更新所有的目标，以备完整地重编译使用</li><li>check和test：一般用来测试makefile的流程</li></ul><h3 id="静态模式">静态模式</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li><p>目标从objects中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ；</p></li><li><p>依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code></p></li><li><p>命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件， <code>$@</code> 表示目标集（也就是“foo.o bar.o”）</p></li><li><p>于是，上面的规则展开后等价于下面的规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure></li></ul><h3 id="自动生成依赖">自动生成依赖</h3><p>把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的Makefile文件， <code>.d</code> 文件中就存放对应 <code>.c</code> 文件的依赖关系，产生 <code>.d</code> 文件的模式规则如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    <span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">    sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">    rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure><ul><li>所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件</li><li><code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件</li><li><code>-M</code> 参数表示自动找寻源文件中包含的头文件，并生成一个依赖关系</li><li>第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个C文件是name.c，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是<code>name.d.12345</code></li><li>第三行使用sed命令做了一个替换</li><li>第四行删除临时文件</li></ul><h2 id="书写命令">书写命令</h2><p>每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的</p><h3 id="显示命令">显示命令</h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，这个命令将不被make显示出来，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br><span class="line"><span class="comment"># 输出：正在编译XXX模块……</span></span><br><span class="line"></span><br><span class="line">echo 正在编译XXX模块......</span><br><span class="line"><span class="comment"># 输出：echo 正在编译XXX模块......</span></span><br><span class="line"><span class="comment">#  正在编译XXX模块......</span></span><br></pre></td></tr></table></figure><p>带入make参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令，这个功能有利于我们调试Makefile，看看命令执行的顺序等</p><h3 id="命令执行">命令执行</h3><p>如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec1:</span></span><br><span class="line">    cd /home/hchen</span><br><span class="line">    pwd</span><br><span class="line">    </span><br><span class="line"><span class="section">exec2:</span></span><br><span class="line">    cd /home/hchen; pwd</span><br></pre></td></tr></table></figure><ul><li>执行 <code>make exec1</code>，打印当前Makefile目录，<code>cd</code> 没有作用</li><li>执行 <code>make exec2</code>，打印出“/home/hchen”</li></ul><h3 id="命令出错">命令出错</h3><p>有时候希望能忽略命令出错，继续执行：</p><ul><li><p>对于单个命令，最前面加-</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure></li><li><p>全局方法：给make加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，Makefile中所有命令都会忽略错误； <code>-k</code> 或是 <code>--keep-going</code> 参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则</p></li><li><p>对于单个规则，以 <code>.IGNORE</code> 作为目标，那么这个规则中的所有命令将会忽略错误</p></li></ul><h3 id="嵌套执行make">嵌套执行make</h3><p>我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure><p>总控Makefile的变量可以传递到下级的Makefile中：</p><ul><li><p>要传递变量到下级Makefile中：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure></li><li><p>不想让某些变量传递到下级Makefile中：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure></li><li><p>传递所有的变量，只要一个export就行了，后面什么也不用跟</p></li></ul><p><strong>注：</strong></p><ul><li>两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否export，总是要传递到下层Makefile中</li><li><code>-w</code> 或是 <code>--print-directory</code> 参数会在make的过程中输出一些信息，让你看到目前的工作目录</li></ul><h3 id="定义命令包（函数）">定义命令包（函数）</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure><ul><li>命令包“run-yacc”中的 <code>$^</code> 就是 <code>foo.y</code> ， <code>$@</code> 就是 <code>foo.c</code></li></ul><h2 id="使用变量-v2">使用变量</h2><h3 id="变量的基础">变量的基础</h3><ul><li>变量在声明时需要给予初值</li><li>在使用时，需要给在变量名前加上 <code>$</code> 符号，使用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来</li><li>如果要使用真实的 <code>$</code> 字符，那么需要用 <code>$$</code> 来表示</li></ul><h3 id="变量中的变量">变量中的变量</h3><p>使用变量的值定义变量</p><h4 id="使用">使用 <code>=</code></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure><ul><li><p><code>=</code> 右侧的变量的值可以定义在文件的任何一处</p></li><li><p>这种方法的缺点在于可能造成递归定义，如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用-v2">使用 <code>:=</code></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure><ul><li>最终y的值为&quot;foo bar&quot;，x的值为&quot;later&quot;</li><li>前面的变量不能使用后面的变量，只能使用前面已定义好了的变量</li></ul><h4 id="使用-v3">使用 <code>?=</code></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure><ul><li>如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做</li></ul><h4 id="定义一个空格">定义一个空格</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure><ul><li>nullstring是一个Empty变量，其中什么也没有</li><li>space的值是一个空格：先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止</li></ul><p><strong>注：</strong></p><p>如果以如下方式定义目录路径的变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure><p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格</p><h3 id="变量高级用法">变量高级用法</h3><h4 id="变量值替换">变量值替换</h4><p>替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> ，其意思是，把变量var中所有以a字串结尾的a替换成b字串。这里的结尾意思是空格或是结束符，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br><span class="line"><span class="comment"># bar的值为  a.c b.c c.c</span></span><br></pre></td></tr></table></figure><p>也可以使用静态模式进行替换：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br><span class="line"><span class="comment"># bar的值为  &quot;a.c b.c c.c&quot;</span></span><br></pre></td></tr></table></figure><h4 id="变量值作为变量">变量值作为变量</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line"><span class="comment"># a的值为  &quot;z&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br><span class="line"><span class="comment"># all的值为  &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="追加变量值">追加变量值</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"></span><br><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> another.o</span><br></pre></td></tr></table></figure><h3 id="override指示符">override指示符</h3><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt;; = &lt;value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt;; := &lt;value&gt;;</span><br></pre></td></tr></table></figure><h3 id="多行变量">多行变量</h3><ul><li><p>使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令</p></li><li><p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><h3 id="环境变量">环境变量</h3><ul><li>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中</li><li>但如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖</li><li>如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量</li></ul><h3 id="目标变量">目标变量</h3><p>可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和全局变量同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值，其语法为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;;</span><br><span class="line"></span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure><ul><li>不管全局的 <code>$(CFLAGS)</code> 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code></li></ul><h3 id="模式变量">模式变量</h3><p>模式变量的好处是，可以给定一种“模式”，把变量定义在符合这种模式的所有目标上，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure><ul><li>给所有以 <code>.o</code> 结尾的目标定义目标变量 <code>CFLAGS</code></li></ul><h2 id="条件判断">条件判断</h2><p>语法为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>其中 <code>&lt;conditional-directive&gt;</code> 表示条件关键字，在 <code>&lt;conditional-directive&gt;</code> 这一行上，多余的空格是被允许的，但是不能以 <code>Tab</code> 键作为开始（不然就被认为是命令）。而注释符 <code>#</code> 同样也是安全的。 <code>else</code> 和 <code>endif</code> 也一样，只要不是以 <code>Tab</code> 键开始就行了。</p><p>条件关键字有以下四种：</p><h3 id="ifeq">ifeq</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，相同则为真</li><li>参数可以使用make的函数</li></ul><h3 id="ifneq">ifneq</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真</li></ul><h3 id="ifdef">ifdef</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure><ul><li><p>如果变量 <code>&lt;variable-name&gt;</code> 的值非空，那到表达式为真</p></li><li><p><code>&lt;variable-name&gt;</code> 同样可以是一个函数的返回值</p></li><li><p><code>ifdef</code> 只是测试一个变量是否有值，其并不会把变量扩展到当前位置，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># frobozz的结果为yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># frobozz的结果为no</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ifndef">ifndef</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure><ul><li>与 <code>ifdef</code> 相反</li></ul><h2 id="使用函数">使用函数</h2><h3 id="函数调用语法">函数调用语法</h3><p>以 <code>$</code> 来标识：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>&lt;function&gt;</code> 就是函数名</li><li><code>&lt;arguments&gt;</code> 为函数的参数，参数间以逗号 <code>,</code> 分隔</li><li>函数名和参数之间以“空格”分隔</li></ul><h3 id="字符串处理函数">字符串处理函数</h3><h4 id="subst">subst</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>名称：字符串替换函数</p></li><li><p>功能：把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换成 <code>&lt;to&gt;</code></p></li><li><p>返回：函数返回被替换过后的字符串</p></li><li><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure><ul><li>把 <code>feet on the street</code> 中的 <code>ee</code> 替换成 <code>EE</code> ，返回结果是 <code>fEEt on the strEEt</code></li></ul></li></ul><h4 id="patsubst">patsubst</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>名称：模式字符串替换函数</p></li><li><p>功能：查找 <code>&lt;text&gt;</code> 中的单词（单词以空格、Tab或回车换行分隔）是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换</p><ul><li><code>&lt;pattern&gt;</code> 可以包括通配符 <code>%</code></li><li>如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么， <code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串</li><li>可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符</li></ul></li><li><p>返回：函数返回被替换过后的字符串</p></li><li><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure><ul><li>把字串 <code>x.c.c bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o bar.o</code></li></ul></li></ul><p><strong>注：</strong></p><ul><li><p><code>$(var:&lt;pattern&gt;=&lt;replacement&gt;;)</code> 相当于 <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code></p></li><li><p><code>$(var: &lt;suffix&gt;=&lt;replacement&gt;)</code> 相当于<code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code></p></li><li><p>如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o baz.o，</span><br></pre></td></tr></table></figure><p>那么， <code>$(objects:.o=.c)</code> 和 <code>$(patsubst %.o,%.c,$(objects))</code> 是一样的</p></li></ul><h4 id="strip">strip</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>名称：去空格函数</p></li><li><p>功能：去掉 <code>&lt;string&gt;</code> 字串中开头和结尾的空字符</p></li><li><p>返回：返回被去掉空格的字符串值</p></li><li><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br></pre></td></tr></table></figure><ul><li>把字串 &quot;a b c “去掉开头和结尾的空字符，结果为&quot;a b c”</li></ul></li></ul><h4 id="findstring">findstring</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>名称：查找字符串函数</p></li><li><p>功能：在字串 <code>&lt;in&gt;</code> 中查找 <code>&lt;find&gt;</code> 字串</p></li><li><p>返回：如果找到，那么返回 <code>&lt;find&gt;</code> ，否则返回空字符串</p></li><li><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure><ul><li>第一个函数返回 <code>a</code> 字符串，第二个返回空字符串</li></ul></li></ul><h4 id="filter">filter</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>名称：过滤函数</p></li><li><p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式</p></li><li><p>返回：返回符合模式 <code>&lt;pattern&gt;</code> 的字串</p></li><li><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="section">foo: <span class="variable">$(sources)</span></span></span><br><span class="line">    cc <span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span> -o foo</span><br></pre></td></tr></table></figure><ul><li><code>$(filter %.c %.s,$(sources))</code> 返回的值为 <code>foo.c bar.c baz.s</code></li></ul></li></ul><h4 id="filter-out">filter-out</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>名称：反过滤函数</p></li><li><p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，去除符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式</p></li><li><p>返回：返回不符合模式 <code>&lt;pattern&gt;</code> 的字串</p></li><li><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects=main1.o foo.o main2.o bar.o</span><br><span class="line">mains=main1.o main2.o</span><br></pre></td></tr></table></figure><ul><li><code>$(filter-out $(mains),$(objects))</code> 返回值为 <code>foo.o bar.o</code></li></ul></li></ul><h4 id="sort">sort</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：排序函数</li><li>功能：给字符串 <code>&lt;list&gt;</code> 中的单词排序（升序）</li><li>返回：返回排序后的字符串</li><li>示例： <code>$(sort foo bar lose)</code> 返回 <code>bar foo lose</code></li><li>备注： <strong><code>sort</code> 函数会去掉 <code>&lt;list&gt;</code> 中相同的单词</strong></li></ul><h4 id="word">word</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：取单词函数</li><li>功能：取字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。（从1开始数）</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。如果 <code>&lt;n&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串</li><li>示例： <code>$(word 2, foo bar baz)</code> 返回值是 <code>bar</code></li></ul><h4 id="wordlist">wordlist</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：取单词串函数</li><li>功能：从字符串 <code>&lt;text&gt;</code> 中取从 <code>&lt;ss&gt;</code> 开始到 <code>&lt;e&gt;</code> 的单词串。 <code>&lt;ss&gt;</code> 和 <code>&lt;e&gt;</code> 是一个数字</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 中从 <code>&lt;ss&gt;</code> 到 <code>&lt;e&gt;</code> 的单词字串。如果 <code>&lt;ss&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数，那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的单词串</li><li>示例： <code>$(wordlist 2, 3, foo bar baz)</code> 返回值是 <code>bar baz</code></li></ul><h4 id="words">words</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：单词个数统计函数</li><li>功能：统计 <code>&lt;text&gt;</code> 中字符串中的单词个数</li><li>返回：返回 <code>&lt;text&gt;</code> 中的单词数</li><li>示例： <code>$(words, foo bar baz)</code> 返回值是 <code>3</code></li><li>备注：如果我们要取 <code>&lt;text&gt;</code> 中最后的一个单词，我们可以这样： <code>$(word $(words &lt;text&gt;),&lt;text&gt;)</code></li></ul><h4 id="firstword">firstword</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：首单词函数</li><li>功能：取字符串 <code>&lt;text&gt;</code> 中的第一个单词</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 的第一个单词</li><li>示例： <code>$(firstword foo bar)</code> 返回值是 <code>foo</code></li><li>备注：这个函数可以用 <code>word</code> 函数来实现： <code>$(word 1,&lt;text&gt;)</code></li></ul><h4 id="函数应用实例">函数应用实例</h4><p>make使用 <code>VPATH</code> 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 <code>CFLAGS</code> ，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-I%,$(<span class="built_in">subst</span> :, ,<span class="variable">$(VPATH)</span>)</span>)</span><br></pre></td></tr></table></figure><p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers</code> ，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ，这正是cc或gcc搜索头文件路径的参数</p><h3 id="文件名操作函数">文件名操作函数</h3><h4 id="dir">dir</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：取目录函数</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出目录部分。目录部分是指最后一个反斜杠（ <code>/</code> ）之前的部分。如果没有反斜杠，那么返回 <code>./</code></li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的目录部分</li><li>示例： <code>$(dir src/foo.c hacks)</code> 返回值是 <code>src/ ./</code></li></ul><h4 id="notdir">notdir</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：取文件函数</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出非目录部分。非目录部分是指最後一个反斜杠（ <code>/</code> ）之后的部分</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的非目录部分</li><li>示例: <code>$(notdir src/foo.c hacks)</code> 返回值是 <code>foo.c hacks</code></li></ul><h4 id="basename">basename</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：取前缀函数</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的前缀部分</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的前缀序列，如果文件没有前缀，则返回空字串</li><li>示例： <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>src/foo src-1.0/bar hacks</code></li></ul><h4 id="addsuffix">addsuffix</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names...&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：加后缀函数</li><li>功能：把后缀 <code>&lt;suffix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面</li><li>返回：返回加过后缀的文件名序列</li><li>示例： <code>$(addsuffix .c,foo bar)</code> 返回值是 <code>foo.c bar.c</code></li></ul><h4 id="addprefix">addprefix</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：加前缀函数</li><li>功能：把前缀 <code>&lt;prefix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词前面</li><li>返回：返回加过前缀的文件名序列</li><li>示例： <code>$(addprefix src/,foo bar)</code> 返回值是 <code>src/foo src/bar</code></li></ul><h4 id="join">join</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>名称：连接函数</li><li>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中</li><li>返回：返回连接过后的字符串</li><li>示例： <code>$(join aaa bbb , 111 222 333)</code> 返回值是 <code>aaa111 bbb222 333</code></li></ul><h3 id="foreach函数">foreach函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li>把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code> 所指定的变量中</li><li>然后再执行 <code>&lt;text&gt;</code> 所包含的表达式</li><li>每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中，<code>&lt;text&gt;</code> 的所返回的每个字符串会以空格分隔</li><li>最后当整个循环结束时， <code>&lt;text&gt;</code> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值</li><li><code>&lt;var&gt;</code> 一般是变量名，<code>&lt;list&gt;</code> 可以是表达式，<code>&lt;text&gt;</code> 一般使用 <code>&lt;var&gt;</code> 这个参数来枚举 <code>&lt;list&gt;</code> 中的单词</li><li><code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用</li></ul><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line"></span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># files的值为 &quot;a.o b.o c.o d.o&quot;</span></span><br></pre></td></tr></table></figure><h3 id="if函数">if函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure><p>if函数的返回值：如果 <code>&lt;condition&gt;</code> 为真（非空字符串）， <code>&lt;then-part&gt;</code> 会是整个函数的返回值；如果 <code>&lt;condition&gt;</code> 为假（空字符串），那么 <code>&lt;else-part&gt;</code> 会是整个函数的返回值，此时如果 <code>&lt;else-part&gt;</code> 没有被定义，那么，整个函数返回空字串</p><h3 id="call函数">call函数</h3><p>可以用来创建新的参数化的函数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</span></span><br></pre></td></tr></table></figure><p><code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、 <code>$(2)</code> 等，会被参数 <code>&lt;parm1&gt;</code> 、 <code>&lt;parm2&gt;</code> 、 <code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的返回值就是 call 函数的返回值，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverse =  $(2) $(1)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo的值为  &quot;b a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>需要注意</strong>：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p><h3 id="origin函数">origin函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure><p>注意， <code>&lt;variable&gt;</code> 是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code> 中使用 <code>$</code> 字符。</p><p>origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p><ul><li><code>undefined</code> ： <code>&lt;variable&gt;</code> 从来没有定义过，</li><li><code>default</code> ： <code>&lt;variable&gt;</code> 是一个默认的定义，比如“CC”这个变量</li><li><code>environment</code> ： <code>&lt;variable&gt;</code> 是一个环境变量，并且当Makefile被执行时， <code>-e</code> 参数没有被打开</li><li><code>file</code> ： <code>&lt;variable&gt;</code> 被定义在Makefile中</li><li><code>command line</code> ：<code>&lt;variable&gt;</code> 是被命令行定义的</li><li><code>override</code> ：<code>&lt;variable&gt;</code> 是被override指示符重新定义的</li><li><code>automatic</code> ：<code>&lt;variable&gt;</code> 是一个命令运行中的自动化变量</li></ul><p>假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> bletch</span><br><span class="line">    <span class="keyword">ifeq</span> <span class="string">&quot;$(origin bletch)&quot;</span> <span class="string">&quot;environment&quot;</span></span><br><span class="line">        bletch = barf, gag, etc.</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="shell函数">shell函数</h3><p>shell函数的参数是操作系统shell的命令，shell函数把执行操作系统命令后的输出作为函数返回，于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure><p>这个函数会新生成一个Shell程序来执行命令，所以要注意其运行性能</p><h3 id="控制make的函数">控制make的函数</h3><p>检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止：</p><h4 id="error函数">error函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>产生一个致命的错误， <code>&lt;text ...&gt;</code> 是错误信息</p></li><li><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># 在变量ERROR_001定义了后执行时产生error调用</span></span><br></pre></td></tr></table></figure></li><li><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: err</span></span><br><span class="line"></span><br><span class="line"><span class="section">err: <span class="variable">$(ERR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目录err被执行时发生error调用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="warning函数">warning函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure><p>和 <code>error</code> 函数很像，但是不会让make退出，只是输出一段警告信息，而make继续执行</p><h2 id="make的运行">make的运行</h2><h3 id="make的退出码">make的退出码</h3><p>make命令执行后有三个退出码：</p><ul><li>0：表示成功执行</li><li>1：如果make运行时出现任何错误，返回1</li><li>2：如果使用make的“-q”选项，并且make使得一些目标不需要更新，那么返回2</li></ul><h3 id="指定makefile">指定makefile</h3><p>使用 <code>-f 或 --file 或 --makefile</code> 参数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure><h3 id="指定目标">指定目标</h3><ul><li><p>一般来说，make的最终目标是makefile中的第一个目标</p></li><li><p>可以指示make，让其完成你所指定的目标：需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）</p></li><li><p>有一个make的环境变量叫 <code>MAKECMDGOALS</code> ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值，使用方法如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">ifneq</span> ( <span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line">    <span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><ul><li>只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile</li></ul></li></ul><h3 id="检查规则">检查规则</h3><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列，可以使用以下参数：</p><ul><li><p><code>-n, --just-print, --dry-run, --recon</code> ：不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行</p></li><li><p><code>-t, --touch</code> ：把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态</p></li><li><p><code>-q, --question</code> ：找目标，如果目标存在，那么什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息</p></li><li><p><code>-W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt;</code> ：指定一个文件。一般是是源文件（或依赖文件），make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令</p></li></ul><h3 id="make的参数">make的参数</h3><ul><li><code>-b, -m</code> ：忽略和其它版本make的兼容性</li><li><code>-B, --always-make</code> ：认为所有的目标都需要更新（重编译）</li><li><code>-C &lt;dir&gt;, --directory=&lt;dir&gt;</code> ：指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog”</li><li><code>-debug[=&lt;options&gt;]</code> ：输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：<ul><li>a: 也就是all，输出所有的调试信息（会非常的多）</li><li>b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标</li><li>v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等</li><li>i: 也就是implicit，输出所以的隐含规则</li><li>j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等</li><li>m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息</li></ul></li><li><code>-d</code> ：相当于“–debug=a”</li><li><code>-e, --environment-overrides</code> ：指明环境变量的值覆盖makefile中定义的变量的值</li><li><code>-f=&lt;file&gt;, --file=&lt;file&gt;, --makefile=&lt;file&gt;</code> ：指定需要执行的makefile</li><li><code>-h, --help</code> ：显示帮助信息</li><li><code>-i, --ignore-errors</code> ：在执行时忽略所有的错误</li><li><code>-I&lt;dir&gt;, --include-dir=&lt;dir&gt;</code> ：指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录</li><li><code>-j [&lt;jobsnum&gt;], --jobs[=&lt;jobsnum&gt;]</code> ：指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的</li><li><code>-k, --keep-going</code> ：出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了</li><li><code>-l &lt;load&gt;, --load-average[=&lt;load&gt;], --max-load[=&lt;load&gt;]</code> ：指定make运行命令的负载</li><li><code>-n, --just-print, --dry-run, --recon</code> ：仅输出执行过程中的命令序列，但并不执行</li><li><code>-o &lt;file&gt;, --old-file=&lt;file&gt;, --assume-old=&lt;file&gt;</code> ：不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它</li><li><code>-p, --print-data-base</code> ：输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用 “make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号</li><li><code>-q, --question</code> ：不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生</li><li><code>-r, --no-builtin-rules</code> ：禁止make使用任何隐含规则</li><li><code>-R, --no-builtin-variables</code> ：禁止make使用任何作用于变量上的隐含规则</li><li><code>-s, --silent, --quiet</code> ：在命令运行时不输出命令的输出</li><li><code>-S, --no-keeping-going, --stop</code> ：取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效</li><li><code>-t, --touch</code> ：相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行</li><li><code>-v, --version</code> ：输出make程序的版本、版权等关于make的信息</li><li><code>-w, --print-directory</code> ：输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用</li><li><code>--no-print-directory</code> ：禁止“-w”选项</li><li><code>-W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt;</code> ：假定目标&lt;file&gt;;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作；如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;;的修改时间为当前时间</li><li><code>--warn-undefined-variables</code> ：只要make发现有未定义的变量，那么就输出警告信息</li></ul><h2 id="隐含规则">隐含规则</h2><h3 id="使用隐含规则">使用隐含规则</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure><p>这个Makefile中并没有写下如何生成 <code>foo.o</code> 和 <code>bar.o</code> 这两目标的规则和命令。因为make调用的隐含规则，把 <code>.o</code> 的目标的依赖文件置成 <code>.c</code> ，并使用C的编译命令 <code>cc –c $(CFLAGS) foo.c</code> 来生成 <code>foo.o</code> 的目标</p><h3 id="一些语言的隐含规则">一些语言的隐含规则</h3><ol><li><p>编译C程序的隐含规则。</p><p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.c</code> ，并且其生成命令是 <code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code></p></li><li><p>编译C++程序的隐含规则。</p><p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.cc</code> 或是 <code>&lt;n&gt;.C</code> ，并且其生成命令是 <code>$(CXX) –c $(CPPFLAGS) $(CFLAGS)</code> 。（建议使用 <code>.cc</code> 作为C++源文件的后缀，而不是 <code>.C</code> ）</p></li><li><p>编译Pascal程序的隐含规则。</p><p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.p</code> ，并且其生成命令是 <code>$(PC) –c $(PFLAGS)</code> 。</p></li><li><p>编译Fortran/Ratfor程序的隐含规则。</p><p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.r</code> 或 <code>&lt;n&gt;.F</code> 或 <code>&lt;n&gt;.f</code> ，并且其生成命令是:</p><ul><li><code>.f</code> <code>$(FC) –c $(FFLAGS)</code></li><li><code>.F</code> <code>$(FC) –c $(FFLAGS) $(CPPFLAGS)</code></li></ul></li><li><p>预处理Fortran/Ratfor程序的隐含规则。</p><p><code>&lt;n&gt;.f</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.r</code> 或 <code>&lt;n&gt;.F</code> 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</p><ul><li><code>.F</code> <code>$(FC) –F $(CPPFLAGS) $(FFLAGS)</code></li><li><code>.r</code> <code>$(FC) –F $(FFLAGS) $(RFLAGS)</code></li></ul></li><li><p>编译Modula-2程序的隐含规则。</p><p><code>&lt;n&gt;.sym</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.def</code> ，并且其生成命令是： <code>$(M2C) $(M2FLAGS) $(DEFFLAGS)</code> 。 <code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.mod</code> ，并且其生成命令是： <code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code> 。</p></li><li><p>汇编和汇编预处理的隐含规则。</p><p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.s</code> ，默认使用编译器 <code>as</code> ，并且其生成命令是： <code>$ (AS) $(ASFLAGS)</code> 。 <code>&lt;n&gt;.s</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.S</code> ，默认使用C预编译器 <code>cpp</code> ，并且其生成命令是： <code>$(AS) $(ASFLAGS)</code> 。</p></li><li><p>链接Object文件的隐含规则。</p><p><code>&lt;n&gt;</code> 目标依赖于 <code>&lt;n&gt;.o</code> ，通过运行C的编译器来运行链接程序生成（一般是 <code>ld</code> ），其生成命令是： <code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code> 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x : y.o z.o</span><br></pre></td></tr></table></figure><p>并且 <code>x.c</code> 、 <code>y.c</code> 和 <code>z.c</code> 都存在时，隐含规则将执行如下命令:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure><p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p></li><li><p>Yacc C程序时的隐含规则。</p><p><code>&lt;n&gt;.c</code> 的依赖文件被自动推导为 <code>n.y</code> （Yacc生成的文件），其生成命令是： <code>$(YACC) $(YFALGS)</code> 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p></li><li><p>Lex C程序时的隐含规则。</p><p><code>&lt;n&gt;.c</code> 的依赖文件被自动推导为 <code>n.l</code> （Lex生成的文件），其生成命令是： <code>$(LEX) $(LFALGS)</code> 。（关于“Lex”的细节请查看相关资料）</p></li><li><p>Lex Ratfor程序时的隐含规则。</p><p><code>&lt;n&gt;.r</code> 的依赖文件被自动推导为 <code>n.l</code> （Lex生成的文件），其生成命令是： <code>$(LEX) $(LFALGS)</code> 。</p></li><li><p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p><p><code>&lt;n&gt;.ln</code> （lint生成的文件）的依赖文件被自动推导为 <code>n.c</code> ，其生成命令是： <code>$(LINT) $(LINTFALGS) $(CPPFLAGS) -i</code> 。对于 <code>&lt;n&gt;.y</code> 和 <code>&lt;n&gt;.l</code> 也是同样的规则。</p></li></ol><h3 id="隐含规则使用的变量">隐含规则使用的变量</h3><h4 id="关于命令的变量">关于命令的变量</h4><ul><li><code>AR</code> : 函数库打包程序。默认命令是 <code>ar</code></li><li><code>AS</code> : 汇编语言编译程序。默认命令是 <code>as</code></li><li><code>CC</code> : C语言编译程序。默认命令是 <code>cc</code></li><li><code>CXX</code> : C++语言编译程序。默认命令是 <code>g++</code></li><li><code>CO</code> : 从 RCS文件中扩展文件程序。默认命令是 <code>co</code></li><li><code>CPP</code> : C程序的预处理器（输出是标准输出设备）。默认命令是 <code>$(CC) –E</code></li><li><code>FC</code> : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 <code>f77</code></li><li><code>GET</code> : 从SCCS文件中扩展文件的程序。默认命令是 <code>get</code></li><li><code>LEX</code> : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 <code>lex</code></li><li><code>PC</code> : Pascal语言编译程序。默认命令是 <code>pc</code></li><li><code>YACC</code> : Yacc文法分析器（针对于C程序）。默认命令是 <code>yacc</code></li><li><code>YACCR</code> : Yacc文法分析器（针对于Ratfor程序）。默认命令是 <code>yacc –r</code></li><li><code>MAKEINFO</code> : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 <code>makeinfo</code></li><li><code>TEX</code> : 从TeX源文件创建TeX DVI文件的程序。默认命令是 <code>tex</code></li><li><code>TEXI2DVI</code> : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 <code>texi2dvi</code></li><li><code>WEAVE</code> : 转换Web到TeX的程序。默认命令是 <code>weave</code></li><li><code>CWEAVE</code> : 转换C Web 到 TeX的程序。默认命令是 <code>cweave</code></li><li><code>TANGLE</code> : 转换Web到Pascal语言的程序。默认命令是 <code>tangle</code></li><li><code>CTANGLE</code> : 转换C Web 到 C。默认命令是 <code>ctangle</code></li><li><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></li></ul><h4 id="关于命令参数的变量">关于命令参数的变量</h4><p>如果没有指明默认值，则为空</p><ul><li><code>ARFLAGS</code> : 函数库打包程序AR命令的参数。默认值是 <code>rv</code></li><li><code>ASFLAGS</code> : 汇编语言编译器参数。（当明显地调用 <code>.s</code> 或 <code>.S</code> 文件时）</li><li><code>CFLAGS</code> : C语言编译器参数</li><li><code>CXXFLAGS</code> : C++语言编译器参数</li><li><code>COFLAGS</code> : RCS命令参数</li><li><code>CPPFLAGS</code> : C预处理器参数。（ C 和 Fortran 编译器也会用到）</li><li><code>FFLAGS</code> : Fortran语言编译器参数</li><li><code>GFLAGS</code> : SCCS “get”程序参数</li><li><code>LDFLAGS</code> : 链接器参数。（如： <code>ld</code> ）</li><li><code>LFLAGS</code> : Lex文法分析器参数。</li><li><code>PFLAGS</code> : Pascal语言编译器参数</li><li><code>RFLAGS</code> : Ratfor 程序的Fortran 编译器参数</li><li><code>YFLAGS</code> : Yacc文法分析器参数</li></ul><h3 id="隐含规则链">隐含规则链</h3><p>有些时候，一个目标可能被一系列的隐含规则所作用。</p><p>例如，一个 <code>.o</code> 的文件生成，可能会是先被 Yacc的[.y]文件生成 <code>.c</code> ，然后再被C的编译器生成：</p><ul><li>如果文件 <code>.c</code> 存在，那么就直接调用C的编译器的隐含规则</li><li>如果没有 <code>.c</code> 文件，但有一个 <code>.y</code> 文件，那么Yacc的隐含规则会被调用，生成 <code>.c</code> 文件，然后，再调用C编译的隐含规则最终由 <code>.c</code> 生成 <code>.o</code> 文件，达到目标</li></ul><p>我们把这种 <code>.c</code> 的文件（或是目标），叫做中间目标</p><ul><li>除非中间的目标不存在，才会引发中间规则</li><li>只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以 <code>rm -f</code> 删除</li></ul><h4 id="中间目标">中间目标</h4><ul><li>显式说明一个文件或是目标是中间目标：<code>.INTERMEDIATE : mid</code></li><li>阻止make自动删除中间目标：<code>.SECONDARY : sec</code></li><li>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况</li></ul><h3 id="模式规则">模式规则</h3><p>使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 <code>%</code> 字符；在依赖目标中同样可以使用 <code>%</code> ，只是依赖目标中的 <code>%</code> 的取值，取决于其目标。</p><p><strong>注意：</strong></p><ul><li><code>%</code> 的展开发生在变量和函数的展开之后</li><li>变量和函数的展开发生在make载入Makefile时</li><li>模式规则中的 <code>%</code> 展开发生在运行时</li></ul><h4 id="模式规则示例">模式规则示例</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li>把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件</li></ul><hr><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.tab.c %.tab.h: %.y</span><br><span class="line">    bison -d <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><ul><li>这条规则告诉make把所有的 <code>.y</code> 文件都以 <code>bison -d &lt;n&gt;.y</code> 执行，然后生成 <code>&lt;n&gt;.tab.c</code> 和 <code>&lt;n&gt;.tab.h</code> 文件（其中， <code>&lt;n&gt;</code> 表示一个任意字符串）</li><li>如果我们的执行程序 <code>foo</code> 依赖于文件 <code>parse.tab.o</code> 和 <code>scan.o</code> ，并且文件 <code>scan.o</code> 依赖于文件 <code>parse.tab.h</code> ，如果 <code>parse.y</code> 文件被更新了，那么根据上述的规则， <code>bison -d parse.y</code> 就会被执行一次，于是， <code>parse.tab.o</code> 和 <code>scan.o</code> 的依赖文件就齐了。（假设， <code>parse.tab.o</code> 由 <code>parse.tab.c</code> 生成，和 <code>scan.o</code> 由 <code>scan.c</code> 生成，而 <code>foo</code> 由 <code>parse.tab.o</code> 和 <code>scan.o</code> 链接生成，而且 <code>foo</code> 和其 <code>.o</code> 文件的依赖关系也写好，那么，所有的目标都会得到满足）</li></ul><h4 id="自动化变量">自动化变量</h4><p>把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完</p><ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合</li><li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code> ，那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code> 。如果目标不是函数库文件（Unix下是 <code>.a</code> ，Windows下是 <code>.lib</code> ），那么，其值为空</li><li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的</li><li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔</li><li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份</li><li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标</li><li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么， <code>$*</code> 的值就是 <code>dir/a.foo</code> 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是make所能识别的后缀名，所以， <code>$*</code> 的值就是 <code>foo</code> 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <code>$*</code> 就是空值</li></ul><p>当你希望只对更新过的依赖文件进行操作时， <code>$?</code> 在显式规则中很有用，例如，假设有一个函数库文件叫 <code>lib</code> ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib : foo.o bar.o lose.o win.o</span><br><span class="line">    ar r lib <span class="variable">$?</span></span><br></pre></td></tr></table></figure><p>在上述所列出来的自动量变量中。四个变量（ <code>$@</code> 、 <code>$&lt;</code> 、 <code>$%</code> 、 <code>$*</code> ）在扩展时只会有一个文件，而另三个的值是一个文件列表。</p><p>这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 <code>D</code> 或 <code>F</code> 字样：</p><ul><li><code>$(@D)</code>：表示 <code>$@</code> 的目录部分（不以斜杠作为结尾），如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@D)</code> 就是 <code>dir</code> ，而如果 <code>$@</code> 中没有包含斜杠的话，其值就是 <code>.</code> （当前目录）</li><li><code>$(@F)</code>：表示 <code>$@</code> 的文件部分，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@F)</code> 就是 <code>foo.o</code> ， <code>$(@F)</code> 相当于函数 <code>$(notdir $@)</code> 。</li><li><code>$(*D)</code>, <code>$(*F)</code>：和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， <code>$(*D)</code> 返回 <code>dir</code> ，而 <code>$(*F)</code> 返回 `foo``</li><li>``$(%D)<code>, </code>$(%F)<code>：分别表示了函数包文件成员的目录部分和文件部分。这对于形同 </code>archive(member)<code>形式的目标中的</code>member` 中包含了不同的目录很有用。</li><li><code>$(&lt;D)</code>, <code>$(&lt;F)</code>：分别表示依赖文件的目录部分和文件部分。</li><li><code>$(^D)</code>, <code>$(^F)</code>：分别表示所有依赖文件的目录部分和文件部分。（无相同的）</li><li><code>$(+D)</code>, <code>$(+F)</code>：分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</li><li><code>$(?D)</code>, <code>$(?F)</code>：分别表示被更新的依赖文件的目录部分和文件部分</li></ul><h4 id="重载内建隐含规则">重载内建隐含规则</h4><p>重新构造和内建隐含规则不同的命令，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -D<span class="variable">$(date)</span></span><br></pre></td></tr></table></figure><p>取消内建的隐含规则，只要不在后面写命令就行。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.s</span><br></pre></td></tr></table></figure><h3 id="隐含规则搜索算法">隐含规则搜索算法</h3><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。如果目标是 <code>archive(member)</code> 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 <code>member</code> 当作T来搜索。</p><ol><li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 <code>src/foo.o</code> ，那么，D就是 <code>src/</code> ，N就是 <code>foo.o</code> ）</li><li>创建所有匹配于T或是N的模式规则列表。</li><li>如果在模式规则列表中有匹配所有文件的模式，如 <code>%</code> ，那么从列表中移除其它的模式。</li><li>移除列表中没有命令的规则。</li><li>对于第一个在列表中的模式规则：<ol><li>推导其“茎”S，S应该是T或是N匹配于模式中 <code>%</code> 非空的部分。</li><li>计算依赖文件。把依赖文件中的 <code>%</code> 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li><li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）</li><li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li></ol></li><li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<ol><li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li><li>计算依赖文件。（同第5步）</li><li>测试所有的依赖文件是否存在或是理当存在。</li><li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li><li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li><li>如果没有隐含规则可以使用，查看 <code>.DEFAULT</code> 规则，如果有，采用，把 <code>.DEFAULT</code> 的命令给T使用。</li></ol></li></ol><p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p><h2 id="使用make更新函数库文件">使用make更新函数库文件</h2><ul><li>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件</li><li>在Unix下，一般是由命令 <code>ar</code> 来完成打包工作</li></ul><h3 id="函数库文件的成员">函数库文件的成员</h3><p>一个函数库文件由多个文件组成，指定函数库文件及其组成：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure><p>从而在 <code>ar</code> 命令中，如此使用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o) : hack.o kludge.o</span><br><span class="line">    ar cr foolib(hack.o kludge.o)</span><br></pre></td></tr></table></figure><h3 id="函数库成员的隐含规则">函数库成员的隐含规则</h3><p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 <code>a(m)</code> 形式的，其会把目标变成 <code>(m)</code> 。于是，如果我们的成员是 <code>%.o</code> 的模式定义，并且如果我们使用 <code>make foo.a(bar.o)</code> 的形式调用Makefile时，隐含规则会去找 <code>bar.o</code> 的规则，如果没有定义 <code>bar.o</code> 的规则，那么内建隐含规则生效，make会去找 <code>bar.c</code> 文件来生成 <code>bar.o</code> ，如果找得到的话，make执行的命令大致如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc -c bar.c -o bar.o</span><br><span class="line">ar r foo.a bar.o</span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wasmi sgx 工作流程</title>
      <link href="2021/03/08/learning-notes/wasmi-sgx/"/>
      <url>2021/03/08/learning-notes/wasmi-sgx/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化enclave">初始化enclave</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_enclave() -&gt; SgxResult&lt;SgxEnclave&gt;</span><br></pre></td></tr></table></figure><p>底层调用rsgx_create_enclave【通过file_name和launch_token来初始化一个enclave实例】，参数如下：</p><blockquote><ul><li><p>file_name：经过编译后的enclave签名文件（<a href="http://enclave.signed.so">enclave.signed.so</a>）</p></li><li><p>debug：</p><ul><li>0 - 不开启debug</li><li>1 - 开启debug，enclave中的数据代码可以被enclave外的程序访问，用于调试</li></ul></li><li><p>launch_token：初始化enclave时可以传入全0 buffer，函数会创建一个有效token与enclave对应，并更新该参数。之后如果要重新创建这个enclave，可以再使用这个token</p></li><li><p>launch_token_updated：</p><ul><li>0 - token没有被自动更新</li><li>1 - token被自动更新</li></ul></li><li><p>misc_attr：misc选择和enclave属性             {暂时不清楚作用}</p></li></ul></blockquote><p>init_enclave()返回一个SgxEnclave结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SgxEnclave</span></span> &#123;</span><br><span class="line">    id: sgx_enclave_id_t,</span><br><span class="line">    debug: <span class="built_in">i32</span>,</span><br><span class="line">    path: PathBuf,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化sgxwasm的SpecDriver">初始化sgxwasm的SpecDriver</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgx_enclave_wasm_init</span></span>(enclave: &amp;SgxEnclave) -&gt; <span class="built_in">Result</span>&lt;(),<span class="built_in">String</span>&gt;</span><br></pre></td></tr></table></figure><p>调用ECall函数sgxwasm_init()，传入两个隐参数：</p><blockquote><ul><li>enclave_id：通过enclave.geteid()获取</li><li>retval：ECall函数的返回值，由Intel定义，不用在ECall函数中手动修改</li></ul></blockquote><p>在Enclave中会通过lazy_static的方式建立一个全局变量SPECDRIVER（带有互斥量）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy_static!&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> SPECDRIVER: SgxMutex&lt;SpecDriver&gt; </span><br><span class="line">    = SgxMutex::new(SpecDriver::new());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sgxwasm_init()在SPECDRIVER中新建一个SpecDriver</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SpecDriver</span></span> &#123;</span><br><span class="line">    spec_module: SpecModule,</span><br><span class="line">    instances: HashMap&lt;<span class="built_in">String</span>, ModuleRef&gt;,</span><br><span class="line">    last_module: <span class="built_in">Option</span>&lt;ModuleRef&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准模块，是从wasm外部导入函数所使用的外部环境</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SpecModule</span></span> &#123;</span><br><span class="line">    table: TableRef,</span><br><span class="line">    memory: MemoryRef,</span><br><span class="line">    global_i32: GlobalRef,</span><br><span class="line">    global_f32: GlobalRef,</span><br><span class="line">    global_f64: GlobalRef,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModuleRef是ModuleInstance的引用</span></span><br><span class="line"><span class="comment">// ModuleInstance是一个wasm模块实例</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ModuleInstance</span></span> &#123;</span><br><span class="line">    signatures: RefCell&lt;<span class="built_in">Vec</span>&lt;Arc&lt;Signature&gt;&gt;&gt;,</span><br><span class="line">    tables: RefCell&lt;<span class="built_in">Vec</span>&lt;TableRef&gt;&gt;,</span><br><span class="line">    funcs: RefCell&lt;<span class="built_in">Vec</span>&lt;FuncRef&gt;&gt;,</span><br><span class="line">    memories: RefCell&lt;<span class="built_in">Vec</span>&lt;MemoryRef&gt;&gt;,</span><br><span class="line">    globals: RefCell&lt;<span class="built_in">Vec</span>&lt;GlobalRef&gt;&gt;,</span><br><span class="line">    exports: RefCell&lt;BTreeMap&lt;<span class="built_in">String</span>, ExternVal&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Enclave外加载wast文件">在Enclave外加载wast文件</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wasm_main_loop(wast_file: &amp;<span class="built_in">str</span>, enclave: &amp;SgxEnclave) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt;</span><br></pre></td></tr></table></figure><p>首先对读入的wast_file文本进行分析（使用ScriptParser），读取每一行的指令到结构Command中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span></span>&lt;F32 = <span class="built_in">f32</span>, F64 = <span class="built_in">f64</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 行号</span></span><br><span class="line">    <span class="keyword">pub</span> line: <span class="built_in">u64</span>,</span><br><span class="line">    <span class="comment">/// 指令类型</span></span><br><span class="line">    <span class="keyword">pub</span> kind: CommandKind&lt;F32, F64&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每一行指令匹配CommandKind，并执行对应的操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">CommandKind</span></span>&lt;F32 = <span class="built_in">f32</span>, F64 = <span class="built_in">f64</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义、验证、实例化一个module</span></span><br><span class="line">    Module &#123;</span><br><span class="line">        <span class="comment">// wasm二进制模块 </span></span><br><span class="line">        module: ModuleBinary,</span><br><span class="line">        <span class="comment">// 模块名称，可以将wasm模块注册到name</span></span><br><span class="line">        name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保特定的指令会产生特定的结果</span></span><br><span class="line">    AssertReturn &#123;</span><br><span class="line">        <span class="comment">// 执行的指令</span></span><br><span class="line">        action: Action&lt;F32, F64&gt;,</span><br><span class="line">        <span class="comment">/// 预期的指令执行结果</span></span><br><span class="line">        expected: <span class="built_in">Vec</span>&lt;Value&lt;F32, F64&gt;&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保指定的指令产生NaN</span></span><br><span class="line">    AssertReturnCanonicalNan &#123;</span><br><span class="line">        <span class="comment">//  执行的指令</span></span><br><span class="line">        action: Action&lt;F32, F64&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保指定的指令产生 NaN with 1 in MSB of fraction field</span></span><br><span class="line">    AssertReturnArithmeticNan &#123;</span><br><span class="line">        <span class="comment">// 执行的指令</span></span><br><span class="line">        action: Action&lt;F32, F64&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保指定的指令产生trap</span></span><br><span class="line">    AssertTrap &#123;</span><br><span class="line">        <span class="comment">// 执行的指令</span></span><br><span class="line">        action: Action&lt;F32, F64&gt;,</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        message: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保特定的模块是无效的</span></span><br><span class="line">    AssertInvalid &#123;</span><br><span class="line">        <span class="comment">// 无效的模块</span></span><br><span class="line">        module: ModuleBinary,</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        message: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保特定的模块不能被decode</span></span><br><span class="line">    AssertMalformed &#123;</span><br><span class="line">        module: ModuleBinary,</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        message: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保特定的模块不能被实例化</span></span><br><span class="line">    AssertUninstantiable &#123;</span><br><span class="line">        <span class="comment">// 不能被实例化的模块</span></span><br><span class="line">        module: ModuleBinary,</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        message: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保特定的指令在资源耗尽的时候执行</span></span><br><span class="line">    AssertExhaustion &#123;</span><br><span class="line">        action: Action&lt;F32, F64&gt;,</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        message: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保特定的模块不能被链接</span></span><br><span class="line">    AssertUnlinkable &#123;</span><br><span class="line">        module: ModuleBinary,</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        message: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将已经注册过的模块改名</span></span><br><span class="line">    Register &#123;</span><br><span class="line">        <span class="comment">// 需要改名的模块名，若爲None则将使用最后定义的模块</span></span><br><span class="line">        name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 新名称</span></span><br><span class="line">        as_name: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行指定指令</span></span><br><span class="line">    PerformAction(Action&lt;F32, F64&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指令Action">指令Action</h4><p>wasm模块中的指令：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Action</span></span>&lt;F32 = <span class="built_in">f32</span>, F64 = <span class="built_in">f64</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    Invoke &#123;</span><br><span class="line">        <span class="comment">// 模块名称，若爲None，则取最后定义的模块</span></span><br><span class="line">        module: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 函数名</span></span><br><span class="line">        field: <span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// 需要传递给函数的参数</span></span><br><span class="line">        args: <span class="built_in">Vec</span>&lt;Value&lt;F32, F64&gt;&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 读取全局变量</span></span><br><span class="line">    Get &#123;</span><br><span class="line">        <span class="comment">// 模块名称，若爲None，则取最后定义的模块</span></span><br><span class="line">        module: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 指令作用在字段field上</span></span><br><span class="line">        field: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sgxwasm中定义的指令：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SgxWasmAction</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    Invoke &#123;</span><br><span class="line">        <span class="comment">// 模块名称，若爲None，则取最后定义的模块</span></span><br><span class="line">        module: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 函数名</span></span><br><span class="line">        field: <span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// 需要传递给函数的参数</span></span><br><span class="line">        args: <span class="built_in">Vec</span>&lt;BoundaryValue&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取全局变量</span></span><br><span class="line">    Get &#123;</span><br><span class="line">        <span class="comment">// 模块名称，若爲None，则取最后定义的模块</span></span><br><span class="line">        module: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 指令作用在字段field上</span></span><br><span class="line">        field: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载模块</span></span><br><span class="line">    LoadModule &#123;</span><br><span class="line">        <span class="comment">// 模块名称，若爲None，则取最后定义的模块</span></span><br><span class="line">        name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 二进制模块</span></span><br><span class="line">        module: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试加载一个模块</span></span><br><span class="line">    TryLoad &#123;</span><br><span class="line">        <span class="comment">// 二进制模块</span></span><br><span class="line">        module: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将已经注册过的模块改名</span></span><br><span class="line">    Register &#123;</span><br><span class="line">        <span class="comment">// 模块名称，若爲None，则取最后定义的模块</span></span><br><span class="line">        name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        <span class="comment">// 新名称</span></span><br><span class="line">        as_name: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CommandKind-Module">CommandKind::Module</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载一个模块</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgx_enclave_wasm_load_module</span></span>(module : <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">        name   : &amp;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">                                enclave : &amp;SgxEnclave)</span><br><span class="line">-&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt;</span><br></pre></td></tr></table></figure><p>创建一个SgxWasmAction::LoadModule结构，再调用sgx_enclave_wasm_invoke()</p><h4 id="CommandKind-AssertReturn">CommandKind::AssertReturn</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据wasm的Action执行指令</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgx_enclave_wasm_run_action</span></span>(action: &amp;Action, enclave: &amp;SgxEnclave) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;RuntimeValue&gt;, InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>先匹配Action：</p><ul><li>如果是Action::Invoke，那么创建一个SgxWasmAction::Invoke结构并交给sgx_enclave_wasm_invoke()</li><li>如果是Action::Get，那么创建一个SgxWasmAction::Get结构并交给sgx_enclave_wasm_invoke()</li></ul><p>然后根据sgx_enclave_wasm_invoke()的返回结果来判断输出是否是我们想要的</p><p>**备注：**对于另外一些CommandKind（包括CommandKind::AssertReturnCanonicalNan、CommandKind::AssertReturnArithmeticNan、CommandKind::AssertExhaustion、CommandKind::AssertTrap），过程同CommandKind::AssertReturn，只不过是对返回值的判断有所不同</p><p>**备注2：**对于CommandKind::PerformAction，只需匹配和执行Action，不需要后面的判断</p><h4 id="CommandKind-AssertInvalid">CommandKind::AssertInvalid</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加载一个模块</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgx_enclave_wasm_try_load</span></span>(module : &amp;[<span class="built_in">u8</span>], enclave : &amp;SgxEnclave) -&gt; <span class="built_in">Result</span>&lt;(), InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>先创建一个SgxWasmAction::TryLoad结构，再交给sgx_enclave_wasm_invoke()</p><p>**备注：**对于另外一些CommandKind（包括CommandKind::AssertMalformed、CommandKind::AssertUnlinkable、CommandKind::AssertUninstantiable），由于这些类型的SgxWasmAction都不能加载可用的模块，所以只能尝试加载模块</p><h4 id="CommandKind-Register">CommandKind::Register</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个模块</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgx_enclave_wasm_register</span></span>(name : <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">                             as_name : <span class="built_in">String</span>,</span><br><span class="line">                             enclave : &amp;SgxEnclave) </span><br><span class="line">-&gt; <span class="built_in">Result</span>&lt;(), InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>创建一个SgxWasmAction::Register结构，再交给sgx_enclave_wasm_invoke()</p><h4 id="调用函數sgx-enclave-wasm-invoke">调用函數sgx_enclave_wasm_invoke()</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据SgxWasmAction通过ECall执行指定的指令</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgx_enclave_wasm_invoke</span></span>(req_str : <span class="built_in">String</span>,</span><br><span class="line">                           result_max_len : <span class="built_in">usize</span>,</span><br><span class="line">                           enclave : &amp;SgxEnclave) -&gt; (<span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;BoundaryValue&gt;, InterpreterError&gt;, sgx_status_t)</span><br></pre></td></tr></table></figure><ul><li>req_str：将SgxWasmAction序列化得到</li><li>result_max_len：返回结果的最大长度</li></ul><p>sgx_enclave_wasm_invoke()调用ECall函数sgxwasm_run_action()</p><h3 id="安全函数sgxwasm-run-action">安全函数sgxwasm_run_action()</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sgxwasm_run_action</span></span>(req_bin : *<span class="keyword">const</span> <span class="built_in">u8</span>, req_length: <span class="built_in">usize</span>,</span><br><span class="line">                      result_bin : *<span class="keyword">mut</span> <span class="built_in">u8</span>, result_max_len: <span class="built_in">usize</span>) -&gt; sgx_status_t</span><br></pre></td></tr></table></figure><ul><li>req_bin：需要执行的SgxWasmAction请求</li><li>req_length：请求长度</li><li>result_bin：返回的内容</li><li>result_max_len：返回值的最大长度</li></ul><p>首先通过req_bin和req_length来在Enclave中创建一个安全的SgxWasmAction结构action_req，再对其进行匹配：</p><h4 id="SgxWasmAction-Invoke">SgxWasmAction::Invoke</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">wasm_invoke</span></span>(module: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;, field: <span class="built_in">String</span>, args: <span class="built_in">Vec</span>&lt;RuntimeValue&gt;)</span><br><span class="line">-&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;RuntimeValue&gt;, InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>首先获取全局的SPECDRIVER存入变量program，根据module的值在SpecDriver.instances中查找对应名字的模块，如果module的值爲None，则通过SpecDriver.last_module返回最后注册的模块，得到一个ModuleRef结构module通过module的invoke_export()方法调用导出函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.invoke_export(&amp;field, &amp;args, program.spec_module())</span><br></pre></td></tr></table></figure><ul><li>&amp;field：函数名</li><li>&amp;args：传入函数的参数</li><li>program.spec_module()：externals，导入wasm函数的外部环境，实现Externals trait</li></ul><p>invoke_export()方法通过函数名查找导出函数，得到FuncRef类型的func_instance，并使用 <code>FuncInstance::invoke(&amp;func_instance, args, externals)</code> 调用函数，FuncInstance结构是一个函数实例，在wasm中，函数的定义方式有两种：在wasm模块中定义或者从宿主环境导入，分别对应FuncInstanceInternal::Internal和FuncInstanceInternal::Host</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FuncInstance</span></span>(FuncInstanceInternal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">enum</span> <span class="title">FuncInstanceInternal</span></span> &#123;</span><br><span class="line">    Internal &#123;</span><br><span class="line">        signature: Arc&lt;Signature&gt;,</span><br><span class="line">        module: Weak&lt;ModuleInstance&gt;,</span><br><span class="line">        body: Arc&lt;FuncBody&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Host &#123;</span><br><span class="line">        signature: Signature,</span><br><span class="line">        host_func_index: <span class="built_in">usize</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FuncInstance::invoke()调用函数时，首先判断传入参数是否符合函数籤名，然后匹配函数的定义方式FuncInstanceInternal</p><ul><li><p>Internal：初始化一个Interpreter，然后调用 <code>interpreter.start_execution(externals)</code> 执行函数（更底层的内容可能会写在下一章）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Interpreter</span></span> &#123;</span><br><span class="line">    value_stack: ValueStack,</span><br><span class="line">    call_stack: CallStack,</span><br><span class="line">    return_type: <span class="built_in">Option</span>&lt;ValueType&gt;,</span><br><span class="line">    state: InterpreterState,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Host：调用 <code>externals.invoke_index(*host_func_index, args.into())</code> ，externals即爲invoke_export()方法传入的第三参数：导入函数的外部环境。这里的externals就是SpecModule，它实现的Externals trait如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Externals <span class="keyword">for</span> SpecModule &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">invoke_index</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        index: <span class="built_in">usize</span>,</span><br><span class="line">        args: RuntimeArgs,</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;RuntimeValue&gt;, Trap&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> index &#123;</span><br><span class="line">            PRINT_FUNC_INDEX =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;print: &#123;:?&#125;&quot;</span>, args);</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">None</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;SpecModule doesn&#x27;t provide function at index &#123;&#125;&quot;</span>, index),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="SgxWasmAction-Get">SgxWasmAction::Get</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">wasm_get</span></span>(module : <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;, field : <span class="built_in">String</span>)</span><br><span class="line">            -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;RuntimeValue&gt;, InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>首先获取全局的SPECDRIVER存入变量program，根据module的值在SpecDriver.instances中查找对应名字的模块，如果module的值爲None，则通过SpecDriver.last_module返回最后注册的模块，得到一个ModuleRef结构module</p><p>然后通过 <code>module.export_by_name(&amp;field)</code> 获得一个wasm的运行时的实体引用ExternVal，可能的值包括：函数、Table、Memory、全局变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExternVal</span></span> &#123;</span><br><span class="line">    Func(FuncRef),</span><br><span class="line">    Table(TableRef),</span><br><span class="line">    Memory(MemoryRef),</span><br><span class="line">    Global(GlobalRef),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着匹配module的该导出实体是否爲Global，若不是，返回None</p><h4 id="SgxWasmAction-LoadModule">SgxWasmAction::LoadModule</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载一个模块到SpecDriver中</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">wasm_load_module</span></span>(name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;, module: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;)</span><br><span class="line">                    -&gt; <span class="built_in">Result</span>&lt;(), InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>首先获取全局的SPECDRIVER存入变量spec_driver，然后通过 <code>try_load_module(&amp;module[..])</code> 获得一个parity_wasm库的Module类型的module，接着通过 <code>ModuleInstance::new(&amp;module, &amp;**spec_driver)</code> 的方式新建一个NotStartedModuleRef实例，并使用 <code>run_start(spec_driver.spec_module())</code> 方法将其转变爲ModuleRef类型</p><p>最后将该实例通过 <code>spec_driver.add_module(name, instance.clone())</code> 存放入spec_driver中，将SpecDriver.last_module改爲该模块，并在SpecDriver.instances中插入该模块与其名字的键值对</p><h4 id="SgxWasmAction-TryLoad">SgxWasmAction::TryLoad</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加载一个模块，不加载到SpecDriver中</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">wasm_try_load</span></span>(wasm: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;) -&gt; <span class="built_in">Result</span>&lt;(), InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>首先获取全局的SPECDRIVER存入变量spec_driver，然后通过 <code>try_load_module(&amp;module[..])</code> 获得一个parity_wasm库的Module类型的module，接着通过 <code>ModuleInstance::new(&amp;module, &amp;ImportsBuilder::default())</code> 的方式新建一个NotStartedModuleRef实例instance，尝试对其使用 <code>run_start(spec_driver.spec_module())</code>方法，若成功，返回Ok(())，若失败，返回错误</p><h4 id="SgxWasmAction-Register">SgxWasmAction::Register</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用as_name注册一个新模块</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">wasm_register</span></span>(name: &amp;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;, as_name: <span class="built_in">String</span>)</span><br><span class="line">                    -&gt; <span class="built_in">Result</span>&lt;(), InterpreterError&gt;</span><br></pre></td></tr></table></figure><p>首先获取全局的SPECDRIVER存入变量spec_driver，根据module的值在SpecDriver.instances中查找对应名字name的模块，如果name的值爲None，则通过SpecDriver.last_module返回最后注册的模块</p><p>最后将该模块通过 <code>spec_driver.add_module(name, instance.clone())</code> 存放入spec_driver中，将SpecDriver.last_module改爲该模块，并在SpecDriver.instances中插入该模块与其名字的键值对</p><h3 id="函数执行Interpreter底层">函数执行Interpreter底层</h3>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
          <category> SGX </category>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust更换项目编译的Channel</title>
      <link href="2021/03/03/instruction/rustup-channel/"/>
      <url>2021/03/03/instruction/rustup-channel/</url>
      
        <content type="html"><![CDATA[<p>查看可用的Channel：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain list</span><br></pre></td></tr></table></figure><p>在项目根目录输入命令修改本项目的编译环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup override <span class="built_in">set</span> nightly</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - Learn</title>
      <link href="2020/12/23/learning-notes/git-notes/"/>
      <url>2020/12/23/learning-notes/git-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制">版本控制</h2><h3 id="1-本地版本控制">1. 本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/1-1602592677643.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/1-1602592677643.webp" srcset="data:image/png;base64,666" alt="img"></p><h3 id="2-集中版本控制">2. 集中版本控制</h3><p>所有的版本数据都存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203819662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203819662.png" srcset="data:image/png;base64,666" alt="image-20201013203819662"></p><h3 id="3-分布式版本控制">3. 分布式版本控制</h3><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203824414.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203824414.png" srcset="data:image/png;base64,666" alt="image-20201013203824414"></p><h3 id="Git与SVN的主要区别">Git与SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h2 id="Git环境配置">Git环境配置</h2><h3 id="Git配置">Git配置</h3><p><strong>查看配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p><strong>查看不同级别的配置文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> Git\etc\gitconfig：Git安装目录下的gitconfig  </span></span><br><span class="line">　　</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> C:\Users\Administrator\.gitconfig    只适用于当前登录用户的配置 </span></span><br></pre></td></tr></table></figure><p><strong>设置用户名与邮箱（用户标识，必要）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;&lt;名称&gt;&quot;  # 名称</span><br><span class="line">git config --global user.email &lt;邮箱&gt;   # 邮箱</span><br></pre></td></tr></table></figure><h2 id="Git基本理论">Git基本理论</h2><h3 id="三个区域">三个区域</h3><p>Git本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/4.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/4.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/5.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/5.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h3 id="工作流程">工作流程</h3><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/6.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/6.png" srcset="data:image/png;base64,666" alt="img"></p><h2 id="Git项目搭建">Git项目搭建</h2><h3 id="创建工作目录与常用指令">创建工作目录与常用指令</h3><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/7.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/7.png" srcset="data:image/png;base64,666" alt="img"></p><h3 id="本地仓库搭建">本地仓库搭建</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p><strong>创建权限仓库</strong></p><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><p><strong>克隆远程仓库</strong></p><p>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Git文件操作">Git文件操作</h2><h3 id="文件的四种状态">文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h3 id="查看文件状态">查看文件状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看指定文件状态</span></span><br><span class="line">git status &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .                  添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br></pre></td></tr></table></figure><h3 id="忽略文件">忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     # 但lib.txt除外</span><br><span class="line">/temp        # 仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       # 忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h2 id="Git分支">Git分支</h2><p>git分支中常用指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="Git子模块">Git子模块</h2><p>git子模块中常用指令：参考https://blog.csdn.net/guotianqing/article/details/82391665</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 遇到报错git submodule: already exists <span class="keyword">in</span> the index</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (path为子模块在本地项目中存储的目录)</span></span><br><span class="line">git rm -r --cached &lt;path&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-SGX环境配置</title>
      <link href="2020/12/10/instruction/sgx-rust-install/"/>
      <url>2020/12/10/instruction/sgx-rust-install/</url>
      
        <content type="html"><![CDATA[<h3 id="安装Intel-SGX">安装Intel SGX</h3><ul><li><p>SGX Driver：根据<a href="https://github.com/intel/linux-sgx-driver">官方github</a>安装</p></li><li><p>SGX PSW：根据<a href="https://github.com/intel/linux-sgx">官方github</a>添加local repo，再直接使用apt安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsgx-launch libsgx-urts libsgx-epid libsgx-quote-ex libsgx-dcap-ql libsgx-uae-service</span><br></pre></td></tr></table></figure></li><li><p>SGX SDK：下载<a href="https://download.01.org/intel-sgx/latest/linux-latest/distro/ubuntu20.04-server/">bin文件</a>，根据<a href="https://download.01.org/intel-sgx/latest/linux-latest/docs/">安装手册</a>安装；应该也可以根据<a href="https://github.com/intel/linux-sgx">官方github</a>安装</p></li></ul><h3 id="下载Rust-SGX-SDK">下载Rust-SGX-SDK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.1.4 https://github.com/apache/incubator-teaclave-sgx-sdk.git</span><br></pre></td></tr></table></figure><h3 id="添加环境变量">添加环境变量</h3><p>在~/.bashrc文件最后添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SGX_SDK_RUST=<span class="variable">$HOME</span>/sgx/incubator-teaclave-sgx-sdk</span><br><span class="line"><span class="built_in">source</span> /opt/intel/sgxsdk/environment</span><br></pre></td></tr></table></figure><p>再在终端执行 <code>source ~/.bashrc</code></p><h3 id="解决：Enclave代码运行出错（Invalid-SGX-Driver）">解决：Enclave代码运行出错（Invalid SGX Driver）</h3><p>不清楚什么原因，反正重装一遍SGX Driver就好了</p><p>卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo /sbin/modprobe -r isgx</span><br><span class="line">sudo rm -rf <span class="string">&quot;/lib/modules/&quot;</span>`uname -r`<span class="string">&quot;/kernel/drivers/intel/sgx&quot;</span></span><br><span class="line">sudo /sbin/depmod</span><br><span class="line">sudo /bin/sed -i <span class="string">&#x27;/^isgx$/d&#x27;</span> /etc/modules</span><br></pre></td></tr></table></figure><p>重装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/intel/linux-sgx-driver</span><br><span class="line">sudo make clean</span><br><span class="line">sudo make</span><br><span class="line">sudo mkdir -p <span class="string">&quot;/lib/modules/&quot;</span>`uname -r`<span class="string">&quot;/kernel/drivers/intel/sgx&quot;</span>    </span><br><span class="line">sudo cp isgx.ko <span class="string">&quot;/lib/modules/&quot;</span>`uname -r`<span class="string">&quot;/kernel/drivers/intel/sgx&quot;</span>    </span><br><span class="line">sudo sh -c <span class="string">&quot;cat /etc/modules | grep -Fxq isgx || echo isgx &gt;&gt; /etc/modules&quot;</span>    </span><br><span class="line">sudo /sbin/depmod</span><br><span class="line">sudo /sbin/modprobe isgx</span><br></pre></td></tr></table></figure><h3 id="解决：-app-error-while-loading-shared-libraries-libsgx-uae-service-so-cannot-open-shared-object-file-No-such-file-or-directory">解决：./app: error while loading shared libraries: libsgx_uae_service.so: cannot open shared object file: No such file or directory</h3><p>错误方案：当使用find命令查询文件之后发现在 <code>/opt/intel/sgxsdk/lib64</code> 中包含 <code>libsgx_uae_service.so</code> ，从而添加该路径到LD_LIBRARY_PATH。这样会导致新的error “Please use the correct uRTS library from PSW package.”，因为sgxsdk下的lib是用作开发环境的，而在 <code>/lib/x86_64-linux-gnu</code> 下的lib是用于生产环境的，相互不兼容</p><p>**正确方案：**出现该问题的原因是psw安装不齐全，即libsgx-uae-service未安装，只要使用命令 <code>sudo apt-get install libsgx-uae-service</code> 就能成功将对应的库安装到 <code>/lib/x86_64-linux-gnu</code> 下</p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> SGX </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> sgx </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu设置终端只显示当前所在目录</title>
      <link href="2020/12/09/instruction/ubuntu-terminal-path/"/>
      <url>2020/12/09/instruction/ubuntu-terminal-path/</url>
      
        <content type="html"><![CDATA[<p>修改~/.bashrc文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$color_prompt</span>&quot;</span> = yes ]; <span class="keyword">then</span></span><br><span class="line">    PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span></span><br></pre></td></tr></table></figure><p>将上面语句中的 <code>w</code> 改为大写的 <code>W</code></p><p>若要查看绝对路径，使用命令 <code>pwd</code> 即可</p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Blocking waiting for file lock on package cache</title>
      <link href="2020/12/03/instruction/rust-cargo-block/"/>
      <url>2020/12/03/instruction/rust-cargo-block/</url>
      
        <content type="html"><![CDATA[<p>删除 <code>home/.cargo/.package-cache</code> 文件再重新编译即可</p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode快捷键</title>
      <link href="2020/12/03/lookup/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/12/03/lookup/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Ctrl+J</code> : 隐藏(显示)底下的控制台/终端面板</p><p><code>Ctrl+Shift+P</code> : 调出搜索设置</p><p><code>Ctrl+Shift+C</code> : 在当前目录调出外部终端</p><p><code>Home</code> ：光标移动到行首</p><p><code>End</code> ：光标移动到行尾</p>]]></content>
      
      
      <categories>
          
          <category> Lookup </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>翻译-SGX Analysis</title>
      <link href="2020/11/29/paper-reading/translation-sgx-analysis/"/>
      <url>2020/11/29/paper-reading/translation-sgx-analysis/</url>
      
        <content type="html"><![CDATA[<p><strong>放在博客上链接不能跳转指定标题，暂时没有办法解决</strong></p><h2 id="6-1-SGX实现概述">6.1 SGX实现概述</h2><p>SGX设计实现的一个未被记录和忽视的成就是，在英特尔处理器上实现它对芯片的硬件设计有非常低的影响。SGX对处理器执行核心(§2.9.4)的修改要么非常小，要么根本不存在。CPU的非核心(§2.9.3，§2.11.3)接收一个新的模块，内存加密引擎，它看起来是相当独立的。</p><p>SGX的大部分实现都归属于处理器的微码(§2.14)，它支持比芯片电路高得多的开发速度。</p><!--### 6.1.1 执行内核修改### 6.1.2 非内核修改### 6.1.3 微代码修改## 6.2 SGX内存访问保护![image-20201128212608690](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212608690.png)### 6.2.1 功能描述<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212642564.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212642564.png" srcset="data:image/png;base64,666" alt="image-20201128212642564" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212658357.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212658357.png" srcset="data:image/png;base64,666" alt="image-20201128212658357" style="zoom:80%;" />![image-20201128212723441](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212723441.png)### 6.2.2 EPCM条目表示### 6.2.3 PMH硬件修改## 6.3 SGX安全检查正确性### 6.3.1 顶层不变的分解### 6.3.2 EPCM条目反映Enclave作者设计### 6.3.3 ELRANGE的TLB条目反映EPCM内容### 6.3.4 修改时EPCM条目不在TLB中## 6.4 Tracking TLB Flushes<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214234965.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214234965.png" srcset="data:image/png;base64,666" alt="image-20201128214234965" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214258057.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214258057.png" srcset="data:image/png;base64,666" alt="image-20201128214258057" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214400485.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214400485.png" srcset="data:image/png;base64,666" alt="image-20201128214400485" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214422480.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214422480.png" srcset="data:image/png;base64,666" alt="image-20201128214422480" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214447889.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214447889.png" srcset="data:image/png;base64,666" alt="image-20201128214447889" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214516682.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214516682.png" srcset="data:image/png;base64,666" alt="image-20201128214516682" style="zoom:80%;" />## 6.5 Enclave签名验证<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214627879.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214627879.png" srcset="data:image/png;base64,666" alt="image-20201128214627879" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214645117.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214645117.png" srcset="data:image/png;base64,666" alt="image-20201128214645117" style="zoom:80%;" />### 6.5.1 步骤1-4的分析<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214710848.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214710848.png" srcset="data:image/png;base64,666" alt="image-20201128214710848" style="zoom:67%;" />### 6.5.2 步骤5-8的分析<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214912326.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214912326.png" srcset="data:image/png;base64,666" alt="image-20201128214912326" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214943124.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214943124.png" srcset="data:image/png;base64,666" alt="image-20201128214943124" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128215016094.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128215016094.png" srcset="data:image/png;base64,666" alt="image-20201128215016094" style="zoom:80%;" />### 6.5.3 实现需求## 6.6 SGX安全属性### 6.6.1 概述### 6.6.2 物理攻击### 6.6.3 特权软件攻击### 6.6.4 内存映射攻击### 6.6.5 对外设的软件攻击### 6.6.6 缓存时间攻击![image-20201128215556589](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128215556589.png)### 6.6.7 软件侧信道攻击和SGX-->]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-SGX Programming Model</title>
      <link href="2020/11/28/paper-reading/translation-sgx-programming-model/"/>
      <url>2020/11/28/paper-reading/translation-sgx-programming-model/</url>
      
        <content type="html"><![CDATA[<p><strong>放在博客上链接不能跳转指定标题，暂时没有办法解决</strong></p><p>SGX的核心概念是enclave，一个受保护的环境，其中包含与安全敏感计算相关的代码和数据。</p><p>启用sgx的处理器通过将每个enclave的环境与enclave外部的不受信任的软件隔离，并实现允许远程方对运行在enclave内部的软件进行身份验证的软件认证方案，从而提供可信的计算。SGX的隔离机制旨在保护在enclave内执行的计算的机密性和完整性，防止来自同一台计算机上的恶意软件的攻击，以及一小部分物理攻击。</p><h2 id="5-1-SGX物理内存组织">5.1 SGX物理内存组织</h2><p>Enclave的代码和数据存储在 <em>Processor Reserved Memory</em> (PRM)中，PRM是DRAM的一个子集，不能被其他软件(包括系统软件和SMM代码)直接访问。CPU的集成内存控制器也拒绝针对PRM的DMA传输，从而保护它不被其他外设访问。</p><p><strong>PRM是一个连续的内存范围</strong>，其边界使用一个基地址和一个掩码寄存器来决定，与可变内存类型范围具有相同的语义。因此，PRM的大小必须是2的整数次幂，并且它的起始地址必须对齐到同样的2次幂。由于这些限制，检查一个地址是否属于PRM可以在硬件上很容易地完成。</p><h3 id="5-1-1-Enclave页面缓存-EPC">5.1.1 Enclave页面缓存 (EPC)</h3><p>Enclave的内容和相关的数据结构存储在Enclave页面缓存(EPC)中，EPC是PRM的一个子集，PRM是DRAM的一个连续范围，<strong>不能被系统软件或外设访问</strong>。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127221918953.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127221918953.png" srcset="data:image/png;base64,666" alt="image-20201127221918953"></p><p>SGX设计支持同时在一个系统上有多个enclaves，这在多进程环境中是必需的。这是通过将EPC拆分为4 KB的页面来实现的，这些页面可以分配给不同的enclaves。EPC使用与体系结构的地址转换特性相同的页面大小。</p><p>EPC由管理计算机其余物理内存的系统软件管理。系统软件(可以是管理程序或操作系统内核)使用SGX指令将未使用的页面分配给enclaves，并释放之前分配的EPC页面。系统软件将向应用程序软件公开enclave创建和管理服务。</p><p>非enclave软件不能直接访问EPC，因为它包含在PRM中。这一限制在SGX的enclave隔离保证中发挥了关键作用，但当系统软件需要将初始代码和数据加载到新创建的enclave中时，就会造成障碍。SGX通过<strong>将分配EPC页面的指令同时也用作初始化页面的指令</strong>来解决这个问题。大多数EPC页是通过从非PRM内存页复制数据来初始化的。</p><h3 id="5-1-2-Enclave页面缓存映射表-EPCM">5.1.2 Enclave页面缓存映射表 (EPCM)</h3><p>SGX设计期望系统软件将EPC页面分配给enclave。然而，由于系统软件不受信任，SGX处理器会检查系统软件分配的正确性，并拒绝执行任何危及SGX安全保证的行为。例如，如果系统软件试图将相同的EPC页面分配给两个enclaves，则执行分配的SGX指令将失败。</p><p>为了执行安全检查，SGX在 <em>Enclave Page Cache Map</em> (EPCM)中记录一些关于系统软件对每个EPC页面的分配决策的信息。EPCM是一个数组，每个EPC页面对应一个条目，因此计算页面的EPCM入口地址只需要逐位移位操作和加操作。</p><p>EPCM的内容仅用于SGX的安全检查。在正常操作下，EPCM不会产生任何软件可见的行为，因而enclave作者和系统软件开发人员基本上可以忽略它。因此，SDM (<em>Intel’s Software Developer Manual</em>) 只在非常高的级别上描述EPCM，列出其中包含的信息，并指出EPCM是“受信任的内存”，而没有公开EPCM使用的存储介质或内存布局。</p><p>EPCM使用下表中的字段来跟踪每个EPC页面的所有权。我们将EPCM的完整讨论推迟到后面的部分，因为它的内容与SGX的所有特征紧密结合，这将在接下来的几节中进行描述。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127223653632.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127223653632.png" srcset="data:image/png;base64,666" alt="image-20201127223653632" style="zoom:80%;" /><p>分配EPC页的SGX指令将相应EPCM条目的VALID位设置为1，并<strong>拒绝对已经设置了VALID位的EPC页进行操作</strong>。</p><p>分配EPC页的指令还决定了该页的预期用途，该用途记录在相应EPCM条目的 <em>page type</em> (PT)字段中。存储enclave代码和数据的页面被认为具有常规类型 <code>PT_REG</code> 。专用于存储SGX支持数据结构的页面被标记为特殊类型。例如，<code>PT_SECS</code> 类型标识保存SGX Enclave控制结构的页面，这将在下一节中进行描述。其他EPC页面类型将在以后的章节中描述。</p><p>最后，页面的EPCM条目还标识拥有EPC页面的enclave，此字段防止一个enclave访问另一个enclave的私有信息。由于EPCM为每个EPC页面标识一个具有所有权的enclave，因此enclave不可能使用EPC页面通过共享内存进行通信。幸运的是，enclaves可以共享不可信的非EPC内存，这将在<a href="#5.2.3-SGX-Enclaves%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">§5.2.3</a>中讨论。</p><h3 id="5-1-3-SGX-Enclave控制结构-SECS">5.1.3 SGX Enclave控制结构 (SECS)</h3><p>SGX将每个Enclave元数据存储在与每个Enclave关联的 <em>SGX Enclave Control Structure</em> (SECS)中。<strong>每个SECS存储在专用的EPC页面中，页面类型为 <code>PT_SECS</code></strong>。</p><p>Enclave的身份几乎等同于它的SECS。启用enclave的第一步是分配EPC页面作为enclave的SECS，销毁enclave的最后一步是释放保存其SECS的页面。标识拥有EPC页面的enclave的EPCM入口字段指向enclave的SECS。当调用SGX指令时，系统软件使用SECS的虚拟地址来识别enclave。</p><p>所有SGX指令都以虚拟地址作为输入。由于SGX指令使用SECS地址来标识enclave，系统软件必须在其页表中创建指向其管理的enclave的SECS的条目。但是，系统软件不能访问任何SECS页面，因为这些页面存储在PRM中。<strong>SECS页面不会映射到它们的enclave的虚拟地址空间中，并且启用SGX的处理器显式地阻止enclave代码访问SECS页面</strong>。</p><p>这个看似随意的限制是为了使SGX实现能够在SECS内存储敏感信息，并且能够假定没有潜在的恶意软件能够访问该信息。例如，SDM声明<strong>每个enclave的度量都存储在SECS中</strong>。如果软件能够修改enclave的测量，SGX的软件认证方案将不能提供安全保证。</p><h2 id="5-2-SGX-Enclave的内存布局">5.2 SGX Enclave的内存布局</h2><p>SGX的设计目的是尽量减少[转换应用程序代码以利用enclave的优势]所需要的工作。历史表明，这是一个明智的决定，因为在英特尔架构的持续主导地位中，一个很大的因素是它保持向后兼容性的能力。为此，SGX  enclave在概念上与领先的软件模块化结构，动态加载库类似。动态加载库在Unix上打包为.so文件，在Windows上打包为.dll文件。</p><p>为简单起见，我们描述enclave和非enclave软件之间的交互时假设每个enclave都由一个应用程序进程使用，我们将其称为enclave的主进程。但是，我们注意到SGX的设计并没有明确地禁止多个应用程序进程共享一个enclave。</p><h3 id="5-2-1-Enclave线性地址范围-ELRANGE">5.2.1 Enclave线性地址范围 (ELRANGE)</h3><p>每个enclave在其虚拟地址空间中指定一个区域，称为 <em>Enclave Linear Address Range</em> (ELRANGE)，该区域用于映射存储在enclave的EPC页面中的代码和敏感数据。ELRANGE之外的虚拟地址空间用于访问主进程的其他内存，内存映射使用系统软件管理的页表建立。如下图所示:</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128133153701.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128133153701.png" srcset="data:image/png;base64,666" alt="image-20201128133153701" style="zoom:100%;" /><p>SGX的设计保证了enclave在ELRANGE内部的内存访问服从虚拟内存抽象，而在ELRANGE外部的内存访问没有得到保证。因此，<strong>enclave必须将其所有代码和私有数据存储在ELRANGE内，并且必须将ELRANGE外的内存视为对外部世界的不可信接口</strong>。</p><p>ELRANGE中的“线性”一词指的是64位Intel架构中残余分割特性产生的线性地址。在大多数情况下，“linear”可以看作是“virtual”的同义词。</p><p>ELRANGE在enclave的SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)中使用一个基地址(BASEADDR字段)和一个大小(SIZE)来指定。ELRANGE必须满足与可变内存类型范围和PRM范围(<a href="#5.1-SGX%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87">§5.1</a>)相同的约束条件，即<strong>大小必须是2的幂，并且基地址必须与大小对齐</strong>。有了这些限制，SGX实现就可以容易地检查一个地址是否属于enclave的ELRANGE，无论是在硬件上还是在软件上。</p><p>非enclave软件不能访问PRM内存。<strong>在PRM内部的内存访问将导致一个中断</strong>，该中断在体系结构级别上未定义，在当前处理器上，中断的写将被忽略，中断的读将返回一个所有bit都设置为1的值。在上面描述的场景中，这就发挥了作用，在该场景中，enclave作为动态加载的库加载到主应用程序进程中。该系统软件将ELRANGE中的enclave代码和数据映射到EPC页面。如果应用程序软件试图访问ELRANGE内的内存，它将经历中断原语。当前原语不会导致应用程序崩溃(例如，由于页面错误)，但也保证了主应用程序不能篡改enclave或读取其私有信息。</p><h3 id="5-2-2-SGX-Enclave属性">5.2.2 SGX Enclave属性</h3><p>Enclave的执行环境很大程度上受到enclave  SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)中ATTRIBUTES字段的值的影响。此工作的其余部分会将ATTRIBUTES字段的子字段(如下表所示)称为enclave属性。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128135622106.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128135622106.png" srcset="data:image/png;base64,666" alt="image-20201128135622106" style="zoom:80%;" /><p>从安全性的角度来看，最重要的属性是 DEBUG 标志。设置此标志后，将启用SGX的调试特性用于此enclave。这些调试特性包括<strong>读取和修改大部分enclave内存的能力</strong>。因此，调试应该只在开发环境中设置，因为这会导致enclave失去SGX的所有安全性保证。</p><p>SGX保证enclave代码将始终在XCR0寄存器设置为 <em>extended features request mask</em> (XFRM) 所指示的值的情况下运行。Enclave作者希望使用XFRM指定用于生成Enclave代码的编译器所支持的一组架构扩展。<strong>显式地指定XFRM允许Intel设计新的架构扩展来改变现有指令的语义</strong>，比如内存保护扩展(MPX)，而不必担心在开发时没有注意到新特性的enclave代码的安全影响。</p><p><strong>对于使用64位Intel架构的enclave,  MODE64BIT标志设置为true</strong>。从安全的角度来看，这个标志甚至不应该存在，因为支持次要架构会给SGX实现增加不必要的复杂性，并增加安全漏洞潜入的可能性。32位架构支持很可能是由于英特尔提供广泛向后兼容性的策略，到目前为止，这一策略取得了相当好的效果。清除MODE64BIT标志位可能会造成SGX漏洞，有待研究人员研究。</p><p>最后，<strong>在创建enclave的SECS时，INIT标志总是为false</strong>。这个标志在enclave生命周期的某个时刻被设置为true，这将在<a href="#5.3-SGX-Enclave%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§5.3</a>中进行总结。</p><h3 id="5-2-3-SGX-Enclaves地址转换">5.2.3 SGX Enclaves地址转换</h3><p>在SGX下，操作系统和管理程序仍然完全控制页表和EPT，每个enclave的代码使用和其主应用程序相同的地址转换过程和页表。这将使向现有系统软件添加SGX支持所需的更改量最小化。同时，让不受信任的系统软件管理页表会使SGX遭受§3.7所述的地址转换攻击。正如未来章节将揭示的，SGX设计的复杂性很大程度上可以归因于防止这些攻击的需要。</p><p>SGX的主动内存映射攻击防御机制围绕着确保每个EPC页面只能映射到一个特定的虚拟地址。<strong>在分配EPC页面时，它的预期虚拟地址记录在该页面的EPCM条目的ADDRESS字段中</strong>。</p><p>当地址转换的结果是EPC页面的物理地址时，CPU保证提供给地址转换过程的虚拟地址与页面EPCM条目中记录的预期虚拟地址相匹配。</p><p>通过确保每个EPC页面的访问权限始终与enclave作者的意图相匹配，SGX还可以防止一些被动内存映射攻击和故障注入攻击。<strong>每个EPC页面的访问权限是在分配页面时指定的，并记录在页面EPCM条目中的可读®、可写(W)和可执行(X)字段中</strong>，如下表所示:</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128143209413.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128143209413.png" srcset="data:image/png;base64,666" alt="image-20201128143209413" style="zoom:80%;" /><p>当一个地址转换解析为一个EPC页面时，相应的EPCM条目的字段将覆盖页表中指定的访问权限属性。例如，EPCM条目中的W字段覆盖可写(W)属性，而X字段覆盖禁用执行(XD)属性。</p><p>因此，<strong>enclave作者必须在包含enclave的同时包含内存布局信息，这样，加载enclave的系统软件将知道每个enclave页面的预期虚拟内存地址和访问权限</strong>。作为回报，SGX设计向enclave作者保证，管理页表和EPT的系统软件将不能以与作者预期不一致的方式设置enclave的虚拟地址空间。</p><p>.so和.dll文件格式是SGX打算使用的enclave运载工具，它们已经规定了指定软件模块要使用的虚拟地址，以及模块的每个内存区域所需的访问权限。</p><p>最后，<strong>启用SGX的CPU将确保ELRANGE内的虚拟内存(<a href="#5.2.1-Enclave%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4-(ELRANGE)">§5.2.1</a>)映射到EPC页面</strong>。这可以防止系统软件执行地址转换攻击，即将enclave的整个虚拟地址空间映射到PRM之外的DRAM页面，而PRM不会触发上述任何检查，系统软件可以直接访问这些页面。</p><h3 id="5-2-4-线程控制结构-TCS">5.2.4 线程控制结构 (TCS)</h3><p>SGX设计完全采用多核处理器。<strong>多个逻辑处理器可以通过不同的线程同时并发地执行同一个enclave的代码</strong>。</p><p>SGX实现为执行enclave代码的每个逻辑处理器使用一个 <em>Thread Control Structure</em> (TCS)。因此，enclave的作者必须至少提供与enclave支持的最大并发线程数相同的TCS实例。</p><p><strong>每个TCS存储在专用的EPC页面中，其EPCM条目类型为 <code>PT_TCS</code></strong>。SDM描述了TCS中的前几个字段。这些字段被认为属于结构的体系结构部分，因此保证在所有支持SGX的处理器上具有相同的语义。</p><p><strong>保存TCS的EPC页面的内容不能直接访问，甚至不能由拥有TCS的enclave的代码访问</strong>。此限制类似于对访问持有SECS实例的EPC页面的限制。但是，<strong>TCS中的体系结构字段可以通过enclave调试指令读取</strong>。TCS中的体系结构字段列出了逻辑处理器在执行非enclave代码和enclave代码之间转换时执行的上下文切换。例如，OENTRY字段指定当TCS用于开始执行enclave代码时加载在 指令指针(RIP) 中的值，因此enclave作者可以严格控制enclave的主程序可用的入口点。此外，OFSBASGX和OFSBASGX字段指定了加载在FS和GS段寄存器中的基地址，这通常指向 线程本地存储(TLS)。</p><h3 id="5-2-5-状态保存区域-SSA">5.2.5 状态保存区域 (SSA)</h3><p>当处理器在enclave中执行代码时遇到硬件异常，比如中断时，它会执行特权级别切换并调用系统软件提供的硬件异常处理程序。然而，在执行异常处理程序之前，处理器需要一个安全的区域来存储enclave代码的执行上下文，这样执行上下文中的信息就不会泄露给不受信任的系统软件。</p><p>在SGX设计中，<strong>在处理硬件异常时用于存储enclave线程的执行上下文的区域</strong>称为 <em>State Save Area</em> (SSA)，如下图所示（enclave虚拟地址空间的一种可能的布局。每个enclave有一个SECS，每个支持的并发线程有一个TCS。每个TCS指向一个SSA序列，并为RIP以及FS和GS的基址指定初始值）。<strong>每个TCS引用一个连续的SSA序列</strong>。SSA数组偏移量(OSSA)字段指定了第一个SSA在enclave的虚拟地址空间中的位置。SSA数量(NSSA)字段表示可用的SSAs的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128145659924.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128145659924.png" srcset="data:image/png;base64,666" alt="image-20201128145659924"></p><p>每个SSA从EPC页面的开头开始，并<strong>使用在enclave的SECS的SSAFRAMESIZE字段中指定的EPC页面数量</strong>。通过减少需要处理的特殊情况的数量，这些对齐和大小限制很可能简化了SGX的实现。</p><p>Enclave线程的执行上下文由通用寄存器(GPRs)和XSAVE指令的结果组成。因此，执行上下文的大小取决于XSAVE使用的 请求特性位图(RFBM)。enclave中的所有代码都使用相同的RFBM，它是在XFRM  enclave属性(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)中声明的。为每个SSA保留的EPC页面数量(在SSAFRAMESIZE中指定)必须足够大，以适合XSAVE输出的XFRM指定的特性位图。</p><p><strong>SSA存储在常规EPC页面中，其EPCM页面类型为 <code>PT_REG</code></strong>。因此，<strong>enclave软件可以访问SSA内容</strong>。SSA布局是体系结构的，并且完全记录在SDM中。这为主机应用程序在发生硬件异常后调用enclave异常处理程序并对SSA中的信息进行操作提供了可能性。</p><h2 id="5-3-SGX-Enclave的生命周期">5.3 SGX Enclave的生命周期</h2><p>Enclave的生命周期与资源管理密切相关，特别是EPC页面的分配。因此，在不同生命周期状态之间转换的指令只能由系统软件执行。系统软件将公开以下描述的SGX指令，作为enclave加载和销毁的服务。</p><p>下面的小节描述了enclave生命周期中的主要步骤，如下图所示:</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128152622170.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128152622170.png" srcset="data:image/png;base64,666" alt="image-20201128152622170"  /><h3 id="5-3-1-创建">5.3.1 创建</h3><p>当系统软件发出 <code>ECREATE</code> 指令时，一个enclave就诞生了，该指令<strong>将一个空闲的EPC页面转换为用于新enclave的SECS</strong>(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)。</p><p><strong><code>ECREATE</code> 使用系统软件拥有的非EPC页面中的信息初始化新创建的SECS</strong>。这个页面指定SDM中定义的所有SECS字段的值，比如BASEADDR和SIZE，使用的是一种体系结构布局，未来的实现保证会保留这种布局。</p><p>虽然最初的SGX实现使用的实际SECS布局很可能与架构布局非常接近，但是未来的实现可以自由地改变这个布局，只要它们保持使用架构布局初始化SECS的能力。软件不能访问包含SECS的EPC页面，因此它不能依赖于SECS的内部布局。这是在虚拟机控制结构(VMCS，§2.8.3)中使用的更强的封装版本。</p><p><strong><code>ECREATE</code> 验证用于初始化SECS的信息，如果信息无效，则会导致页面错误(#PF，§2.8.2)或一般保护错误(#GP，§2.8.2)</strong>。例如，如果SIZE字段不是2的幂，<code>ECREATE</code>结果是#GP。这种验证，加上软件无法访问SECS这一事实，简化了其他SGX指令的实现，这可以假设SECS内部的信息是有效的。</p><p>最后，<strong><code>ECREATE</code>将enclave的INIT属性(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)初始化为false值。在INIT属性被设置为true之前，enclave的代码不能执行</strong>，在初始化阶段会将INIT设置为true，这将在<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>中描述。</p><h3 id="5-3-2-加载">5.3.2 加载</h3><p><code>ECREATE</code> 将新创建的SECS标记为未初始化。当enclave的SECS处于这种状态时，<strong>系统软件可以使用<code>EADD</code>指令将初始代码和数据加载到enclave中。EADD用于创建TCS页面(<a href="#5.2.4-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(TCS)">§5.2.4</a>)和常规页面。</strong></p><p><strong><code>EADD</code> 从<em>页面信息</em>(PAGEINFO)结构中读取其输入数据</strong>，如下图所示。该结构的内容仅用于与SGX实现通信，因此它完全是体系结构的，并在SDM中记录。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128164130332.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128164130332.png" srcset="data:image/png;base64,666" alt="image-20201128164130332"></p><p>目前，PAGEINFO结构包含的将要分配的EPC页面的虚拟地址(LINADDR)、非EPC页面的虚拟地址（其内容将被复制到新分配的EPC页面(SRCPGE)）、一个虚拟地址，解析为SECS的enclave的页面(SECS)以及与新分配的EPC页面相关联的EPCM条目的某些字段的值(SECINFO)。</p><p>PAGEINFO结构中的SECINFO字段实际上是一个虚拟内存地址，并指向一个<em>安全信息</em>(SECINFO)结构，其中一些结构如上图所示。<strong>SECINFO结构包含新分配的EPC页面的访问权限(R、W、X)及其EPCM页面类型(<code>PT_REG</code>或<code>PT_TCS</code>)</strong>。与PAGEINFO一样，SECINFO结构仅用于与SGX实现通信数据，因此它的内容也完全是体系结构的。但是，该结构的大部分64字节内容被保留以备将来使用。</p><p>PAGEINFO和SECINFO结构都是由调用<code>EADD</code>指令的系统软件准备的，因此必须<strong>包含在非EPC页面中</strong>。两个结构必须按照其大小对齐——<strong>PAGEINFO是32字节长，因此每个PAGEINFO实例必须是32字节对齐的，而SECINFO是64字节对齐的，因此每个SECINFO实例必须是64字节对齐的</strong>。对齐要求可能通过减少必须处理的特殊情况的数量来简化SGX实现。</p><p><strong><code>EADD</code>在修改新分配的EPC页面或其EPCM条目之前验证其输入</strong>。最重要的是，<strong>尝试将一个页面<code>EADD</code>到SECS处于初始化状态（INIT属性为true）的enclave将导致一个#GP</strong>。此外，<strong>尝试<code>EADD</code>已经分配的EPC页面(其EPCM条目中的VALID字段为1)将导致一个#PF</strong>。EADD还确保页面的虚拟地址位于enclave的ELRANGE内，并且<strong>SECINFO中的所有保留字段都被设置为零</strong>。</p><ul><li><strong><code>EADD</code> 指令将EPCM条目中的VALID字段置为1？</strong></li></ul><p>在加载enclave时，系统软件还将使用EEXTEND指令，该指令将<strong>更新在软件认证过程中使用的enclave度量值</strong>。软件认证在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中进行了讨论。</p><h3 id="5-3-3-初始化">5.3.3 初始化</h3><p>在将初始代码和数据页面加载到enclave后，<strong>系统软件必须使用<em>Launch enclave</em>(LE)来获取EINIT令牌结构</strong>，这是通过一个未文档化的过程实现的，将在<a href="#5.9.1-Enclave%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">§5.9.1</a>中详细描述。然后<strong>将令牌提供给<code>EINIT</code>指令，该指令将enclave的SECS标记为<em>initialized</em></strong>。</p><p>LE是由Intel提供的特权enclave，是使用由Intel以外的第三方编写的enclave的先决条件。LE是SGX的Enclave，因此必须使用本节中描述的进程来创建、加载和初始化它。然而，LE是用一个特殊的Intel密钥加密签名的(§3.1.3)，这个密钥被硬编码到SGX的实现中，这导致**<code>EINIT</code>在初始化LE时没有检查有效的EINIT令牌结构**。</p><p><strong>当<code>EINIT</code>成功完成时，它将enclave的INIT属性设置为true</strong>。这就为ring 3(§2.3)应用软件使用<a href="#5.4-SGX%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§5.4</a>中描述的SGX指令执行enclave的代码开辟了道路。另一方面，一旦INIT设置为true，就不能再在该enclave上调用<code>EADD</code>，因此<strong>在执行<code>EINIT</code>指令之前，系统软件必须加载构成enclave初始状态的所有页面</strong>。</p><h3 id="5-3-4-销毁">5.3.4 销毁</h3><p>Enclave完成了它要执行的计算之后，<strong>系统软件执行<code>EREMOVE</code>指令来释放enclave使用的EPC页面</strong>。</p><p><strong><code>EREMOVE</code>将EPC页面的EPCM条目的VALID字段设置为0，从而将该页面标记为可用</strong>。在释放页面之前，<code>EREMOVE</code>确保在拥有要删除的页面的enclave内部没有执行代码的逻辑处理器。</p><p>当保存SECS的EPC页面被释放时，enclave将被完全销毁。<strong>如果SECS页面被任何其他EPCM条目的ENCLAVESECS字段引用，<code>EREMOVE</code>将拒绝释放该页面</strong>，因此，<strong>只有在所有enclave页面都被释放之后，才能释放enclave的SECS页面</strong>。</p><h2 id="5-4-SGX线程的生命周期">5.4 SGX线程的生命周期</h2><p>在enclave被初始化(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)和被销毁(<a href="#5.3.4-%E9%94%80%E6%AF%81">§5.3.4</a>)这段时间内，任何将enclave的EPC页面映射到其虚拟地址空间的应用程序进程都可以执行enclave的代码。</p><p>当在enclave中执行代码时，逻辑处理器被称为处于enclave模式，它执行的代码可以<strong>访问属于当前执行的enclave的常规(<code>PT_REG</code>，<a href="#5.1.2-Enclave%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%98%A0%E5%B0%84%E8%A1%A8-(EPCM)">§5.1.2</a>)EPC页面</strong>。<strong>当逻辑进程处于enclave模式之外时，它会退回处理器保留内存范围(PRM, <a href="#5.1-SGX%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87">§5.1</a>)内的任何内存访问，包括EPC</strong>。</p><p><strong>每个执行enclave代码的逻辑处理器都使用一个线程控制结构</strong>(TCS，<a href="#5.2.4-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(TCS)">§5.2.4</a>)。当一个TCS被一个逻辑处理器使用时，它被认为是忙碌的，并且它不能被任何其他逻辑处理器使用。下图演示了主进程用于执行enclave代码的指令，以及它们与目标TCS的交互，这是具有两个状态保存区(SSAs)的SGX线程控制结构(TCS)的生命周期的各个阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128174512721.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128174512721.png" srcset="data:image/png;base64,666" alt="image-20201128174512721"></p><p>假设没有发生硬件异常，enclave的主进程使用<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>中描述的<code>EENTER</code>指令来执行enclave代码。当enclave代码完成它的任务时，它使用EEXIT指令(参见<a href="#5.4.2-%E5%90%8C%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.2</a>)将执行控制权返回给调用enclave的主进程。</p><p>如果在逻辑处理器处于enclave模式时发生硬件异常，则在调用系统软件的异常处理程序之前，使用<em>异步enclave退出</em>(AEX)将处理器从enclave模式中取出(<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)。在系统软件的处理程序被调用后，enclave的主进程可以使用<a href="#5.4.4-%E4%BB%8E%E5%BC%82%E6%AD%A5%E9%80%80%E5%87%BA%E6%81%A2%E5%A4%8D">§5.4.4</a>中描述的<code>ERESUME</code>指令重新输入enclave并恢复它退出之前正在执行的计算。</p><h3 id="5-4-1-同步Enclave进入">5.4.1 同步Enclave进入</h3><p>在较高的级别上，<code>EENTER</code>执行受控跳转到enclave代码，同时执行SGX的安全保证所需要的处理器配置。遍历所有配置步骤是一项冗长乏味的工作，但这是理解SGX使用的所有数据结构如何协同工作的必要先决条件。由于这个原因，<code>EENTER</code>和它的兄弟指令描述的比其他的SGX指令更详细。</p><p>下图所示的<code>EENTER</code>只能由运行在Ring 3(§2.3)的非特权应用程序软件执行，<strong>如果由系统软件执行，则会导致未定义指令(#UD)故障</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128175647644.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128175647644.png" srcset="data:image/png;base64,666" alt="image-20201128175647644"></p><p><code>EENTER</code>将逻辑处理器切换到enclave模式，但<strong>不执行特权级别切换</strong>。因此，<strong>enclave代码总是在Ring3执行</strong>，具有与调用它的应用程序代码相同的特权。这使得基础设施所有者可以允许用户提供的软件创建和使用enclave，同时保证OS内核和管理员仍然可以保护基础设施免受bug或恶意软件的攻击。</p><p><strong><code>EENTER</code>将TCS的虚拟地址作为它的输入，并要求TCS可用，并且TCS中至少有一个状态保存区域(SSA，<a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)可用</strong>。后者是通过确保TCS中的<em>当前SSA索引</em>(CSSA)字段小于SSAs  (NSSA)的数量来实现的。在执行enclave代码时发生硬件异常时，将使用CSSA所指示的SSA(应该称为当前SSA)。</p><p><strong><code>EENTER</code>将逻辑处理器转换为enclave模式，并将指令指针(RIP)设置为它接收到的TCS中的<em>入口点偏移</em>(OENTRY)字段所指示的值</strong>。<code>EENTER</code>被不受信任的调用者用来在一个受保护的环境中执行代码，因此它与用于调用系统软件的<code>SYSCALL</code>(§2.8)具有相同的安全考虑。将RIP设置为OENTRY所指示的值，可以向enclave作者保证enclave代码只会在定义良好的节点上调用，并防止恶意主机应用程序绕过enclave作者可能执行的任何安全检查。</p><p><strong><code>EENTER</code>还将XCR0(§2.6)设置为enclave属性的值XFRM</strong>(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)，XCR0是一个寄存器，用于控制正在使用的扩展架构特性。确保XCR0是根据enclave作者的意图设置的，从而防止恶意操作系统通过启用enclave尚未准备处理的体系结构特性来绕过enclave的安全性。</p><p>此外，<code>EENTER</code>使用TCS中指定的值加载段寄存器(§2.7)FS和GS的基底。段的选择器和类型是硬编码为安全值的Ring3数据段。SGX设计的这个方面使得实现每个线程的<em>线程本地存储</em>(TLS)变得很容易。对于64位的enclave，这是一种方便的特性，而不是一种安全措施，因为enclave代码可以使用WRFSBASE和WRGSBASE指令安全地将新的基底加载到FS和GS中。</p><p><strong><code>EENTER</code>将备份它修改的寄存器的旧值，以便在enclave完成其计算时恢复这些值</strong>。就像<code>SYSCALL</code>一样，<code>EENTER</code>将以下指令的地址保存在RCX寄存器中。</p><p>有趣的是，SDM声明XCR0、FS和GS寄存器的旧值保存在专用于SGX实现的新寄存器中。但是，鉴于它们只用于enclave退出，我们希望寄存器保存在DRAM中，在TCS的保留区域中。</p><p>与<code>SYSCALL</code>一样，<strong><code>EENTER</code>不修改堆栈指针寄存器(RSP)</strong>。为了避免任何安全漏洞，<strong>enclave代码应该将RSP设置为指向完全包含在EPC页面中的堆栈区域</strong>。通过设置每个线程的TLS区域以包含指向线程堆栈的指针，并将RSP设置为通过读取FS或GS段所指向的TLS区域获得的值，多线程enclave可以很容易地实现每个线程的堆栈区域。</p><p>最后，当<code>EENTER</code>进入enclave模式时，它会暂停一些处理器的调试特性，比如硬件断点和精确的基于事件的采样(PEBS)。从概念上讲，附加到主进程的调试器将enclave的执行看作一条单处理器指令。</p><h3 id="5-4-2-同步Enclave退出">5.4.2 同步Enclave退出</h3><p><strong><code>EEXIT</code>只能在逻辑处理器处于enclave模式时执行，如果在任何其他情况下执行，则会导致一个(#UD)</strong>。简而言之，该指令<strong>将处理器返回到Ring3外部enclave模式，并恢复由<code>EENTER</code>保存的寄存器</strong>。</p><p>与<code>SYSRET</code>不同，<strong><code>EEXIT</code>在退出enclave模式后将RIP设置为从RBX读取的值</strong>。这与<code>EENTER</code>不一致，<strong><code>EENTER</code>将RIP值保存到RCX</strong>。除非这种不一致性源于SDM中的错误，否则enclave代码必须确保注意到这种差异。</p><p>SDM明确声明**<code>EEXIT</code>不会修改大多数寄存器**，因此enclave作者必须确保在将控制权返回给主进程之前清除存储在处理器寄存器中的任何秘密。此外，如果enclave软件没有将堆栈指针RSP和堆栈帧基指针RBP恢复到它们在<code>EENTER</code>被调用时拥有的值，那么它很可能会在调用者中造成错误。</p><p>Enclave代码可能会在其调用者中引发错误，这似乎很不幸。无论好坏，这完全符合应用程序调用动态加载模块的情况。更具体地说，模块的代码还负责保存与堆栈相关的寄存器，有bug的模块可能会跳转到主进程的应用程序代码中的任何位置。</p><p>本节描述64位enclave的<code>EENTER</code>行为。32位enclave的<code>EENTER</code>实现要复杂得多，因为在32位Intel架构中仍然存在成熟的分段模型引入了额外的特殊情况。</p><h3 id="5-4-3-异步Enclave退出">5.4.3 异步Enclave退出</h3><p>如果在逻辑处理器执行enclave代码时发生了硬件异常，比如错误(§2.8.2)或中断(§2.12)，处理器<strong>在调用系统软件的异常处理程序之前执行<em>异步enclave退出</em></strong>(AEX)，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128192836878.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128192836878.png" srcset="data:image/png;base64,666" alt="image-20201128192836878"></p><p>AEX保存enclave代码的执行上下文(§2.6)，恢复<code>EENTER</code>保存的状态，并设置处理器寄存器，以便系统软件的硬件异常处理程序返回到enclave的主进程中的异步退出处理程序。<strong>退出处理程序将使用<code>ERESUME</code>指令恢复被硬件异常中断的enclave计算</strong>。</p><p>除了<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>中描述的行为外，<code>EENTER</code>还向当前SSA写入一些信息，这只在AEX发生时使用。<code>EENTER</code>将堆栈指针寄存器RSP和堆栈帧基指针寄存器RBP存储到当前SSA中的U_RSP和U_RBP字段中。最后，<strong><code>EENTER</code>将值存储在当前SSA的<em>异步退出处理程序指针</em>(AEP)字段中的RCX中</strong>。</p><p>当在enclave模式下发生硬件异常时，SGX实现执行一系列步骤，将逻辑处理器从enclave模式中取出，并在系统软件中调用硬件异常处理程序。从概念上讲，SGX首先执行AEX以使逻辑处理器脱离enclave模式，然后使用§2.8.2中描述的标准英特尔架构的行为来处理硬件异常。实际的Intel处理器可能会将AEX实现与异常处理实现交错使用。然而，为了简单起见，该工作将AEX描述为一个单独的过程，在采取任何异常处理步骤之前执行。</p><p>在英特尔架构中，如果发生硬件异常，应用程序代码的执行上下文可以被系统软件的异常处理程序读取和修改(§2.8.2)。当应用程序软件信任系统软件时，这是可以接受的。然而，在SGX的威胁模式下，系统软件不被Enclave信任。因此，<strong>AEX步骤通过将其所有寄存器重置为预定义值来清除执行状态中可能存在的任何秘密</strong>。</p><p>在重置enclave的执行状态之前，将它备份到当前SSA中。具体来说，AEX备份SSA中的GPRSGX区域中的通用寄存器(GPRs，§2.6)，然后使用enclave SECS中的XFRM字段中指定的<em>请求特性位图</em>(RFBM)执行<code>XSAVE</code>(§2.6)。由于每个SSA都完全存储在分配给enclave的EPC页面中，因此<strong>系统软件不能读取或篡改备份的执行状态</strong>。<strong>当SSA接收到enclave的执行状态时，通过递增当前TCS中的CSSA字段，将其标记为used</strong>。</p><p>在清除执行上下文后，<strong>AEX进程将RSP和RBP设置为<code>EENTER</code>在当前SSA中保存的值，将RIP设置为当前SSA的AEP字段中的值</strong>。这样，当系统软件的硬件异常处理程序完成时，处理器将在enclave的主进程中执行异步退出处理程序代码。SGX的设计使得在包含<code>EENTER</code>指令的例程中将异步处理程序代码设置为异常处理程序变得很容易，因为RSP和RBP寄存器拥有的值与执行<code>EENTER</code>时相同。</p><p>AEX在enclave模式之外获取逻辑处理器所采取的许多操作都与<code>EEXIT</code>匹配。段寄存器FS和GS恢复到<code>EENTER</code>保存的值，所有被<code>EENTER</code>抑制的调试工具恢复到它们以前的状态。</p><h3 id="5-4-4-从异步退出恢复">5.4.4 从异步退出恢复</h3><p>当在enclave模式下发生硬件异常时，处理器在调用系统软件设置的异常处理程序之前执行AEX。AEX设置执行上下文的方式是，<strong>当系统软件完成异常处理时，它返回到enclave的主进程中的异步退出处理程序。异步异常处理程序通常执行<code>ERESUME</code>指令</strong>，这将导致逻辑处理器返回到enclave模式并继续被硬件异常中断的计算。</p><p><code>ERESUME</code>与<code>EENTER</code>共享其大部分功能。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128201539849.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128201539849.png" srcset="data:image/png;base64,666" alt="image-20201128201539849"></p><p><code>EENTER</code>和<code>ERESUME</code>接收相同的输入，即<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>中描述的TCS指针和<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>中描述的AEP指针。最常见的应用程序设计将每个<code>EENTER</code>实例与使用完全相同的参数调用<code>ERESUME</code>的异步退出处理程序配对。</p><p><code>ERESUME</code>和<code>EENTER</code>之间的主要区别在于前者使用一个由AEX“填写”的SSA(<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)，而后者使用一个空的SSA。因此，<strong>如果提供的TCS中的CSSA字段为0，则<code>ERESUME</code>会导致#GP故障，而如果CSSA大于或等于NSSA，则<code>EENTER</code>会失败</strong>。</p><p>当成功时，<code>ERESUME</code>递减TCS的CSSA字段，并恢复TCS中CSSA字段所指向的SSA备份的执行上下文。具体来说，<strong><code>ERESUME</code>实现从SSA中的GPRSGX字段中恢复GPRs(§2.6)，并执行<code>XRSTOR</code>(§2.6)来加载与enclave所使用的扩展体系结构特性相关联的执行状态</strong>。</p><p><code>ERESUME</code>与<code>EENTER</code>共享以下行为。这两个指令<strong>都写入当前SSA中的U_RSP、U_RBP和AEP字段</strong>。这两个指令<strong>遵循相同的过程来备份XCR0、FS和GS段寄存器</strong>，并<strong>基于当前TCS及其enclave的SECS将它们设置为相同的值</strong>。最后，这两个指令都<strong>禁用了逻辑处理器的调试特性的同一子集</strong>。</p><p><code>ERESUME</code>正确处理的一个有趣的情况是，它在执行<code>XRSTOR</code>之前将XCR0设置为enclave属性XFRM  。<strong>如果SSA中的<em>请求特性位图</em>(RFBM)不是XFRM的子集，那么<code>ERESUME</code>就会失败</strong>。这很重要，因为尽管AEX总是使用XFRM值作为RFBM，但在另一个线程上执行的enclave代码可以在调用<code>ERESUME</code>之前自由地修改SSA内容。</p><p><code>ERESUME</code>实现中正确的操作顺序可以防止恶意应用程序使用enclave修改与未在XFRM中声明的扩展体系结构特性相关联的寄存器。这将破坏系统软件提供线程级执行上下文隔离的能力。</p><h2 id="5-5-EPC页面交换">5.5 EPC页面交换</h2><p>现代操作系统内核利用地址转换(§2.5)来实现页面交换，也称为分页(§2.5)。简而言之，通过将很少使用的内存页交换到称为磁盘等较慢的存储介质，分页允许OS内核过量提交计算机的DRAM。</p><p>分页是有效利用计算机资源的关键因素。例如，用户并发运行多个程序的桌面系统可以退出分配给不活动应用程序的内存页，而不会显著降低用户体验。</p><p>不幸的是，不能允许OS通过像在PRM范围之外的DRAM内存页面交换一样来交换enclave的EPC页面。在SGX的威胁模型中，enclave不相信系统软件，因此SGX的设计提供了一种EPC页面交换方法，可以防御试图进行§3.7中所述的任何主动地址转换攻击的恶意操作系统。</p><p>SGX所提供的安全性的代价是，支持交换EPC页面的操作系统内核必须使用经过修改的页面交换实现，该实现与SGX机制交互。Enclave作者基本上可以忽略EPC交换，类似于今天的应用程序开发人员可以忽略OS内核的分页实现。</p><p>如下图所示，SGX支持将EPC页面交换到PRM范围之外的DRAM页面。系统软件使用现有的页交换技术实现将这些页的内容从DRAM中交换到磁盘上。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202326077.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202326077.png" srcset="data:image/png;base64,666" alt="image-20201128202326077"></p><p>SGX的交换特性围绕着<code>EWB</code>指令，在<a href="#5.5.4-EPC%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2">§5.5.4</a>中有详细描述。实际上，<strong><code>EWB</code>将EPC页交换到EPC之外的DRAM页，并通过将该页EPCM条目中的VALID字段置零将EPC页标记为可用</strong>。</p><p><strong>SGX设计依赖于对称密钥加密来保证被交换的EPC页面的机密性和完整性，并依赖于nonces(§3.1.4)来保证带回EPC的页面的新鲜度</strong>。这些nonces存储在<a href="#5.5.2-%E7%89%88%E6%9C%AC%E6%95%B0%E7%BB%84" title="VA">§5.5.2</a>中介绍的版本数组(VA)中，它们是专门用于nonce存储的EPC页面。</p><p>在EPC页面被交换并释放给其他enclaves使用之前，SGX实现必须确保没有TLB拥有与被交换的页面相关联的地址转换，以避免§3.7.4中描述的基于TLB的地址转换攻击。</p><p>正如<a href="#5.1.1-Enclave%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98-(EPC)">§5.1.1</a>中所解释的，SGX让系统软件负责管理EPC。自然地，本节中描述的用于实现EPC分页的SGX指令只对运行在Ring 0(§2.3)上的系统软件可用。</p><p>在今天的软件栈(§2.3)中，只有操作系统内核实现了页面交换，以支持DRAM的过度使用。管理程序仅用于在操作系统之间划分计算机的物理资源。因此，在编写本节时，我们期望OS内核也将承担EPC页面交换的责任。为了简单起见，我们经常使用术语“操作系统内核”而不是“系统软件”。读者应该知道，SGX设计并不排除系统管理程序实现自己的EPC页面交换的系统。因此，“OS内核”实际上应该理解为“执行EPC分页的系统软件”。</p><h3 id="5-5-1-页面交换和TLB">5.5.1 页面交换和TLB</h3><p>SGX没有向内存执行单元添加任何安全检查(§2.9.4，§2.10)。相反，SGX的访问控制检查是在地址转换(§2.5)完成之后进行的，就在转换结果写入TLBs之前(§2.11.5)。在整个SDM中，这个方面通常被忽略，但是在解释SGX的EPC页面清除机制时，它就变得显而易见了。</p><p>关于SGX的内存访问保护检查的完整讨论值得单独一节来讨论，请参见§6.2。只需使用SGX的安全模型中的两个需求就可以解释EPC页面清除机制。首先，当一个逻辑处理器通过<code>EEXIT</code>(<a href="#5.4.2-%E5%90%8C%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.2</a>)或AEX(<a href="#5.4.3%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)退出一个enclave时，它的TLB被刷新。其次，当从enclave释放EPC页面时，必须使得执行该enclave代码的所有逻辑处理器退出enclave。这足以保证删除任何针对已释放的EPC的TLB条目。</p><p>系统软件可以通过发送处理器间中断(IPI，§2.12)，使逻辑处理器退出enclave，这将在接收时触发AEX。</p><p>SGX不相信系统软件。因此，<strong>在将EPC页面的EPCM条目标记为free之前，SGX必须确保OS内核已经清除了所有可能包含该页面转换的TLB</strong>。此外，为每个页面清除执行IPIs和TLB刷新会给分页实现增加很大的开销，因此SGX设计允许使用一个IPI/TLB刷新序列来清除一批页面。</p><p><strong>TLB刷新验证逻辑依赖于一个名为BLOCKED的1位EPCM条目字段</strong>。如下图所示，VALID和BLOCKED字段产生三种可能的EPC页面状态。当两个位都为零时，页面是空闲的；当VALID为1，BLOCKED为0时使用；当两个位都为1时，页面被阻塞。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202429126.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202429126.png" srcset="data:image/png;base64,666" alt="image-20201128202429126"></p><p><strong>被阻塞的页面被认为不能被enclave访问</strong>。如果一个地址转换导致一个被阻塞的EPC页面，SGX实现会导致一个页面错误(#PF，§2.8.2)。这保证了一旦一个页面被阻塞，CPU将不会创建任何新的指向它的TLB条目。</p><p>此外，<strong>每条SGX指令都确保它所操作的EPC页面不会被阻塞</strong>。例如，<code>EENTER</code>确保它提供的TCS没有被阻塞，它的enclave的SECS没有被阻塞，以及当前SSA中的每个页面没有被阻塞。</p><p>为了交换一批EPC页面，OS内核必须首先针对这些页面发出<code>EBLOCK</code>指令。SGX还希望OS从页表中删除EPC页的映射，但并不信任OS。</p><p><strong>在所有所需的页面都被阻塞之后，操作系统内核必须执行一条<code>ETRACK</code>指令，这条指令指示SGX实现跟踪哪些逻辑处理器的TLBs已被刷新</strong>。<code>ETRACK</code>要求enclave的SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)的虚拟地址。如果OS希望交换属于多个enclave的一批EPC页面，它必须为每个enclave发出一个<code>ETRACK</code>。</p><p>按照<code>ETRACK</code>指令，操作系统内核必须在所有执行enclave代码的逻辑处理器上的enclave退出。SGX设计期望操作系统将使用IPIs在逻辑处理器中导致AEXs，而逻辑处理器的TLBs必须被刷新。</p><p>当OS对每个要交换的EPC页面执行<code>EWB</code>指令时，EPC页面交换过程就完成了。这条指令将在<a href="#5.5.4-EPC%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2">§5.5.4</a>中详细描述，它将<strong>写入EPC页面的加密版本并将其交换到DRAM中，然后通过清除其EPCM条目中的VALID和BLOCKED位来释放该页面</strong>。在执行其任务之前，<code>EWB</code>确保它所目标的EPC页面已经被阻塞，并检查<code>ETRACK</code>设置的状态，以确保所有相关的TLB都已被刷新。</p><p>可以<strong>通过<code>ELDU</code>和<code>ELDB</code>指令将被交换的页面加载回EPC</strong>。这两个指令启动时都有一个空闲的EPC页面和一个DRAM页面(其中包含EPC页面的已交换内容)，然后将DRAM页面的内容解密到EPC页面，并恢复相应的EPCM条目。<strong><code>ELDU</code>和<code>ELDB</code>之间的唯一区别是后者在页面的EPCM条目中设置阻塞位，而前者将其清除</strong>。</p><p><code>ELDU</code>和<code>ELDB</code>类似于<code>ECREATE</code>和<code>EADD</code>，因为它们填充了一个空闲的EPC页面。由于他们操作的页面是空闲的，因此SGX安全模型断言没有TLB条目可能针对它。因此，这些指令不需要类似于<code>EBLOCK</code>或<code>ETRACK</code>的机制。</p><h3 id="5-5-2-版本数组-VA">5.5.2 版本数组 (VA)</h3><p>当<code>EWB</code>交换EPC的内容时，它会<strong>创建一个8字节的nonce</strong>(§3.1.4)，英特尔的文档将其称为页面版本。<strong>SGX的新鲜度保证是建立在安全存储nonces的假设之上的，所以<code>EWB</code>将它创建的nonce存储在一个<em>版本数组</em>(VA)中</strong>。</p><p>版本数组是EPC页面，专门用于存储由<code>EWB</code>生成的nonces。每个VA被划分成槽，每个槽都足够存储一个nonce。假设EPC页面的大小是4KB，每个nonce占用8字节，那么每个VA就有512个槽。</p><p><strong>页是使用<code>EPA</code>指令分配的，该指令接受空闲EPC页的虚拟地址，并将其转换为具有空槽的版本数组</strong>。每一页在其EPCM条目中以PT_VA类型标识。<strong>与SECS页面一样，VA页面的EPCM条目中的ENCLAVEADDRESS字段设置为零</strong>，任何软件(包括enclave)都不能直接访问它们。</p><p>与到目前为止讨论的其他页面类型不同，<strong>VA页面不与任何enclave关联</strong>。这意味着可以通过<code>EREMOVE</code>释放它们，而不受任何限制。但是，将一个槽正在使用的VA页面释放时会丢弃这些槽中的nonces，这将导致丢失将相应的被交换的页面加载回EPC的能力。因此，一个正确的操作系统实现不太可能在一个非空闲槽的VA调用<code>EREMOVE</code>。</p><p>根据SDM中<code>EPA</code>和<code>EWB</code>的伪代码，<strong>SGX使用零值来表示VA中的空槽</strong>，这意味着所有生成的nonces必须是非零的。这还意味着<code>EPA</code>通过将底层EPC页面归零来初始化VA。然而，由于软件不能访问VA的内容，无论是使用一个特殊值，或值本身都不是体系结构的。</p><h3 id="5-5-3-Enclave-IDs">5.5.3 Enclave IDs</h3><p><code>EWB</code>和<code>ELDU</code> / <code>ELDB</code>指令使用一个<strong><em>enclave ID</em> (EID)来标识拥有被交换页面的enclave</strong>。EID与EPCM条目中的ENCLAVESECS(<a href="#5.1.2-Enclave%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%98%A0%E5%B0%84%E8%A1%A8-(EPCM)">§5.1.2</a>)字段具有相同的用途，后者也用于标识拥有EPC页面的enclave。本节通过比较两个值及其用法，说明使用两个值表示相同概念的必要性。</p><p>SDM声明EPCM条目中的ENCLAVESECS字段用于标识拥有相关EPC页面的enclave的SECS，但没有描述其格式。理论上，ENCLAVESECS字段可以在SGX实现之间更改，因为SGX指令从不向软件暴露其值。</p><p>然而，我们稍后将讨论，ENCLAVESECS最可信的表示是其字段中的enclave物理地址。因此，如果从EPC中交换出enclave的SECS并在另一个位置加载回该enclave，则与给定enclave关联的ENCLAVESECS值将发生更改。由此可见，<strong>ENCLAVESECS值仅适用于标识某个enclave，而其SECS仍在EPC中</strong>。</p><p>根据SDM,  <strong>EID字段是存储在enclave的SECS中的64位字段</strong>。SDM中的<code>ECREATE</code>伪代码显示，在分配SECS时，通过原子递增全局计数器生成enclave的ID。假设计数器不会发生滚动，此过程将确保在电源循环期间创建的每个enclave都具有唯一的EID。</p><p>尽管SDM没有明确保证这一点，但<strong>enclave SECS中的EID字段似乎不会被任何指令修改</strong>。这使得EID的值适合在整个enclave的生命周期内标识它，甚至在从EPC中将其SECS页面驱逐出去时也是如此。</p><h3 id="5-5-4-EPC页面交换">5.5.4 EPC页面交换</h3><p>系统软件使用<code>EWB</code>指令交换EPC页面，<code>EWB</code>指令在稍后通过<code>ELDU</code>指令生成恢复交换页面所需的所有数据，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202614082.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202614082.png" srcset="data:image/png;base64,666" alt="image-20201128202614082"></p><p><strong><code>EWB</code>的输出包括被交换的EPC页面内容的加密版本、与该页面对应的EPCM条目中的字段子集、<a href="#5.5.2-%E7%89%88%E6%9C%AC%E6%95%B0%E7%BB%84-(VA)">§5.5.2</a>中讨论的nonce和消息身份验证代码(MAC，§3.1.3)标记</strong>。除了nonce之外，<code>EWB</code>将其输出写入PRM区域之外的DRAM中，因此系统软件可以选择进一步将其交换出磁盘。</p><p>EPC页面内容被加密，以保护enclave数据的机密性，同时页面存储在PRM范围之外的不受信任的DRAM中。在不使用加密的情况下，系统软件可以通过将EPC页面从EPC中交换出来从而了解该页面的内容。</p><p><strong>页面元数据存储在页面信息(PAGEINFO)结构中</strong>，如下图所示。这个结构类似于<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>中描述的PAGEINFO结构，<strong>除了SECINFO字段被一个PCMD字段所取代</strong>，它包含一个页面加密元数据(PCMD)结构的虚拟地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202629432.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202629432.png" srcset="data:image/png;base64,666" alt="image-20201128202629432"></p><p>PAGEINFO结构中的LINADDR字段用于存储EPCM条目中的地址字段，该字段指示用于访问页面的虚拟地址。<strong>PCMD结构嵌入了<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>中描述的安全信息(SECINFO)，用于在EPCM条目中存储页面类型(PT)和访问权限标志(R, W, X)</strong>。PCMD结构还存储了enclave的ID (EID，<a href="#5.5.3-Enclave-IDs">§5.5.3</a>)。这些字段稍后由<code>ELDU</code>或<code>ELDB</code>用于填充重新加载的EPC页面的EPCM条目。</p><p>上面描述的元数据是未加密存储的，因此操作系统可以选择按原样使用内部信息进行自己的记帐。这对安全性没有负面影响，因为<strong>元数据不是机密的</strong>。实际上，除了enclave ID之外，所有元数据字段都是在调用<code>ECREATE</code>时由系统软件指定的。enclave ID仅用于标识EPC页面所属的enclave，而且系统软件也已经拥有该信息。</p><p>除了上面描述的元数据之外，PCMD结构还存储由<code>EWB</code>生成的MAC标签。<strong>MAC标记涵盖EPC页面内容的真实性、元数据和nonce</strong>。MAC标记由<code>ELDU</code>和<code>ELDB</code>检查，只有在MAC验证确认了页面数据、元数据和nonce的真实性时，它们才会将一个被交换的页面加载回EPC。这个安全检查可以防止在§3.7.3中描述的页面交换攻击。</p><p>与<code>EREMOVE</code>类似，<strong>如果没有其他EPCM条目的ENCLAVESECS字段引用该SECS，则<code>EWB</code>只会交换包含enclave SECS的EPC页面</strong>。同时，作为一种优化，SGX实现在交换SECS时不执行与<code>ETRACK</code>相关的检查。这是安全的，因为只有在EPC没有属于SECS的页面时，才会交换SECS，这意味着EPC中没有属于enclave的任何TCS，因此没有处理器可以执行enclave代码。</p><p>与任何其他EPC页面一样，可以清除持有版本数组的页面。VA页面永远不能被软件访问，所以他们不能有任何TLB条目指向他们。因此，<code>EWB</code>在不执行任何<code>ETRACK</code>相关检查的情况下交换VA页面。</p><p><code>EWB</code>的数据流(如下图所示)有一个方面可能会让操作系统开发人员感到困惑。该指令从寄存器(RBX)中读取将要被交换出的EPC页面的虚拟地址，并将其写入提供给它的PAGEINFO结构的LINADDR字段。可以通过在LINADDR字段中提供EPC页面的地址来删除单独的输入(RBX)。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201129122411533.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201129122411533.png" srcset="data:image/png;base64,666" alt="image-20201129122411533"></p><h3 id="5-5-5-将交换的页面加载回EPC">5.5.5 将交换的页面加载回EPC</h3><p>在交换出属于enclave的EPC页面之后，<strong>任何从enclave代码访问该页面的尝试都将导致页面错误(#PF，§2.8.2)</strong>。#PF将导致逻辑处理器通过AEX退出enclave模式(<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)，然后调用OS内核的页面错误处理程序。</p><p>页面错误从AEX流程接受特殊处理。当离开enclave时，AEX逻辑专门检查触发AEX的硬件异常是否为#PF。如果是这样，AEX实现将清除CR2寄存器中最不重要的12位，该寄存器存储虚拟地址，其转换导致了页面错误。</p><p>通常，操作系统内核的页面处理程序需要能够从CR2中提取虚拟页码(VPN，§2.5.1)，这样它就知道需要将哪些内存页加载回DRAM。操作系统内核还可以使用12个最不重要的地址位，这不是VPN的一部分，从而更好地预测应用程序软件的内存访问模式。然而，与组成VPN的位不同，最下面的12位对于故障处理程序执行其工作不是绝对必要的。因此，SGX的AEX实现清除这12位，以限制页面错误处理程序得到的信息量。</p><p><strong>当OS页面错误处理程序检查CR2寄存器中的地址并确定错误地址在EPC中时，通常希望使用<code>ELDU</code>或<code>ELDB</code>指令将被交换的页面加载回EPC中</strong>。如果<code>EWB</code>的输出已经从DRAM中被交换到较慢的存储介质中，操作系统内核将不得不在调用<code>ELDU</code>  / <code>ELDB</code>之前将输出读回DRAM中。</p><p><code>ELDU</code>和<code>ELDB</code>验证由<code>EWB</code>产生的MAC标签，如<a href="#5.5.4-EPC%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2">§5.5.4</a>所述。这可以防止操作系统内核执行§3.7.3中描述的基于页面交换的主动地址转换攻击。</p><h3 id="5-5-6-交换树">5.5.6 交换树</h3><p>SGX允许从EPC中交换VA页面，就像enclave页面一样。当从EPC中交换一个VA页面时，处理器将无法访问由VA槽存储的所有nonces。因此，在操作系统将VA页面加载回EPC之前，<code>ELDB</code>无法恢复与这些nonces关联的被交换的页面。</p><p>换句话说，<strong>一个被交换的页面依赖于存储其nonce的VA页面，并且在VA页面也被重新加载之前不能被加载回EPC</strong>。由此关系创建的依赖图是一个交换树的森林。如下图所示，一个交换树将EPC页面作为叶子，将VA页面作为内部节点。页面的父页面是保存其nonce的VA页面。由于<code>EWB</code>总是在一个页面中输出一个nonce，所以每个交换树的根节点在EPC中总是一个页面。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202740316.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202740316.png" srcset="data:image/png;base64,666" alt="image-20201128202740316"></p><p>一个简单的归纳表明，<strong>当OS希望将一个交换的enclave页面加载回EPC时，它需要在从交换树的根到与该enclave页面对应的叶的路径上加载所有VA页面</strong>。因此，在EPC中满足页面错误所需的页面加载数量取决于包含该页面的交换树的形状。</p><p>SGX让OS完全掌控交换树的形状。这对安全性没有负面影响，因为树的形状只影响交换方案的性能，而不影响其正确性。</p><h2 id="5-6-SGX-Enclave度量">5.6 SGX Enclave度量</h2><p>SGX实现了一个软件认证方案，该方案遵循了§3.3中概述的一般原则。对于本节而言，最相关的原则是远程方根据其度量对enclave进行身份验证，该度量用于识别正在enclave内部执行的软件。远程方将可信硬件报告的enclave度量与预期的度量进行比较，只有在两个值匹配时才进行。</p><p><a href="#5.3-SGX-Enclave%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§5.3</a>解释了SGX enclave是使用<code>ECREATE</code>(<a href="#5.3.1-%E5%88%9B%E5%BB%BA">§5.3.1</a>)、<code>EADD</code>(<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>)和<code>EEXTEND</code>指令构建的。在通过<code>EINIT</code>(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)初始化enclave之后，上面提到的指令就不能再使用了。SGX度量的方案遵循§3.3.2中概述的原则，SGX enclave的度量是通过计算安全散列(§3.1.3)输入<code>ECREATE</code>,  <code>EADD</code>和<code>EEXTEND</code>。<code>EINIT</code>结束了表示enclave度量值的散列。</p><p>除了enclave的内容之外，enclave作者还需要指定应该使用的指令序列，以便创建一个enclave，该enclave的度量将与软件认证过程中远程方使用的期望值相匹配。.so和.dll动态加载库文件格式是SGX打算使用的enclave传递方法，它们已经包含了加载算法的非正式规范。我们期望非正式的加载规范作为规范的起点，这些规范规定了应该用于从.so和.dll文件创建enclave的SGX指令的确切序列。</p><p>如§3.3.2所述，<strong>enclave的度量是使用安全的哈希算法计算的，因此系统软件只能按照enclave作者指定的指令顺序构建与预期度量匹配的enclave</strong>。</p><p><strong>SGX设计使用256位SHA-2安全哈希函数来计算其度量值</strong>。SHA-2是一个块哈希函数(§3.1.3)，它对64字节的块进行操作，使用32字节的内部状态，并产生32字节的输出。<strong>每个enclave的度量都存储在enclave SECS的MRENCLAVE字段中</strong>。32字节字段存储256位SHA-2安全哈希函数的内部状态和最终输出。</p><h3 id="5-6-1-ECREATE度量">5.6.1 ECREATE度量</h3><p>在<a href="#5.3.1-%E5%88%9B%E5%BB%BA">§5.3.1</a>中概述的<code>ECREATE</code>指令，首先使用256位SHA-2初始化算法在新创建的SECS中初始化MRENCLAVE字段，然后使用下表中描述的64字节块扩展哈希。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202858886.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202858886.png" srcset="data:image/png;base64,666" alt="image-20201128202858886" style="zoom:80%;" /><p>enclave的度量不包括BASEADDR字段。此处省略是有意的，因为它<strong>允许系统软件在满足ELRANGE限制的主进程内的任何虚拟地址加载enclave，而不会改变enclave度量值</strong>。此特性可以与生成位置无关的enclave代码的编译器结合使用，以获得可重定位的enclave。</p><p>enclave的度量包括SSAFRAMESIZE字段，它<strong>保证AEX创建、<code>EENTER</code>(<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>)和<code>ERESUME</code>(<a href="#5.4.4-%E4%BB%8E%E5%BC%82%E6%AD%A5%E9%80%80%E5%87%BA%E6%81%A2%E5%A4%8D">§5.4.4</a>)使用的SSAs(<a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)具有enclave作者所期望的大小</strong>。如果将此字段排除在enclave的度量之外，会允许恶意的enclave加载程序通过指定比enclave作者预期的更大的SSAFRAMESIZE来试图攻击enclave的安全检查，这可能导致AEX编写的SSA内容覆盖enclave的代码或数据。</p><h3 id="5-6-2-度量Enclave属性">5.6.2 度量Enclave属性</h3><p><strong>enclave的度量不包括在SECS中的ATTRIBUTES字段中指定的enclave属性</strong>(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)。相反，它直接包含在认证签名所涵盖的信息中，这将在<a href="#5.8.1-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81">§5.8.1</a>中讨论。</p><p><strong>SGX软件认证需要涵盖enclave属性</strong>。例如，如果XFRM(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a> <a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)不被覆盖，一个恶意的enclave装载机可以通过设置XFRM值试图颠覆一个enclave的安全检查，让体系结构扩展指令使用的enclave的语义变化，但仍然是产生符合SSAFRAMESIZE的XSAVE输出。</p><p>应用到ATTRIBUTES  SECS字段的特殊处理从安全角度来看似乎是有问题的，因为它给软件认证验证器增加了额外的复杂性，从而转化为可利用的漏洞的更多机会。这个决定也增加了SGX软件认证设计的复杂性，在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中有描述。</p><p>尽管存在上述问题，SGX设计决定走这条路的最可能的原因是希望能够使用单一度量来表示一个能够利用一些架构扩展的enclave，但也可以在没有它们的情况下执行其任务。</p><p>例如，考虑使用OpenCV这样的库执行图像处理的enclave，它具有针对SSE和VX优化的例程，但还包括针对不具备这些特性的处理器的通用回退。enclave的作者可能希望允许enclave加载器将位1(SSE)和位2(VX)设置为真或假。如果ATTRIBUTES(以及XFRM)是enclave度量的一部分，则enclave作者必须指定enclave有4个有效度量。通常，允许n个架构扩展独立使用将导致2<sup>n</sup>个无效度量。</p><h3 id="5-6-3-度量EADD">5.6.3 度量EADD</h3><p><a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>中描述的<code>EADD</code>指令用下表中所示的64字节块扩展了MRENCLAVE中的SHA-2哈希。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202953982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202953982.png" srcset="data:image/png;base64,666" alt="image-20201128202953982" style="zoom:80%;" /><p><strong>度量中包含的地址是<code>EADD</code>页面预期映射到enclave的虚拟地址空间中的地址</strong>。这可以确保系统软件根据enclave作者的规范设置enclave的虚拟内存布局。如果恶意的enclave加载程序试图错误地设置enclave的布局，可能是为了挂载一个活动的地址转换攻击(§3.7.2)，所加载的enclave的度量结果将与enclave作者期望的度量结果不同。</p><p>新创建的页面的虚拟地址相对于enclave的ELRANGE的起点进行度量。换句话说，度量中包含的值是LINADDR -  BASEADDR。这使得<strong>enclave的度量对BASEADDR的变化保持不变</strong>，这对于可重定位的enclave是理想的。度量相对地址仍然保留了关于ELRANGE内内存布局的所有信息，因此没有负面的安全影响。</p><p><strong><code>EADD</code>同时也度量提供给<code>EADD</code>的SECINFO(<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>)结构的前48字节</strong>，其中包含用于初始化页面的EPCM条目的页面类型(PT)和访问权限(R,  W, X)字段值。同样，在度量中包含这些值可以保证加载enclave的系统软件构建的内存布局与enclave作者的规范相匹配。</p><p>上面提到的EPCM字段值在SECINFO结构中只占不到一个字节，其余的字节被保留，并被初始化为零。这为SGX未来的功能留下了大量的扩展空间。</p><p>上表中最值得注意的省路是用于初始化新创建的EPC页面的数据。因此，<code>EADD</code>提供的度量数据保证了enclave的内存布局将具有在所需虚拟地址上分配的有指定访问权限的页面。但是，度量不包括在这些页面中加载的代码或数据。</p><p>例如，<code>EADD</code>的度量数据保证enclave的内存布局由三个可执行页面和五个可写数据页面组成，但它不能保证任何代码页面包含enclave作者提供的代码。</p><h3 id="5-6-4-度量EEXTEND">5.6.4 度量EEXTEND</h3><p><code>EEXTEND</code>指令的存在仅仅是为了度量加载在enclave的EPC页面中的数据。该指令读入一个虚拟地址，并使用下表中的5个64字节块扩展enclave的度量散列，这有效地保证了enclave内存中256字节数据块的内容。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203446836.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203446836.png" srcset="data:image/png;base64,666" alt="image-20201128203446836" style="zoom:80%;" /><p>在检查<code>EEXTEND</code>的细节之前，我们注意到，SGX的安全保证只有在对enclave的关键页面的内容进行测量时才有效。例如，<code>EENTER</code>(<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>)只有在测量了所有线程控制结构(TCS，<a href="#5.2.4-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(TCS)">§5.2.4</a>)页面的内容后，才保证在enclave的代码中执行受控跳转。否则，恶意的enclave加载程序可以在构建enclave时更改TCS中的OENTRY字段(§5.2.4，<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>)，然后恶意的操作系统可以使用TCS在enclave代码中执行任意跳转。同样的道理，所有enclave的代码都应该用<code>EEXTEND</code>来度量。任何无法测量的代码片段都可以被恶意的enclave加载程序替换。</p><p>考虑到这些缺陷，令人惊讶的是SGX设计选择将由<code>EADD</code>完成的虚拟地址空间布局度量与由<code>EEXTEND</code>完成的内存内容度量分离。</p><p>乍一看，这种解耦似乎只有一个好处，即能够在构建enclave时将未测量的用户输入加载到该enclave中。但是，这种好处只会转化为很小的性能改进，因为可以将enclave设计为在初始化后从不受信任的DRAM复制用户输入。与此同时，由于没有通过<code>EEXTEND</code>调用度量所有重要数据，这种分离打开了依赖于一个没有提供有意义的安全保证的enclave的可能性。</p><p>然而，<code>EADD</code>  / <code>EEXTEND</code>分离背后的真正原因是由SDM中的<code>EINIT</code>伪代码所暗示的，它表明该指令在执行计算密集型RSA签名检查时打开了一个中断窗口(§2.12)。如果在检查期间发生中断，<code>EINIT</code>会失败并出现错误代码，然后中断。对于处理器指令来说，这种非常不寻常的方法表明，SGX实现受到了其指令被允许添加到中断处理进程中的延迟时间的限制。</p><p>考虑到上面的问题，可以合理地推断引入了<code>EEXTEND</code>，因为使用256位SHA-2度量整个页面非常耗时，而且在<code>EADD</code>中这样做会导致指令超出SGX的延迟预算。需要达到某个延迟目标，这是对似乎任意的256字节块大小的合理解释。</p><p>如果使用构建当前动态加载模块(似乎是SGX设计的目标工作流)的相同工具编写enclave，那么<code>EADD</code> /  <code>EEXTEND</code>分离将不会导致安全问题。在此工作流中，构建enclave的工具可以轻松识别需要度量的enclave数据。</p><p>从安全性的角度来看，让<code>EEXTEND</code>提供给散列函数的消息块除了包含数据内容外，还包含256字节块的地址是正确的，也是有意义的。如果地址不包括在内，恶意的enclave加载器就会装载§3.7.2中描述的内存映射攻击。</p><p>更具体地说，恶意加载程序将在用于泄漏的虚拟地址处<code>EADD</code> <code>errorOut</code>页面内容，在用于泄漏的虚拟地址处<code>EADD disclose</code>页面内容，然后以错误的顺序<code>EEXTEND</code>页面。如果<code>EEXTEND</code>不包含被测量的数据块的地址，那么上面的步骤将产生与正确构造的enclave相同的测量结果。</p><p><code>EEXTEND</code>值得分析的最后一个方面是它对enclave迁移的支持。与<code>EADD</code>类似，<code>EEXTEND</code>测量的虚拟地址是相对于enclave的BASEADDR的。此外，唯一的SGX结构的内容将被<code>EEXTEND</code>测量是TCS。SGX的设计已经仔细地为所有代表enclave地址的TCS字段使用了相对地址，这是OENTRY,  OFSBASGX和OGSBASGX。</p><h3 id="5-6-5-度量EINIT">5.6.5 度量EINIT</h3><p><code>EINIT</code>指令(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)结束了enclave的构建过程。在enclave上成功调用<code>EINIT</code>之后，enclave的内容是“密封的”，这意味着系统软件不能使用<code>EADD</code>指令将代码和数据加载到enclave中，也不能使用<code>EEXTEND</code>指令更新enclave的度量。</p><p><code>EINIT</code>在enclave的SECS的MRENCLAVE字段上使用SHA-2算法(§3.1.3)。在<code>EINIT</code>之后，字段不再存储SHA-2算法的中间状态，而是存储安全哈希函数的最终输出。该值在<code>EINIT</code>完成后保持不变，并包含在SGX软件认证过程生成的认证签名中。</p><h2 id="5-7-SGX-Enclave版本支持">5.7 SGX Enclave版本支持</h2><p>由可信平台模块(§4.4)引入的软件认证模型(§3.3)依赖于度量，它本质上是一个内容散列，用于识别容器内的软件。使用内容哈希进行标识的缺点是，存放同一软件的不同版本的容器的标识之间没有关系。</p><p>在实践中，基于安全容器的系统在初始软件认证过程中不访问远程方来处理软件更新是非常理想的。这需要有能力在拥有旧版本软件的容器和拥有更新版本的容器之间迁移秘密。这一需求转化为对能够识别同一软件的两个版本之间关系的独立身份系统的需求。</p><p>SGX支持在表示同一软件的不同版本的enclave之间迁移秘密，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203650801.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203650801.png" srcset="data:image/png;base64,666" alt="image-20201128203650801"></p><p>秘密迁移特性依赖于一个一级证书层次结构(§3.2.1)，其中每个enclave作者都是一个证书颁发机构，每个enclave从作者那里收到一个证书。这些证书必须格式化为签名结构(SIGSTRUCT)，这在<a href="#5.7.1-Enclave%E8%AF%81%E4%B9%A6">§5.7.1</a>中有描述。这些证书中的信息是<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>中介绍的enclave身份方案的基础，它可以识别同一软件的不同版本之间的关系。</p><p><code>EINIT</code>指令(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)检查目标enclave的证书，并使用其中的信息填充SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)字段，这些字段描述了enclave基于证书的标识。这个过程在<a href="#5.7.4-%E5%BB%BA%E7%AB%8BEnclave%E8%BA%AB%E4%BB%BD">§5.7.4</a>中进行了总结。</p><p>最后，实际的秘密迁移过程是基于<code>EGETKEY</code>指令实现的密钥派生服务，在<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>中进行了描述。发送enclave使用<code>EGETKEY</code>指令根据其身份获得一个对称密钥(§3.1.1)，用该密钥加密其秘密，并将加密的秘密交给不受信任的系统软件。接收enclave将发送enclave的身份传递给<code>EGETKEY</code>，获得与上面相同的对称密钥，并使用该密钥解密从系统软件接收到的秘密。</p><p>从<code>EGETKEY</code>获得的对称密钥可以与加密原语一起使用，这些原语可以在不受信任的系统软件迁移到另一个enclave时保护enclave秘密的机密性(§3.1.2)和完整性(§3.1.3)。但是，仅凭对称密钥无法提供新鲜度保证(§3.1)，因此秘密迁移容易受到重放攻击。当被迁移的秘密是不可变的，例如当秘密是通过软件认证获得的加密密钥时，这是可以接受的。</p><h3 id="5-7-1-Enclave证书">5.7.1 Enclave证书</h3><p>SGX的设计要求每个enclave都有其作者颁发的证书。这一要求是由<code>EINIT</code>强制执行的(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)，它拒绝在没有有效证书的enclave上操作。</p><p>SGX实现使用格式化为签名结构(SIGSTRUCT)的证书，这些证书将由enclave构建工具链生成，如下图所示。</p><p><img src="D:%5CSource%5Cnotes%5Ctranslation-sgx-programming-model%5Cimage-20201128203825740.png" class="lazyload" data-srcset="D:%5CSource%5Cnotes%5Ctranslation-sgx-programming-model%5Cimage-20201128203825740.png" srcset="data:image/png;base64,666" alt="image-20201128203825740"></p><p>SIGSTRUCT证书由元数据字段和保证元数据真实性的（其中最有趣的字段在下表中显示）。字段的语义将在下面的部分中揭示。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203806483.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203806483.png" srcset="data:image/png;base64,666" alt="image-20201128203806483" style="zoom:80%;" /><p>RSA签名组成格式如下表所示：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203943298.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203943298.png" srcset="data:image/png;base64,666" alt="image-20201128203943298" style="zoom:80%;" /><p>enclave证书必须由RSA签名(§3.1.3)签名，该签名遵循RFC 3447中描述的方法，使用256位SHA-2]作为哈希函数来减少输入大小，以及PKCS #1 v1.5中描述的填充方法。</p><h3 id="5-7-2-基于证书的Enclave身份">5.7.2 基于证书的Enclave身份</h3><p>enclave的身份由其证书中的三个字段决定(<a href="#5.7.1-Enclave%E8%AF%81%E4%B9%A6">§5.7.1</a>)：用于签署证书的RSA密钥的模数(模数)、enclave的产品ID(ISVPRODID)和安全版本号(ISVSVN)。</p><p>用于颁发证书的公共RSA密钥标识enclave的作者。用于颁发enclave证书的所有RSA密钥必须将公开指数设置为3，因此它们仅通过模量进行区分。SGX不使用密钥的整个模量，而是模量的256位SHA-2哈希。这称为签名者度量(MRSIGNER)，与标识enclave内容的SHA-2散列的enclave度量(MRENCLAVE)名称量级相同。</p><p>SGX实现依赖于一个硬编码的MRSIGNER值来识别由Intel颁发的证书。拥有英特尔颁发的证书的enclave可以获得额外的特权，这在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中有讨论。</p><p>enclave作者可以使用相同的RSA密钥为表示不同软件模块的enclave颁发证书。每个模块由一个唯一的产品ID(ISVPRODID)值标识。相反，假定证书具有相同ISVPRODID并由相同RSA密钥(因此具有相同的MRENCLAVE)颁发的所有enclave代表同一软件模块的不同版本。通常假定证书由不同密钥签名的enclave包含不同的软件模块。</p><p>表示模块的不同版本的enclave可以具有不同的安全版本号(SVN)。SGX的设计不允许秘密从具有较高SVN的enclave迁移到具有较低SVN的enclave。此限制旨在帮助分发安全补丁，如下所示。</p><p>如果在enclave中发现安全漏洞，作者可以发布具有更高SVN的固定版本。随着用户升级，SGX将帮助机密从enclave的脆弱版本转移到固定版本。一旦用户的秘密迁移完成，SGX中的SVN限制将基于构建易受攻击的enclave版本并使用它读取迁移后的秘密来转移任何攻击。</p><p>增加功能的软件升级不应该伴随着SVN的增加，因为SGX允许秘密在具有匹配SVN值的enclave之间自由迁移。如上所述，只有在发现安全漏洞时，软件模块的SVN才应该增加。SIGSTRUCT只给ISVSVN字段分配2个字节，转换成65,536个可能的SVN值。如果一个大型团队(错误地)设置了一个连续构建系统，为它生成的每个软件构建分配一个新的SVN，并且每个代码更改触发一个构建，那么这个空间就会耗尽。</p><h3 id="5-7-3-CPU安全版本号">5.7.3 CPU安全版本号</h3><p>SGX实现本身有一个安全版本号(CPUSVN)，除了enclave的身份信息之外，它还用于<code>EGETKEY</code>实现的密钥派生过程中。CPUSVN是一个128位的值，根据SDM，它反映了处理器的微码更新版本。</p><p>SDM没有描述CPUSVN的结构，但是它指出使用整型比较来比较CPUSVN的值是没有意义的，并且只有一些CPUSVN值是有效的。此外，CPUSVNs承认的排序关系与enclave SVNs之间的排序关系具有相同的语义。特别地，一个SGX实现将考虑所有具有较低SVN的SGX实现由于安全漏洞而受到损害，并且不会信任它们。</p><p>SGX的一项专利披露，CPUSVN是小整数的串联，这些小整数表示构成SGX实现的各种组件的svn。这种结构与SDM中所做的所有声明一致。</p><h3 id="5-7-4-建立Enclave身份">5.7.4 建立Enclave身份</h3><p>当EINIT(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)指令准备执行代码的enclave时，它还会设置SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)字段，这些字段组成enclave的基于证书的标识，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204429025.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204429025.png" srcset="data:image/png;base64,666" alt="image-20201128204429025"></p><p><code>EINIT</code>需要颁发给enclave的SIGSTRUCT证书的虚拟地址，并使用证书中的信息初始化enclave的SECS中的基于证书的标识信息。在使用证书中的信息之前，<code>EINIT</code>首先验证其RSA签名。SIGSTRUCT字段Q1和Q2，以及RSA指数3，简化了验证算法，这在§6.5中讨论。</p><p>如果发现SIGSTRUCT证书被正确签名，<code>EINIT</code>将按照下面几段中讨论的步骤确保将证书颁发给正在初始化的enclave。检查完成后，<code>EINIT</code>计算MRSIGNER,  SIGSTRUCT中模数字段的256位SHA-2哈希，并将其写入enclave的SECS中。<code>EINIT</code>还将ISVPRODID和ISVSVN字段从SIGSTRUCT复制到enclave的SECS中。正如在<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>中所解释的，这些字段构成了enclave的基于证书的标识。</p><p>在验证了SIGSTRUCT中的RSA签名之后，<code>EINIT</code>将签名的填充复制到enclave的SECS中的填充字段中。PKCS #1 v1.5填充方案不包含随机性，因此填充对于所有enclave应该具有相同的值。</p><p><code>EINIT</code>执行一些检查，以确保正在进行初始化的enclave确实是由提供的SIGSTRUCT证书授权的。最明显的检查包括确保SIGSTRUCT中的MRENCLAVE值等于enclave的度量，后者存储在enclave的SECS中的MRENCLAVE字段中。</p><p>但是，MRENCLAVE没有涵盖enclave的属性，这些属性存储在SECS的ATTRIBUTES字段中。正如在<a href="#5.6.2-%E5%BA%A6%E9%87%8FEnclave%E5%B1%9E%E6%80%A7">§5.6.2</a>中所讨论的，从MRENCLAVE中省略一个ATTRIBUTES有助于编写具有优化实现的enclave，这些实现可以在存在时使用架构扩展，也可以在没有扩展的情况下在CPU上工作的回退实现。当使用XFRM(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a> <a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)属性中的各种值构建时，这样的enclave可以正确执行。与此同时，允许系统软件在ATTRIBUTES字段中使用任意值，将危及SGX的安全保证。</p><p>当enclave使用软件认证(§3.3)访问机密时，用于构建该机密的附加值包含在SGX认证签名(<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>)中。这使认证过程中的远程方有机会拒绝使用不需要的ATTRIBUTES值构建的enclave。但是，当使用基于证书的身份验证的迁移过程获得机密时，没有远程方可以检查enclave的属性。</p><p>SGX设计通过让enclave作者在为enclave颁发的SIGSTRUCT证书的ATTRIBUTES和ATTRIBUTEMASK字段中为enclave传递一组可接受的属性值来解决这个问题。如果在SECS中的ATTRIBUTES字段和SIGSTRUCT中的ATTRIBUTESMASK字段之间的位不等于SIGSTRUCT中的ATTRIBUTES字段，<code>EINIT</code>将拒绝使用SIGSTRUCT初始化enclave。此检查可防止具有不需要的属性的enclave在迁移过程中获取或泄漏机密。</p><p>任何enclave作者都可以使用SIGSTRUCT来请求enclave的ATTRIBUTES字段中的任何位为零。但是，对于由Intel签署的enclave，某些位只能设置为1。<code>EINIT</code>有一个限制ATTRIBUTES比特的掩码，在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中讨论过。<code>EINIT</code>实现包含一个硬编码的MRSIGNER值，该值用于标识英特尔的特权enclave，并且只允许使用与受限制掩码中的任何位匹配的ATTRIBUTES值构建特权enclave。这个检查对于SGX软件认证过程的安全性是至关重要的，这在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中描述。</p><p>最后，<code>EINIT</code>还检查SIGSTRUCT中的VENDOR字段。专用于SIGSTRUCT的一节中对VENDOR字段的SDM描述表明，该字段本质上用于区分由Intel签名的特殊enclave(使用VENDOR值0x8086)和其他所有人的enclave(使用VENDOR值0)。然而，<code>EINIT</code>伪代码似乎暗示了SGX实现只检查VENDOR是否为0或0x8086。</p><h3 id="5-7-5-Enclave密钥分发">5.7.5 Enclave密钥分发</h3><p>SGX的秘密迁移机制基于<code>EGETKEY</code>指令提供给enclave的对称密钥分发服务，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204651510.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204651510.png" srcset="data:image/png;base64,666" alt="image-20201128204651510"></p><p><code>EGETKEY</code>生成的密钥是基于当前enclave的SECS中的身份信息和存储在支持SGX的处理器内的安全硬件中的两个秘密分发的。其中一个秘密是对基本没有文档记录的一系列转换的输入，这些转换为密钥分发过程背后的加密原语生成对称密钥。另一个秘密，在SDM中称为CR_SEAL_FUSES，是在关键推导材料中使用的信息片段之一。</p><p>SDM没有指定密钥分发算法，但SGX专利披露密钥是使用FIPS SP 800-108中描述的方法，使用AES-CMAC]作为伪随机函数(PRF)。同样的专利声明，用于密钥分发的秘密存储在CPU的e-fuse中，这一点在ISCA 2015 SGX教程中得到证实。</p><p>这一附加信息意味着，使用相同密钥分发材料的所有<code>EGETKEY</code>调用将产生相同的密钥，即使是跨CPU能量周期。此外，如果不访问存储在CPU e-fuse中的密钥，对手是不可能从特定密钥派生材料中获得密钥的。SGX的关键层次结构在<a href="#5.8.2%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81">§5.8.2</a>中有进一步的描述。</p><p>下面的段落讨论密钥分发材料中使用的数据片段，这些数据片段由下表中所示的密钥请求(KEYREQUEST)结构选择：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204721723.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204721723.png" srcset="data:image/png;base64,666" alt="image-20201128204721723" style="zoom:80%;" /><p>KEYREQUEST中的KEYNAME字段总是参与密钥生成，它指示要生成的键的类型。虽然SGX设计定义了一些密钥类型，但秘密迁移特性总是使用密封密钥。其他关键类型由SGX软件认证过程使用，将在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中概述。</p><p>KEYREQUEST中的KEYPOLICY字段有两个标志，用于指示是否将使用enclave的SECS中的MRENCLAVE和MRSIGNER字段进行密钥分发。虽然字段允许4个值，但只有两个值是有意义的，如下所述。</p><p>在KEYPOLICY中设置MRENCLAVE标志将分发的密钥与反映其内容的当前enclave度量绑定。其他enclave将无法获得相同的密钥。当分发的密钥用于加密enclave秘密时，这是非常有用的，因此它们可以由系统软件存储在非易失性内存中，从而在电源周期中存活。</p><p>如果设置了KEYPOLICY中的MRSIGNER标志，则分发的密钥将绑定到发布enclave证书的公共RSA密钥。因此，由同一作者发布的其他enclave可能能够获得相同的密钥，但要遵守下面的限制。这是唯一允许秘密迁移的KEYPOLICY值。</p><p>在KEYPOLICY中不设置标志没有什么意义。在这种情况下，分发的密钥没有有用的安全属性，因为它可以由与调用<code>EGETKEY</code>的enclave完全无关的其他enclave获得。相反，设置两个标志是多余的，因为仅设置MRENCLAVE就会导致分发的密钥绑定到当前enclave，这是最严格的策略。</p><p>KEYREQUEST结构指定了密钥分发过程中使用的enclave SVN (ISVSVN，<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>)和SGX实现SVN  (CPUSVN，<a href="#5.7.3-CPU%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC%E5%8F%B7">§5.7.3</a>)。但是，如果期望的enclave SVN大于当前enclave的SVN，或者期望的SGX实现的SVN大于当前实现的SVN,  <code>EGETKEY</code>将拒绝派生请求并生成一个错误代码。</p><p>SVN限制可以防止秘密从具有较高SVN的集合转移到具有较低SVN的集合，或者从具有较高SVN的SGX实现转移到具有较低SVN的实现。<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>认为SVN限制可以减少enclave和SGX实施中安全漏洞的影响。</p><p><code>EGETKEY</code>总是使用来自当前enclave的SECS的ISVPRODID值进行密钥分发。因此，秘密永远不能在其SIGSTRUCT证书为其分配不同产品ID的enclaves之间流动。</p><p>类似地，密钥分发材料总是包含128位所有者轮数(OWNEREPOCH)SGX配置寄存器的值。这个寄存器是由计算机的固件设置为一个秘密生成一次，并存储在非易失性内存。在计算机更改所有权之前，旧的所有者可以从非易失性内存中清除OWNEREPOCH，从而使新所有者无法解密任何可能留在计算机上的enclave机密。</p><p>由于密钥分发过程的加密特性，外部观察者无法关联使用不同的OWNEREPOCH值分发的密钥。这使得软件开发人员不可能使用本节中描述的<code>EGETKEY</code>分发的密钥来跟踪处理器更改所有者。</p><p><code>EGETKEY</code>分发材料还在KEYID字段中包含由enclave提供的256bit值。这使得enclave可以从<code>EGETKEY</code>生成密钥集合，而不是单个密钥。SDM规定KEYID应该用随机数填充，目的是帮助防止密钥损耗。</p><p>最后，密钥分发材料包括enclave的SECS中的ATTRIBUTES(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)字段的位和和KEYREQUEST结构中的ATTRIBUTESMASK字段。该掩码的作用是从密钥分发材料中删除一些ATTRIBUTES比特，从而使在具有不同属性的enclave之间迁移秘密成为可能。<a href="#5.6.2-%E5%BA%A6%E9%87%8FEnclave%E5%B1%9E%E6%80%A7">§5.6.2</a>和<a href="#5.7.4-%E5%BB%BA%E7%AB%8BEnclave%E8%BA%AB%E4%BB%BD">§5.7.4</a>解释此功能的需要及其安全含义。</p><p>在将掩码属性值添加到密钥生成材料之前，<code>EGETKEY</code>强制掩码位对应<code>INIT</code>和调试属性(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)。从实用的角度来看，这意味着秘密永远不会支持调试和生产的enclave之间迁移。</p><p>如果没有此限制，enclave作者使用相同的RSA密钥向调试和生产enclave颁发证书将是不安全的。调试enclave没有从SGX获得完整性保证，因此攻击者有可能修改调试enclave内的代码，使其泄漏它所能访问的任何秘密。</p><h2 id="5-8-SGX软件认证">5.8 SGX软件认证</h2><p>SGX实施的软件认证方案遵循了§3.3中概述的原则。启用SGX的处理器计算加载在每个enclave中的代码和数据的度量，这类似于TPM计算的度量(§4.4)。enclave内部的软件可以启动一个进程，从而产生SGX认证签名，其中包括enclave的度量和enclave消息。</p><p>SGX认证签名中使用的密码原语过于复杂，无法在硬件上实现，因此签名过程是由英特尔发行的一个有特权的引用Enclave来执行的，它可以访问SGX认证密钥。这个enclave在<a href="#5.8.2-%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81">§5.8.2</a>中进行了讨论。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204833328.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204833328.png" srcset="data:image/png;base64,666" alt="image-20201128204833328"></p><p>图79: 建立一个SGX enclave并进行软件认证过程涉及到SGX指令<code>EINIT</code>和<code>EREPORT</code>，以及两个由英特尔编写的特殊enclave，SGX启动enclave和SGX引用enclave。</p><p>将签名功能推入引用Enclave，就需要在正在进行软件认证的Enclave和引用Enclave之间建立安全通信路径。SGX设计通过本地认证机制解决了这个问题，enclave可以使用该机制向同一启用SGX的CPU托管的任何其他enclave证明其身份。<a href="#5.8.1-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81">§5.8.1</a>中描述的这个方案是通过<code>EREPORT</code>指令实现的。</p><p>引用enclave使用的SGX认证密钥在启用SGX的处理器离开工厂时不存在。认证密钥是稍后提供的，使用的过程包括一个由Intel发布的配置Enclave和两种特殊的<code>EGETKEY</code>(<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>)密钥类型。这一过程的公开细节概述在<a href="#5.8.2-%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81">§5.8.2</a>中。</p><p>SGX启动enclave和<code>EINITTOKEN</code>结构将在<a href="#5.9-SGX%E5%90%AF%E5%8A%A8%E6%8E%A7%E5%88%B6">§5.9</a>中讨论。</p><h3 id="5-8-1-本地认证">5.8.1 本地认证</h3><p>enclave通过如图80所示的<code>EREPORT</code>指令向另一个目标enclave证明其身份。SGX指令生成一个认证报告(报告)，该报告以加密方式将enclave提供的消息与enclave的基于度量(<a href="#5.6-SGX-Enclave%E5%BA%A6%E9%87%8F">§5.6</a>)和基于证书(<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>)的身份绑定。加密绑定由MAC标签(§3.1.3)完成，MAC标签使用对称密钥计算，该密钥仅在目标enclave和SGX实现之间共享。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204914002.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204914002.png" srcset="data:image/png;base64,666" alt="image-20201128204914002"></p><p>​图80：EREPORT数据流</p><p><code>EREPORT</code>指令从enclave的SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)中读取当前enclave的标识信息，并使用它填充报告结构。具体来说，<code>EREPORT</code>会复制SECS字段，这些字段表示enclave的度量(MRENCLAVE)、基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)和属性(ATTRIBUTES)。认证报告还包括SGX实现的SVN(CPUSVN)和enclave提供的64字节(512位)消息。</p><p>接收认证报告的目标enclave可以确信报告的真实性，如图81所示。这份报告的真实性证明是它的MAC标签。验证MAC所需的密钥只能由目标enclave获得，通过要求<code>EGETKEY</code>(<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>)分发一个报告密钥。SDM声明MAC标记是使用基于块加密的MAC (CMAC)计算的，但是没有指定底层密码。SGX文件之一声明CMAC是基于128位AES。</p><p><code>EGETKEY</code>返回的报告密钥来自于嵌入在处理器中的一个秘密(<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>)，密钥材料包括目标enclave的度量。可以确保目标enclave报告中的MAC标签是由SGX产生的，原因如下。底层密钥分发的加密特性推导和MAC算法确保只有SGX所实现可以产生MAC标签，因为它是唯一的实体，可以访问处理器的秘密，这是不可能对攻击者获得报告密钥不知道处理器的秘密。SGX的设计保证了<code>EGETKEY</code>生成的密钥依赖于调用enclave的度量，因此只有目标enclave才能获得报告中用于生成MAC标签的密钥。</p><p>当KEYNAME设置为与报告密钥相关联的值时，<code>EREPORT</code>使用与EGETKEY相同的密钥分发过程。因此，<code>EREPORT</code>需要<em>报告目标信息</em>(TARGETINFO)结构的虚拟地址，该结构包含基于度量的标识和目标enclave的属性。</p><p>在分发一个报告密钥时，<code>EGETKEY</code>的行为与它在密封密钥情况下的行为略有不同，如图81所示。密钥生成材料从不包括与enclave的基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)对应的字段，并且KEYREQUEST结构中的KEYPOLICY字段将被忽略。因此，该报告只能由目标enclave加以核实。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204934312.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204934312.png" srcset="data:image/png;base64,666" alt="image-20201128204934312"></p><p>图81: 由<code>EREPORT</code>创建的报告结构的真实性可以而且应该由报告的目标enclave验证。目标代码使用<code>EGETKEY</code>获取嵌入在报告结构中的MAC标记使用的密钥，然后验证标记。</p><p>此外，SGX实现用于密钥生成的SVN  (CPUSVN)值是由当前的CPUSVN决定的，而不是从密钥请求结构中读取。因此，SGX实现升级，增加CPUSVN使所有未完成的报告无效。鉴于CPUSVN的增加与安全修复有关，<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>中的论证表明，这一限制可能会减少SGX实现中漏洞的影响。</p><p>最后，<code>EREPORT</code>将密钥生成材料中的KEYID字段设置为SGX配置寄存器(CR_REPORT_KEYID)的内容，该寄存器在初始化SGX时以随机值初始化。KEYID值也保存在认证报告中，但是它不包含在MAC标签中。</p><!--### 5.8.2 远程认证远程认证过程包括引用Enclave和基础密钥，在Intel的一份出版物中对其进行了高层介绍。本节的内容基于SDM、一篇SGX论文和ISCA 2015 SGX tutorial。SGX的软件认证方案，如图82所示，依赖于密钥生成设施和供应服务，两者都由英特尔运营。![image-20201128205219513](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128205219513.png)图82:SGX的软件认证基于存储在处理器芯片内的e-fuse中的两个秘密，以及从英特尔供应服务接收的密钥。在制造过程中，一个启用了SGX的处理器与英特尔的密钥生成设备进行通信，并有两个秘密被烧到e-fuse中。e-fuse是一种一次性可编程存储介质，可以经济地包含在高性能芯片上。我们将把存储在e-fuse中的秘密称为供应秘密和密封秘密。供应秘密是输出`EGETKEY`使用的SGX主衍生密钥的过程的主要输入，图78、79、80和81中引用了这个过程。密封秘密不会通过SDM中记录的任何架构机制暴露给软件。只有当秘密包含在`EGETKEY`实现的密钥推导过程所使用的材料中时，该秘密才能被访问([§5.7.5](#5.7.5-Enclave密钥分发))。SDM中的伪代码使用CR_SEAL_FUSES起存其名来引用密封机密。名称“Seal Secret”和“Provisioning Secret”与英特尔的官方文件有所不同，后者使用“Seal Key”和“Provisioning  Key”来指代存储在e-fuse中的秘密和`EGETKEY`分发的密钥，这令人困惑。SDM简要地描述了`EGETKEY`生成的密钥，但是没有官方文档明确地描述e-fuse中的秘密。下面的描述是对所有公共信息来源的唯一解释，它与SDM关于关键来源的所有声明一致。![image-20201128205236786](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128205236786.png)![image-20201128205249675](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128205249675.png)## 5.9 SGX启动控制### 5.9.1 Enclave属性访问控制![image-20201128210858231](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128210858231.png)### 5.9.2 许可证### 5.9.3 系统软件可以执行启动策略### 5.9.4 Enclave不能损坏主机计算机### 5.9.5 与杀毒软件交互-->]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSDN博客保存为PDF</title>
      <link href="2020/11/26/useful-skills/csdn-pdf/"/>
      <url>2020/11/26/useful-skills/csdn-pdf/</url>
      
        <content type="html"><![CDATA[<p>F12打开开发者工具，在Console输入以下js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> articleBox = $(<span class="string">&quot;div.article_content&quot;</span>);</span><br><span class="line">articleBox.removeAttr(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;#btn-readmore&quot;</span>).parent().remove();</span><br><span class="line">$(<span class="string">&quot;#side&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;#comment_title, #comment_list, #comment_bar, #comment_form, .announce, #ad_cen, #ad_bot&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.nav_top_2011, #header, #navigator&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.csdn-side-toolbar,.template-box,.reward-user-box,.blog-footer-bottom&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.p4course_target, .comment-box, .recommend-box, #csdn-toolbar, #tool-box,#dmp_ad_58, .more-toolbox, .article-info-box, .btn-readmore, .pub-footer-new&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;aside&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.tool-box&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;main&quot;</span>).css(<span class="string">&#x27;display&#x27;</span>,<span class="string">&#x27;content&#x27;</span>); </span><br><span class="line">$(<span class="string">&quot;main&quot;</span>).css(<span class="string">&#x27;float&#x27;</span>,<span class="string">&#x27;left&#x27;</span>); </span><br><span class="line">$(<span class="string">&quot;#mainBox&quot;</span>).width(<span class="string">&quot;100%&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].style.zoom=<span class="number">0.8</span>;</span><br><span class="line"><span class="built_in">window</span>.print();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">doPrint</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> articleBox = $(<span class="string">&quot;div.article_content&quot;</span>);</span><br><span class="line">articleBox.removeAttr(<span class="string">&quot;style&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> head_str = <span class="string">&quot;&quot;</span>;       </span><br><span class="line"><span class="keyword">var</span> foot_str = <span class="string">&quot;&quot;</span>;   </span><br><span class="line"><span class="keyword">var</span> older = <span class="built_in">document</span>.body.innerHTML;       </span><br><span class="line"><span class="keyword">var</span> title= <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;article-title-box&#x27;</span>)[<span class="number">0</span>].innerHTML; </span><br><span class="line"><span class="keyword">var</span> main_body = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;article_content&#x27;</span>)[<span class="number">0</span>].innerHTML;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = head_str + title + main_body + foot_str;</span><br><span class="line">$(<span class="string">&quot;#mainBox&quot;</span>).width(<span class="string">&quot;100%&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].style.zoom=<span class="number">0.8</span>;     </span><br><span class="line"><span class="built_in">window</span>.print();</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = older;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Useful </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reproduction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学 Notes</title>
      <link href="2020/11/25/learning-notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/"/>
      <url>2020/11/25/learning-notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="古典替换密码">古典替换密码</h2><h3 id="恺撒密码">恺撒密码</h3><p>每个字母用其后的第三个字母替换，即</p><blockquote><p>Plain:   ABCDEFGHIJKLMNOPQRSTUVWXYZ</p><p>Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC</p></blockquote><ul><li>恺撒密码的一般形式，可以将字母移动的位数由3变为1-25中的任何一个</li></ul><h3 id="混合单表替换密码">混合单表替换密码</h3><ul><li>每个字母可以用其它任何一个字母替换（不能重复）</li><li>密钥长度为26个字母，因为每个字母需要一个映射</li></ul><h3 id="简单的单表替换密码">简单的单表替换密码</h3><ul><li>设置一个没有重复字母的“密钥字”，其它字母按顺序写在密钥字最后字母后面</li></ul><blockquote><p>给定密钥字 JULISCAER</p><p>Plain:   ABCDEFGHIJKLMNOPQRSTUVWXYZ</p><p>Cipher: JULISCAERTVWXYZBDFGHKMNOPQ</p></blockquote><h3 id="多字母替换密码">多字母替换密码</h3><p>使用多个单字母替换表，因此一个字母可以被多个字母替换：用一个密钥选择每个字母使用哪个字母表，密钥的第i个字母表示使用第i个字母表，依次使用每个字母表，当密钥的字母使用完后，再从头开始</p><h2 id="古典置换密码">古典置换密码</h2><ul><li>方法：通过重新编排消息字母隐藏信息</li><li>特点：没有改变原来消息的字母集</li><li>关键思想：<strong>按一定规则写出明文，按另一规则读出密文</strong></li><li>密钥：用于读密文的方法和写明文的方法</li></ul><h2 id="分组密码">分组密码</h2><p>在分组密码中，消息被分成许多块，每块都要被加密</p><h3 id="替换运算-S-boxes">替换运算 S-boxes</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210011605.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210011605.png" srcset="data:image/png;base64,666" alt="image-20201125210011605" style="zoom:56%;" /><ul><li><p>一个二进制字用其它二进制字替换，这种替换函数就构成密钥，可以看作是一个大的查表运算</p></li><li><p>混淆：使作用于明文的密钥和密文之间的关系复杂化</p></li></ul><h3 id="置换运算-P-boxes">置换运算 P-boxes</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205943924.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205943924.png" srcset="data:image/png;base64,666" alt="image-20201125205943924" style="zoom:67%;" /><ul><li>二进制字次序被打乱，重新排序的方法构成密钥</li><li>扩散：将明文及密钥的影响尽可能迅速地散布到较多个输出的密文中</li></ul><h4 id="雪崩效应">雪崩效应</h4><ul><li>输入改变1bit, 导致近一半的比特发生变化</li><li>保证小的输入变化导致大的输出变化</li></ul><h4 id="完备性效应">完备性效应</h4><ul><li>每个输出比特是所有输入比特的复杂函数的输出</li><li>保证每个输出比特依赖于所有的输入比特</li></ul><h3 id="Feistel密码">Feistel密码</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125203244552.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125203244552.png" srcset="data:image/png;base64,666" alt="image-20201125203244552" style="zoom: 50%;" /><blockquote><ul><li>把输入块分成左右两部分</li><li>轮函数g是一个S-P网络</li><li>由第i个密钥控制（子密钥）</li></ul><p>L(i) = R(i-1)</p><p>R(i) = L(i-1) xor g(K(i), R(i-1))</p></blockquote><ul><li>求逆很容易</li><li>实际中，一些这样的连续变换形成完整密码变换</li></ul><h4 id="Feistel密码设计">Feistel密码设计</h4><ul><li>分组大小：增加分组长度会提高安全性, 但降低了密码运算速度</li><li>密钥大小：增加密钥长度可以提高安全性(使得穷搜索困难)，但降低了密码速度</li><li>轮数：增加轮数可以提高安全性，但降低速度</li><li>子密钥生成：子密钥生成越复杂就越安全，但降低速度</li></ul><h3 id="Lucifer">Lucifer</h3><ul><li>分组长度是128-bit，密钥长度是128-bit</li><li>每轮使用的子密钥是密钥的左半部分</li><li>密钥每次要向左旋转56-bits，所以密钥的每部分都参加运算</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210039067.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210039067.png" srcset="data:image/png;base64,666" alt="image-20201125210039067" style="zoom: 67%;" /><p>轮函数的具体结构：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205433305.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205433305.png" srcset="data:image/png;base64,666" alt="image-20201125205433305" style="zoom:67%;" /><h2 id="现代分组加密算法">现代分组加密算法</h2><h3 id="简化的DES-S-DES">简化的DES (S-DES)</h3><p>加密算法涉及五个函数：</p><ul><li>初始置换 IP</li><li>复合函数 f<sub>k1</sub> ，由密钥K确定，具有转换和替换的运算</li><li>转换函数 SW</li><li>复合函数 f<sub>k2</sub></li><li>初始置换IP的逆置换 IP<sup>-1</sup></li></ul><h4 id="加解密流程">加解密流程</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126105757628.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126105757628.png" srcset="data:image/png;base64,666" alt="image-20201126105757628" style="zoom:55%;" /><ul><li><p>密文 = IP<sup>-1</sup>(f<sub>k2</sub>(SW(f<sub>k1</sub>(IP(明文)))))</p></li><li><p>明文 = IP<sup>-1</sup>(f<sub>k1</sub>(SW(f<sub>k2</sub>(IP(密文)))))</p></li><li><p>密钥生成：</p><ul><li><p>P10(k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub>, k<sub>4</sub>, k<sub>5</sub>, k<sub>6</sub>, k<sub>7</sub>, k<sub>8</sub>, k<sub>9</sub>, k<sub>10</sub>) = (k<sub>3</sub>, k<sub>5</sub>, k<sub>2</sub>, k<sub>7</sub>, k<sub>4</sub>, k<sub>10</sub>, k<sub>1</sub>, k<sub>9</sub>, k<sub>8</sub>, k<sub>6</sub>)</p></li><li><p>P8(k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub>, k<sub>4</sub>, k<sub>5</sub>, k<sub>6</sub>, k<sub>7</sub>, k<sub>8</sub>, k<sub>9</sub>, k<sub>10</sub>) = (k<sub>6</sub>, k<sub>3</sub>, k<sub>7</sub>, k<sub>4</sub>, k<sub>8</sub>, k<sub>5</sub>, k<sub>10</sub>, k<sub>9</sub>)</p></li><li><p>LS-1为循环左移1位，LS-2为循环左移2位</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126120725293.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126120725293.png" srcset="data:image/png;base64,666" alt="image-20201126120725293" style="zoom:50%;" /></li></ul></li><li><p>IP函数：</p><blockquote><p>IP=   1 2 3 4 5 6 7 8</p><p>​        2 6 3 1 4 8 5 7</p><p>IP<sup>-1</sup>=   1 2 3 4 5 6 7 8</p><p>​          4 1 3 5 7 2 8 6</p></blockquote></li><li><p>函数f<sub>k</sub>：f<sub>k</sub>(L, R) = (L xor F(R, SK), R) , 其中SK为子密钥</p><ul><li><p>F是一个4-bit到4-bit的映射：</p><ul><li><p>首先对R做扩张/置换(E/P)运算</p><blockquote><p>E/P运算：(1, 2, 3, 4)  =&gt;  (4, 1, 2, 3, 2, 3, 4, 1)</p></blockquote></li><li><p>将子密钥SK（对应具体算法中的K<sub>1</sub>和K<sub>2</sub>）与E/P运算的结果异或得到8-bit数</p><blockquote><p>P0,0    P0,1    P0,2    P0,3</p><p>P1,0    P1,1    P1,2    P1,3</p></blockquote></li><li><p>第一行进入S盒S0，第二行进入S盒S1，分别产生2-bit输出</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123020454.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123020454.png" srcset="data:image/png;base64,666" alt="image-20201126123020454" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123032631.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123032631.png" srcset="data:image/png;base64,666" alt="image-20201126123032631" style="zoom:50%;" /><blockquote><p>第1和第4输入比特决定行，第2和第3输入比特决定列，以确定选取S-盒元素的位置</p><p>如 (P0,0 P0,3)=(0 0),并且(P0,1 P0,2)=(1 0)，则选取S盒矩阵的第0行第2列的元素作为2-bit输出</p></blockquote></li></ul></li></ul></li><li><p>加密具体过程</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123926304.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123926304.png" srcset="data:image/png;base64,666" alt="image-20201126123926304" style="zoom:55%;" /><h3 id="数据加密标准DES">数据加密标准DES</h3><h4 id="DES加密流程">DES加密流程</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126130554342.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126130554342.png" srcset="data:image/png;base64,666" alt="image-20201126130554342" style="zoom:60%;" /><blockquote><ol><li>对明文X，通过一个固定的初始置换IP得到X<sub>0</sub>：<br>X<sub>0</sub> = IP(X) = L<sub>0</sub>R<sub>0</sub> , 分为左右两部分。</li><li>函数F的16次迭代：L<sub>i</sub>R<sub>i</sub> (1&lt;=i&lt;=16）<br>L<sub>i</sub> = R<sub>i-1</sub> ,    R<sub>i</sub> = L<sub>i-1</sub> xor F(R<sub>i-1</sub>, K<sub>i</sub>)<br>其中K<sub>i</sub>是长为48位的子密钥。</li><li>对比特串R<sub>16</sub>L<sub>16</sub>使用逆置换IP<sup>-1</sup>得到密文Y：<br>Y = IP<sup>-1</sup>(R<sub>16</sub>L<sub>16</sub>)</li></ol></blockquote><p><a href="#DES%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E8%A1%A8">加密相关的表见附录</a></p><h4 id="DES一轮加密">DES一轮加密</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140254793.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140254793.png" srcset="data:image/png;base64,666" alt="image-20201126140254793" style="zoom:50%;" /><h5 id="轮函数F">轮函数F</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140406545.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140406545.png" srcset="data:image/png;base64,666" alt="image-20201126140406545" style="zoom:40%;" /><p>F(R<sub>i-1</sub>, K<sub>i</sub>) ，输入为32-bit的R<sub>i-1</sub>和48-bit的子密钥K<sub>i</sub></p><blockquote><ol><li>对R<sub>i-1</sub>使用扩展函数E，扩展为48-bit</li><li>计算 E(R<sub>i-1</sub>) xor K<sub>i</sub> ，结果写成8个6-bit串 B=b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>b<sub>6</sub></li><li>使用8个4*16的S盒，其中的元素取0~15的整数，每个S盒输出为4-bit串：<ul><li>b<sub>1</sub>b<sub>6</sub>确定S盒的行数，b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>确定S盒的列数</li></ul></li><li>最后，P为固定置换，输出为32-bit串</li></ol></blockquote><h4 id="密钥K计算子密钥">密钥K计算子密钥</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126142937157.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126142937157.png" srcset="data:image/png;base64,666" alt="image-20201126142937157" style="zoom:55%;" /><p>密钥K是长度为64的位串：56位参加子密钥编排，8位是奇偶校验位，在密钥编排的计算中，不参加运算。</p><blockquote><ol><li><p>给定64位的密钥K，放弃奇偶校验位(8, 16, …, 64)，先进行PC-1固定置换，结果为前28-bit的C<sub>0</sub>和后28-bit的D<sub>0</sub></p></li><li><p>对1 &lt;= i &lt;= 16，计算</p><p>C<sub>i</sub> = LS<sub>i</sub>(C<sub>i-1</sub>)</p><p>D<sub>i</sub> = LS<sub>i</sub>(D<sub>i-1</sub>)</p><p>其中LS<sub>i</sub>表示循环左移1或2位，当i=1,2,9,16时移1位，其他情况移2位</p></li><li><p>计算 K<sub>i</sub> = PC-2(C<sub>i</sub>D<sub>i</sub>)</p></li></ol></blockquote><h4 id="DES的S盒">DES的S盒</h4><p>DES的核心是S盒</p><ul><li>S盒不是它输入变量的线性函数</li><li>改变S盒的一个输入位至少要引起两位的输出改变</li><li>对任何一个S盒，如果固定一个输入比特，其它输入变化时，输出数字中0和1的总数近于相等</li></ul><h4 id="双重DES">双重DES</h4><blockquote><p>加密：C = E<sub>K2</sub>[E<sub>K1</sub>[P]]</p><p>解密：P = D<sub>K1</sub>[D<sub>K2</sub>[P]]</p></blockquote><h4 id="三重DES">三重DES</h4><blockquote><p>两个密钥加密：C = E<sub>K1</sub>[D<sub>K2</sub>[E<sub>K1</sub>[P]]]</p></blockquote><h3 id="IDEA">IDEA</h3><ul><li>分组长度为64位，子分组长度为16位</li><li>密钥长度为128位</li><li>进行8轮循环</li><li>同一算法既可以加密也可以解密</li></ul><h4 id="IDEA加密总体方案">IDEA加密总体方案</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126144958945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126144958945.png" srcset="data:image/png;base64,666" alt="image-20201126144958945" style="zoom:50%;" /><h4 id="IDEA加密具体过程">IDEA加密具体过程</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145235594.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145235594.png" srcset="data:image/png;base64,666" alt="image-20201126145235594" style="zoom:60%;" /><ul><li><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145539436.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145539436.png" srcset="data:image/png;base64,666" alt="image-20201126145539436" style="zoom:80%;" />是整数模2<sup>16</sup>+1乘 (IDEA的S盒)</li><li><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126145717202.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126145717202.png" srcset="data:image/png;base64,666" alt="image-20201126145717202">是整数模2<sup>16</sup>加</li></ul><h4 id="IDEA的密钥生成">IDEA的密钥生成</h4><p>52个16-bit的加密子密钥从128-bit的密钥中生成：</p><blockquote><ol><li>前8个子密钥直接从密钥中取出；</li><li>对密钥进行25-bit循环左移，接下来的密钥从中取出；</li><li>重复进行直到52个子密钥全部生成。</li></ol></blockquote><p>解密密钥从加密子密钥中导出：</p><blockquote><ul><li>解密循环 i 的前4个子密钥从加密循环 10-i 的前4个子密钥中导出：<ul><li>解密密钥的第1、4个子密钥对应于1、4加密子密钥的<strong>乘法逆元</strong>；</li><li>解密密钥的第2、3个子密钥对应于2、3加密子密钥的<strong>加法逆元</strong></li></ul></li><li>对前8个循环来说，循环 i 的最后两个子密钥等于加密循环 9-i 的最后两个子密钥</li></ul></blockquote><h3 id="AES-Rijndael">AES-Rijndael</h3><ul><li>可变块长、可变密钥长度<ul><li>分组长度指定为128位</li><li>密钥长度为128，192或256位，相应的迭代轮数为10、12和14</li></ul></li></ul><h4 id="AES框架">AES框架</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126151721262.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126151721262.png" srcset="data:image/png;base64,666" alt="image-20201126151721262" style="zoom:60%;" /><h4 id="AES轮函数">AES轮函数</h4><p>每一轮迭代的结构都一样，只是最后一轮省略了列混合变换：</p><h5 id="字节替换-Byte-Sub">字节替换(Byte Sub)</h5><p>对数据的每一字节应用一个非线性变换；</p><p><a href="#%E5%AD%97%E8%8A%82%E6%9B%BF%E6%8D%A2%E8%A1%A8">替换表</a>是一个16×16的矩阵。表中纵向的x取自状态矩阵中的高4比特，横向的y取自低4比特。</p><h5 id="行移位-Shift-Row">行移位(Shift Row)</h5><p>对每一行的字节循环重新排序，可以表示为:  B<sub>i,j</sub> = A<sub>i,(i+j)mod4</sub></p><h5 id="列混合-Mix-Column">列混合(Mix Column)</h5><p>对矩阵的列应用一个线性变换:</p><ul><li>将状态的每一列视为GF(2<sup>8</sup>)上的多项式S(x)，然后乘以固定多项式a(x)，并模除x<sup>4</sup>+1。其中a(x) = {03}x<sup>3</sup>+{01}x<sup>2</sup>+{01}x+{02}</li><li>a(x)存在关于x<sup>4</sup>+1的逆元，变换的矩阵为：</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163656799.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163656799.png" srcset="data:image/png;base64,666" alt="image-20201126163656799" style="zoom:50%;" /><ul><li>列混合变换的结果为：</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163743098.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163743098.png" srcset="data:image/png;base64,666" alt="image-20201126163743098" style="zoom:50%;" /><h5 id="轮密钥加-Add-Round-Key">轮密钥加(Add Round Key)</h5><ul><li><p>把轮密钥混合到中间数据，对状态和每轮的子密钥进行简单的异或操作</p></li><li><p>每轮子密钥是通过密钥调度算法从主密钥中产生，子密钥长度等于分组长度</p></li><li><p>轮密钥加运算需要用到4个导出的32比特子密钥</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164006477.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164006477.png" srcset="data:image/png;base64,666" alt="image-20201126164006477" style="zoom:66%;" /><h4 id="AES子密钥生成">AES子密钥生成</h4><p>Rijindael算法每一轮需要用到N<sub>b</sub>比特的子密钥，共有N<sub>r</sub>轮，另外，第一次轮密钥加的时候也需要用一轮子密钥，于是总共需要N<sub>b</sub>*(N<sub>r</sub>+1)比特的子密钥，对于AES-128来说就是用1408比特的子密钥</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164423818.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164423818.png" srcset="data:image/png;base64,666" alt="image-20201126164423818" style="zoom:67%;" /><h4 id="AES解密过程">AES解密过程</h4><p>逆字节替换、逆行移位、逆列混合、轮密钥加(其逆变换就是本身)</p><h3 id="分组密码工作模式">分组密码工作模式</h3><h4 id="ECB-电码本模式">ECB 电码本模式</h4><ul><li>消息分成相互独立的加密模块</li><li>每块独立使用DES算法</li><li>适合少量的数据加密</li><li>如果最后一个分组长度不够，需要填充</li><li>对于同一个明文分组，如果出现多次，其密文是相同的，因为每次的加密密钥都相同 (<strong>缺陷</strong>)</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164736650.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164736650.png" srcset="data:image/png;base64,666" alt="image-20201126164736650" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165303436.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165303436.png" srcset="data:image/png;base64,666" alt="image-20201126165303436" style="zoom:67%;" /><h4 id="CBC-密码分组链接模式">CBC 密码分组链接模式</h4><ul><li>使重复的明文分组产生不同的密文分组：每次加密使用相同加密密钥，但是输入是当前明文分组盒前一个密文分组的异或</li><li>适合加密长度大于64比特的消息</li><li>如果最后一个分组长度不够，需要填充</li><li>可以用来进行用户鉴别</li><li>错误传播</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165145190.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165145190.png" srcset="data:image/png;base64,666" alt="image-20201126165145190" style="zoom:67%;" /><ul><li>解密时，每一个密文分组被解密后，再与前一个密文分组异或，便能得到明文分组</li><li>产生第一个密文分组时，需要一个初始向量IV与第一个明文分组异或，IV对于收发方都是已知的，且应该像密钥一样被保护</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165215403.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165215403.png" srcset="data:image/png;base64,666" alt="image-20201126165215403" style="zoom:67%;" /><h4 id="CFB-密码反馈模式">CFB 密码反馈模式</h4><ul><li>消息作为比特流，不需要对消息填充</li><li>适合数据以比特或字节为单位出现</li><li>错误传播</li><li>可以用于认证</li></ul><p>加密过程：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170039554.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170039554.png" srcset="data:image/png;base64,666" alt="image-20201126170039554" style="zoom:67%;" /><p>解密过程：</p><ul><li>将收到的密文单元和加密函数的输出进行异或</li><li>仍然使用加密算法而不是解密算法</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170254044.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170254044.png" srcset="data:image/png;base64,666" alt="image-20201126170254044" style="zoom:67%;" /><h4 id="OFB-输出反馈模式">OFB 输出反馈模式</h4><ul><li>结构类似CFB，不同之处在于OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器</li><li>消息作为比特流，不需要对消息填充</li><li>比特错误不会被传播</li></ul><p>加密过程：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170529982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170529982.png" srcset="data:image/png;base64,666" alt="image-20201126170529982" style="zoom:67%;" /><p>解密过程：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170543567.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170543567.png" srcset="data:image/png;base64,666" alt="image-20201126170543567" style="zoom:67%;" /><h4 id="CTR-计算器模式">CTR 计算器模式</h4><ul><li>可并行加密</li><li>预处理</li><li>吞吐量仅受可使用并行数量的限制</li><li>加密数据块随机访问</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170708908.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170708908.png" srcset="data:image/png;base64,666" alt="image-20201126170708908" style="zoom:67%;" /><h2 id="流密码">流密码</h2><h3 id="流密码简单结构">流密码简单结构</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083144531.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083144531.png" srcset="data:image/png;base64,666" alt="image-20201127083144531" style="zoom:67%;" /><ul><li>密钥源是一个容易记住的密钥</li><li>密钥流生成器生成一个周期较长、可用于加解密运算的伪随机序列</li></ul><h3 id="同步流密码与自同步流密码">同步流密码与自同步流密码</h3><h4 id="同步流密码">同步流密码</h4><ul><li>密钥流的产生与明文消息流相互独立</li><li>无错误传播：在传输期间一个密文字符被改变只影响该符号的恢复，不会对后继的符号产生影响</li></ul><h4 id="自同步流密码">自同步流密码</h4><p>密钥流的产生与之前已经产生的若干密文有关</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083600988.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083600988.png" srcset="data:image/png;base64,666" alt="image-20201127083600988" style="zoom:67%;" /><h3 id="线性反馈移位寄存器-LFSR">线性反馈移位寄存器 LFSR</h3><ul><li>用于生成密钥流：<ul><li>LFSR的结构非常适合硬件实现</li><li>LFSR的结构便于使用代数方法进行理论分析</li><li>产生的序列的周期可以很大</li><li>产生的序列具有良好的统计特性</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083933077.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083933077.png" srcset="data:image/png;base64,666" alt="image-20201127083933077" style="zoom:67%;" /><ul><li><p>反馈函数为：<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084035769.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084035769.png" srcset="data:image/png;base64,666" alt="image-20201127084035769" style="zoom:60%;" />， 其中加法运算为模2加，乘法为普通乘法</p></li><li><p>第t+1时刻第i级寄存器的内容为：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084404733.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084404733.png" srcset="data:image/png;base64,666" alt="image-20201127084404733" style="zoom:60%;" /></li><li><p>LFSR的联接多项式为：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127090215010.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127090215010.png" srcset="data:image/png;base64,666" alt="image-20201127090215010" style="zoom:67%;" /></li></ul><h4 id="LFSR的周期与m序列">LFSR的周期与m序列</h4><ul><li>一个n级LFSR序列的周期最大只能是2<sup>n</sup>-1</li><li>若n级LFSR产生的非零序列的周期为2<sup>n</sup>-1，则称其为m序列</li><li>一个n级LFSR为最长移位寄存器的充要条件是它的联接多项式为F<sub>2</sub>上的n次本原多项式</li><li>2<sup>n</sup>-1为素数时，F<sub>2</sub>上的每一个n次不可约多项式均为n次本原多项式</li></ul><h3 id="伪随机序列">伪随机序列</h3><h4 id="Golomb随机性假设">Golomb随机性假设</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092052608.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092052608.png" srcset="data:image/png;base64,666" alt="image-20201127092052608" style="zoom:70%;" /><p>注：游程指一段连续的相同数字</p><h4 id="m序列的伪随机性">m序列的伪随机性</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127091508439.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127091508439.png" srcset="data:image/png;base64,666" alt="image-20201127091508439" style="zoom:70%;" /><h3 id="线性复杂度">线性复杂度</h3><p>线性复杂度：能够输出该序列的最小线性移位寄存器的级数，即次数最小的联接多项式</p><ul><li>如果序列的线性复杂度为l(&gt;=1)，则只要知道序列中任意相继的2l位，就可确定整个序列</li></ul><h3 id="安全的密钥流">安全的密钥流</h3><ul><li>周期充分长，一般不少于1016</li><li>随机统计特性好，即基本满足Golomb的随机性假设</li><li>大的线性复杂度，为序列长度的一半</li></ul><h3 id="基于LFSR的伪随机序列生成器">基于LFSR的伪随机序列生成器</h3><p>在LFSR的基础上加入非线性化的手段，产生适合于流密码应用的密钥序列(伪随机序列)</p><h4 id="滤波生成器">滤波生成器</h4><p>由一个n级线性移位寄存器和一个m(&lt;n)元非线性滤波函数组成，滤波函数的输出为密钥流序列</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092445491.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092445491.png" srcset="data:image/png;base64,666" alt="image-20201127092445491" style="zoom: 67%;" /><ul><li>g是一个m元布尔函数</li></ul><h4 id="组合生成器">组合生成器</h4><p>若干个线性移位寄存器LFSR<sub>i</sub>(i=1, …, n)和一个非线性组合函数组成，组合函数的输出构成密钥流序列</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092657734.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092657734.png" srcset="data:image/png;base64,666" alt="image-20201127092657734" style="zoom:67%;" /><ul><li>其中LFSR<sub>i</sub>为n个级数分别为r<sub>1</sub>, r<sub>2</sub>, …, r<sub>n</sub>的线性移位寄存器</li><li>f是n元布尔函数</li></ul><h4 id="钟控制生成器">钟控制生成器</h4><p>用一个或多个移位寄存器来控制另一个或多个移位寄存器的时钟</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093002106.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093002106.png" srcset="data:image/png;base64,666" alt="image-20201127093002106" style="zoom:67%;" /><ul><li>当LFSR<sub>1</sub>输出1时，移位时钟脉冲通过与门使LFSR<sub>2</sub>进行一次移位，从而生成下一位</li><li>当LFSR<sub>1</sub>输出0时，移位时钟脉冲无法通过与门影响LFSR<sub>2</sub>，因此LFSR<sub>2</sub>重复输出前一位</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093608989.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093608989.png" srcset="data:image/png;base64,666" alt="image-20201127093608989" style="zoom:77%;" /><ul><li>当LFSR<sub>1</sub>的输出是1时，LFSR<sub>2</sub>被时钟驱动</li><li>当LFSR<sub>1</sub>的输出是0时，LFSR<sub>3</sub>被时钟驱动</li><li>LFSR<sub>1</sub>的输出与LFSR<sub>2</sub>的输出做异或运算即为这个<strong>交错式停走生成器</strong>的输出</li></ul><h3 id="实用流密码">实用流密码</h3><h4 id="全球移动通信系统GSM中的A5算法">全球移动通信系统GSM中的A5算法</h4><p>A5的钟控机制：如果在某一时刻钟控单元中三个值的某两个或三个相同，则对应的移位寄存器在下一时刻被驱动，而剩下的一个(或0个)值对应的移位寄存器则停走</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209103006094.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209103006094.png" srcset="data:image/png;base64,666" alt="image-20201209103006094" style="zoom:80%;" /><h4 id="RC4">RC4</h4><ul><li>参数n，长为n的秘密内部状态(2<sup>n</sup>数组)，当n取8时，内部状态有256(=2<sup>n</sup>)个元素(S[0], S[1], …, S[255])构成，每个元素都是0~255之间的一个数字</li><li>输入：一个可变长的密钥，用于初始化内部状态</li><li>输出：状态中按照一定方式选出的某一个元素K，该输出构成密钥流的一个字节，加解密时，K与一个明文/密文字节执行XOR运算</li><li>每生成一个K值，内部状态中的元素会被重新置换一次，以便下次生成K值</li></ul><h5 id="密钥调度算法">密钥调度算法</h5><ul><li><p>用来设置内部状态的随机排列，最开始设置为S[i]=i (i=0, 1, …, 255)</p></li><li><p>密钥长度可变，设为L个字节(K[0],…, K[L-1])，一般L在5~32之间，用这L个字节不断重复填充，直到得到 K[0],…, K[255]。该数组K将被用于对内部状态S进行随机化</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209112304978.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209112304978.png" srcset="data:image/png;base64,666" alt="image-20201209112304978" style="zoom:67%;" /></li></ul><h5 id="伪随机生成算法">伪随机生成算法</h5><p>从内部状态中选取一个随机元素作为密钥流中的一个字节，并修改内部状态以便下一次选取</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209112418590.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209112418590.png" srcset="data:image/png;base64,666" alt="image-20201209112418590" style="zoom:67%;" /><h5 id="例子">例子</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209112644630.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201209112644630.png" srcset="data:image/png;base64,666" alt="image-20201209112644630" style="zoom:80%;" /><h2 id="公钥密码">公钥密码</h2><h3 id="对称密码体制的缺陷">对称密码体制的缺陷</h3><ol><li>密钥分配问题：缺少安全信道</li><li>密钥管理问题：任意两个用户之间都需要共享密钥，数量级很大</li><li>没有签名功能</li></ol><h3 id="公钥算法分类">公钥算法分类</h3><ul><li>Public Key Distribution Schemes (PKDS) 密钥交换<ul><li>用于交换秘密信息(依赖于双方主体)</li><li>常用于交换对称加密算法的密钥</li></ul></li><li>Public Key Encryption (PKE) 公钥加密<ul><li>用于加密任何消息</li><li>任何人可以用公钥加密消息</li><li>私钥的拥有者可以解密消息</li><li>任何公钥加密方案能够用于密钥分配方案PKDS</li><li>许多公钥加密方案也是数字签名方案</li></ul></li><li>Signature Schemes<ul><li>用于生成对某消息的数字签名</li><li>私钥的拥有者生成数字签名</li><li>任何人可以用公钥验证签名</li></ul></li></ul><h3 id="Diffie-Hellman密钥分配">Diffie-Hellman密钥分配</h3><ul><li>不能用于交换任意消息</li><li>基于有限域上的指数问题</li><li>安全性是基于计算离散对数的困难性</li><li>能抵抗被动攻击，不能抵抗主动攻击（中间人）</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/20200723135236713.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/20200723135236713.png" srcset="data:image/png;base64,666" alt="img" style="zoom:80%;" /><h3 id="RSA">RSA</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201211082859483.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201211082859483.png" srcset="data:image/png;base64,666" alt="image-20201211082859483"></p><ul><li>素数p, q要求足够大</li><li>通常选择小的加密指数E，可以对所有用户都相同</li></ul><h4 id="RSA快速实现">RSA快速实现</h4><ul><li>加密快，指数小；解密慢，指数大</li><li>利用中国剩余定理CRT快速实现RSA解密(M=C<sup>D</sup> mod N)：<ul><li>M<sub>1</sub> = M mod p = (C mod p)<sup>Dmod(p-1)</sup></li><li>M<sub>2</sub> = M mod q = (C mod q)<sup>Dmod(q-1)</sup></li><li>解方程：M = M<sub>1</sub> mod p 和 M = M<sub>2</sub> mod q</li><li>具有唯一解(利用CRT)：M = (quM<sub>1</sub> + pu’M<sub>2</sub>) mod N，其中pu mod q =1，qu’ mod p = 1</li></ul></li></ul><h4 id="RABIN公钥密码体制">RABIN公钥密码体制</h4><ul><li>基于二次剩余问题和模n平方根问题</li><li>加密密钥为2，安全性等价于对大整数n的分解；解密更为困难</li><li>不能抵抗选择密文攻击</li></ul><h3 id="EI-Gamal公钥加密">EI Gamal公钥加密</h3><ul><li><p>D-H算法的变形，用于安全交换密钥</p></li><li><p>安全性基于离散对数</p></li><li><p>缺点：增加消息长度（2倍）</p></li></ul><img src="D:\Source\notes\现代密码学-notes\image-20201216105037750.png" class="lazyload" data-srcset="D:\Source\notes\现代密码学-notes\image-20201216105037750.png" srcset="data:image/png;base64,666" alt="image-20201216105037750" style="zoom:80%;" /><h2 id="认证和哈希函数">认证和哈希函数</h2><ul><li>认证的主要目的：<ul><li>实体认证(发送者非冒充)</li><li>消息认证(验证信息的完整性)</li></ul></li><li>三类产生认证符的函数：<ul><li>消息加密</li><li>消息认证码(MAC)</li><li>哈希函数</li></ul></li></ul><h3 id="消息加密">消息加密</h3><ul><li>对称加密：提供保密与一定程度的认证，不提供签名</li><li>公钥加密：(A -&gt; B)<ul><li>E(KU<sub>b</sub>, M) =&gt; 提供保密，不提供认证</li><li>E(KR<sub>a</sub>, M) =&gt; 提供认证和签名</li><li>E(KU<sub>b</sub>, E(KR<sub>a</sub>, M)) =&gt; 提供保密、认证和签名</li></ul></li></ul><h3 id="消息认证码-MAC">消息认证码(MAC)</h3><p>对选定消息使用一个密钥产生一个短小的定长数据分组，附加在消息中提供认证功能 (MAC = C<sub>k</sub>(M))</p><ul><li><p>基本用法：</p><ul><li>M || C<sub>k</sub>(M) =&gt; 提供认证</li><li>E<sub>k2</sub>(M || C<sub>k1</sub>(M)) =&gt; 提供认证(K1)和保密(K2)</li><li>E<sub>k2</sub>(M) || C<sub>k1</sub>(E<sub>k2</sub>(M)) =&gt; 提供认证(K1)和保密(K2)</li></ul></li><li><p>适用于消息广播、比消息加密的工作量小、认证与保密分离、延长消息的保护期限</p></li><li><p>不可逆，且不提供数字签名</p></li></ul><h3 id="哈希函数">哈希函数</h3><ul><li>基本用法：<ul><li>E<sub>k</sub>(M || H(M)) =&gt; 提供保密和鉴别</li><li>M || E<sub>k</sub>(H(M)) =&gt; 提供鉴别</li><li>M || E<sub>KRa</sub>(H(M)) =&gt; 提供鉴别和数字签名</li><li>E<sub>k</sub>(M || E<sub>KRa</sub>(H(M))) =&gt; 提供鉴别、数字签名以及保密</li><li>M || H(M || S) =&gt; 提供鉴别(S是通信双方共享的一个秘密值)</li><li>E<sub>k</sub>(M || H(M || S)) =&gt; 提供鉴别和保密</li></ul></li><li>哈希函数要求：<ul><li>消息长度任意，输出定长</li><li>易于计算</li><li>单向性</li><li>弱抗碰撞性：任意给定分组x，寻求不等于x的y，使得H(y)= H(x)在计算上不可行</li><li>强抗碰撞性：寻求对任何的(x,y)对使得H(x)=H(y)在计算上不可行</li></ul></li></ul><h4 id="简单的异或哈希函数">简单的异或哈希函数</h4><p>每个n比特长度分组按比特异或，得到长度为n的哈希码</p><ul><li>改进：(使得输入数据完全随机化，掩盖输入的数据格式)<ul><li>先将n比特的哈希值设置为0</li><li>当前的哈希值循环左移一位</li><li>数据分组与哈希值异或形成新的哈希值</li></ul></li><li>Merkle-Damgard结构：</li></ul><img src="D:\Source\notes\现代密码学-notes\image-20201216193951310.png" class="lazyload" data-srcset="D:\Source\notes\现代密码学-notes\image-20201216193951310.png" srcset="data:image/png;base64,666" alt="image-20201216193951310" style="zoom:75%;" /><h4 id="MD5">MD5</h4><p>输入任意长度报文，输出128比特的摘要；输入分组长度为512比特；符合Merkle-Damgard结构</p><h5 id="算法流程">算法流程</h5><ol><li><p>在消息的最后添加填充位（一个1和若干个0），使得数据的长度满足length = 448 mod 512，填充完后，信息的长度为N*512+448(bit)</p></li><li><p>记录信息长度，用64位来存储填充前信息长度，如果信息长度超过2<sup>64</sup>位，则只保留低64位。这64位加在第一步结果的后面，这样信息长度就变为(N+1)*512(bit)</p></li><li><p>初始化MD缓存，使用一个128位缓存存放哈希的中间和最后结果，缓存表示为4个32位的缓存器（A,B,C,D），初始化格式为低位字节存放在高地址字节</p></li><li><p>四轮循环处理512bit分组</p><ul><li><p>输入：当前处理的512位分组Y<sub>q</sub>与上一轮输出CV<sub>q</sub></p></li><li><p>循环：4轮循环依次记为F，G，H，I；借助列表T[1,…,64]（T[i]=2<sup>32</sup> * |sin(i)|的整数部分），列表提供随机化的32位模板以消除输入的规律</p><ul><li><p>每个循环包括16步操作，每一步的基本形式：<br>$$<br>b \leftarrow b + ((a + g(b, c, d) + X[k] + T[i]) &lt;&lt;&lt; s)<br>$$</p><ul><li>+：模2<sup>32</sup>加</li><li>a, b, c, d：MD缓存中的4个字，一开始被初始化，之后每一步操作结果都会替换其中一个字</li><li>&lt;&lt;&lt; s：循环左移s位</li><li>T[i]：矩阵T中的第i个32比特字，i = 1,…,16</li><li>g：循环函数F、G、H、I</li><li>X[k]：当前分组的第k个字</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223105753560.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223105753560.png" srcset="data:image/png;base64,666" alt="image-20201223105753560" style="zoom:60%;" /></li><li><p>输出：第4次循环输出加到第1轮循环的输入上产生CV<sub>q+1</sub>，相加是缓存中的4个字分别与CV<sub>q</sub>中对应的4个字以模2<sup>32</sup>相加</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223110415662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223110415662.png" srcset="data:image/png;base64,666" alt="image-20201223110415662" style="zoom:67%;" /></li></ol><h5 id="MD5应用">MD5应用</h5><ul><li>对明文消息生成消息摘要</li><li>用于数字签名（UNIX、Linux等操作系统保护用户口令）</li></ul><h5 id="MD5口令逆向">MD5口令逆向</h5><h4 id="SHA-1">SHA-1</h4><p>输入最大长度为2<sup>64</sup>位的消息，输出160比特 ，分组为512比特</p><h5 id="算法流程-v2">算法流程</h5><ol><li><p>在消息的最后添加填充位（一个1和若干个0），使得数据的长度满足length = 448 mod 512，填充完后，信息的长度为N*512+448(bit)</p></li><li><p>记录信息长度，用64位来存储填充前信息长度，如果信息长度超过2<sup>64</sup>位，则只保留低64位。这64位加在第一步结果的后面，这样信息长度就变为(N+1)*512(bit)</p></li><li><p>初始化MD缓冲区，使用160位MD缓冲区来保存中间和最终哈希结果，表示为5个32位寄存器（A,B,C,D,E），存储为低位字节放在低地址字节上</p></li><li><p>以512位数据块为单位处理消息，4轮，每轮20步，每次循环分别使用一个额外的常数K<sub>t</sub></p><ul><li><p>每一步的基本形式：</p><p>$$<br>A,B,C,D,E\leftarrow (E+f_t(B,C,D)+S<sup>5(A)+W_i+K_t),A,S</sup>{30}(B),C,D<br>$$</p><ul><li><p>+：模2<sup>32</sup>加法</p></li><li><p>f<sub>t</sub>：逻辑函数，每轮循环不同</p></li><li><p>S<sup>i</sup>：32位常数循环左移i位</p></li><li><p>K<sub>t</sub>：额外的常数</p></li><li><p>W<sub>i</sub>：当前512位数据导出的一个32位字；共80个</p><ul><li><p>前16个直接来自当前分组的16个字</p></li><li><p>其余：<br>$$<br>W_t=S^1(W_{t-16}\bigoplus W_{t-14}\bigoplus W_{t-8}\bigoplus W_{t-3})<br>$$</p></li></ul></li></ul></li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223121458851.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223121458851.png" srcset="data:image/png;base64,666" alt="image-20201223121458851" style="zoom: 67%;" /><ol start="5"><li>第4次循环输出加到CV<sub>q</sub>，得到160位CV<sub>q+1</sub>（模2<sup>32</sup>加）</li></ol><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223121515315.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223121515315.png" srcset="data:image/png;base64,666" alt="image-20201223121515315" style="zoom:67%;" /><h4 id="哈希函数对比">哈希函数对比</h4><ul><li>SHA = MD4 ＋ 扩展变换 ＋ 外加一轮 ＋ 更好的雪崩</li><li>MD5 = MD4 ＋ 改进的比特杂凑 ＋ 外加一轮 ＋ 更好的雪崩</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223122213539.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223122213539.png" srcset="data:image/png;base64,666" alt="image-20201223122213539" style="zoom: 67%;" /><h2 id="数字签名算法">数字签名算法</h2><p>只对消息的哈希签名，否则交换信息长度增加一倍；数字签名可以提供消息的不可否认性</p><h3 id="RSA-v2">RSA</h3><p>给定(e, R), (d, p, q)</p><ul><li>计算明文M的哈希h，S = h<sup>d</sup>(mod R)，发送(M, S)</li><li>接收方同样计算哈希h，S<sup>e</sup> mod R = h’ mod R，对比h和h’</li><li>若先加密后签名，签名可能被替换</li></ul><h3 id="EI-Gamal">EI Gamal</h3><ul><li>加密算法不可交换——需要专门的签名算法</li><li>安全性基于离散对数的计算困难性</li><li>公钥：(y, g, p)，私钥(x)</li><li>签名方案:<ul><li>随机数k，与p-1互素</li><li>计算K = g<sup>k</sup> mod p</li><li>计算S = k<sup>−1</sup>(M − Kx) mod (p−1)</li><li>发送签名(M, K, S)，销毁k</li><li>验证y<sup>K</sup>K<sup>S</sup> mod p=g<sup>M</sup> mod p</li></ul></li><li>签名长度为消息的两倍</li></ul><h3 id="DSA">DSA</h3><ul><li>El Gamal的变形，生成320位签名</li><li>安全性基于离散对数的计算困难性</li><li>密钥生成<ul><li>公开参数 (p, q, g)<ul><li>p：大素数，2<sup>L</sup>，L为512到1024位且为64的倍数</li><li>q：160位（p-1）的素因子</li><li>g：h<sup>(p−1)/q</sup>,   h &lt; p−1 且 h<sup>(p−1)/q</sup>(mod p) &gt; 1</li></ul></li><li>选择私钥x，计算y = g<sup>x</sup> mod p，公钥为 (p, q, g, y)</li></ul></li><li>签名生成（SHA：哈希函数）<ul><li>r = (g<sup>k</sup> mod p) mod q</li><li>s = k<sup>−1</sup>(SHA(M) + xr) mod q</li><li>发送 (M, r, s)</li></ul></li><li>签名验证<ul><li>w = s<sup>−1</sup> mod q</li><li>u1 = SHA(M)w mod q</li><li>u2 = rw mod q</li><li>v = (g<sup>u1</sup>y<sup>u2</sup> mod p) mod q</li><li>验证 v = r</li></ul></li></ul><h3 id="HMAC">HMAC</h3><ul><li>以上为需要私钥的认证方案，计算量大</li><li>密钥与消息同时参加运算：KeyedHash = Hash(Key | Message)或Hash(Key1 | Hash(Key2 | Message))</li><li>HMAC：使用带密钥hash函数的结果<ul><li>HMAC<sub>K</sub> = Hash((K′ ⨁ opad) || Hash((K′ ⨁ ipad) || M))</li><li>K’：经过填充的密钥</li><li>opad、ipad：特殊的填充值</li></ul></li><li>安全性基于原始的hash</li></ul><h2 id="信息隐藏与隐写分析">信息隐藏与隐写分析</h2><h3 id="信息隐藏的基本概念">信息隐藏的基本概念</h3><p>信息隐藏是将信息秘密嵌入在数字图像、声音、文档、视频等数字产品中，用以隐蔽通信、隐蔽标识，或识别所有者、完整性、发源地、使用权、序列号等。</p><h4 id="信息隐藏技术的主要分支">信息隐藏技术的主要分支</h4><ul><li>隐蔽信道：系统存在的一些安全漏洞，通过某些非正常的访问控制操作，能形成隐秘数据流，而基于正常安全机制的软硬件不能觉察和有效控制</li><li>匿名通信<ul><li>源重写技术：采用路由转发策略，发送者匿名</li></ul></li><li>隐写术</li><li>版权标志</li></ul><h4 id="水印的分类">水印的分类</h4><p>根据应用分类：</p><ul><li>隐蔽通信</li><li>版权保护</li><li>认证和完整性</li><li>内容标注</li></ul><p>根据嵌入域分类：</p><ul><li>空域，如LSB</li><li>变换域，如DFT、DCT、DWT等</li></ul><p>根据是否可见分类</p><ul><li>可见水印</li><li>不可见水印</li></ul><p>根据密钥分类</p><ul><li>密钥水印</li><li>公钥水印</li></ul><p>根据原始数据分类</p><ul><li>私有水印：检测时需要原始数据</li><li>盲水印：检测时不需要原始数据</li></ul><p>根据载体恢复分类</p><ul><li>可逆水印</li><li>不可逆水印</li></ul><p>根据鲁棒性分类</p><ul><li>鲁棒水印：用于认证、版权保护</li><li>半易碎水印</li><li>易碎水印：对恶意改动敏感，用于完整性判定</li></ul><h4 id="鲁棒水印特性">鲁棒水印特性</h4><ul><li>不可见性</li><li>安全可靠性</li><li>鲁棒性</li><li>复杂性</li><li>容量</li></ul><h3 id="信息隐藏的一般过程">信息隐藏的一般过程</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223160600413.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223160600413.png" srcset="data:image/png;base64,666" alt="image-20201223160600413" style="zoom:70%;" /><h4 id="水印生成">水印生成</h4><p>类似噪声，具有不可预测的随机性</p><ul><li>Arnold置乱技术：置乱96次回到原图</li><li>扩频技术<ul><li>基于片率</li><li>基于伪随机序列</li></ul></li></ul><h4 id="水印嵌入">水印嵌入</h4><ul><li>加法嵌入：X<sub>w</sub>(k) = X<sub>0</sub>(k) + a(k)w(k)</li><li>乘法嵌入：X<sub>w</sub>(k) = X<sub>0</sub>(k)(1 + a(k)w(k))</li></ul><h3 id="信息隐藏的常见算法">信息隐藏的常见算法</h3><h4 id="空域信息隐藏算法">空域信息隐藏算法</h4><p>通过直接修改像素值实现信息嵌入</p><ul><li>优点：简单、快速、容量大</li><li>缺点：鲁棒性差</li></ul><p>图像位平面特性：</p><ul><li>位平面越高，对灰度值的贡献越大，相邻比特的相关也越强</li><li>最低位平面类似随机噪声</li></ul><h5 id="LSB算法">LSB算法</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162221552.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162221552.png" srcset="data:image/png;base64,666" alt="image-20201223162221552" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162248435.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162248435.png" srcset="data:image/png;base64,666" alt="image-20201223162248435" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162326057.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162326057.png" srcset="data:image/png;base64,666" alt="image-20201223162326057" style="zoom:60%;" /><h5 id="Patchwork算法">Patchwork算法</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162458268.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162458268.png" srcset="data:image/png;base64,666" alt="image-20201223162458268" style="zoom:80%;" /><h5 id="Checksum算法">Checksum算法</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162614060.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201223162614060.png" srcset="data:image/png;base64,666" alt="image-20201223162614060" style="zoom:80%;" /><h4 id="频域水印算法">频域水印算法</h4><p>通过修改频域空间的系数实现水印嵌入</p><ul><li>离散傅里叶变换（DFT）</li><li>离散余弦变换（DCT）</li><li>离散小波变换（DWT）</li></ul><p>优点：鲁棒性好</p><p>缺点：复杂度高</p><h2 id="附录">附录</h2><h3 id="DES算法相关表">DES算法相关表</h3><h4 id="初始置换IP-对明文输入进行次序打乱">初始置换IP (对明文输入进行次序打乱)</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133239171.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133239171.png" srcset="data:image/png;base64,666" alt="image-20201126133239171" style="zoom: 40%;" /><h4 id="初始置换的逆置换IP-1">初始置换的逆置换IP<sup>-1</sup></h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133334739.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133334739.png" srcset="data:image/png;base64,666" alt="image-20201126133334739" style="zoom:40%;" /><h4 id="扩展置换E-32-bit到48-bit">扩展置换E (32-bit到48-bit)</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135403930.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135403930.png" srcset="data:image/png;base64,666" alt="image-20201126135403930" style="zoom: 40%;" /><h4 id="置换函数P">置换函数P</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135548535.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135548535.png" srcset="data:image/png;base64,666" alt="image-20201126135548535" style="zoom:40%;" /><h4 id="PC1">PC1</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135745175.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135745175.png" srcset="data:image/png;base64,666" alt="image-20201126135745175" style="zoom:44%;" /><h4 id="PC2">PC2</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135956793.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135956793.png" srcset="data:image/png;base64,666" alt="image-20201126135956793" style="zoom:44%;" /><h4 id="S-box-例子">S-box 例子</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140106789.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140106789.png" srcset="data:image/png;base64,666" alt="image-20201126140106789" style="zoom:40%;" /><h3 id="AES算法相关表">AES算法相关表</h3><h4 id="字节替换表">字节替换表</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126152318235.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126152318235.png" srcset="data:image/png;base64,666" alt="image-20201126152318235"></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-SGX Support for Dynamic Memory Management Inside an Enclave</title>
      <link href="2020/11/25/paper-reading/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/"/>
      <url>2020/11/25/paper-reading/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction">1. Introduction</h2><h3 id="SGX1-shortcomings">SGX1 shortcomings</h3><ul><li><p>enclave建立时必须分配其所需的所有内存，并且难以根据工作量自适应分配enclave，需要根据最坏情况的工作量来分配内存</p></li><li><p>enclave页的访问控制由EPCM来管理，当页被加入enclave时其权限就得写入EPCM中，并且不能再改变，这就意味着必须允许页上将来可能执行的任何操作，不能做到权限最小化</p></li><li><p>library OS，异常处理和代码延迟加载</p></li></ul><h2 id="2-SGX2-Considerations-Requirements">2. SGX2 Considerations &amp; Requirements</h2><h3 id="动态内存管理需要满足的条件">动态内存管理需要满足的条件</h3><ul><li>enclave需要自己掌控其内存和权限</li><li>enclave代码在enclave不知情的情况下被改变时，将不会被执行</li><li>系统的资源管理器能够正常管理和分配资源</li><li>需要同时有EPCM权限和系统权限才能更改内存权限</li></ul><h3 id="安全考量">安全考量</h3><ul><li>enclave软件需要改变页的权限来进行访问控制</li><li>权限更改时要保证旧的权限从TLB中移除</li><li>如果enclave要将页还回系统，并且想要在以后使用相同的内存地址，则enclave需要知道页是什么时候被还回的</li></ul><h3 id="软件考量">软件考量</h3><ul><li>enclave内部的内存管理机构需要能够重新分配内存资源</li></ul><h2 id="3-SGX2-Overview-and-Usage">3. SGX2 Overview and Usage</h2><h3 id="SGX2新增的指令">SGX2新增的指令</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160452272.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160452272.png" srcset="data:image/png;base64,666" alt="image-20201125160452272" style="zoom: 80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160710352.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160710352.png" srcset="data:image/png;base64,666" alt="image-20201125160710352"></p><h3 id="Enclave内存分配">Enclave内存分配</h3><blockquote><p>To implement dynamic memory allocation and commitment, the enclave runtime system and the operating system have to agree on a protocol that coordinates the operating system usage of EAUG and the enclave runtime system usage of EACCEPT.</p></blockquote><p><strong>Committed：</strong> Virtual Size减去为程序保留的内存（未分配）。怎么理解为程序保留的但未分配的内存？就是告诉系统我要一块内存，但暂时还用不上，不过分配的地址得给我，系统就给程序一个不用的地址，但不分配内存，等程序真的要使用时（读写），就从页面或物理内存中分配出来映射到那个地址上。</p><p><strong>提交的内存：</strong> 系统从物理内存或者换页内存分配给进程的那一部分。这部分内存在虚拟内存的线性地址中是连续的，不过在物理内存或者换页内存中，不一定是连续的。提交但未使用的内存一般都在换页内存里面，只有去使用的时候，才会换到物理内存里面，这点要注意。</p><h3 id="Enclave内存释放">Enclave内存释放</h3><blockquote><p>SGX2 provides a more robust reclamation of committed memory. OS and enclave runtime system need to coordinate the execution of EMODT, ETRACK, and EREMOVE by the OS and execution of EACCEPT by the enclave runtime.</p></blockquote><h3 id="改变页的权限">改变页的权限</h3><p>分为扩大权限和缩减权限。</p><ul><li><p>扩大权限：</p><blockquote><ol><li>The internal manager executes EMODPE to extend the page permissions in the EPCM.</li><li>The internal manager requests the system manager to extend page permissions in the page tables.</li></ol></blockquote></li><li><p>缩减权限：</p><blockquote><ol><li><p>The internal manager requests that the system manager to restrict permissions on a page.</p></li><li><p>The system manager executes EMODPR and updates page table permissions. After permissions have been updated, the system manager executes ETRACK on the SECS of the calling enclave and sends <strong>IPI</strong>s (处理器间中断：允许一个CPU向系统其他的CPU发送中断信号) to all processors that may be executing inside the enclave to flush TLB mappings.</p></li><li><p>After all IPIs have been acknowledged, control is returned to the internal manager. The internal manager verifies that page permissions have been restricted and TLB mappings flushed by executing EACCEPT.</p></li></ol></blockquote></li><li><p>权限的更改(同时包含扩大和缩减权限)：先缩减后扩大 —— 避免产生不安全的中间临时情况</p></li></ul><h3 id="线程控制机构TCS分配">线程控制机构TCS分配</h3><blockquote><p>The software protocol is very similar to page restriction except that instead of executing EMODPR the OS executes EMODT.</p></blockquote><h3 id="动态加载模块">动态加载模块</h3><blockquote><p>To support dynamic loading of modules, SGX2 provides EACCEPTCOPY which allows the internal manager to atomically initialize the contents and permission of a page.</p></blockquote><h3 id="Library-OS支持">Library OS支持</h3><ul><li>提供异常处理<ul><li>由enclave产生的异常</li><li>异常的类型</li><li>错误情况的具体信息</li></ul></li><li>SGX2还另外提供enclave运行时产生的enclave内部的异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internet安全协议与分析Notes</title>
      <link href="2020/11/25/learning-notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/"/>
      <url>2020/11/25/learning-notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/</url>
      
        <content type="html"><![CDATA[<h2 id="IPSec">IPSec</h2><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101110459619.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101110459619.png" srcset="data:image/png;base64,666" alt="image-20201101110459619"></p><h3 id="通信保护协议">通信保护协议</h3><h4 id="AH">AH</h4><ul><li>通信提供数据源认证、<strong>抗抵赖性</strong>、数据完整性和反重播保证，但不提供机密性保护</li></ul><p><strong>AH传输模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111305325.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111305325.png" srcset="data:image/png;base64,666" alt="image-20201101111305325" style="zoom:80%;" /><ul><li>源IP地址、目的IP地址是不能修改的，否则会被检测出来，因此AH在传输模式下和NAT冲突</li></ul><p><strong>AH隧道模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111704982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111704982.png" srcset="data:image/png;base64,666" alt="image-20201101111704982" style="zoom:80%;" /><ul><li>AH验证的范围也是整个IP包，因此AH和NAT的冲突在隧道模式下也存在</li></ul><h4 id="ESP">ESP</h4><ul><li>为IP提供<strong>机密性</strong>、数据源认证、抗重播以及数据完整性等安全服务，但不提供抗抵赖性</li><li>对IP头部不进行认证，因此不会和NAT冲突</li></ul><p><strong>ESP传输模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112035985.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112035985.png" srcset="data:image/png;base64,666" alt="image-20201101112035985"  /><p><strong>ESP隧道模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112141274.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112141274.png" srcset="data:image/png;base64,666" alt="image-20201101112141274" style="zoom:80%;" /><h3 id="密钥交换管理协议IKE">密钥交换管理协议IKE</h3><ul><li>安全机制<ul><li>前向安全性：一个密钥被破解不影响其他密钥的安全性</li><li>数据验证</li><li>DH交换和密钥分发</li></ul></li></ul><h4 id="阶段1">阶段1</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113424882.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113424882.png" srcset="data:image/png;base64,666" alt="image-20201101113424882" style="zoom:80%;" /><p><strong>主模式协商</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113221833.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113221833.png" srcset="data:image/png;base64,666" alt="image-20201101113221833" style="zoom:80%;" /><p><strong>野蛮模式协商</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113300883.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113300883.png" srcset="data:image/png;base64,666" alt="image-20201101113300883" style="zoom:80%;" /> <p><strong>两种模式对比</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113329111.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113329111.png" srcset="data:image/png;base64,666" alt="image-20201101113329111" style="zoom:80%;" /><h4 id="阶段2">阶段2</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113446458.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113446458.png" srcset="data:image/png;base64,666" alt="image-20201101113446458" style="zoom:80%;" /><h2 id="SSL">SSL</h2><ul><li>安全机制<ul><li>数据机密性：对称加密</li><li>身份验证机制：基于证书的数字签名</li><li>消息完整性：MAC算法</li></ul></li><li>SSL连接和会话<ul><li>连接是点对点的、暂时的</li><li>会话是客户端和服务器之间持久的关联</li></ul></li></ul><h3 id="SSL分层结构">SSL分层结构</h3><ul><li>上层协议<ul><li>SSL握手协议：协商加密套件，交换密钥，身份认证</li><li>SSL password变化协议：修改新的加密套件和密钥</li><li>SSL警告协议：当其他过程中出现错误或发送异常时，向对方报告告警信息</li></ul></li><li>下层协议<ul><li>SSL记录协议：对上层数据分块、压缩、加密、传输</li></ul></li></ul><h4 id="SSL握手协议">SSL握手协议</h4><p><strong>阶段1：建立安全能力</strong></p><ul><li>协商加密套件</li></ul><p><strong>阶段2：服务器鉴别与密钥交换</strong></p><p><strong>阶段3：客户端鉴别与密钥交换</strong></p><ul><li>服务器和客户端分别发送自己的证书并交换密钥信息以便进行身份认证</li></ul><p><strong>阶段4：完成</strong></p><ul><li>检验双方是否获得同样的安全参数</li></ul><h4 id="SSL记录协议">SSL记录协议</h4><p>为每个SSL连接提供：</p><ul><li>机密性</li><li>完整性</li></ul><h3 id="SSL协议安全性分析">SSL协议安全性分析</h3><ul><li>鉴别机制：公开密钥机制和数字证书</li><li>加密机制：混合密码体制</li><li>完整性机制：定义了共享的、可以用来形成报文鉴别码MAC的密钥</li><li>抗重放攻击：序列号，用随机数标记握手</li></ul><h3 id="SSL脆弱性分析">SSL脆弱性分析</h3><ul><li>客户端假冒</li><li>无法提供基于UDP的应用的安全保护</li><li>不能对抗通信流量分析：SSL只对数据进行保护，数据包的IP头和TCP头暴露在外</li><li>SSL进程存储空间中的主密钥泄露</li></ul><h2 id="SET">SET</h2><h3 id="双重数字签名">双重数字签名</h3><ul><li>订单信息OI：客户给商家</li><li>支付信息PI：客户给银行</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125501014.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125501014.png" srcset="data:image/png;base64,666" alt="image-20201101125501014" style="zoom:80%;" /><h3 id="SET电子支付流程">SET电子支付流程</h3><ol><li><p>支付初始化：持卡人选择商品，下订单，选择银行卡</p><ul><li>初始请求：持卡人发送请求指定交易环境</li><li>初始应答：商家回复交易环境信息，以及证书等，并附上签名</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125955162.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125955162.png" srcset="data:image/png;base64,666" alt="image-20201101125955162" style="zoom:80%;" /></li><li><p>购物请求：</p><ul><li>持卡人检查商家初始应答发送的签名信息，确保数据完整性</li><li>持卡人发送PReq</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130235811.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130235811.png" srcset="data:image/png;base64,666" alt="image-20201101130235811" style="zoom:80%;" /></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130805188.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130805188.png" srcset="data:image/png;base64,666" alt="image-20201101130805188" style="zoom:150%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131210287.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131210287.png" srcset="data:image/png;base64,666" alt="image-20201101131210287"></p><ol start="3"><li><p>商家验证持卡人的身份和授权</p><ul><li>商家将相关信息发送给支付网关</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131339258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131339258.png" srcset="data:image/png;base64,666" alt="image-20201101131339258" style="zoom:150%;" /></li><li><p>支付网关认证</p><ul><li>网关将信息发送给银行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101132850316.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101132850316.png" srcset="data:image/png;base64,666" alt="image-20201101132850316"></p></li><li><p>收单银行处理</p><ul><li><p>确保PI和AuthReq的一致性</p></li><li><p>校验持卡人和商家对于订购行为的一致性</p></li><li><p>发送AuthRes给商家</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133223907.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133223907.png" srcset="data:image/png;base64,666" alt="image-20201101133223907"></p></li><li><p>支付完成</p><ul><li>通过捕获令牌(Capture Token)完成支付</li></ul></li><li><p>下单回复</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133759144.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133759144.png" srcset="data:image/png;base64,666" alt="image-20201101133759144"></p></li></ol><h3 id="SET核心技术">SET核心技术</h3><ul><li>公开密钥加密</li><li>数字签名</li><li>数字信封：公钥算法加密对称密钥</li><li>电子安全证书</li></ul><h2 id="PGP">PGP</h2><ul><li>提供可用于电子邮件和文件存储应用的<strong>保密</strong>与<strong>鉴别</strong>服务</li></ul><h3 id="PGP数字签名与认证">PGP数字签名与认证</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101134921229.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101134921229.png" srcset="data:image/png;base64,666" alt="image-20201101134921229"></p><h3 id="PGP保密性">PGP保密性</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135128996.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135128996.png" srcset="data:image/png;base64,666" alt="image-20201101135128996"></p><ul><li>邮件的存储转发特性不适合用DH算法交换密钥</li><li>使用公钥算法对每个消息生成<strong>一次性</strong>会话密钥</li></ul><h3 id="PGP保密和认证结合">PGP保密和认证结合</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135448177.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135448177.png" srcset="data:image/png;base64,666" alt="image-20201101135448177"></p><h3 id="PGP压缩">PGP压缩</h3><ul><li>使用ZIP算法</li><li>先签名后压缩<ul><li>只需要存储原始报文和签名</li><li>易于更换压缩算法</li></ul></li></ul><h3 id="PGP密钥环">PGP密钥环</h3><ul><li>每个结点都有存储密钥的结构<ul><li>私钥环：存储该结点拥有的公/私钥对</li><li>公钥环：存储该结点拥有的其他所有用户的公钥</li></ul></li></ul><h3 id="PGP信任网">PGP信任网</h3><ul><li>PGP中没有认证机构，而是由用户互相对对方的公钥进行数字签名</li><li>确认是否信任<ul><li>通过自己的数字签名</li><li>通过自己完全信任的人的数字签名</li><li>通过自己有限信任的多个人的数字签名</li></ul></li></ul><h2 id="Kerberos">Kerberos</h2><ul><li>采用传统加密算法(非公钥算法)</li></ul><h3 id="基本概念">基本概念</h3><ul><li>Principle：安全个体，有名字和口令</li><li>KDC：网络服务，提供ticket和临时会话密钥</li><li>Ticket：客户用来向服务器证明身份的票据<ul><li>其大多数信息被服务器的密钥加密</li></ul></li><li>Authenticator：包含最近产生的信息的记录，需要用到会话密钥</li><li>Credentials：一个Ticket加上秘密的会话密钥</li><li>AS：Authentication Server<ul><li>通过long-term key认证用户</li><li>授予用户ticket granting ticket和short-term key</li><li>认证服务</li></ul></li><li>TGS：Ticket Granting Server<ul><li>通过ticket granting ticket和short-term key认证用户</li><li>发放service granting ticket给用户以访问其他服务器</li><li>授权和访问控制服务</li></ul></li></ul><h3 id="Kerberos工作流程">Kerberos工作流程</h3><h4 id="1-认证服务交换：获得票据许可票据-ticket-granting-ticket">1. 认证服务交换：获得票据许可票据(ticket granting ticket)</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101144837036.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101144837036.png" srcset="data:image/png;base64,666" alt="image-20201101144837036"></p><h4 id="2-票据许可服务交换：获得服务许可票据-service-granting-ticket">2. 票据许可服务交换：获得服务许可票据(service granting ticket)</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145139960.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145139960.png" srcset="data:image/png;base64,666" alt="image-20201101145139960"></p><h4 id="3-客户-服务器认证交换：获得服务image-20201101145321623">3. 客户/服务器认证交换：获得服务<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145321623.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145321623.png" srcset="data:image/png;base64,666" alt="image-20201101145321623"></h4><h3 id="Kerberos跨域认证">Kerberos跨域认证</h3><ol><li>获得本地TGS访问权</li><li>请求一张远程TGS的票据许可票据</li><li>向远程TGS请求其域内的服务</li></ol><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145413287.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145413287.png" srcset="data:image/png;base64,666" alt="image-20201101145413287" style="zoom: 50%;" /><h3 id="Kerberos优缺点">Kerberos优缺点</h3><h4 id="优点">优点</h4><ul><li>密码不在网上传输，不易被窃听，难以猜测</li><li>单点登录机制，只用输入一次口令</li><li>票据被盗之后难以使用，因为需要配合认证头来使用</li></ul><h4 id="缺点">缺点</h4><ul><li>缺乏撤销机制</li><li>密钥管理复杂</li><li>跨域认证复杂</li><li>需要始终同步</li><li>需要始终在线的AS和TGS</li></ul><h2 id="BAN">BAN</h2><h3 id="所用符号">所用符号</h3><ul><li><p>A, B, S：泛指参与协议的主体</p></li><li><p>P, Q, R：主体变量</p></li><li><p>X, Y: 公式变量</p></li><li><p>K: 密钥变量</p></li><li><p>K<sub>ab</sub>, K<sub>bs</sub>, K<sub>as</sub>: 主体之间的共享密钥</p></li><li><p>K<sub>a</sub>, K<sub>b</sub>, K<sub>s</sub>: 主体的公钥</p></li><li><p>K<sub>a</sub><sup>-1</sup>, K<sub>b</sub><sup>-1</sup>, K<sub>s</sub><sup>-1</sup>: 主体的私钥</p></li><li><p>N<sub>a</sub>, N<sub>b</sub>, N<sub>s</sub>：主体各自生成的用于确认新鲜性的随机数Nonce</p></li><li><p>{X}<sub>k</sub>：用密钥k加密X的结果</p></li><li><p>&lt;X&gt;Y：X和Y的组合</p></li><li><p>P-&gt;Q:(X)：P发送消息X给Q</p></li><li><p>bel(P,Q)：主体P相信X</p></li><li><p>sees(P,X)：P接收到X</p></li><li><p>said(P,X)：P发送X</p></li><li><p>cont(P,X)：P拥有对X正确与否的判决权</p></li><li><p>fresh(X)：X是新鲜的</p></li><li><p>skey(P,K,Q)：K是P,Q的共享密钥</p></li><li><p>goodkey(P,K,Q)：K是P,Q共享的良好密钥</p></li><li><p>pubkey(P,K)：K是P的公钥</p></li><li><p>secret(P,X,Q)：X是P和Q的共享秘密</p></li></ul><h3 id="推理规则">推理规则</h3><h4 id="消息意义规则">消息意义规则</h4><p>从加密消息所使用密钥以及消息中包含的秘密来推断消息发送者的身份</p><ul><li>例如对于共享密钥：bel(P,goodkey(P,K,Q)) and sees(P,{X}<sub>k</sub>) =&gt; bel(P,said(Q,X))</li></ul><h4 id="随机数验证规则">随机数验证规则</h4><p>如果P相信X是新鲜的，并且P相信Q曾经发送过X，那么P相信Q相信X</p><ul><li>bel(P,fresh(X)) and bel(P,said(Q,X)) =&gt; bel(P,bel(Q,X))</li></ul><h4 id="仲裁规则">仲裁规则</h4><p>如果P相信Q对X是有仲裁权的，并且P相信Q相信X，那么P相信X</p><ul><li>bel(P,cont(Q,X)) and bel(P,bel(Q,X)) =&gt; bel(P,X)</li></ul><h4 id="信仰规则">信仰规则</h4><ul><li><p>bel(P,X) and bel(P,Y) =&gt; bel(P,(X,Y))</p></li><li><p>bel(P,(X,Y)) =&gt; bel(P,X) or bel(P,Y)</p></li><li><p>bel(P,bel(Q,(X,Y))) =&gt; bel(P,bel(Q,X)) or bel(P,bel(Q,Y))</p></li></ul><h4 id="接收规则">接收规则</h4><ul><li>如果P接收到一个消息，那么P也接收到这个消息的一部分<ul><li>sees(P,(X,Y)) =&gt; sees(P,X)</li><li>sees(P,&lt;X&gt;Y) =&gt; sees(P,X)</li></ul></li><li>如果P收到加密消息，那么以下三种情况P可以读出消息原文<ul><li>bel(P,goodkey(P,K,Q)) and sees(P,{X}<sub>K</sub>) =&gt; sees(P,X)</li><li>bel(P,pubkey(P,K)) and sees(P,{X}<sub>K</sub>) =&gt; sees(P,X)</li><li>bel(P,pubkey(Q,K)) and sees(P,{X}<sub>K</sub><sup>-1</sup>) =&gt; sees(P,X)</li></ul></li></ul><h4 id="新鲜规则">新鲜规则</h4><p>如果消息的一部分是新鲜的，则整个消息是新鲜的</p><ul><li>bel(P,fresh(X)) =&gt; bel(P,fresh(X,Y))</li></ul><h4 id="传递规则">传递规则</h4><p>如果P相信Q曾经发送过整个消息，那么P相信Q曾经发送过消息的部分</p><ul><li>bel(P,said(Q,(X,Y))) =&gt; bel(P,said(Q,X))</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SGX Developer Guide - Reading Notes</title>
      <link href="2020/11/25/learning-notes/SGX-Developer-Guide-Notes/"/>
      <url>2020/11/25/learning-notes/SGX-Developer-Guide-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="专业名词">专业名词</h2><ul><li><p>ECall：“Enclave Call”一个调用enclave内部接口函数的操作</p></li><li><p>OCall：“Out call”从enclave内部向外部的应用发起调用的操作</p></li><li><p>Trusted：任何在enclave内部 <code>trusted</code> 环境下执行的代码或者数据结构</p></li><li><p>Trusted Thread Context：线程的上下文存放在enclave中，主要包括以下几个部分组成：</p><ul><li>Thread Control Structure（TCS）线程控制结构</li><li>Thread Data/Thread Local Storage 在enclave中的线程相关的数据</li><li>State Save Area(SSA) 线程异常处理机制</li><li>Stack 线程栈</li></ul></li><li><p>Untrusted：指代任何运行在应用的 <code>untrusted</code> 环境下（等价于enclave外部）的代码或者数据结构。</p></li></ul><h2 id="Enclave-编程模型">Enclave 编程模型</h2><h3 id="Enclave开发原则">Enclave开发原则</h3><ul><li>enclave是一个庞大而单一的软件实体，目标在于将对于一个应用而言的可信计算基降低至可信运行时系统，ISV代码和第三方可信库。在上述组件中的任一个bug将会导致enclave的安全问题。</li><li>非可信域控制了enclave 接口函数什么时候被调用的顺序。</li><li>当调用进入enclave中，是由不可信域来在enclave中选择可信线程上下文去执行。</li><li>并不保证传递进去enclave（ecall）中的参数和从enclave向外部发送的参数（ocall）是正确的，因为这是由不可信域提供的。</li><li>enclave向外部发送的调用 <code>OCall</code>，不能保证不可信函数一定正确地被执行。</li><li>任何人都可以加载一个enclave。更为严重的是，攻击者可能使用攻击性应用程序去加载一个enclave，利用该enclave存在的安全漏洞，窃取相关数据。</li></ul><h3 id="Enclave文件格式">Enclave文件格式</h3><ul><li>一个 enclave library 文件包括可信代码和数据部分，当enclave被创建时，这些将会被导入到受保护的 enclave 内存（即EPC）中</li><li>在一个enclave文件中，还存在着Intel SGX特定的数据结构，enclave元数据：<ul><li>元数据没有导入EPC中，而是被不可信的加载器加载，并决定enclave如何导入到EPC中</li><li>元数据中定义了可信线程上下文的数量，包括可信堆和可信栈的大小，在enclave初始化的时候，可信堆和可信栈被可信运行时系统初始化</li><li>元数据同时包括enclave的签名，这对于enclave的认证和初始化时非常重要的</li></ul></li></ul><p>**注：**不管enclave中定义了多少个可信线程，在设计的过程中不能假设不可信应用将会以特定的顺序去调用 Enclave 中的接口函数。一旦enclave被初始化，一个攻击者可以调用 Enclave 接口函数，以任何可能的顺序去发起调用并且提供相应的输入参数。</p><h3 id="Enclave可信计算基">Enclave可信计算基</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201118224903930.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201118224903930.png" srcset="data:image/png;base64,666" alt="image-20201118224903930"></p><h3 id="Enclave-Interface-函数-ECalls">Enclave Interface 函数 (ECalls)</h3><ul><li>enclave无法控制哪个ECall被执行，或者ECall将会以怎样的顺序被调用</li><li>ISV接口函数仅仅只能在enclave初始化后被调用，这意味着：<ul><li>任何必要的地址基地址重置被正确地执行。</li><li>可信全局数据，例如栈等被正确地初始化。</li><li>可信线程的上下文，可信线程被正确地初始化。</li><li>不直接说明的可信初始化函数执行完成。（例如ISV全局构造函数）</li></ul></li></ul><h3 id="Enclave的输入">Enclave的输入</h3><ul><li>Enclave输入和输出可以被不可信的代码观察和修改</li><li>为了防止针对输入函数的攻击，软件开发者应该采用加密的方式和完整性检测来保证enclave执行的可信性</li></ul><p><strong>当一个encalve函数被调用时</strong>：</p><ul><li>函数的参数和其他任何通过引用传递的序列化数据参数进入到可信环境中，并且对于攻击者无法访问的。</li><li>在参数上进行读写操作，返回值和其他序列化的引用，根据enclave开发者的参数与特殊定义，将不会影响ISV代码和数据的保密和完整性。<ul><li>参数和返回值，序列化数据被可信运行时分配和管理，不对任何ISV代码和数据进行覆盖。</li><li>参数，返回值和序列化引用的大小被ISV所指定。</li></ul></li></ul><h2 id="通过引用传递的输入参数">通过引用传递的输入参数</h2><p>当ISV接口函数被调用时，输入参数将被停留在enclave中。然而，当一个输入参数通过引用的形式传递，只有引用（或指针）将会放置到enclave中。引用所指向的值停留在外部，并且会不断地变化。例如，一个攻击者可能在enclave检查函数参数后改变所引用的值。</p><h3 id="外部Enclave调用-OCalls">外部Enclave调用 (OCalls)</h3><p>Enclave无法直接访问OS提供的服务。作为替代的是，encalve必须发起一个OCall将其传递到不可信应用中。</p><p>当一个enclave内的ISV函数发起OCall时：</p><ul><li>OCall仅仅暴露其参数和返回值到不可信域中。</li><li>当一个OCall发生时，返回值和任何序列化数据的引用将传递进入可信执行环境中，对攻击者不可以访问。另外enclave需要检查指针。</li><li>当一个OCall发生时，可信线程上下文与OCall之前的相同，除了在栈上的数据和易变寄存器上的值。</li></ul><h2 id="Enclave签名">Enclave签名</h2><p>在软件中通过enclave建立信任的过程中主要有着以下三种行为：</p><ul><li>Measurement（度量）：作为enclave在可信环境中初始化时用来验证文件准确性的身份。</li><li>Attestation（认证）：向其它实体证明当前的环境被正确的初始化。</li><li>Sealing（数据的密封）：通过某种方式保证可信环境上的数据可以正确地持久化和重新加载。</li></ul><p>Enclave签名包含允许Intel SGX硬件检测enclave的完整性是否被篡改的信息，同时可以识别enclave持有人的身份。encalve 签名包含这几个如下的重要字段，对于外部实体的认证非常重要。</p><ul><li>Enclave Measurement - 一个简单的256位哈希值用来标注代码和放入到enclave中的初始化数据，包括他们放入到EPC中期待的顺序和位置，以及这些页面的安全属性。当enclave代码/数据加载到EPC中，CPU开始计算enclave measurement并且将这个值存储在MRENCLAVE 寄存器中。接着CPU比较MRENCLAVE寄存器中的内容和存放在SIGSTRUCT中的enclave measurement值。当且仅当它们相等的时候，CPU允许enclave被初始化。</li><li>Enclave所有者的公钥 - 当一个enclave被正确地初始化，CPU将enclave所有者的公钥的hash存放在MRSIGNER寄存器中。MRSIGNER中的内容将会用作enclave所有者的身份证明。被同一个key认证的enclave在MRSIGNER寄存器中的值相同。</li><li>Enclave的安全版本号（ISVSVN）- enclave所有者对于enclave的每个版本号分配一个安全版本号。安全版本号反映了enclave的安全属性级别，并且需要单调递增，随着安全属性的不断上升。在一个enclave被正确初始化后，CPU记录SVN，并且在远程认证的过程中被使用。一个有着相同安全属性的enclave的不同版本应该分配相同的安全版本号。例如，一个没有解决安全相关bug的新版本enclave需要与旧版本的enclave持有相同的安全版本号。</li><li>Enclave的产品ID（ISVPRODID）- enclave所有者针对每一个enclave分配一个产品ID。产品ID允许enclave所有者使用相同的enclave所有者身份去分割enclave。当一个enclave被正确的初始化后，CPU记录Product ID，在远程认证的过程中可以被使用。</li></ul><h2 id="Enclave认证">Enclave认证</h2><h3 id="本地认证">本地认证</h3><p>一个enclave可以请求硬件生成一个证书，即report，其中通过密码学证据证明着enclave存在这个平台上。这个report可以给其他的enclave，让其进行验证report是同一平台上生成。内部enclave之间认证机制使用的是对称密钥，只有验证report结构的enclave和创建enclave report的硬件可以访问到，并且嵌入到硬件平台中。</p><p>一个enclave report包含着以下的信息：</p><ul><li>enclave中的code和初始化数据的measurement。</li><li>enclave初始化的时候记录ISV证书公钥的哈希值。</li><li>用户后来添加的数据。</li><li>其他安全相关的状态信息。</li><li>上述所有数据的一个签名，可以被生成report的同一平台去进行验证。</li></ul><h4 id="本地认证过程">本地认证过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122114320790.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122114320790.png" srcset="data:image/png;base64,666" alt="image-20201122114320790"></p><ol><li><p>在上图中，应用A持有enclave A，应用B持有enclave B。在不可信应用A和B为两个enclave建立通信后，enclave B向enclave A发送了MRENCLAVE的值。（应用A和B可以是同一应用）</p><p>有两种方法对于应用而言可以提取enclave的MRENCLAVE measurement:</p><ul><li>应用B从enclave B的enclave证书中提取MRENCLAVE的值。</li><li>enclave B提供了一个接口来导出该值，通过创建一个report。</li></ul></li><li><p>Encalve A请求硬件生成一份report送至enclave B，并且其中包含着从enclave B获取到的数据。enclave A通过不可信应用将数据发送给enclave B。</p></li><li><p>当enclave B收到了来自enclave A的报告，enclave B要求硬件去验证report来确认enclave A和B在同一平台上运行。enclave B从enclave A中提取相应的MRENCLAVE，然后请求硬件生成自己的report，接着发送给enclave A。</p></li><li><p>enclave A验证enclave B的report，并且验证enclave B和自己运行在同一平台上。</p></li></ol><h3 id="远程-跨平台-认证">远程 (跨平台) 认证</h3><p>一个持有enclave的应用可以要求enclave去生成一份report，接着将这份report传到平台服务去生成一种类型的证书，反映着enclave和平台的状态。这种类型的证书被称为quote。这个quote可以传递到平台外的实体，并且使用Intel Enhanced Privacy ID（Intel EPID）签名技术去进行验证。作为结果，CPU的密钥并没有直接从平台内部暴露出去。</p><p>一个quote包含这以下的数据：</p><ul><li>enclave中代码和初始化数据的measurement。</li><li>enclave初始化的时候记录ISV证书公钥的哈希值。</li><li>enclave的产品ID和安全版本号。</li><li>enclave的属性，例如，encalve是否运行在debug mode。</li><li>enclave中添加的用户数据。提供了一种方式由enclave向外部实体提供数据。</li><li>上述所有数据的一个签名，借助于Intel EPID组签名技术。 包含在quote中的enclave 数据（MRENCLAVE, MRSIGNER, ISVPRODID, ISVSVN, ATTRIBUTES等等）在远程认证过程的末尾提供给远程服务使用上。服务提供者将根据这些数据去进行判断是否可信。</li></ul><h4 id="EPID">EPID</h4><p>Intel EPID是一种组签名技术，允许平台去匿名签名对象并且可以保护签名者的隐私（如果使用机器的CPUID签名，会导致隐私的泄露）。通过Intel EPID签名技术，组里面的每一个签名者都有他们各自的私钥，但是验证者使用相同的公钥去验证个人的签名。因此，用户无法识别出两个交易是否来自于同一个机构，因为用户无法检测中是组里面哪个成员做了签名。在Intel SGX中，这个组是所有支持Intel SGX平台的集合。</p><h4 id="QE">QE</h4><p>Intel中内嵌了一种特殊的enclave，成为Quoting Enclave（QE），QE验证report正确地按照其MRENCLAVE mesurement值进行创建，然后将它用一个硬件特定的非对称密钥（Intel EPID key）进行签名，输出的内容就是quote。当enclave 系统正在运行的过程中，只有QE有权限访问Intel EPID key。因此quote可以看作直接来自于硬件本身，但是CPU key永远不会暴露到平台外部。</p><h4 id="远程认证过程">远程认证过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122120414342.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122120414342.png" srcset="data:image/png;base64,666" alt="image-20201122120414342"></p><ol><li>当应用需要在平台外部的服务，它首先和外部服务提供系统建立连接。服务提供者发起挑战(包含一个nonce)来证明应用确实运行在enclave中</li><li>应用从应用的enclave请求一份report，并将来自外部服务提供商的nonce传递进enclave中</li><li>enclave生成一份report结构，并将其连同一个清单返回给应用，清单包含report中用户数据部分的值以及nonce和用于挑战应答交互的密钥</li><li>report发送给QE去做签名<ul><li>QE验证report</li><li>QE转换report的body转换为quote，并对其使用EPID进行签名</li></ul></li><li>QE返回quote structure</li><li>应用返回quote结构体和其他相关的信息到外部服务者</li><li>外部服务者使用EPID验证公钥去验证quote的签名信息。</li><li>外部服务者对比来自enclave的信息，并与其它可信配置的信息进行比较。判断enclave是否满足条件。其中包括检测enclave是否运行在debug模式，及其的measurement，产品ID和enclave所有人等等。</li></ol><h3 id="区分不同的Enclave运行实例">区分不同的Enclave运行实例</h3><p>Intel SGX不直接提供一种机制（例如，通过自动生成的REPORT字段）来区分同一个enclave的两个不同的实例。</p><p>如果想要尝试的话，可以使用RDRAND函数生成随机数，并作为作为用户数据，嵌入到REPORT中。</p><h2 id="Enclave密封">Enclave密封</h2><p>为了保护和持久化数据，提供了一种由enclave软件从特定的enclave中提取key的机制。这个Key只能在特定的平台上被某个enclave生成。enclave 软件使用那个key去在平台上加密数据或者从平台上解密已经存在的数据。我们把这种加密和解密的操作成为密封和解封。</p><h3 id="软件密封技术">软件密封技术</h3><h4 id="密封到当前的enclave（依照于enclave度量）">密封到当前的enclave（依照于enclave度量）</h4><p>密封到当前enclave 使用enclave measurement的当前版本（MRENCLAVE），当enclave创建的时候，将这个值绑定到密封操作所需要使用的key上。这个绑定操作由硬件执行通过EGETKEY指令。</p><p>只有有着相同的MRENCLAVE度量的enclave才能够将密封的数据进行解密。如果enclave的DLL，Dynamic Library，或者Shared Object文件被篡改，那么enclave的measurement将会发生改变。作为影响，密封的key同样会发生变化，数据将不会被还原。</p><h4 id="密封到enclave当前的所有者">密封到enclave当前的所有者</h4><p>将数据密封到enclave的当前的所有者需要使用enclave所有者的身份，这个值由CPU在enclave初始化的过程中存储在MRSIGNER寄存器中，并且这个值被绑定到密封数据函数所需要使用到的key中。这个绑定是由硬件通过EGETKEY指令完成。被密封数据函数使用的key同时也被绑定到enclave的产品ID上。产品ID在enclave初始化时存储在CPU中。</p><p>当MRSIGNER度量寄存器的值和产品ID相同时，enclave才能解密。 这种机制的好处是：</p><ul><li>它允许enclave的所有者对enclave进行升级，但是不需要进行复杂的升级过程来解密之前密封在之前版本的enclave（MRENCLAVE 度量值不同）中的数据，并且重新使用密封到新的版本</li><li>它允许来自相同的所有者的enclave实现共享数据</li></ul><p>Enclave所有者生产出enclave后，可以为之指定安全版本号。这个安全版本号同样在enclave初始化的时候存储在CPU中。一个enclave在从CPU中获取密封key的请求中必须提供一个相应的安全版本号。一个enclave不能指定一个比它当前安全版本号靠后的enclave，但是encalve可以指定一个在当前安全版本号之前的安全版本号。这个选项使enclave获得了解封之前版本的enclave中的数据，对于enclave软件更新，是有着巨大的好处的。</p><h3 id="密封和解封过程">密封和解封过程</h3><p>在enclave中<strong>密封</strong>数据的主要过程如下：</p><ol><li><p>为加密数据和密封数据结构在enclave中分配内存。其中密封数据结构主要包括要加密的数据和额外认证数据(AAD, 额外的参与MAC计算但不进行加密的数据或文本)。额外认证数据中的信息可能包括应用enclave，版本号，数据等</p></li><li><p>调用加密数据的API来执行加密操作，一个加密操作算法如下：</p><ul><li>验证输入参数是有效的。例如，如果作为参数进行传递的是一个指向加密数据结构的指针，它指向的缓存必须存在于enclave中。</li><li>初始化并向其中填充一个将要被EGETKEY指令来执行密钥请求的数据结构。过程如下：<ul><li>获取EREPORT去获得安全ISV和TCB安全版本号，将在key获取中使用</li><li>Key 名称：识别获取key的名字，在这种情况下即为Seal key</li><li>Key Policy：识别即将使用的软件密封策略。使用MRSIGNER来表示密封到enclave的所有者上，使用MRENCLAVE来表示密封到当前的enclave（enclave measurement）中。保留位必须被清除</li><li>Key ID：调用RDRAND来获取一个随机数</li><li>属性字段：表明密封密钥应该与什么属性进行绑定</li></ul></li><li>使用上一步构造出的密钥请求结构调用EGETKEY获取Seal key</li><li>使用加密算法来使用密封密钥来执行密封操作。推荐使用AES-GCM加解密函数，例如Rijndael128GCM</li><li>从内存删除seal key以防泄露</li></ul></li><li><p>将密封数据结构（包括密钥请求结构）从enclave中保存到外部内存中。密钥请求结构将用来在今后的enclave初始化后去获取密封密钥。</p></li></ol><p>在enclave中对加密数据进行<strong>解密</strong>主要包括以下过程：</p><ol><li><p>为待解密的数据分配内存。</p></li><li><p>调用解密api去执行解密操作。一个解密操作算法如下：</p><ul><li>验证输入参数的合法性。</li><li>从密封数据结构中提取密钥请求结构</li><li>借助密钥请求结构去通过EGETKEY指令获取密封密钥</li><li>调用解密算法使用密封密钥解密</li><li>从内存中删除密封密钥以防止泄露</li><li>验证解密算法生成的hash与加密过程中生成的hash一致</li></ul></li></ol><h3 id="区分不同的Enclave实例">区分不同的Enclave实例</h3><p>即使同一个enclave的两个不同的实例可以在它们认证时区分，但是当两个enclave都使用EGETKEY指令时，目前Intel SGX不提供一种机制来阻止一个enclave实例去访问另一个enclave的密封数据，两个实例将会返回相同的密钥值。</p><p>如果要区分enclave实例的SEAL key，推荐：</p><blockquote><p>Intel recommends that enclave writers use the KEYID field of the KEYREQUEST structure passed into the EGETKEY instruction to pass an enclave instance specific nonce. This will provide a different key even when the same enclave is in a different virtual machine.</p></blockquote><h2 id="处理器特征">处理器特征</h2><p>在enclave中可以执行大部分Ring3软件能执行的指令</p><h2 id="程序性能">程序性能</h2><h3 id="Enclave创建">Enclave创建</h3><p>enclave的大小很大程度上影响了创建enclave的时间，主要是由于在enclave的度量（measurement）过程中，需要进行一系列操作以保证所有的代码加载到enclave中是可信的。</p><p>在enclave的创建过程中，一系列的EADD和EEXTEND指令将被运行，主要用于加载和度量enclave的页面。</p><ul><li>EADD每次加载4k字节的数据。</li><li>EEXTEND每次度量256字节的数据。这意味着对于EADD添加的4KB的数据，需要发起16次的EEXTEND调用。</li></ul><p>相关的性能优化建议：</p><ul><li>减小enclave的大小。仔细检查在enclave中每段代码和数据元素，如有必要，将其移除。（使用工具：Intel VTune Amplifier）。例如，将即将静态链接的.o 文件先转换为诶.a文件。</li><li>Intel SGX 允许enclave通过 Enclave Dynamic Memory Management（EDMM）的方式去进行扩展。当你的OS支持EDMM，那么可以先创建一个比较小的enclave，然后扩展它。</li><li>通过在application中添加加载条的方式来获取用户的注意力，借此隐藏应用的加载时间。</li><li>避免频繁的enclave创建和重新加载，进而最小化重复的加载性能损耗。</li></ul><h3 id="Enclave切换">Enclave切换</h3><p>在enclave之间的频繁转变需要在上下文之间切换非常多次。当一个EENTER指令触发进入enclave时，为了保证enclave可以正常运行，属于不可信运行时的注册状态（register state）和其它信息被存储，enclave中的线程状态和其它属于可信状态的信息被加载，这部分工作主要是由SDK生成的代码执行。一个相反的过程发生在从enclave中退出（被EEXIT指令触发）：可信线程状态信息被保存，不可信的注册状态和其它信息被还原，在这个过程中同样执行着安全检查，这部分工作也主要由SDK生成的代码自动执行。这些行为构成了在应用和enclave之间控制权切换所带来的固定负载。</p><p>然而，这个转变中有一些可变变量影响着损耗，即传递参数的大小。参数在从不可信应用部分到可信enclave传递的过程中被序列化，并且返回值被反序列化。在可信enclave中，来自不可信应用的参数被反序列化，并且将返回值序列化。如果应用传递大量的参数，将会有显著的性能损耗。</p><p>如果在enclave和应用之间的控制权的转变很大程度地冲击着性能，考虑通过通过以下的方式降低影响：</p><ul><li>减小传递参数的总大小。（使用工具：Intel VTunte Amplifier）</li><li>当确实有大量数据需要进行传递的时候，考虑使用指针的方式。<strong>需要说明的是，使用指针会带来一部分安全风险，为此你必须自己去实现指针检查器，如果使用这种方式的话。</strong></li></ul><h3 id="过多缓存未命中">过多缓存未命中</h3><p>encalve所存储的内存内容在处理器cache之外的部分都是加密受保护的。这种类型的保护在从内存中获取cache lines带来了相应的负载。这种负载和Intel SGX实现方式有直接关系。</p><p>Intel SGX架构中在缓存未命中的情况下，相对于其他传统的负载，新增了两种类型的负载：</p><ul><li>对于不在处理器cache中的每一条cache line所执行的完成check/anti-replay 检查，以及在系统内存中更新相应的数据结构（如果必要的话）。这种类型的负载依赖于内存访问模式。</li><li>在cache和内存中加载和移除数据所带来的加解密。</li></ul><p>如果你的系统受到大量的缓存未命中而相关的性能损耗的冲击，可以考虑下面的步骤：</p><ul><li>减小enclave中的数据的大小。观察数据，以保证只有必要的数据才能装载进入enclave中。更少的数据意味着更少的加减密和更少的数据结构检查，在Intel SGX内存控制/保护机制下。可以使用Intel VTune Amplifier来观察应用中的cache行为。</li><li>可以查看下面的文档去创建一个更加“缓存友好”的应用：<a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf">PDF地址</a></li></ul><h3 id="过多的页写入">过多的页写入</h3><p>需要考虑Intel SGX应用频繁大量的页面切换对性能的影响，并且如何最小化这方面的后果：</p><p>Intel SGX使用安全存储 EPC 来存储enclave中的内容。Enclave页面大小为4KB。当enclave比EPC总可用的内存要大的话，enclave分页机制可能会被某些特权软件来使用。当OS尝试交换enclave页面时，CPU使用EWB指令执行以下的步骤：</p><ul><li>读取要替换出去的Intel SGX页面（移出）</li><li>加密页面中的内容</li><li>将加密的页面写到未收到保护的系统内存中</li></ul><p>由于这个过程有着固定的负载，因此越多的页面被替换出去，越多的性能损耗发生。为了阻止应用频繁经历这种页面的交换，尽可能确保enclave的大小小于EPC。尽可能只将秘密数据和在这之上的操作放入enclave中，从而最小化页面交换的可能性。可以使用Intel VTune Amplifier工具来观察应用中页面替换的行为，来保证做出正确的决定</p><h3 id="多线程下的性能">多线程下的性能</h3><p>如果应用是多线程的，从数据同步，锁，线程模型和内存分配算法上去寻找改善性能的方法。</p><ul><li>Intel SGX SDK 的一些关于同步和锁的原语已经被优化。</li><li>对于较重的多线程应用，推荐选择更好的内存分配算法。Intel SGX SDK针对linux提供了TCMalloc内存分配算法，相对于默认的dlmalloc内存分配算法，有着更好的性能表现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGX程序基础</title>
      <link href="2020/11/24/instruction/sgx-programming/"/>
      <url>2020/11/24/instruction/sgx-programming/</url>
      
        <content type="html"><![CDATA[<h2 id="项目目录结构">项目目录结构</h2><p>以<code>SampleEnclave</code>为例，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── App</span><br><span class="line">│   ├── App.cpp</span><br><span class="line">│   ├── App.h</span><br><span class="line">│   ├── Edger8rSyntax</span><br><span class="line">│   │   ├── Arrays.cpp</span><br><span class="line">│   │   ├── Functions.cpp</span><br><span class="line">│   │   ├── Pointers.cpp</span><br><span class="line">│   │   └── Types.cpp</span><br><span class="line">│   └── TrustedLibrary</span><br><span class="line">│       ├── Libc.cpp</span><br><span class="line">│       ├── Libcxx.cpp</span><br><span class="line">│       └── Thread.cpp</span><br><span class="line">├── Enclave</span><br><span class="line">│   ├── Edger8rSyntax</span><br><span class="line">│   │   ├── Arrays.cpp</span><br><span class="line">│   │   ├── Arrays.edl</span><br><span class="line">│   │   ├── Functions.cpp</span><br><span class="line">│   │   ├── Functions.edl</span><br><span class="line">│   │   ├── Pointers.cpp</span><br><span class="line">│   │   ├── Pointers.edl</span><br><span class="line">│   │   ├── Types.cpp</span><br><span class="line">│   │   └── Types.edl</span><br><span class="line">│   ├── Enclave.config.xml</span><br><span class="line">│   ├── Enclave.cpp</span><br><span class="line">│   ├── Enclave.edl</span><br><span class="line">│   ├── Enclave.h</span><br><span class="line">│   ├── Enclave.lds</span><br><span class="line">│   ├── Enclave_private_test.pem</span><br><span class="line">│   └── TrustedLibrary</span><br><span class="line">│       ├── Libc.cpp</span><br><span class="line">│       ├── Libc.edl</span><br><span class="line">│       ├── Libcxx.cpp</span><br><span class="line">│       ├── Libcxx.edl</span><br><span class="line">│       ├── Thread.cpp</span><br><span class="line">│       └── Thread.edl</span><br><span class="line">├── Include</span><br><span class="line">│   └── user_types.h</span><br><span class="line">├── Makefile</span><br><span class="line">└── README.txt</span><br></pre></td></tr></table></figure><ul><li>App目录：存放应用程序中的不可信代码部分<ul><li>App.cpp文件：应用程序中的不可信部分代码，其中包括了创建Enclave及销毁Enclave的代码，也定义了一些相关的返回码供使用者查看Enclave程序的执行状态。其中的main函数是整个项目的入口函数。</li><li>App.h文件：应用程序中的不可信部分代码的头文件，定义了一些宏常量和函数声明。</li><li>Edger8rSyntax文件夹：提供了一些工具。</li><li>TrustedLibrary文件夹：提供了一些函数库。</li></ul></li><li>Enclave目录：存放应用程序中的可信代码部分和可信与不可信代码接口文件<ul><li>Enclave.config.xml文件：Enclave的配置文件，定义了Enclave的元数据信息。</li><li>Enclave.cpp文件：应用程序中的可信部分代码，包括了可信函数的实现。</li><li>Enclave.h文件：应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明。</li><li>Enclave.edl文件：Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口，trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。</li><li>Enclave.lds文件：定义了一些Enclave可执行文件信息。</li><li>Enclave_private_test.pem文件：SGX生成的私钥。</li><li>Edger8rSyntax文件夹：提供了一些工具。</li><li>TrustedLibrary文件夹：提供了一些函数库。</li></ul></li><li>Include目录：存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义<ul><li>user_types.h文件：定义了用户自定义的类型</li></ul></li><li>Makefile文件：项目的编译文件，定义了项目的编译信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> SGX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu将安装的应用固定到桌面</title>
      <link href="2020/11/23/instruction/ubuntu-show-application/"/>
      <url>2020/11/23/instruction/ubuntu-show-application/</url>
      
        <content type="html"><![CDATA[<p>升级了一下ubuntu，从18.04升到了20.04，发现自动安装了国际版的firefox，之前安装的国内版firefox目录还在<code>/opt</code>下，但是桌面显示的firefox是国际版的，且启动栏也没有国内版的firefox应用。</p><h2 id="Step1">Step1</h2><p>卸载国际版firefox</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections | grep firefox</span><br><span class="line">sudo apt-get purge firefox ... <span class="comment"># 所有上一步列出的应用</span></span><br></pre></td></tr></table></figure><h2 id="Step2">Step2</h2><p>在<code>/usr/share/applications/</code>目录新建<code>firefox.desktop</code>，并添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name&#x3D;Firefox</span><br><span class="line">Exec&#x3D;&#x2F;opt&#x2F;firefox&#x2F;firefox</span><br><span class="line">Icon&#x3D;&#x2F;opt&#x2F;firefox&#x2F;browser&#x2F;chrome&#x2F;icons&#x2F;default&#x2F;default128.png</span><br><span class="line">Terminal&#x3D;False</span><br><span class="line">Type&#x3D;Application</span><br></pre></td></tr></table></figure><h2 id="Step3">Step3</h2><p>更改firefox.desktop文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 firefox.desktop</span><br></pre></td></tr></table></figure><h2 id="Step4">Step4</h2><p>在启动栏可以看见新建的应用图标，并且可以添加到侧边栏</p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust - Learn</title>
      <link href="2020/11/16/learning-notes/Rust-notes/"/>
      <url>2020/11/16/learning-notes/Rust-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Ch0-安装Rust">Ch0 安装Rust</h2><ul><li><p>使用rustup安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></li><li><p>安装时出现的问题（<s>未完全</s>解决）：默认<code>.cargo</code>环境变量设置为了<code>/home/&lt;username&gt;/~/.cargo</code>，导致在用户家目录下又新建了<code>~</code>目录，在安装完rust后，将<code>.cargo</code>目录移动到<code>~/</code>家目录下，并修改所有可能会更改环境变量的文件，包括<code>~/.profile</code>、<code>/etc/profile</code>、<code>/etc/bash.bashrc</code>、<code>~/.cargo/env</code>，将其中的<code>/home/&lt;username&gt;/~/.cargo</code>改为<code>~/.cargo</code>。但是每当打开终端时，环境变量PATH还是会自动添加<code>/home/&lt;username&gt;/~/.cargo/bin</code></p><ul><li><p><s>暂时的</s>解决方案：在<code>~/.bashrc</code>文件中添加语句，覆盖错误的环境变量(重启后就成功了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/.cargo/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Ch1-Cargo">Ch1 Cargo</h2><h3 id="1-1-使用Cargo创建项目">1.1 使用Cargo创建项目</h3><ul><li><p>创建hello_world目录，并在其中新建二进制项目hello_world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world</span><br></pre></td></tr></table></figure></li><li><p>创建库项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world --lib</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-1-Cargo-toml">1.1.1 Cargo.toml</h4><p>Cargo.toml是项目的配置文件，通过cargo new自动生成</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><ul><li>[package]片段：配置一个包，包含项目名称、版本、作者和Rust版本</li><li>[dependencies]片段：罗列项目依赖</li></ul><h4 id="1-1-2-源代码目录src">1.1.2 源代码目录src</h4><p>包含main.rs以及其他源文件</p><h3 id="1-2-构建并运行Cargo项目">1.2 构建并运行Cargo项目</h3><p><strong>编译项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><p><strong>编译并运行项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br></pre></td></tr></table></figure><p><strong>快速检查代码确保其可以编译，但不生成可执行文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br></pre></td></tr></table></figure><p>以上命令会生成以下文件：</p><h4 id="1-2-1-可执行文件">1.2.1 可执行文件</h4><p>存放目录为<code>./target/debug/hello_world</code></p><h4 id="1-2-2-Cargo-lock">1.2.2 Cargo.lock</h4><p>Cargo.lock记录项目依赖的实际版本，确保项目构建是可重现的，这个文件不需要人为修改</p><h3 id="1-3-发布-release-构建">1.3 发布(release)构建</h3><p>当项目最终准备好发布时，可以优化编译项目是的Rust代码运行更快</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br></pre></td></tr></table></figure><p>此时生成的可执行文件在<code>./target/release/</code>目录下</p><h2 id="Ch2-引入-guess-number">Ch2 引入 - guess_number</h2><h3 id="2-1-创建变量">2.1 创建变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure><ul><li><code>let</code> 创建变量，变量默认不可变</li><li><code>mut</code> 使得变量可变</li><li><code>::</code> 表明new是<code>String</code>类型的一个关联函数</li></ul><h3 id="2-2-从标准输入读取">2.2 从标准输入读取</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>io::stdin</code>函数返回一个终端标准输入句柄</li><li><code>read_line</code>将标准输入存入字符串</li><li><code>&amp;</code>表示这个参数是一个引用</li><li><code>read_line</code>函数返回一个<code>Result</code>类型（枚举），成员有<code>Ok</code>和<code>Err</code></li><li><code>Result</code>实例有<code>expect</code>方法：<ul><li>若<code>Result</code>值为<code>Ok</code>，<code>expect</code>获取<code>Ok</code>中的值并原样返回</li><li>若<code>Result</code>值为<code>Err</code>，<code>expect</code>导致程序崩溃，并显式当做参数传给<code>expect</code>的信息</li></ul></li></ul><h3 id="2-3-crate">2.3 crate</h3><p>crate是一个Rust代码包</p><ul><li>我们构建的项目是一个<strong>二进制crate</strong></li><li>rand crate是一个<strong>库crate</strong></li></ul><h4 id="2-3-1-导入外部crate">2.3.1 导入外部crate</h4><p>以rand crate为例</p><ul><li><p>在使用rand编写代码之前需要修改<code>Cargo.toml</code>文件</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.5.5&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>再进行<code>cargo build</code>，此时会从Crates.io拷贝数据并下载对应的库文件，需要更换国内镜像源进行加速，编辑<code>.cargo/config</code>文件，加入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;</span><br><span class="line">replace-with &#x3D; &#39;ustc&#39;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-更新crate">2.3.2 更新crate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo update</span><br></pre></td></tr></table></figure><h4 id="2-3-3-获取所有本地依赖提供的文档">2.3.3 获取所有本地依赖提供的文档</h4><p>查看应该 <code>use</code>哪个<code>trait</code>以及该从<code>crate</code>中调用哪个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo doc --open</span><br></pre></td></tr></table></figure><h2 id="Ch3-常见编程概念">Ch3 常见编程概念</h2><h3 id="3-1-变量和可变性">3.1 变量和可变性</h3><ul><li><p>使用<code>let</code>声明的变量默认是不可改变的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">5</span>;   <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure></li><li><p>在变量名之前加<code>mut</code>来使其可变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">5</span>;   <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-1-变量和常量的区别">3.1.1 变量和常量的区别</h4><ul><li><p>常量使用关键字<code>const</code>声明，并且必须<strong>注明值的类型</strong></p></li><li><p>不能对常量使用<code>mut</code></p></li><li><p>常量只能被设置为常量表达式，而不能是函数调用的结果</p></li></ul><h4 id="3-1-2-隐藏">3.1.2 隐藏</h4><ul><li><p>定义一个与之前变量同名的新变量，而新变量会<strong>隐藏</strong>之前的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>当再次使用<code>let</code>时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字</p></li></ul><h3 id="3-2-数据类型">3.2 数据类型</h3><p>Rust 是 <strong>静态类型</strong>语言，在编译时就必须知道所有变量的类型</p><h4 id="3-2-1-标量类型">3.2.1 标量类型</h4><ul><li><strong>标量</strong>类型代表一个单独的值</li></ul><h5 id="整型">整型</h5><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal</td><td><code>98_222</code></td></tr><tr><td>Hex</td><td><code>0xff</code></td></tr><tr><td>Octal</td><td><code>0o77</code></td></tr><tr><td>Binary</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr></tbody></table><h5 id="浮点型">浮点型</h5><ul><li><p>Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位</p></li><li><p>默认类型是 <code>f64</code></p></li></ul><h5 id="布尔型">布尔型</h5><ul><li><code>bool</code>，两个可能的值<code>true</code>和<code>false</code></li></ul><h5 id="字符类型">字符类型</h5><ul><li><code>char</code> 类型的大小为四个字节，并代表了一个 Unicode 标量值</li></ul><h4 id="3-2-2-复合类型">3.2.2 复合类型</h4><h5 id="元组类型">元组类型</h5><ul><li><p>元组长度固定：一旦声明，其长度不会增大或缩小</p></li><li><p>元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;   <span class="comment">// 解构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five_hundred = tup.<span class="number">0</span>;   <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure><h5 id="数组类型">数组类型</h5><ul><li>数组中的每个元素的类型必须相同</li><li>Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">0</span>; <span class="number">10</span>];   <span class="comment">// 初始化一个长度为10的全零数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];   <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure><h3 id="3-3-函数">3.3 函数</h3><ul><li><p><code>fn</code> 关键字声明新函数</p></li><li><p>在函数签名中，<strong>必须</strong>声明每个参数的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-1-具有返回值的函数">3.3.1 具有返回值的函数</h4><ul><li><p>以表达式结尾</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-注释">3.4 注释</h3><ul><li>// 单行注释</li></ul><h3 id="3-5-控制流">3.5 控制流</h3><h4 id="3-5-1-if表达式">3.5.1 if表达式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rust 不会尝试自动地将非布尔值转换为布尔值，所以<code>if</code>后跟的表达式必须是<code>bool</code></li></ul><h5 id="在let语句中使用if">在let语句中使用if</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>代码块的值是其最后一个表达式的值</li><li><code>if</code>和<code>else</code>中返回的类型要相同</li></ul><h4 id="3-5-2-循环">3.5.2 循环</h4><h5 id="loop">loop</h5><ul><li><p>无限循环，直到按下ctrl+c，或有break</p></li><li><p>内循环可以 <code>continue</code> 或者 <code>break</code> 外循环，此时需要在外循环添加生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unreachable_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="symbol">&#x27;outer</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Entered the outer loop&quot;</span>);</span><br><span class="line">        <span class="symbol">&#x27;inner</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Entered the inner loop&quot;</span>);</span><br><span class="line">            <span class="comment">// This would break only the inner loop</span></span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">            <span class="comment">// This breaks the outer loop</span></span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;outer</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loop</code> 可以返回值，返回 <code>break</code> 后的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="while">while</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    number = number - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for遍历集合">for遍历集合</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// iter引用集合a，在循环结束后仍然可以使用a</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// into_iter移动集合a的所有权，在循环结束后不能使用a</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.into_iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// iter_mut引用可变集合b，可以在循环中改变b中的元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.iter_mut() &#123;</span><br><span class="line">    *element += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch4-所有权">Ch4 所有权</h2><h3 id="4-1-什么是所有权">4.1 什么是所有权</h3><ul><li>Rust管理内存的方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查</li></ul><h4 id="4-1-1-所有权规则：">4.1.1 所有权规则：</h4><blockquote><ol><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol></blockquote><h4 id="4-1-2-变量作用域">4.1.2 变量作用域</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3-String类型">4.1.3 String类型</h4><ul><li>字符串的字面值是不可变的，而<code>String</code>类型的字符串是可变的</li><li><code>String</code>类型的字符串被分配到<strong>堆</strong>上，所以能够存储在编译时未知大小的文本</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于字符串字面值来创建String</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-1-4-内存与分配">4.1.4 内存与分配</h4><p>对于<code>String</code>类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向操作系统请求内存</li><li>需要一个当我们处理完<code>String</code>时将内存返回给操作系统的方法</li></ul><p>Rust处理第二点的策略：内存在拥有它的变量离开作用域后就被自动释放</p><h4 id="4-1-5-存储在堆上的变量">4.1.5 存储在堆上的变量</h4><h5 id="1-移动">1. 移动</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234252508.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234252508.png" srcset="data:image/png;base64,666" alt="image-20201110234252508"></p><p><code>String</code> 由三部分组成，如上图所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。</p><p>当 <code>s2</code> 和 <code>s1</code> 离开作用域，他们都会尝试释放相同的内存。这是一个叫做<strong>二次释放</strong>的错误，两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>在Rust中，经过以上语句，会认为s1不再有效，即<code>s1</code> 被<strong>移动</strong>到了 <code>s2</code> 中，因此当<code>s1</code>离开作用域时不会释放内存。</p><h5 id="克隆">克隆</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br></pre></td></tr></table></figure><p><code>s2</code>深度复制了<code>s1</code>堆上的内容，而不仅仅是栈上的指针。</p><ul><li>以上只针对存储在堆上的类型，而对于类似整型等存储在栈上的类型，可以直接拷贝，变量值不会被移动</li></ul><h4 id="4-1-6-所有权与函数">4.1.6 所有权与函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中, </span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-引用与借用">4.2 引用与借用</h3><p>当<code>String</code>类型的变量传入函数中时，如何以引用的方式传入而不是将所有权交给函数？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;  <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">   <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234314662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234314662.png" srcset="data:image/png;base64,666" alt="image-20201110234314662"></p><ul><li><p><code>&amp;s1</code>语法让我们创建一个<strong>指向</strong>值<code>s1</code>的引用，但是并不拥有它</p></li><li><p>我们将获取引用作为函数参数称为<strong>借用</strong></p></li><li><p>引用<strong>默认</strong>不允许被修改</p></li></ul><h4 id="4-2-1-可变引用">4.2.1 可变引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用，如以下代码是非法的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s被引用了两次，非法</span></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure><ul><li><p>这样的限制可以避免<strong>数据竞争</strong>，即</p><ul><li>两个或更多指针同时访问同一数据</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制</li></ul></li><li><p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能<strong>同时</strong>拥有</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可变引用和不可变引用不能同时存在，如以下代码非法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><ul><li><p>由于一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，所以以下代码合法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-2-2-悬垂引用">4.2.2 悬垂引用</h4><ul><li><p>所谓<strong>悬垂指针</strong>是其指向的内存可能已经被分配给其它持有者</p></li><li><p>在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域，如以下函数非法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。危险！</span></span><br></pre></td></tr></table></figure><ul><li>而应该直接返回<code>String</code>，将所有权移动出去</li></ul></li></ul><h3 id="4-3-Slice类型">4.3 Slice类型</h3><ul><li><code>slice</code>是一个没有所有权的数据类型</li><li><code>slice</code>允许你引用集合中一段连续的元素序列，而不用引用整个集合</li></ul><h4 id="4-3-1-字符串slice">4.3.1 字符串slice</h4><p>字符串 slice是<code>String</code>中一部分值的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> all_s = &amp;s[..];</span><br></pre></td></tr></table></figure><ul><li>字符串字面值就是slice，如<code>let s = &quot;Hello world&quot;</code>中，<code>s</code>的类型是<code>&amp;str</code>，是一个指向二进制程序特定位置的slice</li></ul><h4 id="4-3-2-其他类型的slice">4.3.2 其他类型的slice</h4><p>如数组slice:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="Ch5-结构体">Ch5 结构体</h2><h3 id="5-1-结构体的定义和实例化">5.1 结构体的定义和实例化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并修改字段</span></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>想要修改实例中的字段，必须将整个结构体声明为可变</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>..</code>语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值</li></ul><h4 id="5-1-1-元组结构体">5.1.1 元组结构体</h4><ul><li>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5-1-2-结构体数据的所有权">5.1.2 结构体数据的所有权</h4><ul><li>结构体可以直接存放自身拥有所有权的类型，如<code>String</code>等</li><li>结构体在存储<code>引用</code>、<code>slice</code>等没有自身所有权的类型时，需要用上生命周期</li></ul><h3 id="5-2-结构体引用和打印">5.2 结构体引用和打印</h3><h4 id="5-2-1-函数调用结构体">5.2.1 函数调用结构体</h4><p>函数引用结构体时，不需要获得其所有权，所以采用引用的方式调用:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        area(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-结构体打印">5.2.2 结构体打印</h4><p>需要使用派生trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    <span class="comment">// 或 println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-方法语法">5.3 方法语法</h3><p>使用关键字<code>impl</code>给结构体定义方法，可以避免另外定义函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 将self以不可变引用的方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.area()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-关联函数">5.3.1 关联函数</h4><p>在<code>impl</code>块中定义不以<code>self</code>作为参数的函数，通常用作返回一个结构体实例的构造函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 返回一个正方形的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>let sq = Rectangle::square(3);</code>调用关联函数</li></ul><h2 id="Ch6-枚举和模式匹配">Ch6 枚举和模式匹配</h2><h3 id="6-1-定义枚举">6.1 定义枚举</h3><ul><li>以IP地址类型为例，通过<code>enum</code>定义一个枚举类型：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建<code>IpAddrKind</code>实例：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4(<span class="number">127.0</span>.<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>枚举类型也可以像结构体一样使用<code>impl</code>为其定义方法</li></ul><h4 id="6-1-1-Option枚举">6.1.1 Option枚举</h4><ul><li><p><code>Option</code>是标准库定义的另一个枚举，且被包含在<code>preclude</code>中</p></li><li><p>Rust没有空值，但拥有<code>Option</code>枚举来编码存在或不存在</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Some</code>可以包含任意类型的数据</p></li><li><p>使用<code>None</code>需要指定类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Option&lt;T&gt;</code>类型的值不能和<code>T</code>类型的值直接运算，必须提前进行转换，因此空值在使用前必须被检查</p></li></ul><h3 id="6-2-match控制流运算符">6.2 match控制流运算符</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">   Penny,</span><br><span class="line">   Nickel,</span><br><span class="line">   Dime,</span><br><span class="line">   Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个<code>match</code>表达式的返回值</li></ul><h4 id="6-2-1-匹配Option-T">6.2.1 匹配Option&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> six = plus_one(five);</span><br><span class="line"><span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure><ul><li>用于空值处理</li><li>匹配是有穷的，必须覆盖变量的所有情况</li></ul><h4 id="6-2-2-通配符">6.2.2 _通配符</h4><ul><li><p>可以在match的所有分支的最后使用<code>_</code>来匹配剩余的所有情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-if-let-简单控制流">6.3 if let 简单控制流</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以用于替代只有两分支的<code>match</code>语句</li></ul><h2 id="Ch7-使用包、Crate和模块管理项目">Ch7 使用包、Crate和模块管理项目</h2><h3 id="7-1-包和crate">7.1 包和crate</h3><ul><li>crate是一个二进制项或者库</li><li>包 (package) 是提供一系列功能的一个或者多个 crate，一个包会包含有一个<code>Cargo.toml</code>文件，阐述如何去构建这些 crate<ul><li>一个包中至多<strong>只能</strong>包含一个库 crate</li><li>一个包中可以包含任意多个二进制 crate</li><li>一个包中至少包含一个 crate，无论是库的还是二进制的</li></ul></li><li>使用<code>cargo new</code>创建项目时，<code>src/main.rs</code>就是一个与包同名的二进制 crate 的 crate根</li><li>通过将文件放在 <code>src/bin</code> 目录下，一个包可以拥有多个二进制 crate：每个 <code>src/bin</code> 下的文件都会被编译成一个独立的二进制 crate</li></ul><h3 id="7-2-模块">7.2 模块</h3><p>模块定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">server_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模块树：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><h3 id="7-3-引用模块树中项的路径">7.3 引用模块树中项的路径</h3><p>路径的两种形式，都是通过<code>::</code>连接：</p><ul><li>**绝对路径 ** 从 crate 根开始，以 crate 名或者字面值 <code>crate</code> 开头。</li><li><strong>相对路径</strong> 从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li></ul><h4 id="7-3-1-使用pub关键字暴露路径">7.3.1 使用pub关键字暴露路径</h4><ul><li>Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，父模块不能使用子模块的私有项，但子模块可以使用父模块中的项，同级的两个模块可以互相引用</li><li>当父模块需要使用子模块的项的，需要在子模块中将其声明为<code>pub</code></li></ul><h4 id="7-3-2-使用super起始的相对路径">7.3.2 使用super起始的相对路径</h4><ul><li><code>super</code>相当于文件系统中的<code>..</code>，即当前模块的父模块</li></ul><h4 id="7-3-3-创建公有的结构体和枚举">7.3.3 创建公有的结构体和枚举</h4><ul><li>如果在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造实例 <code>Breakfast</code>，否则无法在 <code>eat_at_restaurant</code> 中创建实例</li></ul><h3 id="7-4-use关键字">7.4 use关键字</h3><ul><li>使用use关键字可以简化模块中项的调用：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;  <span class="comment">// 绝对路径</span></span><br><span class="line"><span class="comment">// 或 use front_of_house::hosting;  相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用 <code>as</code> 关键字提供新名称</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用 <code>use</code> 关键字将名称导入作用域时，在新作用域中可用的名称是私有的，可以使用 <code>pub use</code> 重导出，使得名称可以引入任何代码的作用域中</p></li></ul><h4 id="7-4-1-使用嵌套路径精简代码">7.4.1 使用嵌套路径精简代码</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 可以精简为：</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="comment">// 可以精简为：</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-2-glob运算符">7.4.2 glob运算符</h4><p>如果希望将一个路径下<strong>所有</strong>公有项引入作用域，可以指定路径后跟 <code>*</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure><h3 id="7-5-将模块分割进不同文件">7.5 将模块分割进不同文件</h3><p>先使用如下语句引入模块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br></pre></td></tr></table></figure><h2 id="Ch8-常见集合">Ch8 常见集合</h2><h3 id="8-1-vector">8.1 vector</h3><ul><li>在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值</li><li>vector 只能储存相同类型的值</li></ul><h4 id="8-1-1-新建vector">8.1.1 新建vector</h4><ul><li><p>新建空vector时需要指明类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>vec!</code> 宏来定义含有初值的vector</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-2-vector添加元素">8.1.2 vector添加元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>当vector离开作用域时，会连同其元素全部销毁</li></ul><h4 id="8-1-3-读取vector元素">8.1.3 读取vector元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li><p>使用索引访问，若越界，则会报错崩溃(适用于访问边界严格的vector)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>get</code> 方法返回一个 <code>Option&lt;&amp;T&gt;</code>，若越界，则会返回None(适用于vector索引可能由用户输入而越界)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当获取了vector的一个元素的不可变引用后，不能在其末尾添加元素，如下代码<code>非法</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.push(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-4-遍历vector中的元素">8.1.4 遍历vector中的元素</h4><ul><li><p>遍历不可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-5-结合枚举来存储多种类型">8.1.5 结合枚举来存储多种类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="8-2-字符串">8.2 字符串</h3><h4 id="8-2-1-新建字符串">8.2.1 新建字符串</h4><ul><li><p>新建空字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure></li><li><p>往空字符串中装载数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;initial contents&quot;</span>.to_string();</span><br></pre></td></tr></table></figure></li><li><p>新建有初始值的字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;initial contents&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-2-更新字符串">8.2.2 更新字符串</h4><ul><li><p>使用 <code>push_str</code> 方法来附加字符串 slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>push</code> 附加一个字符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.push(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>+</code> 运算符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>format!</code> 宏</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-3-索引字符串">8.2.3 索引字符串</h4><p>Rust的 <code>String</code> 字符串不支持索引单个值，但能够创建字符串slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><h4 id="8-2-4-遍历字符串">8.2.4 遍历字符串</h4><ul><li><p>遍历每个元素（每个元素可能不止一个字节）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历每个原始字节</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-哈希map">8.3 哈希map</h3><p><code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射</p><h4 id="8-3-1-新建一个哈希map">8.3.1 新建一个哈希map</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个空的Hashmap</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li>哈希 map 将它们的数据储存在堆上</li><li>所有的键必须是相同类型，值也必须都是相同类型</li></ul><p>也可以通过vector的 <code>collect</code> 方法创建</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure><h4 id="8-3-2-哈希map和所有权">8.3.2 哈希map和所有权</h4><ul><li>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map</li><li>对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者</li></ul><h4 id="8-3-3-访问哈希map中的值">8.3.3 访问哈希map中的值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure><ul><li><code>get</code> 方法返回的 <code>score</code> 是 <code>Option&lt;T&gt;</code> 类型</li></ul><h4 id="8-3-4-遍历哈希map">8.3.4 遍历哈希map</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-5-更新哈希map">8.3.5 更新哈希map</h4><ul><li><p>使用相同的键插入不同的值，会覆盖旧值</p></li><li><p>使用 <code>entry</code> 方法，只有在键没有对应的值存在的时候插入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure></li><li><p>根据旧值更新一个值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计单词出现的次数</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure><ul><li><code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）</li></ul></li></ul><h2 id="Ch9-错误处理">Ch9 错误处理</h2><h3 id="9-1-panic-与不可恢复的错误">9.1 panic!与不可恢复的错误</h3><p>遇到错误时，Rust 有 <code>panic!</code>宏，当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出</p><h4 id="9-1-1-backtrace">9.1.1 backtrace</h4><ul><li><p>backtrace 是一个执行到目前位置所有被调用的函数的列表</p></li><li><p>使用backtrace来找到自己写的代码中错误出在哪一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-Result与可恢复的错误">9.2 Result与可恢复的错误</h3><p><code>Result</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型</li><li><code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型</li></ul><h4 id="9-2-1-匹配不同的错误">9.2.1 匹配不同的错误</h4><ul><li>使用 <code>match</code> 代码比较冗长，且较难理解</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, </span><br><span class="line">                other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-unwrap">9.2.2 unwrap</h4><ul><li>如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值</li><li>如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-3-expect">9.2.3 expect</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).expect(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用方法类似 <code>unwrap</code> ，但是可以自己指定显示的错误信息</li></ul><h4 id="9-2-4-传播错误">9.2.4 传播错误</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 若文件打开失败，函数会返回相应的错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="comment">// 若文件内容写入字符串失败，函数会返回相应的错误</span></span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="comment">// 若函数执行完成没有出错，则返回Ok</span></span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust提供了<code>fs::read_to_string</code> 的函数来简化从文件读取到一个字符串中的操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-panic-的使用场景">9.3 panic!的使用场景</h3><p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code> —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况：</p><ul><li>有害状态并不包含 <strong>预期</strong> 会偶尔发生的错误</li><li>之后的代码的运行依赖于处于这种有害状态</li><li>当没有可行的手段来将有害状态信息编码进所使用的类型中的情况</li></ul><h2 id="Ch10-泛型、trait和生命周期">Ch10 泛型、trait和生命周期</h2><h3 id="10-1-泛型">10.1 泛型</h3><p>使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型</p><h4 id="10-1-1-在函数定义中使用泛型">10.1.1 在函数定义中使用泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，所以需要在函数名称之后写上 <code>&lt;T&gt;</code></li></ul><h4 id="10-1-2-结构体定义中的泛型">10.1.2 结构体定义中的泛型</h4><ul><li>字段 <code>x</code> 和 <code>y</code> 必须是相同的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段 <code>x</code> 和 <code>y</code> 可以是不同的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> both_integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> both_float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> integer_and_float = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-3-枚举定义中的泛型">10.1.3 枚举定义中的泛型</h4><p><code>Option&lt;T&gt;</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result&lt;T, E&gt;</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-4-方法定义中的泛型">10.1.4 方法定义中的泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用</li><li>必须在 <code>impl</code> 后面声明 <code>T</code>，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型</li></ul><h4 id="10-1-5-泛型代码的性能">10.1.5 泛型代码的性能</h4><ul><li>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失</li><li>Rust 通过在编译时进行泛型代码的<strong>单态化</strong>来保证效率，即在编译时填充泛型所使用的具体类型，从而将通用代码转换为特定代码</li></ul><h3 id="10-2-trait：定义共享的行为">10.2 trait：定义共享的行为</h3><p><em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能</p><h4 id="10-2-1-定义并使用trait">10.2.1 定义并使用trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实现这个 trait 的类型所需要的行为的方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在impl关键字之后，提供需要实现trait的名称，接着是for和需要实现trait的类型的名称</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait</li><li>不能为外部类型实现外部 trait：例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中，它们并不位于 <code>aggregator</code> crate 本地作用域中</li></ul><h4 id="10-2-2-默认实现">10.2.2 默认实现</h4><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait提供默认实现</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-trait作为参数">10.2.3 trait作为参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>item</code> 参数，指定了 <code>impl</code> 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code></p><ul><li><p>使用trait bound重写上面的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>trait bound适合函数传入多个相同类型的参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item1和item2的类型可以不同，只要它们都实现了Summary</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: <span class="keyword">impl</span> Summary, item2: <span class="keyword">impl</span> Summary) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// item1和item2的类型必须相同</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定多个trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display)</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: T)</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>where</code> 简化trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-2-4-返回trait类型">10.2.4 返回trait类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型</li><li>只适用于返回单一类型的情况，如果有分支结构，每个分支返回不同类型，则编译不能通过</li></ul><h3 id="10-3-生命周期与引用有效性">10.3 生命周期与引用有效性</h3><h4 id="10-3-1-生命周期防止悬垂引用">10.3.1 生命周期防止悬垂引用</h4><ul><li>Rust 编译器有一个<strong>借用检查器</strong>，它比较作用域来确保所有的借用都是有效的</li><li>避免了引用比数据的生命周期短的情况</li></ul><h4 id="10-3-2-函数的泛型生命周期">10.3.2 函数的泛型生命周期</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code></li></ul><h5 id="生命周期注解语法">生命周期注解语法</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><ul><li>当有两个或以上的引用参数的生命周期注解都定义为 <code>&amp;'a i32</code> ，则这些参数的生命周期必须与这泛型生命周期一样长</li></ul><h5 id="函数签名中的生命周期注解">函数签名中的生命周期注解</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写上面的longest函数，指定了签名中所有的引用必须有相同的生命周期&#x27;a</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-3-结构体定义生命周期注解">10.3.3 结构体定义生命周期注解</h4><p>有生命周期注解的结构体可以存放引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-4-生命周期省略">10.3.4 生命周期省略</h4><p>编译器采用三条规则来判断引用何时不需要明确的注解，这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块</p><ul><li>每一个是引用的参数都有它自己的生命周期参数</li><li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数</li><li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数</li></ul><h4 id="10-3-5-方法定义中的生命周期注解">10.3.5 方法定义中的生命周期注解</h4><p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return_part</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-6-静态生命周期">10.3.6 静态生命周期</h4><ul><li><p><code>'static</code> 其生命周期<strong>能够</strong>存活于整个程序期间</p></li><li><p>所有的字符串字面值都拥有 <code>'static</code> 生命周期</p></li></ul><h2 id="Ch11-编写自动化测试">Ch11 编写自动化测试</h2><h3 id="11-1-如何编写测试">11.1 如何编写测试</h3><p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p><ol><li>设置任何所需的数据或状态</li><li>运行需要测试的代码</li><li>断言其结果是我们所期望的</li></ol><h4 id="11-1-1-测试函数剖析">11.1.1 测试函数剖析</h4><ul><li>为了将一个函数变成测试函数，需要在 <code>fn</code> 行之前加上 <code>#[test]</code></li><li>使用 <code>cargo test</code> 命令运行测试</li><li>使用 Cargo 新建一个<strong>库项目</strong>时，它会自动为我们生成一个测试模块和一个测试函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">exploration</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-2-使用assert-宏来检查结果">11.1.2 使用assert!宏来检查结果</h4><ul><li>如果值是 <code>true</code>，<code>assert!</code> 什么也不做，同时测试会通过</li><li>如果值为 <code>false</code>，<code>assert!</code> 调用 <code>panic!</code> 宏，这会导致测试失败</li></ul><h4 id="11-1-3-使用assert-eq-和assert-ne-宏来测试相等">11.1.3 使用assert_eq!和assert_ne!宏来测试相等</h4><ul><li><code>assert_eq!</code> 判断是否相等，<code>assert_ne!</code> 判断是否不等</li><li>断言失败时他们会打印出这两个值具体是什么，以便于观察测试<strong>为什么</strong>失败</li></ul><h4 id="11-1-4-自定义失败信息">11.1.4 自定义失败信息</h4><p>为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 <code>greeting</code> 函数的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greeting_contains_name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = greeting(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.contains(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">        <span class="string">&quot;Greeting did not contain name, value was `&#123;&#125;`&quot;</span>, result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-5-使用-should-panic-检查-panic">11.1.5 使用 should_panic 检查 panic</h4><ul><li><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前</li><li>这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败</li></ul><h4 id="11-1-6-将-Result-T-E-用于测试">11.1.6 将 Result&lt;T, E&gt; 用于测试</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-运行测试">11.2 运行测试</h3><h4 id="11-2-1-并行或连续的运行测试">11.2.1 并行或连续的运行测试</h4><ul><li><p>当运行多个测试时， Rust 默认使用线程来并行运行</p></li><li><p>应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境</p></li><li><p>如果有依赖，可以限制线程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --test-threads=1</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-2-显示函数输出">11.2.2 显示函数输出</h4><ul><li><p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容</p></li><li><p>如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 <code>--nocapture</code> 参数来禁用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --nocapture</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-3-通过指定名字来运行部分测试">11.2.3 通过指定名字来运行部分测试</h4><ul><li><p>运行单个测试，向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> one_hundred</span><br></pre></td></tr></table></figure></li><li><p>过滤运行多个测试，指定部分测试的名称，任何名称匹配这个名称的测试会被运行，以下命令运行了所有名字中带有 <code>add</code> 的测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> add</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-4-忽略某些测试">11.2.4 忽略某些测试</h4><p>使用 <code>ignore</code> 属性来标记耗时的测试并排除他们</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 需要运行一个小时的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code></p><h3 id="11-3-测试的组织结构">11.3 测试的组织结构</h3><h4 id="11-3-1-单元测试">11.3.1 单元测试</h4><ul><li>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。</li><li>单元测试与他们要测试的代码共同存放在位于 <em>src</em> 目录下相同的文件中。</li><li>规范是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块。</li></ul><h5 id="测试模块">测试模块</h5><p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码</p><h4 id="11-3-2-集成测试">11.3.2 集成测试</h4><ul><li><p>集成测试的目的是测试库的多个部分能否一起正常工作</p></li><li><p>二进制项目，即只有 <em>src/main.rs</em> 而没有 <em>src/lib.rs</em> 不能进行集成测试</p></li><li><p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级，可以随意在这个目录中创建任意多的测试文件</p></li><li><p>需要在文件顶部添加 <code>use</code></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch12-I-O项目：命令行程序">Ch12 I/O项目：命令行程序</h2><h3 id="12-1-接受命令行参数">12.1 接受命令行参数</h3><ul><li>使用标准库提供的函数：<code>std::env::args</code> ，返回一个传递给程序的命令行参数的<strong>迭代器</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-读取文件">12.2 读取文件</h3><ul><li>使用标准库  <code>std::fs</code> 来处理文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>, contents);</span><br></pre></td></tr></table></figure><h3 id="12-3-重构改进模块性和错误处理">12.3 重构改进模块性和错误处理</h3><p>在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程:</p><ul><li>将程序拆分成 <em><a href="http://main.rs">main.rs</a></em> 和 <em><a href="http://lib.rs">lib.rs</a></em> 并将程序的逻辑放入 <em><a href="http://lib.rs">lib.rs</a></em> 中。</li><li>当命令行解析逻辑比较小时，可以保留在 <em><a href="http://main.rs">main.rs</a></em> 中。</li><li>当命令行解析开始变得复杂时，也同样将其从 <em><a href="http://main.rs">main.rs</a></em> 提取到 <em><a href="http://lib.rs">lib.rs</a></em> 中。</li></ul><p>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>设置任何其他的配置</li><li>调用 <em><a href="http://lib.rs">lib.rs</a></em> 中的 <code>run</code> 函数</li><li>如果 <code>run</code> 返回错误，则处理这个错误</li></ul><h3 id="12-4-采用测试驱动开发完善库的功能">12.4 采用测试驱动开发完善库的功能</h3><p>测试驱动开发（Test Driven Development, TDD）模式，是一个软件开发技术，它遵循如下步骤：</p><ol><li>编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。</li><li>编写或修改刚好足够的代码来使得新的测试通过。</li><li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li><li>从步骤 1 开始重复！</li></ol><h3 id="12-6-将错误信息输出到标准错误">12.6 将错误信息输出到标准错误</h3><ul><li><p>使用 <code>eprintln!</code> 将错误信息写入标准错误而不是标准输出</p></li><li><p>使用输出重定向：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run to poem.txt &gt; output.txt</span><br></pre></td></tr></table></figure><ul><li>若出错，会输出到标准错误，即显示在命令行，而不写入 <em>output.txt</em></li><li>若正常执行，会输出到标准输出，即重定向到 <em>output.txt</em></li></ul></li></ul><h2 id="Ch13-迭代器和闭包">Ch13 迭代器和闭包</h2><h3 id="13-1-闭包">13.1 闭包</h3><ul><li><p>可以保存进变量或作为参数传递给其他函数的匿名函数</p></li><li><p>使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它</p></li></ul><h4 id="13-1-1-定义闭包">13.1.1 定义闭包</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">expensive_closure(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>闭包的定义以一对竖线（<code>|</code>）开始，在竖线中指定闭包的参数</li><li>如果有多于一个参数，可以使用逗号分隔，比如 <code>|param1, param2|</code></li></ul><h4 id="13-1-2-闭包类型推断和注解">13.1.2 闭包类型推断和注解</h4><ul><li>闭包不用于暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用</li><li>闭包定义会为每个参数和返回值推断一个具体类型</li><li>如果尝试调用闭包两次，第一次使用 <code>String</code> 类型作为参数而第二次使用 <code>u32</code>，则会得到一个错误</li></ul><h4 id="13-1-3-使用带有泛型和Fn-trait的闭包">13.1.3 使用带有泛型和Fn trait的闭包</h4><p>可以创建一个存放闭包和调用闭包结果的结构体，该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="comment">// 闭包有一个 u32 的参数并返回一个 u32</span></span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="comment">/*检查self.value是否已经有了一个 Some 的结果值；</span></span><br><span class="line"><span class="comment">            如果有，它返回 Some 中的值并不会再次执行闭包*/</span></span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="comment">/* 如果 self.value 是 None，</span></span><br><span class="line"><span class="comment">            则会调用 self.calculation 中储存的闭包，</span></span><br><span class="line"><span class="comment">            将结果保存到 self.value 以便将来使用，</span></span><br><span class="line"><span class="comment">            并同时返回结果值*/</span></span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> v = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="literal">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行闭包之前，<code>value</code> 将是 <code>None</code>。如果使用 <code>Cacher</code> 的代码请求闭包的结果，这时会执行闭包并将结果储存在 <code>value</code> 字段的 <code>Some</code> 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 <code>Some</code> 成员中的结果。</p><ul><li><code>Cacher</code> 实现的限制：<ul><li>第一次初始化 <code>value</code> 的值之后，就无法再改动；可以通过使 <code>Cacher</code> 存储一个哈希map而不是一个单独的值解决</li><li>它的应用被限制为只接受获取一个 <code>u32</code> 值并返回一个 <code>u32</code> 值的闭包</li></ul></li></ul><h4 id="13-1-4-闭包会捕获其环境">13.1.4 闭包会捕获其环境</h4><ul><li><p>闭包周围的作用域被称为其<strong>环境</strong></p></li><li><p>闭包可以捕获其环境并访问其被定义的作用域的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/* x 并不是 equal_to_x 的一个参数，</span></span><br><span class="line"><span class="comment">但equal_to_x 闭包也被允许使用变量 x，</span></span><br><span class="line"><span class="comment">因为它与 equal_to_x 定义于相同的作用域*/</span></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>闭包有三种方式捕获其环境</p><ul><li><code>FnOnce</code> 消费从周围作用域捕获的变量。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次</li><li><code>FnMut</code> 获取可变的借用值，所以可以改变其环境</li><li><code>Fn</code> 从其环境获取不可变的借用值</li></ul></li></ul><h3 id="13-2-迭代器">13.2 迭代器</h3><ul><li><p><strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑</p></li><li><p>迭代器是惰性的，即在调用方法使用迭代器之前它都不会有效果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 创建一个迭代器，但是没有任何效果</span></span><br><span class="line"><span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="comment">/* 使用迭代器遍历，迭代器中的元素才开始迭代</span></span><br><span class="line"><span class="comment">用 for 循环时无需使 v1_iter 可变，</span></span><br><span class="line"><span class="comment">因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变*/</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-1-Iterator-trait-和-next方法">13.2.1 Iterator trait 和 next方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator 是定义于标准库的 trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="comment">// Item类型将是迭代器next方法返回元素的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"><span class="comment">// next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代器上直接调用 <code>next</code> 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_demonstration</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 需要将迭代器定义为可变，因为next方法会改变迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-2-2-消费适配器">13.2.2 消费适配器</h4><ul><li><p>调用 <code>next</code> 方法的方法，如 <code>sum</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="comment">// 调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权</span></span><br><span class="line">    <span class="keyword">let</span> total: <span class="built_in">i32</span> = v1_iter.sum();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-3-迭代器适配器">13.2.3 迭代器适配器</h4><ul><li><p>将当前迭代器变为不同类型的迭代器，如 <code>map</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 调用 map 方法创建一个新迭代器，接着调用collect方法消费新迭代器并创建一个vector</span></span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-4-创建自定义迭代器">13.2.4 创建自定义迭代器</h4><p>可以实现 <code>Iterator</code> trait 来创建任何我们希望的迭代器</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Counter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的Counter迭代器的多种方法</span></span><br><span class="line"><span class="comment">// 获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">using_other_iterator_trait_methods</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum: <span class="built_in">u32</span> = Counter::new().zip(Counter::new().skip(<span class="number">1</span>))</span><br><span class="line">                                 .map(|(a, b)| a * b)</span><br><span class="line">                                 .filter(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                 .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch14-进一步认识Cargo和Crates-io">Ch14 <a href="http://xn--CargoCrates-km8q749dp96e4c7etpa368c.io">进一步认识Cargo和Crates.io</a></h2><h3 id="14-1-采用发布配置自定义构建">14.1 采用发布配置自定义构建</h3><p>Cargo 有两个主要的配置：</p><ul><li>运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置</li><li>运行 <code>cargo build --release</code> 的 <code>release</code> 配置</li></ul><p><code>dev</code> 配置被定义为开发时的好的默认配置，<code>release</code> 配置则有着良好的发布构建的默认配置</p><p>可以在 <em>Cargo.toml</em> 文件中定义 <code>[profile.*]</code> 部分来覆盖默认配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><code>opt-level</code> 设置控制 Rust 会对代码进行何种程度的优化，值从0到3，越高的优化级别需要更多的时间编译</li></ul><h3 id="14-2-将-crate-发布到-Crates-io">14.2 将 crate 发布到 <a href="http://Crates.io">Crates.io</a></h3><h3 id="14-3-Cargo工作空间">14.3 Cargo工作空间</h3><h3 id="14-4-从-Crates-io-安装二进制文件">14.4 从 <a href="http://Crates.io">Crates.io</a> 安装二进制文件</h3><p>使用命令 <code>cargo install</code> 可以从crates.io下载二进制crate，安装到 <em>~/.cargo/bin</em></p><h2 id="Ch15-智能指针">Ch15 智能指针</h2><h3 id="15-1-Box-T">15.1 Box&lt;T&gt;</h3><p>box 允许将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针</p><p>使用场景：</p><ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li></ul><h4 id="15-1-1-Box创建递归类型">15.1.1 Box创建递归类型</h4><ul><li>Rust 需要在编译时知道类型占用多少空间，而<strong>递归类型</strong>无法在编译的时候知道大小</li><li>box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了</li></ul><h5 id="以cons-list为例">以cons list为例</h5><ul><li><p>cons list 的每一项都包含两个元素：当前项的值和下一项。</p></li><li><p>其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。</p></li><li><p>cons list 通过递归调用 <code>cons</code> 函数产生。</p></li><li><p>代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust编译器无法计算一个 <code>List</code> 需要的大小，因为编译器尝试计算出储存一个 <code>List</code> 枚举需要多少内存，并开始检查 <code>Cons</code> 成员，那么 <code>Cons</code> 需要的空间等于 <code>i32</code> 的大小加上 <code>List</code> 的大小。为了计算 <code>List</code> 需要多少内存，它检查其成员，从 <code>Cons</code> 成员开始。<code>Cons</code>成员储存了一个 <code>i32</code> 值和一个<code>List</code>值，这样的计算将无限进行下去。</p><h5 id="使用Box-T-给递归类型一个已知的大小">使用Box&lt;T&gt;给递归类型一个已知的大小</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>,</span><br><span class="line">            <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>,</span><br><span class="line">                <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何 <code>List</code> 值最多需要一个 <code>i32</code> 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 <code>List</code> 值需要的大小了。</p><h3 id="15-2-Deref-trait">15.2 Deref trait</h3><p>实现 <code>Deref</code> trait 允许我们重载<strong>解引用运算符</strong> <code>*</code></p><h4 id="15-2-1-像引用一样使用-Box-T">15.2.1 像引用一样使用 Box&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-自定义智能指针">15.2.2 自定义智能指针</h4><p>定义 <code>MyBox&lt;T&gt;</code> 类型:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-3-在自定义智能指针实现-Deref-trait">15.2.3 在自定义智能指针实现 Deref trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义trait的关联类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        <span class="comment">// deref返回了我希望通过*运算符访问的值的引用</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br></pre></td></tr></table></figure><p><code>*y</code> 在Rust底层运行了 <code>*(y.deref())</code></p><h4 id="15-2-4-函数和方法的隐式解引用强制多态">15.2.4 函数和方法的隐式解引用强制多态</h4><p><strong>解引用强制多态</strong>是 Rust 在函数或方法传参上的一种便利。将实现了 <code>Deref</code> 的类型的引用转换为原始类型通过 <code>Deref</code> 所能够转换的类型的引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">// 解引用强制多态将 &amp;MyBox&lt;String&gt; 自动转换为 &amp;str</span></span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-Drop-trait">15.3 Drop trait</h3><ul><li><p>允许我们在值要离开作用域时执行一些代码，可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源</p></li><li><p>通过 <code>Drop</code> trait 中的 <code>drop</code> 方法，可以在变量离开作用域时自动丢弃该值</p></li></ul><h4 id="15-3-1-通过-std-mem-drop-提早丢弃值">15.3.1 通过 std::mem::drop 提早丢弃值</h4><ul><li>Rust不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法</li><li>当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>，其位于preclude，可以直接通过 <code>drop(variable);</code> 调用</li></ul><h3 id="15-4-Rc-T-引用计数智能指针">15.4 Rc&lt;T&gt; 引用计数智能指针</h3><ul><li><p>有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。</p></li><li><p>Rust 使用<strong>引用计数</strong> <code>Rc&lt;T&gt;</code> 的类型来启用多所有权，记录了一个值引用的数量来知晓这个值是否仍在被使用。</p></li><li><p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。</p></li><li><p><code>Rc&lt;T&gt;</code> 只能用于单线程场景</p></li></ul><h4 id="15-4-1-使用-Rc-T-共享数据">15.4.1 使用 Rc&lt;T&gt; 共享数据</h4><p>使用 <code>Box&lt;T&gt;</code> 定义的 cons list 的两个列表 <code>b</code> 和 <code>c</code>, 共享第三个列表 <code>a</code> 的所有权</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201112210915469.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201112210915469.png" srcset="data:image/png;base64,666" alt="image-20201112210915469"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Rc::clone</code> 只会增加引用计数，而不会深拷贝</li><li>在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 <code>Rc::strong_count</code> 函数获得</li></ul><h3 id="15-5-RefCell-T-和内部可变性模式">15.5 RefCell&lt;T&gt; 和内部可变性模式</h3><p><strong>内部可变性</strong>是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的</p><h3 id="15-6-引用循环与内存泄漏">15.6 引用循环与内存泄漏</h3><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存，但是创建引用循环从而造成内存泄漏的可能性是存在的</p><h2 id="Ch16-并发">Ch16 并发</h2><h3 id="16-1-使用线程同时运行代码">16.1 使用线程同时运行代码</h3><p>线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p><ul><li>竞争状态，多个线程以不一致的顺序访问数据或资源</li><li>死锁，两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li><li>只会发生在特定情况且难以稳定重现和修复的 bug</li></ul><h4 id="16-1-1-使用-spawn-创建新线程">16.1.1 使用 spawn 创建新线程</h4><p>为了创建一个新线程，需要调用 <code>thread::spawn</code> 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            <span class="comment">// thread::sleep调用强制线程停止执行一小段时间，允许其他不同的线程运行</span></span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 4 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>当主线程结束时，新线程也会结束，而不管其是否执行完毕</li></ul><h4 id="16-1-2-使用-join-等待所有线程结束">16.1.2 使用 join 等待所有线程结束</h4><ul><li><code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code></li><li><code>JoinHandle</code> 是一个拥有所有权的值，当对其调用 <code>join</code> 方法时，它会等待其线程结束</li><li>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 从thread::spawn保存一个JoinHandle来确保该线程能够运行结束</span></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-1-3-线程与-move-闭包">16.1.3 线程与 move 闭包</h4><p>在参数列表前使用 <code>move</code> 关键字强制闭包获取其使用的环境值的所有权，可用于创建新线程时将值的所有权从一个线程移动到另一个线程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-2-线程间消息传递">16.2 线程间消息传递</h3><p>Rust 中一个实现消息传递并发的主要工具是<strong>通道</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>mpsc::channel</code> 函数创建一个新的通道，可以有多个<strong>发送端</strong>，但只能有一个<strong>接收端</strong>， <code>mpsc::channel</code> 函数返回一个元组：(发送端，接收端)，或 <code>(tx, rx)</code></p></li><li><p>通道的发送端有一个 <code>send</code> 方法用来获取需要放入通道的值，返回一个 <code>Result&lt;T, E&gt;</code> 类型</p><ul><li><code>send</code> 函数获取其参数的所有权并移动这个值归接收者所有，所以线程在发送 <code>val</code> 之后就不能再使用它了</li></ul></li><li><p>通道的接收端有两个有用的方法：<code>recv</code> 和 <code>try_recv</code></p><ul><li><code>recv</code> 会阻塞主线程执行直到从通道中接收一个值，一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它；当通道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了</li><li><code>try_recv</code> 不会阻塞，立刻返回一个 <code>Result&lt;T, E&gt;</code>：<code>Ok</code> 值包含可用的信息，而 <code>Err</code> 值代表此时没有任何消息</li></ul></li><li><p>可以将 <code>rx</code> 作为迭代器来接收发送端发送的多个数据，并通过 <code>for</code> 循环打印</p></li><li><p>可以通过 <code>clone</code> 方法来创建多个发送端:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br></pre></td></tr></table></figure></li></ul><h3 id="16-3-共享状态并发">16.3 共享状态并发</h3><h4 id="16-3-1-互斥器">16.3.1 互斥器</h4><ul><li>通过<strong>锁</strong>来保证任意时刻只有一个线程能访问某些数据</li><li>使用方式：<ul><li>在使用数据之前尝试获取锁。</li><li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li></ul></li><li>使用 <code>Mutex&lt;T&gt;</code> 实现<ul><li>通过关联函数 <code>new</code> 来创建 <code>Mutex&lt;T&gt;</code></li><li>使用 <code>lock</code> 方法获取锁，该方法会阻塞当前线程，直到拥有锁为止</li><li><code>lock</code> 调用返回一个叫做 <code>MutexGuard</code> 的智能指针，当其离开作用域时，会自动释放锁</li></ul></li></ul><h4 id="16-3-2-在线程间共享-Mutex-T">16.3.2 在线程间共享 Mutex&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<strong>原子引用计数</strong> <code>Arc&lt;T&gt;</code> 来实现 <code>Mutex&lt;T&gt;</code> 在多线程之间共享所有权</li></ul><h2 id="Ch17-Rust面向对象">Ch17 Rust面向对象</h2><h3 id="17-1-面向对象语言的特征">17.1 面向对象语言的特征</h3><ul><li>对象包含数据和行为：结构体和枚举包含数据，<code>impl</code> 块提供对应方法</li><li>封装隐藏了实现细节：不添加 <code>pub</code> 就是私有的</li><li>通过继承重用代码：使用 <code>trait</code> 对象</li></ul><h3 id="17-2-为使用不同类型的值而设计的-trait-对象">17.2 为使用不同类型的值而设计的 trait 对象</h3><h3 id="17-3-面向对象设计模式的实现">17.3 面向对象设计模式的实现</h3><h2 id="Ch18-模式">Ch18 模式</h2><h3 id="18-1-用到模式的位置">18.1 用到模式的位置</h3><h4 id="18-1-1-match分支">18.1.1 match分支</h4><p>在形式上 <code>match</code> 表达式由 <code>match</code> 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-1-2-if-let-表达式">18.1.2 if let 表达式</h4><ul><li>等同于只关心一个情况的 <code>match</code> 语句简写</li><li><code>if let</code> 表达式的缺点在于其穷尽性没有为编译器所检查，而 <code>match</code> 表达式则检查了</li></ul><h4 id="18-1-3-while-let-条件循环">18.1.3 while let 条件循环</h4><p>允许只要模式匹配就一直进行 <code>while</code> 循环</p><h4 id="18-1-4-for循环">18.1.4 for循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.iter().enumerate() &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>(index, value)</code> 来匹配 <code>enumerate</code></p><h4 id="18-1-5-let语句">18.1.5 let语句</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PATTERN = EXPRESSION;</span><br></pre></td></tr></table></figure><h4 id="18-1-6-函数参数">18.1.6 函数参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x</code> 部分就是一个模式</p><h3 id="18-2-可反驳和不可反驳">18.2 可反驳和不可反驳</h3><ul><li><p>能匹配任何传递的可能值的模式被称为是<strong>不可反驳的</strong>，如 <code>let x = 5;</code> 中的 <code>x</code></p></li><li><p>对某些可能的值进行匹配会失败的模式被称为是<strong>可反驳的</strong>，如 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code></p></li><li><p>函数参数、 <code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式</p></li><li><p>匹配分支必须使用可反驳模式，如 <code>if let</code></p></li></ul><h3 id="18-3-模式语法">18.3 模式语法</h3><h4 id="18-3-1-匹配字面值">18.3.1 匹配字面值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-2-匹配命名变量">18.3.2 匹配命名变量</h4><p>命名变量是匹配任何值的不可反驳模式，当其用于 <code>match</code> 表达式时，情况会不一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">会打印：</span></span><br><span class="line"><span class="comment">Matched, y = 5</span></span><br><span class="line"><span class="comment">at the end: x = Some(5), y = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>match</code> 表达式的新作用域中， <code>y</code> 是一个新变量，而不是开头声明为值 10 的那个 <code>y</code> ，新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值</li></ul><h4 id="18-3-3-多个模式">18.3.3 多个模式</h4><p>使用 <code>|</code> 语法匹配多个模式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-4-通过-…-匹配值的范围">18.3.4 通过 …= 匹配值的范围</h4><ul><li><p>使用 <code>1..=5</code> 替代 <code>1 | 2 | 3 | 4 | 5</code></p></li><li><p>对 <code>char</code> 类型也适用：<code>'a'..='j'</code></p></li></ul><h4 id="18-3-5-忽略模式中的值">18.3.5 忽略模式中的值</h4><ul><li><p>使用 <code>_</code> 忽略整个值</p></li><li><p>通过 <code>_x</code> 来忽略未使用的变量</p></li><li><p>使用 <code>..</code> 忽略剩余的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., last) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="18-3-6-匹配守卫">18.3.6 匹配守卫</h4><p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-7-绑定">18.3.7 @绑定</h4><ul><li><p><code>@</code> 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式</p></li><li><p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="built_in">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    <span class="comment">// 将id值保存在id_variable中</span></span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无法保存id值</span></span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch19-高级特征">Ch19 高级特征</h2><h3 id="19-1-不安全的Rust">19.1 不安全的Rust</h3><h3 id="19-2-高级trait">19.2 高级trait</h3><h3 id="19-3-高级类型">19.3 高级类型</h3><h3 id="19-4-高级函数与闭包">19.4 高级函数与闭包</h3><h3 id="19-5-宏">19.5 宏</h3>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pointers on C - Learn</title>
      <link href="2020/11/11/learning-notes/C%E5%92%8C%E6%8C%87%E9%92%88notes/"/>
      <url>2020/11/11/learning-notes/C%E5%92%8C%E6%8C%87%E9%92%88notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Ch2-基本概念">Ch2 基本概念</h2><h3 id="2-1-环境">2.1 环境</h3><h4 id="2-1-1-翻译环境">2.1.1 翻译环境</h4><ul><li><p>翻译过程：各源文件通过<code>编译过程</code>分别转为<strong>目标代码</strong> -&gt; 各目标代码文件由<strong>链接器</strong>捆绑为单一完整的可执行程序</p></li><li><p>编译过程：预处理器处理 -&gt; 源代码经过<strong>解析</strong>判断语句的意思，从而生成目标代码 -&gt; 优化器对目标代码进一步处理</p></li></ul><h4 id="2-1-4-执行环境">2.1.4 执行环境</h4><ul><li><p>程序执行过程：程序载入内存 -&gt; 启动程序调用main函数 -&gt; 程序的终止</p></li><li><p>程序运行过程中使用一个运行时的<strong>堆栈</strong>，用于存储函数的局部变量和返回地址；同时，程序也可以使用<strong>静态内存</strong>，其中的值在程序整个执行过程都会保留</p></li></ul><h3 id="2-2-词法规则">2.2 词法规则</h3><h4 id="2-2-1-字符">2.2.1 字符</h4><ul><li><p>\ddd：三个八进制数字表示的字符</p></li><li><p>\xddd：三个十六进制数字表示的字符</p></li></ul><h4 id="2-2-2-注释">2.2.2 注释</h4><ul><li><p>//：单行注释</p></li><li><p>/*     */：多行注释</p></li></ul><h3 id="TIPS">TIPS:</h3><ul><li>有的程序从标准输入读取数据，读到EOF停止，在终端输入时Ctrl+D即为输入EOF</li></ul><h2 id="Ch3-数据">Ch3 数据</h2><h3 id="3-1-基本数据类型">3.1 基本数据类型</h3><h4 id="3-1-1-整型">3.1.1 整型</h4><p>变量的最小范围</p><table><thead><tr><th>类型</th><th>最小范围</th></tr></thead><tbody><tr><td>char</td><td>0 ~ 2<sup>7</sup>-1</td></tr><tr><td>signed char</td><td>-(2<sup>7</sup>-1) ~ 2<sup>7</sup>-1</td></tr><tr><td>unsigned char</td><td>0 ~ 2<sup>8</sup>-1</td></tr><tr><td>short int</td><td>-(2<sup>15</sup>-1) ~ 2<sup>15</sup>-1</td></tr><tr><td>unsigned short int</td><td>0 ~ 2<sup>16</sup>-1</td></tr><tr><td>int</td><td>-(2<sup>15</sup>-1) ~ 2<sup>15</sup>-1</td></tr><tr><td>unsigned int</td><td>0 ~ 2<sup>16</sup>-1</td></tr><tr><td>long int</td><td>-(2<sup>31</sup>-1) ~ 2<sup>31</sup>-1</td></tr><tr><td>unsigned long int</td><td>0 ~ 2<sup>32</sup>-1</td></tr></tbody></table><ul><li><p>short int至少16位，long int至少32位</p></li><li><p>头文件limits.h说明各种不同的整型的特点</p></li></ul><p><strong>一、整型常量</strong></p><ul><li><p>声明为const，初始化之后不能被改变</p></li><li><p>十进制整型常量可能是int、long、unsigned long。缺省情况下为最短类型但能完整容纳这个值</p></li><li><p>八进制整数以0开头</p></li><li><p>十六进制整数以0x开头</p></li><li><p>字符常量：类型为int，是单引号包围的单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;M&#x27;</span><span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>宽字符常量：多字节字符常量的前面有个L</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&#x27;X&#x27;L&#x27;e^&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二、枚举类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Jar_Type</span> &#123;</span>CUP, PINT, QUART, HALF_GALLON, GALLON&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Jar_Type</span> <span class="title">milk_jug</span>, <span class="title">gas_can</span>, <span class="title">medicine_bottle</span>;</span></span><br></pre></td></tr></table></figure><ul><li>以整型方式存储，符号名实际值都是整型值。如CUP=0，PINT=1，以此类推</li><li>可以显式定值，若未指定值，则比前一个符号名大1</li></ul><h4 id="3-1-2-浮点类型">3.1.2 浮点类型</h4><ul><li>包括float、double、long double类型</li><li>所有浮点类型至少能容纳从10<sup>-37</sup>到10<sup>37</sup>之间的任何值</li><li>头文件float.h说明各种不同的浮点型的特点</li><li>浮点数默认为double类型；后面跟L/l表示long double；后面跟F/f表示float</li></ul><h4 id="3-1-3-指针">3.1.3 指针</h4><p><strong>一、指针常量</strong></p><ul><li>一般都通过操作符来获得一个变量的地址，而不是通过表示为字面值的指针常量，如0xff2044ec</li></ul><p><strong>二、字符串常量</strong></p><ul><li>字符串：以NUL字节结尾的零个或多个字符，存储在字符数组中</li><li>字符串常量：直接值是一个“指向字符的指针”，而不是这些字符本身</li></ul><h3 id="3-2-基本声明">3.2 基本声明</h3><h4 id="3-2-2-声明简单数组">3.2.2 声明简单数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><ul><li>编译器不检查数组的下标是否在合法范围内，所以当下标是通过用户输入计算而来的，必须检测是否越界<ul><li>如果越界，不会报错，只会返回null</li></ul></li></ul><h4 id="3-2-3-声明指针">3.2.3 声明指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">// 把message声明为一个指向字符的指针，并用字符串常量中的第1个字符的地址对其初始化</span></span><br><span class="line"><span class="comment">// 等价于以下语句</span></span><br><span class="line"><span class="keyword">char</span> *message;</span><br><span class="line">message = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-typedef">3.3 typedef</h3><p>为各种数据类型定义新名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将变量ptr_to_char声明为一个指向字符的指针类型的新名字</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *ptr_to_char;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明a是一个指向字符的指针</span></span><br><span class="line">ptr_to_char a;</span><br></pre></td></tr></table></figure><h3 id="3-4-常量">3.4 常量</h3><p>const</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明整数常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *pci;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向整型的常量指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> cpi;</span><br></pre></td></tr></table></figure><p>#define</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 20</span></span><br></pre></td></tr></table></figure><h3 id="3-5-作用域">3.5 作用域</h3><h4 id="3-5-1-代码块作用域">3.5.1 代码块作用域</h4><ul><li><p>代码块：位于一对花括号之间的所有语句</p></li><li><p>嵌套代码块中，内层可以访问外层变量，而外层无法访问内层变量，但是当内外层有名字相同的变量时，内层无法访问外层的那个同名变量</p></li><li><p>非嵌套的代码块中，作用域没有重叠，所以编译器可以把它们存储在同一个内存地址</p></li></ul><h4 id="3-5-2-文件作用域">3.5.2 文件作用域</h4><ul><li>任何在所有代码块之外声明的标识符都具有文件作用域，在声明处到源文件末尾都可以访问</li></ul><h4 id="3-5-3-原型作用域">3.5.3 原型作用域</h4><ul><li>只适用于在函数原型中声明的参数名</li></ul><h4 id="3-5-4-函数作用域">3.5.4 函数作用域</h4><ul><li>只适用于语句标签，语句标签用于goto语句</li></ul><h3 id="3-6-链接属性">3.6 链接属性</h3><p><strong>一、none 没有链接属性</strong></p><ul><li>声明的同名标识符被当作独立不同的实体</li></ul><p><strong>二、internal属性</strong></p><ul><li>单个文件中声明的同名标识符表示同一个实体</li></ul><p><strong>三、external属性</strong></p><ul><li>多个文件中声明的同名标识符表示同一个实体</li><li>只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。</li><li>默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体。</li></ul><p><strong>四、关键字extern和static</strong></p><ul><li>如果某个标识符在正常情况下具有external链接属性(只能是具有文件作用域的标识符)，在其前面加上static关键字可以将其链接属性变为internal</li><li>链接属性只能修改一次，也就是说一旦将标识符的链接属性变为internal，就无法变回external了</li></ul><h3 id="3-7-存储类型">3.7 存储类型</h3><ul><li>存储变量的内存类型，有普通内存、运行时堆栈、硬件寄存器</li><li>在任何代码块之外声明的变量存储在<strong>静态内存</strong>中，为静态变量，在程序运行之前创建</li><li>在代码块内部声明的变量的缺省存储类型是自动的，即存储于<strong>堆栈</strong>中，进入代码块创建，离开代码块销毁<ul><li>在代码块内部声明的变量加上static关键字，变为静态变量，但作用域不变。如在函数中声明static变量a，则a在程序开始执行时就被初始化，并且每次函数被调用时，a不会重新初始化</li></ul></li><li>关键字register声明自动变量，存储在<strong>硬件寄存器</strong>中，为寄存器变量</li></ul><p><strong>初始化</strong></p><ul><li>如果不显式指定初值，静态变量将初始化为0，而自动变量初始值不确定</li></ul><h3 id="3-8-static关键字">3.8 static关键字</h3><ul><li>用于函数定义或在代码块外声明变量时，将标识符的链接属性从external改为internal，但变量的存储类型和作用域不受影响</li><li>在代码块内部声明变量时将标识符的存储类型从自动变量改为静态变量，但变量的链接属性和作用域不受影响</li></ul><h3 id="3-9-总结">3.9 总结</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201028211529931.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201028211529931.png" srcset="data:image/png;base64,666" alt="image-20201028211529931"></p><h2 id="Ch4-语句">Ch4 语句</h2><h3 id="4-1-空语句">4.1 空语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><p>只包含一个分号，不执行任何任务</p><h3 id="4-2-表达式语句">4.2 表达式语句</h3><ul><li><p>C不存在赋值语句，赋值通过表达式语句(在表达式之后加上一个分号)实现，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>以下语句也是合法的，但结果被立即丢弃：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码块">4.3 代码块</h3><p>位于一对花括号之内的可选的声明和语句列表</p><h3 id="4-4-if语句">4.4 if语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C语言不存在布尔变量，而使用整型的0和1代替，所以expression的结果不是0就是1</li></ul><h3 id="4-5-while语句">4.5 while语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>break终止所在while代码块的所有循环；continue终止所在while代码块的当前循环</li></ul><h3 id="4-6-for语句">4.6 for语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化部分; 条件部分; 调整部分)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-do语句">4.7 do语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure><ul><li>循环体至少执行一次</li></ul><h3 id="4-8-switch语句">4.8 switch语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression<span class="number">-1</span>:</span><br><span class="line">        statement<span class="number">-1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression<span class="number">-2</span>:</span><br><span class="line">        statement<span class="number">-2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch的条件expression必须为整型值</li><li>每个case标签必须具有唯一的值</li><li>每个switch语句都应该添加一条并且只能添加一条default语句，可以在case语句列表的任何位置</li></ul><h3 id="4-9-goto语句">4.9 goto语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 语句标签;</span><br></pre></td></tr></table></figure><ul><li>语句标签是在标识符后添加一个冒号，并跟上一些表达式语句</li><li>要尽可能避免使用goto语句</li></ul><h2 id="Ch5-操作符和表达式">Ch5 操作符和表达式</h2><h3 id="5-1-操作符">5.1 操作符</h3><h4 id="5-1-1-算术操作符">5.1.1 算术操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure><h4 id="5-1-2-移位操作符">5.1.2 移位操作符</h4><ul><li><p>左移：&lt;&lt;</p></li><li><p>右移：&gt;&gt;</p></li><li><p>无符号数的所有移位操作都是逻辑移位，有符号数是逻辑移位还是算术移位取决于编译器</p></li></ul><h4 id="5-1-3-位操作符">5.1.3 位操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; | ~</span><br><span class="line"><span class="comment">// 与或非</span></span><br></pre></td></tr></table></figure><ul><li><p>将value指定位置1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = value | <span class="number">1</span> &lt;&lt; bit_number;</span><br></pre></td></tr></table></figure></li><li><p>将value指定位置0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = value &amp; ~ (<span class="number">1</span> &lt;&lt; bit_number);</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-5-单目操作符">5.1.5 单目操作符</h4><ul><li><p>!：逻辑取反，产生整型结果0或1</p></li><li><p>~：操作数每一位取反</p></li><li><p>-：取负</p></li><li><p>&amp;：取操作数的地址</p></li><li><p>*：间接访问，访问指针所指向的值</p></li><li><p>sizeof：判断操作数的类型长度，以字节为单位，操作数可以是变量，也可以是加上括号的类型</p><ul><li>sizeof (a = b + 1)并没有向a赋值</li></ul></li><li><p>强制类型转换，如获得整型变量a对应的浮点数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">float</span>) a</span><br></pre></td></tr></table></figure></li><li><p>c+：增值操作符，<ins>a在变量被使用之前增加它的值，a</ins>在变量被使用之后增加它的值</p></li></ul><h4 id="5-1-6-关系操作符">5.1.6 关系操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;=    &lt;  &lt;=    ==  !=</span><br></pre></td></tr></table></figure><ul><li>产生的结果是整型的0或1</li></ul><h4 id="5-1-7-逻辑操作符">5.1.7 逻辑操作符</h4><ul><li>&amp;&amp;：对于expression1 &amp;&amp; expression2，若expression1为假，则不再对expression2求值</li><li>||：对于expression1 || expression2，若expression1为真，则不再对expression2求值</li></ul><h4 id="5-1-8-条件操作符">5.1.8 条件操作符</h4><p>expression1 ? expression2 : expression3</p><h3 id="5-2-布尔值">5.2 布尔值</h3><ul><li>C没有显式的布尔类型，用整数代替，0是假，任何非零值都是真</li></ul><h3 id="5-4-表达式求值">5.4 表达式求值</h3><ul><li><p>函数进行表达式求值时应该尽量避免以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f() + g() + h()</span><br></pre></td></tr></table></figure><p>而使用以下形式，因为如果函数的返回值和执行顺序相关，则会产生不确定性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = f();</span><br><span class="line">temp += g();</span><br><span class="line">temp += h();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch6-指针">Ch6 指针</h2><h3 id="6-1-内存和地址">6.1 内存和地址</h3><ul><li>内存中的每个位置由一个独一无二的地址标识</li><li>内存中的每个位置都包含一个值</li><li>编译器帮助实现通过变量访问内存位置，但是硬件仍然通过地址访问内存位置</li></ul><h3 id="6-2-值和类型">6.2 值和类型</h3><p>不能简单地通过检查一个值的位来判断它的类型，因为不同的数据类型和指令会将其解释为不同的类型</p><h3 id="6-5-未初始化和非法的指针">6.5 未初始化和非法的指针</h3><p>在对指针进行间接访问之前，一定要进行初始化，下面是一个<strong>错误例子</strong>，因为指针a指向的位置不能确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">*a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="6-6-NULL指针">6.6 NULL指针</h3><ul><li><p>NULL指针不指向任何东西</p></li><li><p>要使一个指针变量为NULL，可以给它赋一个零值；测试一个指针变量是否为NULL，可以将它与零值比较</p></li></ul><h3 id="6-7-指针、间接访问和左值">6.7 指针、间接访问和左值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *d = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法，对指针d指向的值(a)进行修改</span></span><br><span class="line">*d = <span class="number">10</span> - *d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法，整型数的计算结果赋给指针</span></span><br><span class="line">d = <span class="number">10</span> - *d;</span><br></pre></td></tr></table></figure><h3 id="6-10-指针的指针">6.10 指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>相当的表达式</th></tr></thead><tbody><tr><td>a</td><td>12</td></tr><tr><td>b</td><td>&amp;a</td></tr><tr><td>*b</td><td>a, 12</td></tr><tr><td>c</td><td>&amp;b</td></tr><tr><td>*c</td><td>b, &amp;a</td></tr><tr><td>**c</td><td>*b, a, 12</td></tr></tbody></table><h3 id="6-11-指针表达式">6.11 指针表达式</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112510530.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112510530.png" srcset="data:image/png;base64,666" alt="image-20201030112510530"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112528313.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112528313.png" srcset="data:image/png;base64,666" alt="image-20201030112528313"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112553253.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112553253.png" srcset="data:image/png;base64,666" alt="image-20201030112553253"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112611434.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112611434.png" srcset="data:image/png;base64,666" alt="image-20201030112611434"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112624338.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112624338.png" srcset="data:image/png;base64,666" alt="image-20201030112624338"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112817215.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112817215.png" srcset="data:image/png;base64,666" alt="image-20201030112817215"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112834050.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112834050.png" srcset="data:image/png;base64,666" alt="image-20201030112834050"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112852658.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112852658.png" srcset="data:image/png;base64,666" alt="image-20201030112852658"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112905585.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112905585.png" srcset="data:image/png;base64,666" alt="image-20201030112905585"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112918911.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112918911.png" srcset="data:image/png;base64,666" alt="image-20201030112918911"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112931420.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112931420.png" srcset="data:image/png;base64,666" alt="image-20201030112931420"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112944852.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112944852.png" srcset="data:image/png;base64,666" alt="image-20201030112944852"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112958540.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112958540.png" srcset="data:image/png;base64,666" alt="image-20201030112958540"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030113010189.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030113010189.png" srcset="data:image/png;base64,666" alt="image-20201030113010189"></p><h3 id="6-13-指针运算">6.13 指针运算</h3><h4 id="6-13-1-算术运算">6.13.1 算术运算</h4><ul><li>当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据对应变量的类型的长度进行调整。例如若float类型指针变量p占4个字节，则p+1不会指向p的第二字节，而是会指向p所占的4个字节之后的那个字节</li><li>两个指针只有当都指向同一个数组中的元素时，才允许进行相减，并且减法的结果是两个元素在数组中的距离，而不是内存地址的差值，即在减法运算的同时会除掉变量类型的长度</li></ul><h4 id="6-13-2-关系运算">6.13.2 关系运算</h4><p>对于指向同一个数组中的元素的指针，可以用关系操作符(<code>&gt; &lt; &gt;= &lt;=</code>)来判断哪个指针指向数组中更前或更后的元素</p><h2 id="Ch7-函数">Ch7 函数</h2><h3 id="7-2-函数声明">7.2 函数声明</h3><h4 id="7-2-1-原型">7.2.1 原型</h4><ul><li><p>原型总结了函数定义的起始部分的声明，向编译器提供有关函数应该如何调用的完整信息</p></li><li><p>函数原型的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func_use.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// func.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>声明一个没有参数的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2-2-函数的缺省认定">7.2.2 函数的缺省认定</h4><p>当程序调用一个无法见到原型的函数时，编译器会认为该函数返回一个整型</p><h3 id="7-3-函数的参数">7.3 函数的参数</h3><ul><li>所有参数都是<strong>传值调用</strong>，函数不会修改实际传递的参数</li><li>当传递的参数是指针时，可以通过指针的间接访问修改指针所指的值，称为<strong>传址调用</strong></li></ul><h3 id="7-4-ADT和黑盒">7.4 ADT和黑盒</h3><p>使用static关键字限制对非接口函数和数据的访问</p><h3 id="7-5-递归">7.5 递归</h3><ul><li>通过运行时堆栈支持递归函数的实现</li></ul><p>通过一个简单的递归作为实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个整型值(无符号)，把它转换为字符并打印，前导零被删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_to_ascii</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quotient;</span><br><span class="line">    </span><br><span class="line">    quotient = value / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (quotient != <span class="number">0</span>) &#123;</span><br><span class="line">        binary_to_ascii(quotient);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(value % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-1-追踪递归函数">7.5.1 追踪递归函数</h4><p>程序运行时堆栈的变化：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144906982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144906982.png" srcset="data:image/png;base64,666" alt="image-20201030144906982"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144921304.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144921304.png" srcset="data:image/png;base64,666" alt="image-20201030144921304"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144933258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144933258.png" srcset="data:image/png;base64,666" alt="image-20201030144933258"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144943300.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144943300.png" srcset="data:image/png;base64,666" alt="image-20201030144943300"></p><p>​…</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144956035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144956035.png" srcset="data:image/png;base64,666" alt="image-20201030144956035"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145042009.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145042009.png" srcset="data:image/png;base64,666" alt="image-20201030145042009"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145053160.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145053160.png" srcset="data:image/png;base64,666" alt="image-20201030145053160"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145101621.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145101621.png" srcset="data:image/png;base64,666" alt="image-20201030145101621"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145110915.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145110915.png" srcset="data:image/png;base64,666" alt="image-20201030145110915"></p><h4 id="7-5-2-递归与迭代">7.5.2 递归与迭代</h4><ul><li>如果一个递归函数内部所执行的最后一条语句就是调用自身时，被称为尾部递归，这样的递归很容易被改写为循环迭代的形式，而迭代的效率通常较高</li></ul><h3 id="7-6-可变参数列表">7.6 可变参数列表</h3><h4 id="7-6-1-stdarg宏">7.6.1 stdarg宏</h4><p>定义于stdarg.h头文件</p><ul><li>类型va_list：用于声明变量来访问参数列表的未确定部分<ul><li>此时声明函数的方式为<code>float average(int n, ...)</code></li></ul></li><li>宏va_start：初始化va_list声明的变量，第1个参数是va_list变量名，第2个参数是省略号前的最后一个有名字的参数</li><li>宏va_arg：用于访问参数，第1个参数是va_list变量名，第2个参数是参数列表中下一个参数的类型，返回这个参数的值，并指向下一个可变参数</li><li>宏va_end：访问完最后一个可变参数后调用，参数为va_list变量名</li></ul><h4 id="7-6-2-可变参数的限制">7.6.2 可变参数的限制</h4><ul><li>这些宏无法判断实际存在的参数的数量</li><li>这些宏无法判断每个参数的类型</li></ul><h2 id="Ch8-数组">Ch8 数组</h2><h3 id="8-1-一维数组">8.1 一维数组</h3><h4 id="8-1-1-数组名">8.1.1 数组名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><p>b[3]的类型是整型</p></li><li><p>b是一个指向b[0]的常量指针，因而不能修改数组名的值，即不能修改数组存储的内存地址</p></li><li><p>数组的赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个表达式作用相同，将c指向a[0]</span></span><br><span class="line">c = &amp;a[<span class="number">0</span>];</span><br><span class="line">c = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>// 以下表达式非法，不能将数组复制给数组，数组间的复制只能通过循环逐个元素复制<br>b = a;</p><p>// 以下表达式非法，a是常量，不能被修改<br>a = c;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 8.1.2 下标引用</span><br><span class="line"></span><br><span class="line">通过以下例子说明：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">int array[10];</span><br><span class="line">int *ap &#x3D; array + 2;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>对等表达式</th></tr></thead><tbody><tr><td>ap</td><td>array+2, &amp;array[2]</td></tr><tr><td>*ap</td><td>array[2], *(array+2)</td></tr><tr><td>ap[0]</td><td>array[2]</td></tr><tr><td>ap+6</td><td>array+8, &amp;array[8]</td></tr><tr><td>*ap+6</td><td>array[2]+6</td></tr><tr><td>*(ap+6)</td><td>array[8]</td></tr><tr><td>ap[-1]</td><td>array[1]</td></tr><tr><td>ap[9]</td><td>非法</td></tr></tbody></table><h4 id="8-1-3-指针与下标">8.1.3 指针与下标</h4><p>指针有时比下标更加高效</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172144100.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172144100.png" srcset="data:image/png;base64,666" alt="image-20201030172144100"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172236189.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172236189.png" srcset="data:image/png;base64,666" alt="image-20201030172236189"></p><ul><li>在数组中一次一步移动时，与固定数字相乘的运算在编译的时候完成，所以在运行时所需的指令就少</li><li>但这在实际中不常用，因为可能编译器对循环会有优化</li></ul><h4 id="8-1-5-数组和指针">8.1.5 数组和指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];   <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> *b;     <span class="comment">// 指针</span></span><br></pre></td></tr></table></figure><ul><li><p>a和b都具有指针值，都可以进行间接访问和下标引用操作</p></li><li><p>区别：</p><ul><li>声明数组时，编译器会为数组保留内存空间，然后再创建数组名</li><li>声明指针变量时，编译器只为指针本身保留内存空间，而不为整型值分配内存空间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030175554658.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030175554658.png" srcset="data:image/png;base64,666" alt="image-20201030175554658"></p></li><li><p>在上述声明后：</p><ul><li>*a是合法的，*b是非法的，因为*b将访问内存中某个不确定的位置</li><li>b<ins>是合法的，a</ins>是非法的，因为a是常量指针</li></ul></li></ul><h4 id="8-1-7-声明数组参数">8.1.7 声明数组参数</h4><p>下面的函数原型是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-1-8-初始化">8.1.8 初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>静态初始化：静态变量存储在静态内存，只初始化一次</li><li>自动初始化：自动变量在缺省情况下是未初始化的，若给定初值，则每次进入代码块都会重新初始化</li></ul><h4 id="8-1-9-不完整的初始化">8.1.9 不完整的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>vector[4]被初始化为0</p><h4 id="8-1-10-自动计算数组长度">8.1.10 自动计算数组长度</h4><p>如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有初始值的长度</p><h4 id="8-1-11-字符数组的初始化">8.1.11 字符数组的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字符串数组</span></span><br><span class="line"><span class="keyword">char</span> message1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个字符串常量</span></span><br><span class="line"><span class="keyword">char</span> *message2 = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030233429373.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030233429373.png" srcset="data:image/png;base64,666" alt="image-20201030233429373"></p><h3 id="8-2-多维数组">8.2 多维数组</h3><h4 id="8-2-1-存储顺序">8.2.1 存储顺序</h4><p>定义一个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><p>其在内存中的存储形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030235423211.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030235423211.png" srcset="data:image/png;base64,666" alt="image-20201030235423211"></p><p>这18个元素的下标值依次是(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (1,0) … (2,4) (2,5)</p><h4 id="8-2-2-数组名">8.2.2 数组名</h4><p>如在<code>int matrix[3][10]</code>中，matrix是指向一个包含10个整型元素的数组的指针</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000129705.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000129705.png" srcset="data:image/png;base64,666" alt="image-20201031000129705"></p><p>那么matrix+1则指向：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000214011.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000214011.png" srcset="data:image/png;base64,666" alt="image-20201031000214011"></p><p>而*(matrix + 1) + 5就等价于matrix[1] + 5，是一个指向整型的指针：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000530029.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000530029.png" srcset="data:image/png;base64,666" alt="image-20201031000530029"></p><h4 id="8-2-4-指向数组的指针">8.2.4 指向数组的指针</h4><p>声明一个指向整型数组的指针，并令其指向matrix数组的第一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = matrix;</span><br></pre></td></tr></table></figure><h4 id="8-2-5-作为函数参数的多维数组">8.2.5 作为函数参数的多维数组</h4><p>可以使用以下两张形式的任何一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*mat)[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> mat[][<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-2-6-初始化">8.2.6 初始化</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031171919198.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031171919198.png" srcset="data:image/png;base64,666" alt="image-20201031171919198"></p><h4 id="8-2-7-数组长度自动计算">8.2.7 数组长度自动计算</h4><p>在多维数组中，只有第1维才能根据初始化列表缺省地提供，剩余的几个维必须显式写出</p><h3 id="8-3-指针数组">8.3 指针数组</h3><p>定义方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *keyword[] = &#123;</span><br><span class="line">    <span class="string">&quot;do&quot;</span>,</span><br><span class="line">    <span class="string">&quot;for&quot;</span>,</span><br><span class="line">    <span class="string">&quot;if&quot;</span>,</span><br><span class="line">    <span class="string">&quot;return&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义的好处在于如果要遍历这个表，只需要<code>for (kwp=keyword; *kwp!=NULL; kwp++)</code></p><h2 id="Ch9-字符串、字符和字节">Ch9 字符串、字符和字节</h2><h3 id="9-1-字符串基础">9.1 字符串基础</h3><ul><li>字符串的长度不包含最后的NUL字节</li><li>头文件string.h包含了使用字符串函数所需的原型和声明</li></ul><h3 id="9-2-字符串长度">9.2 字符串长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回类型为size_t，是一个无符号整数类型</p></li><li><p>不要在表达式中同时包含有符号数和无符号数，因此应该把strlen的返回值<strong>强制转换为int</strong></p></li></ul><h3 id="9-3-不受限制的字符串函数">9.3 不受限制的字符串函数</h3><h4 id="9-3-1-复制字符串">9.3.1 复制字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>dst必须是一个字符数组或是一个指向动态分配内存的数组的指针</li><li>复制字符串前必须保证目标字符数组的空间足以容纳需要复制的字符串，不然会覆盖数组之后内存的内容</li></ul><h4 id="9-3-2-连接字符串">9.3.2 连接字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将src字符串的拷贝添加到dst字符串之后</li></ul><h4 id="9-3-4-字符串比较">9.3.4 字符串比较</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若s1小于s2，返回一个小于0的值；若s1大于s2，返回一个大于0的值；若s1和s2相等，返回0</li></ul><h3 id="9-4-长度受限的字符串函数">9.4 长度受限的字符串函数</h3><ul><li><p>字符串复制，将src的前len个字符(不够补NUL)复制给dst，但当src的长度大于len时，只能复制len个字符给dst，因此结果的dst最后是没有NUL的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串连接，将src的前len个字符(不够补NUL)连接到dst后面，会自动添加一个NUL在dst的最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串比较，比较两个字符串的前len位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-5-字符串查找基础">9.5 字符串查找基础</h3><h4 id="9-5-1-查找一个字符">9.5.1 查找一个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在字符串str中查找字符ch第一次出现的位置，返回一个指向该位置的指针，若没有找到返回NULL指针</li><li>strchr从左开始找，strrchr从右开始找</li></ul><h4 id="9-5-2-查找任何几个字符">9.5.2 查找任何几个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回一个指向str中第一个匹配group中任何一个字符的位置指针</li></ul><h4 id="9-5-3-查找一个子串">9.5.3 查找一个子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针</li></ul><h3 id="9-6-高级字符串查找">9.6 高级字符串查找</h3><h4 id="9-6-1-查找一个字符串前缀">9.6.1 查找一个字符串前缀</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strspn</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strcspn</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>strspn返回str起始部分匹配group中任意字符的字符数，而strcspn找的是非group中的字符</p></li><li><p>例如得到指向字符串中第一个非空白字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prt = buffer + <span class="built_in">strspn</span>(buffer, <span class="string">&quot;\n\t\r\f\v&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-6-2-查找标记">9.6.2 查找标记</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *sep)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>从字符串中隔离各个单独的称为标记的部分</p></li><li><p>sep定义了用作分隔符的字符集合</p></li><li><p>若strtok的第一个参数不是NULL，函数将找到字符串的第一个标记，同时保存它在字符串中的位置；若strtok的第一个参数是NULL，函数将在同一个字符串中从保存的位置开始查找下一个标记；若找不到下一个标记，则返回NULL</p></li><li><p>例子：查找被空白分隔的单词</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (token=strtok(line, whitespace); token!=<span class="literal">NULL</span>; token=strtok(<span class="literal">NULL</span>, whitespace)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-7-错误信息">9.7 错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> error_number)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数为错误代码，返回一个指向用于描述错误的字符串的指针</li></ul><h3 id="9-8-字符操作">9.8 字符操作</h3><p>头文件ctype.h</p><h4 id="9-8-1-字符分类">9.8.1 字符分类</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031215526209.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031215526209.png" srcset="data:image/png;base64,666" alt="image-20201031215526209"  /><h4 id="9-8-2-字符大小写转换">9.8.2 字符大小写转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-9-内存操作">9.9 内存操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a, <span class="keyword">void</span> <span class="keyword">const</span> *b, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>与strn带头的函数不同，这些函数遇到NUL字节时不会停止操作</li></ul><h2 id="Ch10-结构和联合">Ch10 结构和联合</h2><h3 id="10-1-结构基础知识">10.1 结构基础知识</h3><p>当一个结构变量在表达式中使用时，并不被替换成一个指针，而是一个标量类型</p><h4 id="10-1-1-结构声明">10.1.1 结构声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125; x, y[<span class="number">20</span>], *z;</span><br></pre></td></tr></table></figure><ul><li>声明了结构体x，包含20个结构体的数组y，指向结构体的指针z</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">x</span>, <span class="title">y</span>[20], *<span class="title">z</span>;</span></span><br></pre></td></tr></table></figure><p>推荐使用以下声明方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125; Simple;</span><br><span class="line"></span><br><span class="line">Simple x, y[<span class="number">20</span>], *z;</span><br></pre></td></tr></table></figure><h4 id="10-1-2-结构成员">10.1.2 结构成员</h4><ul><li><p>直接访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple simp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问成员a</span></span><br><span class="line">simp.a</span><br></pre></td></tr></table></figure></li><li><p>间接访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple *simp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问成员a</span></span><br><span class="line">simp-&gt;a</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-1-5-结构的自引用">10.1.5 结构的自引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; SELF_REF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; SELF_REF;</span><br></pre></td></tr></table></figure><h4 id="10-1-6-不完整的声明">10.1.6 不完整的声明</h4><p>用于多个相互依赖的结构体之间的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-2-结构、指针和成员">10.2 结构、指针和成员</h3><p>后面几节都以以下结构体为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b[<span class="number">2</span>];</span><br><span class="line">&#125; Ex2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ex</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">    Ex2 c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EX</span> *<span class="title">d</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184819038.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184819038.png" srcset="data:image/png;base64,666" alt="image-20201101184819038" style="zoom:80%;" /><p>若声明一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex x = &#123;<span class="number">10</span>, <span class="string">&quot;Hi&quot;</span>, &#123;<span class="number">5</span>, &#123;<span class="number">-1</span>, <span class="number">25</span>&#125;&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">Ex *px = &amp;x;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184841055.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184841055.png" srcset="data:image/png;base64,666" alt="image-20201101184841055"></p><h4 id="10-2-1-访问指针">10.2.1 访问指针</h4><ul><li>px的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185055208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185055208.png" srcset="data:image/png;base64,666" alt="image-20201101185055208"></p><ul><li>px的左值：<ul><li>px+1是一个非法的左值</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185116789.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185116789.png" srcset="data:image/png;base64,666" alt="image-20201101185116789"></p><h4 id="10-2-2-访问结构">10.2.2 访问结构</h4><ul><li>*px的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185329988.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185329988.png" srcset="data:image/png;base64,666" alt="image-20201101185329988"></p><ul><li>*px的左值（接受一个新值）：<ul><li>*px+1是非法的，因为没办法将结构体和整型相加</li><li>*(px+1)也是非法的</li></ul></li></ul><h4 id="image-2020110118534746710-2-3-访问结构成员"><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185347467.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185347467.png" srcset="data:image/png;base64,666" alt="image-20201101185347467">10.2.3 访问结构成员</h4><ul><li>px-&gt;a的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185553782.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185553782.png" srcset="data:image/png;base64,666" alt="image-20201101185553782"></p><ul><li><p>如果进行以下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = &amp;px-&gt;a;</span><br></pre></td></tr></table></figure><p>则pi为：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185756719.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185756719.png" srcset="data:image/png;base64,666" alt="image-20201101185756719"></p><p>​**注：**<em>px的结果是整个结构，而</em>pi的结果是一个整型数</p><ul><li>px-&gt;b的右值为指针常量，所以没有合法左值：<ul><li>对数组元素的访问采用px-&gt;b[1]</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190015612.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190015612.png" srcset="data:image/png;base64,666" alt="image-20201101190015612"></p><h4 id="10-2-4-访问嵌套的结构">10.2.4 访问嵌套的结构</h4><ul><li>px-&gt;c的左值是整个结构，右值如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190226613.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190226613.png" srcset="data:image/png;base64,666" alt="image-20201101190226613"></p><ul><li>px-&gt;c.a的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190313143.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190313143.png" srcset="data:image/png;base64,666" alt="image-20201101190313143"></p><ul><li>*px-&gt;c.b的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190339608.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190339608.png" srcset="data:image/png;base64,666" alt="image-20201101190339608"></p><h4 id="10-2-5-访问指针成员">10.2.5 访问指针成员</h4><p>对px-&gt;d进行初始化，使其指向一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex y;</span><br><span class="line">px-&gt;d = &amp;y;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190547718.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190547718.png" srcset="data:image/png;base64,666" alt="image-20201101190547718"></p><ul><li>px-&gt;d-&gt;c.b[1]的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190624854.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190624854.png" srcset="data:image/png;base64,666" alt="image-20201101190624854"></p><h3 id="10-3-结构的存储分配">10.3 结构的存储分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上述结构体，若整型长度为4字节，而且它的起始存储位置必须能被4整除，于是a存储为1字节，但是后面必须空出3字节才能存放b，其存储形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101191932308.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101191932308.png" srcset="data:image/png;base64,666" alt="image-20201101191932308"></p><p>一个结构体占了12个字节的存储空间，有效利用空间却只有6字节</p><p>如果声明改为如下形式，则只需要8个字节就能存储这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>sizeof可以得出一个结构体的整体长度，包括跳过的字节</li><li>使用offset(type, member)能获得结构体中某成员的实际位置，如offset(struct ALIGN, b)</li></ul><h3 id="10-4-作为函数参数的结构">10.4 作为函数参数的结构</h3><ul><li><p>最好使用指针来传递参数，并声明为寄存器变量来提高效率</p><ul><li><p>若结构体成员不能改变，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">register</span> ALIGN <span class="keyword">const</span> *test)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>若需要根据程序运行结果修改结构体中的值，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">register</span> ALIGN *test)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>调用方式都为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(&amp;align);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="10-5-位段">10.5 位段</h3><ul><li>注重可移植性的程序应该避免使用位段</li></ul><h3 id="10-6-联合">10.6 联合</h3><ul><li><p>联合的所有成员引用的是内存中的相同位置</p></li><li><p>如果联合的各个成员具有不同的长度，联合的长度就是最长成员的长度</p></li><li><p>应用场景比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VARIABLE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>INT, FLOAT, STRING&#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">float</span> f;</span><br><span class="line">        <span class="keyword">char</span> *s;</span><br><span class="line">    &#125; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于整型，type设为INT，存储于value.i中；对于浮点数，type设为FLOAT，存储于value.f中；</p></li><li><p>联合的初始化，初始值必须是联合第一个成员的类型，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">4</span>];</span><br><span class="line">&#125; x = &#123;<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch11-动态内存分配">Ch11 动态内存分配</h2><h3 id="11-1-为什么使用动态分配内存">11.1 为什么使用动态分配内存</h3><p>声明数组时，数组的长度往往在运行时才能知道，但是编译时需要指定数组的长度，因为需要提前开辟内存空间。</p><h3 id="11-2-malloc和free">11.2 malloc和free</h3><ul><li>在头文件stdlib.h中声明</li></ul><h4 id="11-2-1-malloc">11.2.1 malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>malloc从内存池中提取一块合适的内存，并返回一个指向这块内存起始位置的指针(如果内存池中的内存可以满足需求的话，否则返回NULL)</li><li>参数是需要分配的内存字节数</li><li>malloc分配的是一块连续的内存</li><li>分配的内存不会被初始化</li></ul><h4 id="11-2-2-free">11.2.2 free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *pointer)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数是NULL时不会产生任何效果</li><li>参数是先前从malloc、calloc或realloc返回的值时，将分配的内存归还给内存池</li></ul><h3 id="11-3-calloc和realloc">11.3 calloc和realloc</h3><h4 id="11-3-1-calloc">11.3.1 calloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num_elements, <span class="keyword">size_t</span> element_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数包括所需元素的数量和每个元素的字节数</li><li>将分配的内存初始化为0</li></ul><h4 id="11-3-2-realloc">11.3.2 realloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>用于修改一个原先已经分配的内存块的大小</li><li>扩大内存块时，在原先的内存块之后添加；缩小内存块时，从原先内存块的尾部删除</li></ul><h3 id="11-4-使用动态分配的内存">11.4 使用动态分配的内存</h3><ul><li><p>获得足够存储25个整型的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = <span class="built_in">malloc</span>(<span class="number">25</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-5-常见的动态内存错误">11.5 常见的动态内存错误</h3><ul><li><p>对NULL指针进行解引用操作</p></li><li><p>对分配的内存进行操作时越界</p></li><li><p>释放并非动态分配的内存</p></li><li><p>试图释放一块动态分配的内存的一部分</p></li><li><p>一块动态内存被释放之后被继续使用</p></li><li><p>内存泄漏：在使用完毕动态内存后没有进行释放</p></li></ul><h2 id="Ch12-使用结构和指针">Ch12 使用结构和指针</h2><h3 id="12-2-单链表">12.2 单链表</h3><p>声明一个节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>链表结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105130430994.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105130430994.png" srcset="data:image/png;base64,666" alt="image-20201105130430994"></p><h4 id="12-2-1-插入一个有序单链表">12.2.1 插入一个有序单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的参数是一个指向链表第一个节点的指针，以及一个需要插入的新值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sll_node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sll_insert</span><span class="params">(<span class="keyword">register</span> Node **linkp, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> Node *current;</span><br><span class="line">    <span class="keyword">register</span> Node *<span class="keyword">new</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找正确的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> ((current=*linkp) != <span class="literal">NULL</span> &amp;&amp; current-&gt;value &lt; new_value) &#123;</span><br><span class="line">        linkp = &amp;current-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    <span class="keyword">new</span> = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;link = current;</span><br><span class="line">    *linkp = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-双链表">12.3 双链表</h3><p>声明一个双链表节点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">fwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">bwd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>双链表结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105133824925.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105133824925.png" srcset="data:image/png;base64,666" alt="image-20201105133824925"></p><h2 id="Ch14-预处理器">Ch14 预处理器</h2><h3 id="14-1-预定义符号">14.1 预定义符号</h3><table><thead><tr><th>符号</th><th>样例</th><th>含义</th></tr></thead><tbody><tr><td>_<em>FILE</em>_</td><td>“name.c”</td><td>进行编译的文件名</td></tr><tr><td>_<em>LINE</em>_</td><td>25</td><td>文件当前行的行号</td></tr><tr><td>_<em>DATE</em>_</td><td>“Jan 31 1997”</td><td>文件被编译的日期</td></tr><tr><td>_<em>TIME</em>_</td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td>_<em>STDC</em>_</td><td>1</td><td>如果编译器遵循ANSI C，值为1</td></tr></tbody></table><h3 id="14-2-define">14.2 #define</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> name stuff</span></span><br></pre></td></tr></table></figure><p>替换文本不仅限于数值字面值常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_forever for(;;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE break;case</span></span><br></pre></td></tr></table></figure><h4 id="14-2-1-宏">14.2.1 宏</h4><p>#define允许把参数替换到文本中，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) (x)*(x)</span></span><br><span class="line"></span><br><span class="line">SQUARE(<span class="number">5</span>)   <span class="comment">// 输出25</span></span><br></pre></td></tr></table></figure><h4 id="14-2-3-宏与函数">14.2.3 宏与函数</h4><p>可以使用宏来实现简单的函数，如比较大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><h4 id="14-2-6-undef">14.2.6 #undef</h4><p>移除一个宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> name</span></span><br></pre></td></tr></table></figure><h3 id="14-3-条件编译">14.3 条件编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 常量表达式</span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>如果常量表达式非零，则statements正常编译，否则不编译</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习 - SQ1复形</title>
      <link href="2020/11/04/others/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/"/>
      <url>2020/11/04/others/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview">Overview</h2><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104190715236.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104190715236.png" srcset="data:image/png;base64,666" alt="image-20201104190715236"></p><h2 id="CS-Algs-by-Depth">CS Algs by Depth</h2><h3 id="Depth-1">Depth 1</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104191942490.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104191942490.png" srcset="data:image/png;base64,666" alt="image-20201104191942490"></td><td>/</td><td>/</td></tr></tbody></table><h3 id="Depth-2">Depth 2</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192059289.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192059289.png" srcset="data:image/png;base64,666" alt="image-20201104192059289"></td><td>/-3-3/</td><td>/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192131237.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192131237.png" srcset="data:image/png;base64,666" alt="image-20201104192131237"></td><td>/3/</td><td>/-3/</td></tr></tbody></table><h3 id="Depth-3">Depth 3</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192837328.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192837328.png" srcset="data:image/png;base64,666" alt="image-20201104192837328"></td><td>/3/1/</td><td>/-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104193911825.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104193911825.png" srcset="data:image/png;base64,666" alt="image-20201104193911825"></td><td>/-3/-2/</td><td>/2/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194301885.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194301885.png" srcset="data:image/png;base64,666" alt="image-20201104194301885"></td><td>/3/3/</td><td>/-3/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194351763.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194351763.png" srcset="data:image/png;base64,666" alt="image-20201104194351763"></td><td>/3/12/</td><td>/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194631403.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194631403.png" srcset="data:image/png;base64,666" alt="image-20201104194631403"></td><td>/33/-1-2/</td><td>/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194831210.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194831210.png" srcset="data:image/png;base64,666" alt="image-20201104194831210"></td><td>/33/-1/</td><td>/1/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194906760.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194906760.png" srcset="data:image/png;base64,666" alt="image-20201104194906760"></td><td>/-3-3/2/</td><td>/-2/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195100188.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195100188.png" srcset="data:image/png;base64,666" alt="image-20201104195100188"></td><td>/3/1-4/</td><td>/-14/-3/</td></tr></tbody></table><h3 id="Depth-4">Depth 4</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195239653.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195239653.png" srcset="data:image/png;base64,666" alt="image-20201104195239653"></td><td>/33/-1-2/-2-4/</td><td>/24/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195402306.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195402306.png" srcset="data:image/png;base64,666" alt="image-20201104195402306"></td><td>/-3-3/01/-2-2/</td><td>-2/22/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195546376.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195546376.png" srcset="data:image/png;base64,666" alt="image-20201104195546376"></td><td>/3/1-4/42/</td><td>/24/1/-4/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104200419264.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104200419264.png" srcset="data:image/png;base64,666" alt="image-20201104200419264"></td><td>/3/1-4/-2-4/</td><td><strong><code>/-4-2/1/-4/3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104203853713.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104203853713.png" srcset="data:image/png;base64,666" alt="image-20201104203853713"></td><td>/33/-1-2/0-4/</td><td>/04/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204102761.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204102761.png" srcset="data:image/png;base64,666" alt="image-20201104204102761"></td><td>/33/12/02/</td><td>/0-2/21/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204218035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204218035.png" srcset="data:image/png;base64,666" alt="image-20201104204218035"></td><td>/33/-1-2/0-2/</td><td>/02/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204256742.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204256742.png" srcset="data:image/png;base64,666" alt="image-20201104204256742"></td><td>/-3-3/01/-2/</td><td>/2/0-1/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204502256.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204502256.png" srcset="data:image/png;base64,666" alt="image-20201104204502256"></td><td>/3/1-4/4/</td><td>y2 /0-4/-41/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204733435.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204733435.png" srcset="data:image/png;base64,666" alt="image-20201104204733435"></td><td>1-1/0-3/5-2/04/</td><td><strong><code>y2 /-4/1/-4/3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205118213.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205118213.png" srcset="data:image/png;base64,666" alt="image-20201104205118213"></td><td>/03/12/-32/</td><td>/-34/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205234862.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205234862.png" srcset="data:image/png;base64,666" alt="image-20201104205234862"></td><td>1-1/0-3/-1-2/3-2/</td><td>/-32/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205624947.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205624947.png" srcset="data:image/png;base64,666" alt="image-20201104205624947"></td><td>/3/1-4/02/</td><td><strong><code>/0-2/-14/-3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205728979.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205728979.png" srcset="data:image/png;base64,666" alt="image-20201104205728979"></td><td>/0-3/0-1/02/</td><td>/0-2/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205859708.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205859708.png" srcset="data:image/png;base64,666" alt="image-20201104205859708"></td><td>/0-3/0-1/12/</td><td>/-1-2/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205950415.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205950415.png" srcset="data:image/png;base64,666" alt="image-20201104205950415"></td><td>1-1/3/21/-2/</td><td><strong><code>/2/12/03/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210319195.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210319195.png" srcset="data:image/png;base64,666" alt="image-20201104210319195"></td><td>/3/12/4/</td><td>/-4/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210408388.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210408388.png" srcset="data:image/png;base64,666" alt="image-20201104210408388"></td><td>1-1/0-3/-1-2/0-4/</td><td>/04/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210512395.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210512395.png" srcset="data:image/png;base64,666" alt="image-20201104210512395"></td><td>1-1/3/21/-2-3/</td><td>/23/-2-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210603505.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210603505.png" srcset="data:image/png;base64,666" alt="image-20201104210603505"></td><td>/3/12/23/</td><td>/-2-3/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210645921.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210645921.png" srcset="data:image/png;base64,666" alt="image-20201104210645921"></td><td>/33/-1/4/</td><td>/-4/1/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210758160.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210758160.png" srcset="data:image/png;base64,666" alt="image-20201104210758160"></td><td>1-1/3/21/0-3/</td><td>/03/-2-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210924727.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210924727.png" srcset="data:image/png;base64,666" alt="image-20201104210924727"></td><td>/0-3/0-1/1/</td><td>/-1/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104211056172.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104211056172.png" srcset="data:image/png;base64,666" alt="image-20201104211056172"></td><td>/0-3/0-1/04/</td><td>/0-4/01/03/</td></tr></tbody></table><h3 id="Depth-5">Depth 5</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th><th>Note</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104214123694.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104214123694.png" srcset="data:image/png;base64,666" alt="image-20201104214123694"></td><td>/03/12/-3/02/</td><td><strong><code>/0-2/3/-1-2/0-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104215905927.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104215905927.png" srcset="data:image/png;base64,666" alt="image-20201104215905927"></td><td>/0-3/0-1/1/02/</td><td><strong><code>/0-2/-1/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104220413801.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104220413801.png" srcset="data:image/png;base64,666" alt="image-20201104220413801"></td><td>1-1/03/01/-1/0-2/</td><td><strong><code>/02/02/1/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221315982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221315982.png" srcset="data:image/png;base64,666" alt="image-20201104221315982"></td><td>/3/12/2-3/34/</td><td>/32/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213314692.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213314692.png" srcset="data:image/png;base64,666" alt="image-20201104213314692"></td><td>1-1/0-3/-1-2/3-4/-3/</td><td>/3/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213425561.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213425561.png" srcset="data:image/png;base64,666" alt="image-20201104213425561"></td><td>1-1/0-3/-1-2/3-2/3/</td><td>/-3/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221827619.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221827619.png" srcset="data:image/png;base64,666" alt="image-20201104221827619"></td><td>1-1/0-3/-1-2/0-4/-3/</td><td><strong><code>/3/04/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104222735067.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104222735067.png" srcset="data:image/png;base64,666" alt="image-20201104222735067"></td><td>/03/12/04/3/</td><td><strong><code>/-3/62/-12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233553524.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233553524.png" srcset="data:image/png;base64,666" alt="image-20201104233553524"></td><td>/33/1/-2/2/</td><td>/-2/2/-1/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104223119427.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104223119427.png" srcset="data:image/png;base64,666" alt="image-20201104223119427"></td><td>/33/-1-2/-2/1-2/</td><td><strong><code>/-12/2/12/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104224012377.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104224012377.png" srcset="data:image/png;base64,666" alt="image-20201104224012377"></td><td>/33/-1-2/02/2-1/</td><td><strong><code>/-21/0-2/12/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234024560.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234024560.png" srcset="data:image/png;base64,666" alt="image-20201104234024560"></td><td>1-1/3/21/2-3/2-1/</td><td>/-21/-23/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234520095.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234520095.png" srcset="data:image/png;base64,666" alt="image-20201104234520095"></td><td>1-1/3/21/4-3/-21/</td><td>/2-1/-43/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230509180.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230509180.png" srcset="data:image/png;base64,666" alt="image-20201104230509180" style="zoom:130%;" /></td><td>/0-3/0-1/1/32/</td><td><strong><code>/-3-2/-1/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230553088.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230553088.png" srcset="data:image/png;base64,666" alt="image-20201104230553088" style="zoom:130%;" /></td><td>1-1/0-3/-1/0-2/-3-2/</td><td><strong><code>/32/02/1/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104225944910.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104225944910.png" srcset="data:image/png;base64,666" alt="image-20201104225944910"></td><td>/33/-1-2/-2-4/-3/</td><td>/3/24/12/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104230030964.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104230030964.png" srcset="data:image/png;base64,666" alt="image-20201104230030964"></td><td>1-1/0-3/-1-2/0-4/-32/</td><td><strong><code>/3-2/04/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231503453.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231503453.png" srcset="data:image/png;base64,666" alt="image-20201104231503453"></td><td>1-1/-3/-1-2/4/-2/</td><td><strong><code>/2/-4/12/3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235201130.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235201130.png" srcset="data:image/png;base64,666" alt="image-20201104235201130"></td><td>/33/-1-2/0-4/02/</td><td>/0-2/04/12/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231611888.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231611888.png" srcset="data:image/png;base64,666" alt="image-20201104231611888"></td><td>1-1/3/21/2/0-1/</td><td><strong><code>/01/-2/-2-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232130549.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232130549.png" srcset="data:image/png;base64,666" alt="image-20201104232130549"></td><td>1-1/0-3/-1-2/02/0-1/</td><td><strong><code>/01/0-2/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232211689.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232211689.png" srcset="data:image/png;base64,666" alt="image-20201104232211689"></td><td>/3/12/-2/01/</td><td><strong><code>/0-1/2/-1-2/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232318699.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232318699.png" srcset="data:image/png;base64,666" alt="image-20201104232318699"></td><td>/03/12/02/3-2/</td><td><strong><code>/-32/0-2/-1-2/0-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232554844.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232554844.png" srcset="data:image/png;base64,666" alt="image-20201104232554844"></td><td>/3/1/-2/2/</td><td>/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232626895.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232626895.png" srcset="data:image/png;base64,666" alt="image-20201104232626895"></td><td>/3/1/-2-1/01/</td><td><strong><code>/0-1/21/-1/-3/</code></strong></td><td>三小角换风筝尾</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233425542.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233425542.png" srcset="data:image/png;base64,666" alt="image-20201104233425542"></td><td>/3/1/-2/0-1/</td><td><strong><code>/01/2/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235428645.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235428645.png" srcset="data:image/png;base64,666" alt="image-20201104235428645"></td><td>1-1/0-3/-1-2/3-4/32/</td><td>/-3-2/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235508229.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235508229.png" srcset="data:image/png;base64,666" alt="image-20201104235508229"></td><td>/3/12/-23/21/</td><td>/-2-1/2-3/-1-2/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235554034.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235554034.png" srcset="data:image/png;base64,666" alt="image-20201104235554034"></td><td>1-1/0-3/-1-2/3-2/-3/</td><td>/3/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235637927.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235637927.png" srcset="data:image/png;base64,666" alt="image-20201104235637927"></td><td>/03/12/-32/3/</td><td>/-3/3-2/-1-2/0-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235721071.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235721071.png" srcset="data:image/png;base64,666" alt="image-20201104235721071"></td><td>1-1/0-3/-1-2/3-2/0-2/</td><td>/02/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235832145.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235832145.png" srcset="data:image/png;base64,666" alt="image-20201104235832145"></td><td>/3/1-4/02/-1/</td><td>/1/0-2/-14/-3/</td><td>构造飞镖</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093024208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093024208.png" srcset="data:image/png;base64,666" alt="image-20201105093024208"></td><td>/3/1-4/02/0-2/</td><td><strong><code>/02/0-2/-14/-3/</code></strong></td><td>构造飞镖</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105000229881.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105000229881.png" srcset="data:image/png;base64,666" alt="image-20201105000229881"></td><td>1-1/3/21/2-3/0-1/</td><td>/01/-23/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105092327756.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105092327756.png" srcset="data:image/png;base64,666" alt="image-20201105092327756"></td><td>/33/-1-2/2/0-1/</td><td><strong><code>/01/-2/12/-3-3/</code></strong></td><td>三小角并一小角</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093823821.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093823821.png" srcset="data:image/png;base64,666" alt="image-20201105093823821"></td><td>/-3-3/01/-2-2/1-2/</td><td>\</td><td>合并六星</td></tr></tbody></table><h3 id="Depth-6">Depth 6</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th><th>Note</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094450515.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094450515.png" srcset="data:image/png;base64,666" alt="image-20201105094450515"></td><td>/0-3/-2-1/-32/-1-2/-4/</td><td><strong><code>/4/12/3-2/21/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094654340.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094654340.png" srcset="data:image/png;base64,666" alt="image-20201105094654340"></td><td>1-1/-3/-1-2/2-3/-2-1/0-4/</td><td>/04/21/-23/12/3/</td><td>待优化</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094819794.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094819794.png" srcset="data:image/png;base64,666" alt="image-20201105094819794"></td><td>1-1/0-3/-1-2/3-4/-1-2/-2/</td><td><strong><code>/2/12/ -34/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095130553.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095130553.png" srcset="data:image/png;base64,666" alt="image-20201105095130553"></td><td>1-1/3/21/4-3/21/02/</td><td><strong><code>/0-2/-2-1/-43/-2-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095323990.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095323990.png" srcset="data:image/png;base64,666" alt="image-20201105095323990"></td><td>/0-3/0-1/12/2/-1/</td><td><strong><code>/1/-2/-1-2/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095631429.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095631429.png" srcset="data:image/png;base64,666" alt="image-20201105095631429"></td><td>/3/1/-2-1/0-2/01/</td><td><strong><code>/0-1/02/21/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095654217.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095654217.png" srcset="data:image/png;base64,666" alt="image-20201105095654217"></td><td>/3/1/-2/2/03/</td><td>/0-3/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095830977.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095830977.png" srcset="data:image/png;base64,666" alt="image-20201105095830977"></td><td>/33/1/-2-2/21/-2-2/</td><td>\</td><td>两步变六星</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100045458.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100045458.png" srcset="data:image/png;base64,666" alt="image-20201105100045458"></td><td>/3/1/-2/0-1/2/</td><td>/-2/01/2/-1/-3/</td><td>两步后23动1</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100234945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100234945.png" srcset="data:image/png;base64,666" alt="image-20201105100234945"></td><td>/3/1/-2-1/01/-2/</td><td>/2/0-1/21/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100350400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100350400.png" srcset="data:image/png;base64,666" alt="image-20201105100350400"></td><td>/33/1/-2/2/-2-3/</td><td><strong><code>/23/-2/2/-1/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100619220.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100619220.png" srcset="data:image/png;base64,666" alt="image-20201105100619220"></td><td>/3/12/-2/01/2/</td><td><strong><code>/-2/0-1/2/-1-2/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101051905.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101051905.png" srcset="data:image/png;base64,666" alt="image-20201105101051905"></td><td>/3/12/-2/2-3/-2/</td><td><strong><code>/21/2-1/21/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101400605.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101400605.png" srcset="data:image/png;base64,666" alt="image-20201105101400605"></td><td>/3/1/-2/2/-23/</td><td>/2-3/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101539136.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101539136.png" srcset="data:image/png;base64,666" alt="image-20201105101539136"></td><td>/33/-1-2/-2/1/2/</td><td></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101705861.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101705861.png" srcset="data:image/png;base64,666" alt="image-20201105101705861"></td><td>/33/12/2/-1/-2/</td><td></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101757442.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101757442.png" srcset="data:image/png;base64,666" alt="image-20201105101757442"></td><td>1-1/3/2-5/2/0-1/-4/</td><td><strong><code>/4/01/-2/-25/-3/</code></strong></td><td>构造shield-paw</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105102105612.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105102105612.png" srcset="data:image/png;base64,666" alt="image-20201105102105612"></td><td>/3/1/-2/2/-2/</td><td>/2/-2/2/-1/-3/</td><td>构造shield-kite</td></tr></tbody></table><h3 id="Depth-7">Depth 7</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094216164.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094216164.png" srcset="data:image/png;base64,666" alt="image-20201105094216164"></td><td>/3/1/-2/2/-2/1/</td><td>/-1/2/-2/2/-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094250825.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094250825.png" srcset="data:image/png;base64,666" alt="image-20201105094250825"></td><td>/0-3/0-1/02/0-2/02/0-1/</td><td>/01/0-2/02/0-2/01/03/</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Cube </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sq1 </tag>
            
            <tag> cube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux - Learn</title>
      <link href="2020/11/04/learning-notes/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/04/learning-notes/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="了解系统信息">了解系统信息</h2><h3 id="硬盘大小">硬盘大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">&#x2F;dev&#x2F;sda 操作系统中第一块硬盘的名称以及所在路径</span><br><span class="line">Linux操作系统一切皆文件 （文件名） sd (硬盘类型) a（第一块）</span><br></pre></td></tr></table></figure><h3 id="内存大小">内存大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure><h3 id="cpu大小">cpu大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><h3 id="收集系统信息">收集系统信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="Linux文件系统">Linux文件系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin    普通用户和管理员都可以执行的命令</span><br><span class="line">&#x2F;sbin   只有管理员才能执行的命令 eg.关机重启</span><br><span class="line">&#x2F;boot   引导 主引导目录 独立的分区 启动菜单 内核</span><br><span class="line">&#x2F;dev    device 设备文件存放目录</span><br><span class="line">&#x2F;etc    配置文件存放目录</span><br><span class="line">&#x2F;home   普通用户的家目录</span><br><span class="line">&#x2F;root   管理员的家</span><br><span class="line">&#x2F;media  光驱的挂载目录</span><br><span class="line">&#x2F;mnt    临时设备的挂载目录</span><br><span class="line">&#x2F;proc   里面的数据都在内存中，进程的所在目录</span><br><span class="line">&#x2F;tmp    临时文件存放目录</span><br><span class="line">&#x2F;usr    第三方软件的安装目录</span><br><span class="line">&#x2F;var    常变文件存放目录 eg.日志文件、邮件文件</span><br></pre></td></tr></table></figure><h3 id="挂载光驱">挂载光驱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弹出光驱：umount &#x2F;dev&#x2F;cdrom</span><br><span class="line">挂载光驱：mount &#x2F;dev&#x2F;cdrom &#x2F;media</span><br></pre></td></tr></table></figure><h2 id="Linux文件类型的显示颜色">Linux文件类型的显示颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">蓝色 目录</span><br><span class="line">黑色 普通文件</span><br><span class="line">浅蓝色 符号链接（快捷方式）</span><br><span class="line">黑底黄字 设备文件 硬盘 sda</span><br><span class="line">红色 压缩包</span><br><span class="line">绿色 带有执行权限的文件</span><br><span class="line">紫色 图片 模块文件</span><br></pre></td></tr></table></figure><h2 id="压缩和解压缩">压缩和解压缩</h2><h3 id="文件压缩和解压缩">文件压缩和解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip bigfile</span><br><span class="line">gunzip bigfile.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 bigfile</span><br><span class="line">bunzip2 bigfile.bz2</span><br></pre></td></tr></table></figure><h3 id="目录-文件夹-打包压缩">目录(文件夹)打包压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf &#x2F;tmp&#x2F;allfile.tar.gz &#x2F;tmp&#x2F;allfile</span><br><span class="line">tar -jcf &#x2F;tmp&#x2F;allfile.tar.bz2 &#x2F;tmp&#x2F;allfile</span><br></pre></td></tr></table></figure><h3 id="目录-文件夹-解压缩并解包">目录(文件夹)解压缩并解包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf &#x2F;tmp&#x2F;allfile.tar.gz -C &#x2F;tmp</span><br><span class="line">tar -jxf &#x2F;tmp&#x2F;allfile.tar.bz2 -C &#x2F;tmp</span><br><span class="line">-C 指定解包位置</span><br></pre></td></tr></table></figure><h2 id="vim">vim</h2><h3 id="模式切换">模式切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令模式 -&gt; 输入模式：i</span><br><span class="line">输入模式 -&gt; 命令模式：Esc</span><br><span class="line">命令模式 -&gt; 末行模式：:</span><br></pre></td></tr></table></figure><h3 id="末行模式命令">末行模式命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:wq   保存并退出</span><br><span class="line">:q!    不保存退出</span><br><span class="line">:set nu   显示行号</span><br><span class="line">:% s&#x2F;old&#x2F;new&#x2F;g   每一行中的old替换成new</span><br><span class="line">:50,56 d     删除50-56行的数据</span><br></pre></td></tr></table></figure><h3 id="命令模式命令">命令模式命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0       光标移动到当前行首</span><br><span class="line">$       光标移动到当前行末</span><br><span class="line">yy      复制当前行</span><br><span class="line">2yy     复制当前行以及后一行，其他数字以此类推</span><br><span class="line">p       粘贴到当前行下一行</span><br><span class="line">dd      删除当前行</span><br><span class="line">gg      回到第一行</span><br><span class="line">G       回到最后一行</span><br></pre></td></tr></table></figure><h2 id="Linux软件安装——封装后的软件包">Linux软件安装——封装后的软件包</h2><h3 id="后缀名">后缀名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm     red hat系统</span><br><span class="line">deb     debian系统</span><br><span class="line">源码包  不考虑系统版本</span><br></pre></td></tr></table></figure><h3 id="有关软件包安装的命令">有关软件包安装的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa             列出所有已经安装的rpm包</span><br><span class="line">查询特定的rpm包使用管道符：rpm -qa | grep &quot;tree&quot;</span><br><span class="line">rpm -qpi 软件名     确认该软件的作用</span><br><span class="line">rpm -qpl 软件名     确认该软件的安装路径(无法修改)</span><br><span class="line">rpm -ivh 软件名     安装软件</span><br><span class="line">rpm -e 软件名       软件卸载</span><br></pre></td></tr></table></figure><h2 id="Linux软件安装——yum">Linux软件安装——yum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install 软件名</span><br><span class="line">yum remove 软件名</span><br></pre></td></tr></table></figure><h2 id="用户和组">用户和组</h2><h3 id="三个重要文件">三个重要文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;passwd     保存操作系统中所有的用户信息</span><br><span class="line">root : x : 0 : 0 : root : &#x2F;root : &#x2F;bin&#x2F;bash</span><br><span class="line">每一条目共7个字段，用冒号隔开</span><br><span class="line">字段1：用户名</span><br><span class="line">字段2：密码占位符</span><br><span class="line">字段3：用户的UID</span><br><span class="line">    0 表示超级用户</span><br><span class="line">    500-60000 普通用户</span><br><span class="line">    1-499 程序用户</span><br><span class="line">字段4：基本组的GID，先有组才有用户</span><br><span class="line">字段5：用户信息记录字段</span><br><span class="line">字段6：用户的家目录</span><br><span class="line">字段7：用户登录系统后使用的命令解释器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadow     保存了用户密码信息</span><br><span class="line">root : $6$ME9wjPHAid5ds$PO&#x2F;GlBVEt1 : 18325 : 0 : 99999 : 7 :::</span><br><span class="line">字段1：用户名</span><br><span class="line">*字段2：用户的密码加盐并通过散列算法后的字符串（sha）</span><br><span class="line">字段3：距离1970&#x2F;1&#x2F;1密码最近一次修改的时间</span><br><span class="line">字段4：密码的最短有效期</span><br><span class="line">*字段5：密码的最长有效期（建议时间 90）</span><br><span class="line">字段6：密码过期前7天警告</span><br><span class="line">字段7：密码的不活跃期</span><br><span class="line">字段8：用户的失效时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group      记录了系统中所有组的信息</span><br></pre></td></tr></table></figure><h3 id="建立和调整用户属性">建立和调整用户属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1、建立一个名为class1的组ID为1000，class2的组ID为2000</span><br><span class="line">建立：</span><br><span class="line">groupadd class1</span><br><span class="line">groupadd -g 2000 class2</span><br><span class="line">修改gid：</span><br><span class="line">groupmod -g 1000 class1</span><br><span class="line">查看：</span><br><span class="line">vim &#x2F;etc&#x2F;group</span><br><span class="line"></span><br><span class="line">2、建立tom用户要求其基本组是class1,附加组为class2，tom用户的UID为600</span><br><span class="line">建立：</span><br><span class="line">useradd -g class1 -G class2 -u 600 tom</span><br><span class="line">修改：</span><br><span class="line">usermod</span><br><span class="line">查看：</span><br><span class="line">id tom</span><br><span class="line"></span><br><span class="line">3、建立一个程序用户UID为250,用户名为testuser，没有家目录（程序用户没有登录系统权限）</span><br><span class="line">useradd -u 250 -M -s &#x2F;sbin&#x2F;nologin testuser</span><br><span class="line">-M：没有家目录</span><br><span class="line">-s &#x2F;sbin&#x2F;nologin：不能登录</span><br><span class="line"></span><br><span class="line">4、为tom用户设定密码为123，并设定密码最长有效期为90天，将用户密码进行锁定使其无法登录</span><br><span class="line">passwd tom        设定密码</span><br><span class="line">chage -M 90 tom   设定密码最长有效期</span><br><span class="line">或者修改配置文件&#x2F;etc&#x2F;login.defs</span><br><span class="line">passwd -l tom     锁定</span><br><span class="line">passwd -u tom     解锁</span><br><span class="line">查看：</span><br><span class="line">passwd -S tom</span><br><span class="line">vim &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br><span class="line">5、删除tom用户和testuser用户，删除class1组和class2组</span><br><span class="line">userdel -r tom     （-r  连同用户的家目录一起删除）</span><br><span class="line">userdel -r testuser</span><br><span class="line">groupdel class1</span><br><span class="line">groupdel class1</span><br></pre></td></tr></table></figure><h2 id="文件目录权限">文件目录权限</h2><h3 id="列出文件信息">列出文件信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -a       列出所有文件，包括隐藏文件</span><br><span class="line">ls -l(ll)   列出文件详细信息</span><br><span class="line">文件：-rw-rw-r--.(权限) 1(链接数) centos(所属用户) centos(所属组)   12(文件大小，字节) Sep 12 10:07(最后修改时间) test.txt</span><br><span class="line">目录：drwxrwxr-x.(权限) 2(子目录数) centos(所属用户) centos(所属组)    6 Sep 12 10:06(最后修改时间) testdir</span><br><span class="line">ls -ld      列出某一目录的详细信息</span><br><span class="line">ls -h       用人能看懂的方式显示文件大小</span><br></pre></td></tr></table></figure><h3 id="权限详细">权限详细</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- rw- rw- r--.</span><br><span class="line">d rwx rwx r-x.</span><br><span class="line">共4个字段</span><br><span class="line">字段1：文件类型</span><br><span class="line">    -普通文件</span><br><span class="line">    d目录文件</span><br><span class="line">    l符号链接文件</span><br><span class="line">    b块设备</span><br><span class="line">字段2：文件所属者的权限</span><br><span class="line">            r               w           x</span><br><span class="line">    文件    读取            写入        可执行</span><br><span class="line">    目录    查看目录文件    增删文件    进入目录</span><br><span class="line">字段3：文件所属组的权限</span><br><span class="line">字段4：其他用户的权限</span><br></pre></td></tr></table></figure><h3 id="赋权限">赋权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：chmod 对象 算术运算符 权限 文件</span><br><span class="line">    对象：u-所属者 g-所属组 o-其他用户 a-所有用户</span><br><span class="line">    算术运算符：- + &#x3D;</span><br><span class="line">    权限：r w x</span><br><span class="line">方法2：chmod 777 文件</span><br></pre></td></tr></table></figure><h3 id="改变文件的所属者和所属组">改变文件的所属者和所属组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown 用户 文件</span><br><span class="line">chgrp 组 文件</span><br></pre></td></tr></table></figure><h3 id="粘滞位-sgid-suid权限">粘滞位 sgid suid权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">粘滞位针对目录赋权，目录中创建的文件只有建立者可以删除</span><br><span class="line">    chmod o+t 文件</span><br><span class="line">    chmod o-t 文件</span><br><span class="line">sgid 针对目录建立的权限，在该目录中建立的文件所属组继承父目录的所属组</span><br><span class="line">    chmod g+s 文件</span><br><span class="line">    chmod g-s 文件</span><br><span class="line">suid 对可执行文件建立。谁运行该文件，就具有该文件所属者的权限</span><br><span class="line">    chmod u+s 文件</span><br><span class="line">    chmod u-s 文件</span><br><span class="line">    eg. chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim</span><br></pre></td></tr></table></figure><h3 id="查找有异常权限的文件">查找有异常权限的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查找有suid权限的可执行文件</span><br><span class="line">find &#x2F;usr&#x2F;bin -perm 4755</span><br><span class="line">其中权限的第一个4表示suid权限，如果是2则表示sgid权限，如果是1则表示粘滞位</span><br><span class="line">权限的多一位也可以用于赋权限</span><br></pre></td></tr></table></figure><h3 id="不再允许添加新用户">不再允许添加新用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建用户时会更改的文件</span><br><span class="line">    &#x2F;etc&#x2F;group</span><br><span class="line">    &#x2F;etc&#x2F;passwd</span><br><span class="line">    &#x2F;etc&#x2F;shadow</span><br><span class="line">    home&#x2F;xxxx</span><br><span class="line">锁定文件从而不能添加新用户</span><br><span class="line">    chattr +i &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow</span><br><span class="line">查看文件是否被锁定</span><br><span class="line">    lsattr &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h3 id="umask">umask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般目录的最高权限是777</span><br><span class="line">一般文件的最高权限是666</span><br><span class="line">用户创建的文件通过umask来确定其权限</span><br><span class="line">root的umask是0022(第一位是特殊权限)</span><br><span class="line">普通用户并且uid&#x3D;sid的umask是0002</span><br><span class="line"></span><br><span class="line">umask的设置在&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc两个文件中</span><br></pre></td></tr></table></figure><h2 id="网络地址配置">网络地址配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 确认网卡信息：ip addr &#x2F; ifconfig</span><br><span class="line">2. 关闭NetworkManager服务：systemctl stop NetworkManager</span><br><span class="line">3. 网卡启用桥接模式，并配置网络地址：</span><br><span class="line">    ip addr add IP&#x2F;掩码长度 dev ens33</span><br><span class="line">4. 设置网关：</span><br><span class="line">    ip route add default via IP dev ens33</span><br><span class="line">5. 配置DNS：</span><br><span class="line">    vim &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">    nameserver 202.120.2.101</span><br><span class="line">6. 关闭防火墙：</span><br><span class="line">    systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h2 id="日志文件">日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">位置：&#x2F;var&#x2F;log</span><br><span class="line">日志记录的配置文件：&#x2F;etc&#x2F;rsyslog.conf</span><br><span class="line">    其中配置方式为 日志类型.日志级别 ，如authpriv.*表示记录所有级别的登录日志</span><br><span class="line">日志分类：</span><br><span class="line">    系统日志    &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">    登录日志    &#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line">    程序日志</span><br><span class="line">日志记录的日志级别：</span><br><span class="line">debug,  info,  notice, warning(warn), err(error), crit, alert, emerg(panic)</span><br><span class="line">最不严重  -&gt; 最严重</span><br><span class="line"></span><br><span class="line">配置日志备份服务器：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43252204&#x2F;article&#x2F;details&#x2F;105518163</span><br></pre></td></tr></table></figure><h2 id="WEB服务-apache">WEB服务-apache</h2><h3 id="开启并使用apache">开启并使用apache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 启动服务</span><br><span class="line">    service httpd start</span><br><span class="line">2. 验证服务是否开启</span><br><span class="line">    ss -antpl | grep 80</span><br><span class="line">3. 主页建立</span><br><span class="line">    vim &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><h3 id="httpd配置文件">httpd配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">默认会开启共享目录功能，这样会导致别人可以远程下载&#x2F;var&#x2F;www&#x2F;html中的内容，建议将其关闭：</span><br><span class="line">    Options Indexes FollowSymLinks改为Options FollowSymLinks</span><br><span class="line">限制访问，将Require all granted修改为以下语句：</span><br><span class="line">    &lt;RequireAll&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    Require not ip 192.168.1.10 192.168.2.0&#x2F;24</span><br><span class="line">        &#x2F;&#x2F;拒绝192.168.1.10和192.168.2.0网段客户机访问</span><br><span class="line">    &lt;&#x2F;RequireAll&gt;</span><br><span class="line">用户授权限制，只有通过指定的用户名密码才能访问网页：</span><br><span class="line">    设置用户名密码：htpasswd -c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser test   (-c表示新建文件)</span><br><span class="line">    设置该文件只有apache用户可读：</span><br><span class="line">        chown apache httpuser</span><br><span class="line">        chmod 400 httpuser</span><br><span class="line">    修改配置文件：</span><br><span class="line">        Authtype basic</span><br><span class="line">        Authname &quot;Input username and password&quot; &#x2F;&#x2F; 提示信息</span><br><span class="line">        Authuserfile &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser</span><br><span class="line">        Require valid-user</span><br></pre></td></tr></table></figure><h2 id="lamp平台搭建">lamp平台搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 安装apache</span><br><span class="line">2. 安装mysql</span><br><span class="line">    yum install mysql-server    &#x2F;&#x2F; 安装</span><br><span class="line">    service mysqld start        &#x2F;&#x2F; 启动</span><br><span class="line">    mysqladmin -u root -p password &quot;123.sck&quot;     &#x2F;&#x2F; 设置root密码</span><br><span class="line">    mysql -u root -p        &#x2F;&#x2F; 登录数据库</span><br><span class="line">3. 安装php</span><br><span class="line">    yum install php</span><br><span class="line">    yum install php-mysqlnd</span><br><span class="line">    yum install php-mbstring</span><br><span class="line">4. 配置php配置文件</span><br><span class="line">    vim &#x2F;etc&#x2F;php.ini</span><br><span class="line">    将short_open_tag从Off改为On</span><br><span class="line">5. 在&#x2F;var&#x2F;www&#x2F;html新建一个php文件</span><br></pre></td></tr></table></figure><h2 id="iptables防火墙">iptables防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四个表：</span><br><span class="line">    raw</span><br><span class="line">    mangle</span><br><span class="line">    nat     网络地址转换</span><br><span class="line">    filter  过滤</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Volantis个人博客部署</title>
      <link href="2020/11/03/instruction/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
      <url>2020/11/03/instruction/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="配置部署Hexo">配置部署Hexo</h2><h3 id="配置流程">配置流程</h3><ul><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">参考链接</a></p><ul><li>安装<a href="https://www.cnblogs.com/lgx5/p/10732016.html">npm</a></li><li>安装<a href="https://blog.csdn.net/sinat_20177327/article/details/76062030">git</a></li><li>其中配置npm源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取npm源</span></span><br><span class="line">npm get registry</span><br><span class="line"><span class="comment"># 修改为淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 重置</span></span><br><span class="line"><span class="comment"># npm config set registry https://registry.npmjs.org/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常用命令">常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传至github</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地运行</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="Markdown公式显示问题">Markdown公式显示问题</h3><p>使用<a href="https://www.jianshu.com/p/588ab3d22eb8">hexo-renderer-markdown-it</a>插件</p><h2 id="处理Markdown图片问题">处理Markdown图片问题</h2><p>在最开始的尝试中遇到以下问题：</p><ul><li>直接将图片保存到github，在hexo编译生成的html网页中通过相对路径访问<strong>速度太慢</strong></li><li>将博客部署到gitee上，由于服务器在国内，图片加载速度确实比github快很多，但是问题在于部署在gitee上的博客会有各种奇怪<strong>显示问题</strong>，所以也放弃</li></ul><p>最终的解决办法：</p><ul><li>先在github新建一个仓库Source，专门用来存放博客文章用到的图片</li><li>使用jsdelivr提供的cdn加速<ul><li>在本地编写好markdown后，将图片文件夹复制到Source目录下并push到github仓库</li><li>在markdown文档中通过<code>ctrl+f</code>将所有图片的路径前缀改为<code>https://cdn.jsdelivr.net/gh/&lt;github用户名&gt;/Source@latest/&lt;文件夹名&gt;</code></li></ul></li></ul><h2 id="Volantis主题配置">Volantis主题配置</h2><h3 id="主题安装">主题安装</h3><ol><li><p>修改<code>./_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">volantis</span></span><br></pre></td></tr></table></figure></li><li><p>下载主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-volantis</span><br></pre></td></tr></table></figure></li><li><p>volantis主题会安装在<code>./node_modules/hexo-theme-volantis</code>中</p></li></ol><h3 id="主题个性化">主题个性化</h3><h4 id="搜索工具安装">搜索工具安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-json-content</span><br></pre></td></tr></table></figure><h4 id="字数统计工具安装">字数统计工具安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="主题配置文件">主题配置文件</h4><h5 id="顶部导航栏">顶部导航栏</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># choose [img] or [icon + title]</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/taiga.svg</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">主页</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-stack-overflow</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">Search...</span>   <span class="comment"># Search bar placeholder</span></span><br></pre></td></tr></table></figure><h5 id="封面">封面</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">layout_scheme:</span> <span class="string">dock</span> <span class="comment"># blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点)</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/interstellar.jpg</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&#x27;Schenk - Blog&#x27;</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;SJTUer | Cuber&#x27;</span></span><br><span class="line">  <span class="attr">features:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br></pre></td></tr></table></figure><h5 id="全局CSS">全局CSS</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="attr">navbar:</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">44px</span> </span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="comment"># auto, max</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">blur</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">    <span class="attr">highlight:</span></span><br><span class="line">      <span class="attr">language:</span> <span class="literal">true</span> <span class="comment"># show language of codeblock</span></span><br><span class="line">      <span class="attr">copy_btn:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">grayscale:</span> <span class="literal">false</span> <span class="comment"># Enable grayscale effect</span></span><br><span class="line">    <span class="attr">text_align:</span> <span class="comment"># left, right, justify, center</span></span><br><span class="line">      <span class="attr">h1:</span> <span class="string">center</span></span><br><span class="line">      <span class="attr">h2:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h3:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h4:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">p:</span> <span class="string">justify</span></span><br><span class="line">  <span class="attr">gap:</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="string">30px</span> <span class="comment"># Spacing above H2 (only px unit)</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="string">18px</span> <span class="comment"># Spacing above H3 (only px unit)</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="string">8px</span> <span class="comment"># Spacing above H4 (only px unit)</span></span><br><span class="line">    <span class="attr">p:</span> <span class="string">1em</span> <span class="comment"># Paragraph spacing between paragraphs</span></span><br><span class="line">    <span class="attr">line_height:</span> <span class="number">1.6</span> <span class="comment"># normal, 1.5, 1.75, 2 ...</span></span><br><span class="line">  <span class="attr">fontsize:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">16px</span></span><br><span class="line">    <span class="attr">h1:</span> <span class="number">1.</span><span class="string">5rem</span> <span class="comment"># 不推荐用在文章中</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="number">1.</span><span class="string">5rem</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="number">1.</span><span class="string">25rem</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="number">1.</span><span class="string">125rem</span></span><br><span class="line">    <span class="attr">h5:</span> <span class="string">1rem</span></span><br><span class="line">    <span class="attr">h6:</span> <span class="string">1rem</span></span><br><span class="line">    <span class="attr">list:</span> <span class="string">.9375rem</span></span><br><span class="line">    <span class="attr">meta:</span> <span class="string">.875rem</span></span><br><span class="line">    <span class="attr">code:</span> <span class="string">.875rem</span></span><br><span class="line">    <span class="attr">footnote:</span> <span class="string">.78125rem</span></span><br><span class="line">  <span class="attr">fontfamily:</span></span><br><span class="line">    <span class="attr">logofont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Microsoft Yahei&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">bodyfont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Microsoft Yahei&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">codefont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/UbuntuMono-Regular.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure><h5 id="页脚">页脚</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_footer:</span></span><br><span class="line">  <span class="comment"># layout of footer: [aplayer, social, license, info, copyright]</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">copyright</span>]</span><br><span class="line">  <span class="comment"># site copyright</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">&#x27;[Copyright © 2020 Schenk](https://github.com/Schenk75/Schenk75.github.io)&#x27;</span></span><br><span class="line">  <span class="comment"># You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;)</span></span><br><span class="line">  <span class="attr">br:</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="文章布局">文章布局</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">article:</span></span><br><span class="line">  <span class="comment"># 文章列表页面的文章卡片布局方案</span></span><br><span class="line">  <span class="attr">preview:</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">landscape</span> <span class="comment"># landscape</span></span><br><span class="line">    <span class="comment"># pin icon for post</span></span><br><span class="line">    <span class="attr">pin_icon:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg</span></span><br><span class="line">    <span class="comment"># auto generate title if not exist</span></span><br><span class="line">    <span class="attr">auto_title:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># auto generate excerpt if not exist</span></span><br><span class="line">    <span class="attr">auto_excerpt:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># show split line or not</span></span><br><span class="line">    <span class="attr">line_style:</span> <span class="string">solid</span> <span class="comment"># hidden, solid, dashed, dotted</span></span><br><span class="line">    <span class="comment"># show author</span></span><br><span class="line">    <span class="attr">author:</span> <span class="literal">false</span> <span class="comment"># true, false</span></span><br><span class="line">    <span class="comment"># show readmore button</span></span><br><span class="line">    <span class="attr">readmore:</span> <span class="string">always</span> <span class="comment"># auto, always</span></span><br><span class="line">  <span class="comment"># 文章详情页面的文章卡片本体布局方案</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="comment"># 文章顶部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">top_meta:</span> [<span class="string">author</span>, <span class="string">category</span>, <span class="string">date</span>, <span class="string">wordcount</span>, <span class="string">counter</span>]</span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="comment"># 文章页脚组件</span></span><br><span class="line">    <span class="attr">footer_widget:</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 参考资料、相关资料等 (for layout: post/docs)</span></span><br><span class="line">      <span class="attr">references:</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">参考资料</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-quote-left</span></span><br><span class="line">        <span class="comment"># 在 front-matter 中:</span></span><br><span class="line">        <span class="comment">#   references:</span></span><br><span class="line">        <span class="comment">#     - title: 某篇文章</span></span><br><span class="line">        <span class="comment">#       url: https://</span></span><br><span class="line">        <span class="comment"># 即可显示此组件。</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 相关文章，需要安装插件 (for layout: post)</span></span><br><span class="line">      <span class="comment"># npm i hexo-related-popular-posts</span></span><br><span class="line">      <span class="attr">related_posts:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">相关文章</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bookmark</span></span><br><span class="line">        <span class="attr">max_count:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># 设为空则不使用文章头图</span></span><br><span class="line">        <span class="attr">placeholder_img:</span> <span class="string">data:image/png;base64,666</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 打赏组件 (for layout: post)</span></span><br><span class="line">      <span class="attr">donate:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">height:</span> <span class="string">128px</span></span><br><span class="line">        <span class="attr">images:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png</span></span><br><span class="line">    <span class="comment"># 文章底部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">bottom_meta:</span> [<span class="string">updated</span>, <span class="string">tags</span>]</span><br><span class="line">    <span class="comment"># meta library</span></span><br><span class="line">    <span class="attr">meta_library:</span></span><br><span class="line">      <span class="comment"># 默认文章作者（可在 front-matter 中覆盖）</span></span><br><span class="line">      <span class="attr">author:</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Schenk</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">      <span class="comment"># 文章创建日期</span></span><br><span class="line">      <span class="attr">date:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-calendar-alt</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;发布于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章更新日期</span></span><br><span class="line">      <span class="attr">updated:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-edit</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;更新于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章分类</span></span><br><span class="line">      <span class="attr">category:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="comment"># 文章浏览计数</span></span><br><span class="line">      <span class="attr">counter:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-eye</span></span><br><span class="line">        <span class="attr">unit:</span> <span class="string">&#x27;次浏览&#x27;</span></span><br><span class="line">      <span class="comment"># 文章字数和阅读时长</span></span><br><span class="line">      <span class="attr">wordcount:</span></span><br><span class="line">        <span class="attr">icon_wordcount:</span> <span class="string">fas</span> <span class="string">fa-keyboard</span></span><br><span class="line">        <span class="attr">icon_duration:</span> <span class="string">fas</span> <span class="string">fa-hourglass-half</span></span><br><span class="line">      <span class="comment"># 文章标签</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-hashtag</span></span><br></pre></td></tr></table></figure><h5 id="侧边栏">侧边栏</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 主页、分类、归档等独立页面</span></span><br><span class="line">  <span class="attr">for_page:</span> [<span class="string">blogger</span>, <span class="string">category</span>, <span class="string">tagcloud</span>, <span class="string">webinfo</span>]</span><br><span class="line">  <span class="comment"># layout: docs/post 这类文章页面</span></span><br><span class="line">  <span class="attr">for_post:</span> [<span class="string">toc</span>]</span><br><span class="line">  <span class="comment"># 侧边栏组件库</span></span><br><span class="line">  <span class="attr">widget_library:</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># blogger info widget</span></span><br><span class="line">    <span class="attr">blogger:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">blogger</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg</span></span><br><span class="line">      <span class="attr">shape:</span> <span class="string">circle</span> <span class="comment"># circle, rectangle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/about/</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">Schenk</span></span><br><span class="line">      <span class="attr">subtitle:</span></span><br><span class="line">      <span class="attr">jinrishici:</span> <span class="literal">false</span> <span class="comment"># Poetry Today. You can set a string, and it will be displayed when loading fails.</span></span><br><span class="line">      <span class="attr">social:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/github-icon.svg</span></span><br><span class="line">          <span class="attr">size:</span> <span class="string">30px</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://github.com/Schenk75</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/struts.svg</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/logos/WCAlogo.svg</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://cubingchina.com/results/person/2018SHEN04</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># toc widget (valid only in articles)</span></span><br><span class="line">    <span class="attr">toc:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">本文目录</span></span><br><span class="line">      <span class="attr">list_number:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">min_depth:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">max_depth:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># category widget</span></span><br><span class="line">    <span class="attr">category:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">category</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># tagcloud widget</span></span><br><span class="line">    <span class="attr">tagcloud:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">tagcloud</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">热门标签</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">      <span class="attr">min_font:</span> <span class="number">14</span></span><br><span class="line">      <span class="attr">max_font:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">start_color:</span> <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      <span class="attr">end_color:</span> <span class="string">&#x27;#555&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># qrcode widget</span></span><br><span class="line">    <span class="attr">donate:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">qrcode</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">64px</span>  <span class="comment"># Automatic height if not set</span></span><br><span class="line">      <span class="attr">images:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># webinfo widget</span></span><br><span class="line">    <span class="attr">webinfo:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">webinfo</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>]</span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-award</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">站点信息</span></span><br><span class="line">      <span class="attr">type:</span></span><br><span class="line">        <span class="attr">article:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;文章数目：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;篇&#x27;</span></span><br><span class="line">        <span class="attr">runtime:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">data:</span> <span class="string">&#x27;2020/11/01&#x27;</span>    <span class="comment"># 填写建站日期</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;已运行时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;天&#x27;</span></span><br><span class="line">        <span class="attr">wordcount:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;本站总字数：&#x27;</span>   <span class="comment"># 需要启用 wordcount</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;字&#x27;</span></span><br><span class="line">        <span class="attr">visitcounter:</span></span><br><span class="line">          <span class="attr">service:</span> <span class="string">busuanzi</span>  <span class="comment"># busuanzi, leancloud</span></span><br><span class="line">          <span class="attr">siteuv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站访客数：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;人&#x27;</span></span><br><span class="line">          <span class="attr">sitepv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站总访问量：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;次&#x27;</span></span><br><span class="line">        <span class="attr">lastupd:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">friendlyShow:</span> <span class="literal">true</span>    <span class="comment"># 更友好的时间显示</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;最后活动时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;日&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="统计工具">统计工具</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">analytics:</span></span><br><span class="line">  <span class="attr">busuanzi:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/tools/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure><h5 id="关闭评论">关闭评论</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&lt;i</span> <span class="string">class=&#x27;fas</span> <span class="string">fa-comments&#x27;&gt;&lt;/i&gt;</span> <span class="string">评论</span></span><br><span class="line">  <span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="comment"># valine, minivaline, disqus, gitalk, vssue, livere, isso, hashover</span></span><br></pre></td></tr></table></figure><h5 id="插件">插件</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="comment">######## Plugins to optimize the experience:</span></span><br><span class="line">  <span class="comment"># Codeblock Copy Button</span></span><br><span class="line">  <span class="attr">clipboard:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">######## Plugins for SEO:</span></span><br><span class="line">  <span class="comment"># npm i hexo-wordcount</span></span><br><span class="line">  <span class="attr">wordcount:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="页面布局模板">页面布局模板</h4><p><a href="https://volantis.js.org/page-settings/layout/">参考链接</a></p><h4 id="front-matter设置">front-matter设置</h4><p><a href="https://volantis.js.org/page-settings/front-matter/">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Instruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker - Learn</title>
      <link href="2020/10/24/lookup/docker-notes/"/>
      <url>2020/10/24/lookup/docker-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="底层原理">底层原理</h2><p><strong>Docker是怎么工作的？</strong></p><p>Docker是一个C-S结构的系统，Docker的守护进程运行在服务主机上，通过Socket从客户端访问。</p><p>DockerServer接收到DockerClient的指令就会执行这个命令。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120921063.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120921063.png" srcset="data:image/png;base64,666" alt="image-20201013120921063"></p><p><strong>Docker为什么比VM快？</strong></p><ol><li>Docker有着比虚拟机更少的抽象层</li><li>Docker利用的是宿主机的内核，VM需要有Guest OS。所以新建一个容器的时候，docker不需要像VM一样重新加载一个操作系统内核，避免引导</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120834703.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120834703.png" srcset="data:image/png;base64,666" alt="image-20201013120834703"></p><h2 id="Docker常用命令">Docker常用命令</h2><h3 id="docker的默认工作路径">docker的默认工作路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker</span><br></pre></td></tr></table></figure><h3 id="帮助命令">帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version# 显示docker的版本信息</span><br><span class="line">docker info# 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker &lt;命令&gt; --help   # 查看帮助命令</span><br></pre></td></tr></table></figure><h3 id="镜像命令">镜像命令</h3><p><strong>docker images</strong> 查看所有本地的主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        9 months ago        13.3kB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释</span></span><br><span class="line">REPOSITORY镜像的仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的ID</span><br><span class="line">CREATED镜像的创建时间</span><br><span class="line">SIZE 镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令可选项</span></span><br><span class="line">-a, --all列出所有镜像</span><br><span class="line">-q, --quiet只显示镜像的id</span><br></pre></td></tr></table></figure><p><strong>docker search <image></strong> 搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search mysql</span><br><span class="line">NAME       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql      MySQL is a widely used, open-source relation…   10046     [OK]                </span><br><span class="line">mariadb    MariaDB is a community-developed fork of MyS…   3680      [OK]                </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项，通过收藏数过滤</span></span><br><span class="line">--filter=STAR=3000搜索出来的镜像是STARS大于3000的</span><br></pre></td></tr></table></figure><p><strong>docker pull <image>[:tag]</strong> 下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest# 如果不写tag，默认是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Pull complete # 分层下载，docker镜像的核心 联合文件系统</span><br><span class="line">f3cebc0b4691: Pull complete </span><br><span class="line">1862755a0b37: Pull complete </span><br><span class="line">489b44f3dbb4: Pull complete </span><br><span class="line">690874f836db: Pull complete </span><br><span class="line">baa8be383ffb: Pull complete </span><br><span class="line">55356608b4ac: Pull complete </span><br><span class="line">dd35ceccb6eb: Pull complete </span><br><span class="line">429b35712b19: Pull complete </span><br><span class="line">162d8291095c: Pull complete </span><br><span class="line">5e500ef7181b: Pull complete </span><br><span class="line">af7528e958b6: Pull complete </span><br><span class="line">Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest# 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载指定版本，共用的层会复用，不用重复下载</span></span><br><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Already exists </span><br><span class="line">f3cebc0b4691: Already exists </span><br><span class="line">1862755a0b37: Already exists </span><br><span class="line">489b44f3dbb4: Already exists </span><br><span class="line">690874f836db: Already exists </span><br><span class="line">baa8be383ffb: Already exists </span><br><span class="line">55356608b4ac: Already exists </span><br><span class="line">277d8f888368: Pull complete </span><br><span class="line">21f2da6feb67: Pull complete </span><br><span class="line">2c98f818bcb9: Pull complete </span><br><span class="line">031b0a770162: Pull complete </span><br><span class="line">Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>docker rmi</strong> 删除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;镜像id&gt; [&lt;镜像id&gt; &lt;镜像id&gt;]# 删除指定的镜像</span><br><span class="line">docker rmi -f $(docker images -aq)# 删除所有镜像</span><br></pre></td></tr></table></figure><h3 id="容器命令">容器命令</h3><p>**注：**有了镜像才可以创建容器，以centos镜像为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>docker run [可选参数] <image></strong>  新建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name=&quot;&lt;Name&gt;&quot;容器名字，自定义，用来区分容器</span><br><span class="line">-d 后台方式运行</span><br><span class="line">-it使用交互方式运行，进入容器查看内容</span><br><span class="line">-p指定容器的端口，配置端口转发</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 主机端口:容器端口（常用）</span><br><span class="line">-p 容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并进入容器</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器并关闭容器</span></span><br><span class="line">[root@bebbdced119e /]# exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器但不关闭容器</span></span><br><span class="line">Ctrl + p + q</span><br></pre></td></tr></table></figure><p><strong>docker ps [可选参数]</strong> 列出运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">-a列出所有运行过的容器</span><br><span class="line">-n=&lt;n&gt;列出最近创建的n个容器</span><br><span class="line">-q只显示容器编号</span><br></pre></td></tr></table></figure><p>**docker rm 删除容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器id&gt;删除指定容器，不能删除正在运行的容器，若要强制删除加参数-f</span><br><span class="line">docker rm -f $(docker ps -aq)  删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  删除所有的容器</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;容器id&gt;启动容器</span><br><span class="line">docker restart &lt;容器id&gt;重启容器</span><br><span class="line">docker stop &lt;容器id&gt;停止容器</span><br><span class="line">docker kill &lt;容器id&gt;强制停止容器</span><br></pre></td></tr></table></figure><h3 id="常用其他命令">常用其他命令</h3><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题：docker ps发现centos停止了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -ft &lt;容器id&gt;# 查看所有日志</span><br><span class="line">docker logs -ft --tail &lt;n&gt; &lt;容器id&gt;# 查看最新的n条日志</span><br></pre></td></tr></table></figure><p>**查看容器中的进程信息 **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器id&gt;</span><br></pre></td></tr></table></figure><p><strong>查看容器的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器id&gt;</span><br></pre></td></tr></table></figure><p><strong>进入正在后台运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法1</span></span><br><span class="line">docker exec -it &lt;容器id&gt; &lt;bashshell&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法2</span></span><br><span class="line">docker attach &lt;容器id&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><p><strong>从容器内拷贝文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;容器id&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Lookup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
