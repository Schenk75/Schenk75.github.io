<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust错误处理</title>
      <link href="2020/12/04/rust-error/"/>
      <url>2020/12/04/rust-error/</url>
      
        <content type="html"><![CDATA[<ul><li><p>对于 <code>Result</code>、<code>Option</code>等类型，如果使用 <code>unwrap</code>、<code>expect</code>等方法，会直接导致panic</p></li><li><p>对于 <code>Result</code> 类型，如果遇到错误只需要返回 <code>None</code>，那么可以使用如下简单的语法来替代 <code>match</code> :</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_var = something_that_returns_result().ok()?;</span><br></pre></td></tr></table></figure><p>其中，<code>Result::ok()</code> 函数将 <code>Result</code> 转换为 <code>Option</code>：</p><ul><li>对于 <code>Ok(val)</code>，返回 <code>Some(val)</code>；</li><li>对于 <code>Err(some_error)</code>，返回 <code>None</code></li></ul><p><code>?</code> 提取 <code>Option</code> 中的内容，如果为 <code>None</code>，则返回 <code>None</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode快捷键</title>
      <link href="2020/12/03/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/12/03/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Ctrl+J</code> : 隐藏(显示)底下的控制台/终端面板</p><p><code>Ctrl+Shift+P</code> : 调出搜索设置</p><p><code>Ctrl+Shift+C</code> : 在当前目录调出外部终端</p><p><code>Home</code> ：光标移动到行首</p><p><code>End</code> ：光标移动到行尾</p>]]></content>
      
      
      <categories>
          
          <category> Useful Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Blocking waiting for file lock on package cache</title>
      <link href="2020/12/03/rust-cargo-block/"/>
      <url>2020/12/03/rust-cargo-block/</url>
      
        <content type="html"><![CDATA[<p>删除 <code>home/.cargo/.package-cache</code> 文件再重新编译即可</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> cargo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-SGX Analysis</title>
      <link href="2020/11/29/translation-sgx-analysis/"/>
      <url>2020/11/29/translation-sgx-analysis/</url>
      
        <content type="html"><![CDATA[<p><strong>放在博客上链接不能跳转指定标题，暂时没有办法解决</strong></p><h2 id="6-1-SGX实现概述">6.1 SGX实现概述</h2><p>SGX设计实现的一个未被记录和忽视的成就是，在英特尔处理器上实现它对芯片的硬件设计有非常低的影响。SGX对处理器执行核心(§2.9.4)的修改要么非常小，要么根本不存在。CPU的非核心(§2.9.3，§2.11.3)接收一个新的模块，内存加密引擎，它看起来是相当独立的。</p><p>SGX的大部分实现都归属于处理器的微码(§2.14)，它支持比芯片电路高得多的开发速度。</p><!--### 6.1.1 执行内核修改### 6.1.2 非内核修改### 6.1.3 微代码修改## 6.2 SGX内存访问保护![image-20201128212608690](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212608690.png)### 6.2.1 功能描述<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212642564.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212642564.png" srcset="data:image/png;base64,666" alt="image-20201128212642564" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212658357.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212658357.png" srcset="data:image/png;base64,666" alt="image-20201128212658357" style="zoom:80%;" />![image-20201128212723441](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128212723441.png)### 6.2.2 EPCM条目表示### 6.2.3 PMH硬件修改## 6.3 SGX安全检查正确性### 6.3.1 顶层不变的分解### 6.3.2 EPCM条目反映Enclave作者设计### 6.3.3 ELRANGE的TLB条目反映EPCM内容### 6.3.4 修改时EPCM条目不在TLB中## 6.4 Tracking TLB Flushes<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214234965.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214234965.png" srcset="data:image/png;base64,666" alt="image-20201128214234965" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214258057.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214258057.png" srcset="data:image/png;base64,666" alt="image-20201128214258057" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214400485.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214400485.png" srcset="data:image/png;base64,666" alt="image-20201128214400485" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214422480.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214422480.png" srcset="data:image/png;base64,666" alt="image-20201128214422480" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214447889.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214447889.png" srcset="data:image/png;base64,666" alt="image-20201128214447889" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214516682.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214516682.png" srcset="data:image/png;base64,666" alt="image-20201128214516682" style="zoom:80%;" />## 6.5 Enclave签名验证<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214627879.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214627879.png" srcset="data:image/png;base64,666" alt="image-20201128214627879" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214645117.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214645117.png" srcset="data:image/png;base64,666" alt="image-20201128214645117" style="zoom:80%;" />### 6.5.1 步骤1-4的分析<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214710848.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214710848.png" srcset="data:image/png;base64,666" alt="image-20201128214710848" style="zoom:67%;" />### 6.5.2 步骤5-8的分析<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214912326.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214912326.png" srcset="data:image/png;base64,666" alt="image-20201128214912326" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214943124.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128214943124.png" srcset="data:image/png;base64,666" alt="image-20201128214943124" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128215016094.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128215016094.png" srcset="data:image/png;base64,666" alt="image-20201128215016094" style="zoom:80%;" />### 6.5.3 实现需求## 6.6 SGX安全属性### 6.6.1 概述### 6.6.2 物理攻击### 6.6.3 特权软件攻击### 6.6.4 内存映射攻击### 6.6.5 对外设的软件攻击### 6.6.6 缓存时间攻击![image-20201128215556589](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-analysis/image-20201128215556589.png)### 6.6.7 软件侧信道攻击和SGX-->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
          <category> SGX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-SGX Programming Model</title>
      <link href="2020/11/28/translation-sgx-programming-model/"/>
      <url>2020/11/28/translation-sgx-programming-model/</url>
      
        <content type="html"><![CDATA[<p><strong>放在博客上链接不能跳转指定标题，暂时没有办法解决</strong></p><p>SGX的核心概念是enclave，一个受保护的环境，其中包含与安全敏感计算相关的代码和数据。</p><p>启用sgx的处理器通过将每个enclave的环境与enclave外部的不受信任的软件隔离，并实现允许远程方对运行在enclave内部的软件进行身份验证的软件认证方案，从而提供可信的计算。SGX的隔离机制旨在保护在enclave内执行的计算的机密性和完整性，防止来自同一台计算机上的恶意软件的攻击，以及一小部分物理攻击。</p><h2 id="5-1-SGX物理内存组织">5.1 SGX物理内存组织</h2><p>Enclave的代码和数据存储在 <em>Processor Reserved Memory</em> (PRM)中，PRM是DRAM的一个子集，不能被其他软件(包括系统软件和SMM代码)直接访问。CPU的集成内存控制器也拒绝针对PRM的DMA传输，从而保护它不被其他外设访问。</p><p><strong>PRM是一个连续的内存范围</strong>，其边界使用一个基地址和一个掩码寄存器来决定，与可变内存类型范围具有相同的语义。因此，PRM的大小必须是2的整数次幂，并且它的起始地址必须对齐到同样的2次幂。由于这些限制，检查一个地址是否属于PRM可以在硬件上很容易地完成。</p><h3 id="5-1-1-Enclave页面缓存-EPC">5.1.1 Enclave页面缓存 (EPC)</h3><p>Enclave的内容和相关的数据结构存储在Enclave页面缓存(EPC)中，EPC是PRM的一个子集，PRM是DRAM的一个连续范围，<strong>不能被系统软件或外设访问</strong>。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127221918953.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127221918953.png" srcset="data:image/png;base64,666" alt="image-20201127221918953"></p><p>SGX设计支持同时在一个系统上有多个enclaves，这在多进程环境中是必需的。这是通过将EPC拆分为4 KB的页面来实现的，这些页面可以分配给不同的enclaves。EPC使用与体系结构的地址转换特性相同的页面大小。</p><p>EPC由管理计算机其余物理内存的系统软件管理。系统软件(可以是管理程序或操作系统内核)使用SGX指令将未使用的页面分配给enclaves，并释放之前分配的EPC页面。系统软件将向应用程序软件公开enclave创建和管理服务。</p><p>非enclave软件不能直接访问EPC，因为它包含在PRM中。这一限制在SGX的enclave隔离保证中发挥了关键作用，但当系统软件需要将初始代码和数据加载到新创建的enclave中时，就会造成障碍。SGX通过<strong>将分配EPC页面的指令同时也用作初始化页面的指令</strong>来解决这个问题。大多数EPC页是通过从非PRM内存页复制数据来初始化的。</p><h3 id="5-1-2-Enclave页面缓存映射表-EPCM">5.1.2 Enclave页面缓存映射表 (EPCM)</h3><p>SGX设计期望系统软件将EPC页面分配给enclave。然而，由于系统软件不受信任，SGX处理器会检查系统软件分配的正确性，并拒绝执行任何危及SGX安全保证的行为。例如，如果系统软件试图将相同的EPC页面分配给两个enclaves，则执行分配的SGX指令将失败。</p><p>为了执行安全检查，SGX在 <em>Enclave Page Cache Map</em> (EPCM)中记录一些关于系统软件对每个EPC页面的分配决策的信息。EPCM是一个数组，每个EPC页面对应一个条目，因此计算页面的EPCM入口地址只需要逐位移位操作和加操作。</p><p>EPCM的内容仅用于SGX的安全检查。在正常操作下，EPCM不会产生任何软件可见的行为，因而enclave作者和系统软件开发人员基本上可以忽略它。因此，SDM (<em>Intel’s Software Developer Manual</em>) 只在非常高的级别上描述EPCM，列出其中包含的信息，并指出EPCM是“受信任的内存”，而没有公开EPCM使用的存储介质或内存布局。</p><p>EPCM使用下表中的字段来跟踪每个EPC页面的所有权。我们将EPCM的完整讨论推迟到后面的部分，因为它的内容与SGX的所有特征紧密结合，这将在接下来的几节中进行描述。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127223653632.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201127223653632.png" srcset="data:image/png;base64,666" alt="image-20201127223653632" style="zoom:80%;" /><p>分配EPC页的SGX指令将相应EPCM条目的VALID位设置为1，并<strong>拒绝对已经设置了VALID位的EPC页进行操作</strong>。</p><p>分配EPC页的指令还决定了该页的预期用途，该用途记录在相应EPCM条目的 <em>page type</em> (PT)字段中。存储enclave代码和数据的页面被认为具有常规类型 <code>PT_REG</code> 。专用于存储SGX支持数据结构的页面被标记为特殊类型。例如，<code>PT_SECS</code> 类型标识保存SGX Enclave控制结构的页面，这将在下一节中进行描述。其他EPC页面类型将在以后的章节中描述。</p><p>最后，页面的EPCM条目还标识拥有EPC页面的enclave，此字段防止一个enclave访问另一个enclave的私有信息。由于EPCM为每个EPC页面标识一个具有所有权的enclave，因此enclave不可能使用EPC页面通过共享内存进行通信。幸运的是，enclaves可以共享不可信的非EPC内存，这将在<a href="#5.2.3-SGX-Enclaves%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">§5.2.3</a>中讨论。</p><h3 id="5-1-3-SGX-Enclave控制结构-SECS">5.1.3 SGX Enclave控制结构 (SECS)</h3><p>SGX将每个Enclave元数据存储在与每个Enclave关联的 <em>SGX Enclave Control Structure</em> (SECS)中。<strong>每个SECS存储在专用的EPC页面中，页面类型为 <code>PT_SECS</code></strong>。</p><p>Enclave的身份几乎等同于它的SECS。启用enclave的第一步是分配EPC页面作为enclave的SECS，销毁enclave的最后一步是释放保存其SECS的页面。标识拥有EPC页面的enclave的EPCM入口字段指向enclave的SECS。当调用SGX指令时，系统软件使用SECS的虚拟地址来识别enclave。</p><p>所有SGX指令都以虚拟地址作为输入。由于SGX指令使用SECS地址来标识enclave，系统软件必须在其页表中创建指向其管理的enclave的SECS的条目。但是，系统软件不能访问任何SECS页面，因为这些页面存储在PRM中。<strong>SECS页面不会映射到它们的enclave的虚拟地址空间中，并且启用SGX的处理器显式地阻止enclave代码访问SECS页面</strong>。</p><p>这个看似随意的限制是为了使SGX实现能够在SECS内存储敏感信息，并且能够假定没有潜在的恶意软件能够访问该信息。例如，SDM声明<strong>每个enclave的度量都存储在SECS中</strong>。如果软件能够修改enclave的测量，SGX的软件认证方案将不能提供安全保证。</p><h2 id="5-2-SGX-Enclave的内存布局">5.2 SGX Enclave的内存布局</h2><p>SGX的设计目的是尽量减少[转换应用程序代码以利用enclave的优势]所需要的工作。历史表明，这是一个明智的决定，因为在英特尔架构的持续主导地位中，一个很大的因素是它保持向后兼容性的能力。为此，SGX  enclave在概念上与领先的软件模块化结构，动态加载库类似。动态加载库在Unix上打包为.so文件，在Windows上打包为.dll文件。</p><p>为简单起见，我们描述enclave和非enclave软件之间的交互时假设每个enclave都由一个应用程序进程使用，我们将其称为enclave的主进程。但是，我们注意到SGX的设计并没有明确地禁止多个应用程序进程共享一个enclave。</p><h3 id="5-2-1-Enclave线性地址范围-ELRANGE">5.2.1 Enclave线性地址范围 (ELRANGE)</h3><p>每个enclave在其虚拟地址空间中指定一个区域，称为 <em>Enclave Linear Address Range</em> (ELRANGE)，该区域用于映射存储在enclave的EPC页面中的代码和敏感数据。ELRANGE之外的虚拟地址空间用于访问主进程的其他内存，内存映射使用系统软件管理的页表建立。如下图所示:</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128133153701.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128133153701.png" srcset="data:image/png;base64,666" alt="image-20201128133153701" style="zoom:100%;" /><p>SGX的设计保证了enclave在ELRANGE内部的内存访问服从虚拟内存抽象，而在ELRANGE外部的内存访问没有得到保证。因此，<strong>enclave必须将其所有代码和私有数据存储在ELRANGE内，并且必须将ELRANGE外的内存视为对外部世界的不可信接口</strong>。</p><p>ELRANGE中的“线性”一词指的是64位Intel架构中残余分割特性产生的线性地址。在大多数情况下，“linear”可以看作是“virtual”的同义词。</p><p>ELRANGE在enclave的SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)中使用一个基地址(BASEADDR字段)和一个大小(SIZE)来指定。ELRANGE必须满足与可变内存类型范围和PRM范围(<a href="#5.1-SGX%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87">§5.1</a>)相同的约束条件，即<strong>大小必须是2的幂，并且基地址必须与大小对齐</strong>。有了这些限制，SGX实现就可以容易地检查一个地址是否属于enclave的ELRANGE，无论是在硬件上还是在软件上。</p><p>非enclave软件不能访问PRM内存。<strong>在PRM内部的内存访问将导致一个中断</strong>，该中断在体系结构级别上未定义，在当前处理器上，中断的写将被忽略，中断的读将返回一个所有bit都设置为1的值。在上面描述的场景中，这就发挥了作用，在该场景中，enclave作为动态加载的库加载到主应用程序进程中。该系统软件将ELRANGE中的enclave代码和数据映射到EPC页面。如果应用程序软件试图访问ELRANGE内的内存，它将经历中断原语。当前原语不会导致应用程序崩溃(例如，由于页面错误)，但也保证了主应用程序不能篡改enclave或读取其私有信息。</p><h3 id="5-2-2-SGX-Enclave属性">5.2.2 SGX Enclave属性</h3><p>Enclave的执行环境很大程度上受到enclave  SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)中ATTRIBUTES字段的值的影响。此工作的其余部分会将ATTRIBUTES字段的子字段(如下表所示)称为enclave属性。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128135622106.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128135622106.png" srcset="data:image/png;base64,666" alt="image-20201128135622106" style="zoom:80%;" /><p>从安全性的角度来看，最重要的属性是 DEBUG 标志。设置此标志后，将启用SGX的调试特性用于此enclave。这些调试特性包括<strong>读取和修改大部分enclave内存的能力</strong>。因此，调试应该只在开发环境中设置，因为这会导致enclave失去SGX的所有安全性保证。</p><p>SGX保证enclave代码将始终在XCR0寄存器设置为 <em>extended features request mask</em> (XFRM) 所指示的值的情况下运行。Enclave作者希望使用XFRM指定用于生成Enclave代码的编译器所支持的一组架构扩展。<strong>显式地指定XFRM允许Intel设计新的架构扩展来改变现有指令的语义</strong>，比如内存保护扩展(MPX)，而不必担心在开发时没有注意到新特性的enclave代码的安全影响。</p><p><strong>对于使用64位Intel架构的enclave,  MODE64BIT标志设置为true</strong>。从安全的角度来看，这个标志甚至不应该存在，因为支持次要架构会给SGX实现增加不必要的复杂性，并增加安全漏洞潜入的可能性。32位架构支持很可能是由于英特尔提供广泛向后兼容性的策略，到目前为止，这一策略取得了相当好的效果。清除MODE64BIT标志位可能会造成SGX漏洞，有待研究人员研究。</p><p>最后，<strong>在创建enclave的SECS时，INIT标志总是为false</strong>。这个标志在enclave生命周期的某个时刻被设置为true，这将在<a href="#5.3-SGX-Enclave%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§5.3</a>中进行总结。</p><h3 id="5-2-3-SGX-Enclaves地址转换">5.2.3 SGX Enclaves地址转换</h3><p>在SGX下，操作系统和管理程序仍然完全控制页表和EPT，每个enclave的代码使用和其主应用程序相同的地址转换过程和页表。这将使向现有系统软件添加SGX支持所需的更改量最小化。同时，让不受信任的系统软件管理页表会使SGX遭受§3.7所述的地址转换攻击。正如未来章节将揭示的，SGX设计的复杂性很大程度上可以归因于防止这些攻击的需要。</p><p>SGX的主动内存映射攻击防御机制围绕着确保每个EPC页面只能映射到一个特定的虚拟地址。<strong>在分配EPC页面时，它的预期虚拟地址记录在该页面的EPCM条目的ADDRESS字段中</strong>。</p><p>当地址转换的结果是EPC页面的物理地址时，CPU保证提供给地址转换过程的虚拟地址与页面EPCM条目中记录的预期虚拟地址相匹配。</p><p>通过确保每个EPC页面的访问权限始终与enclave作者的意图相匹配，SGX还可以防止一些被动内存映射攻击和故障注入攻击。<strong>每个EPC页面的访问权限是在分配页面时指定的，并记录在页面EPCM条目中的可读®、可写(W)和可执行(X)字段中</strong>，如下表所示:</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128143209413.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128143209413.png" srcset="data:image/png;base64,666" alt="image-20201128143209413" style="zoom:80%;" /><p>当一个地址转换解析为一个EPC页面时，相应的EPCM条目的字段将覆盖页表中指定的访问权限属性。例如，EPCM条目中的W字段覆盖可写(W)属性，而X字段覆盖禁用执行(XD)属性。</p><p>因此，<strong>enclave作者必须在包含enclave的同时包含内存布局信息，这样，加载enclave的系统软件将知道每个enclave页面的预期虚拟内存地址和访问权限</strong>。作为回报，SGX设计向enclave作者保证，管理页表和EPT的系统软件将不能以与作者预期不一致的方式设置enclave的虚拟地址空间。</p><p>.so和.dll文件格式是SGX打算使用的enclave运载工具，它们已经规定了指定软件模块要使用的虚拟地址，以及模块的每个内存区域所需的访问权限。</p><p>最后，<strong>启用SGX的CPU将确保ELRANGE内的虚拟内存(<a href="#5.2.1-Enclave%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4-(ELRANGE)">§5.2.1</a>)映射到EPC页面</strong>。这可以防止系统软件执行地址转换攻击，即将enclave的整个虚拟地址空间映射到PRM之外的DRAM页面，而PRM不会触发上述任何检查，系统软件可以直接访问这些页面。</p><h3 id="5-2-4-线程控制结构-TCS">5.2.4 线程控制结构 (TCS)</h3><p>SGX设计完全采用多核处理器。<strong>多个逻辑处理器可以通过不同的线程同时并发地执行同一个enclave的代码</strong>。</p><p>SGX实现为执行enclave代码的每个逻辑处理器使用一个 <em>Thread Control Structure</em> (TCS)。因此，enclave的作者必须至少提供与enclave支持的最大并发线程数相同的TCS实例。</p><p><strong>每个TCS存储在专用的EPC页面中，其EPCM条目类型为 <code>PT_TCS</code></strong>。SDM描述了TCS中的前几个字段。这些字段被认为属于结构的体系结构部分，因此保证在所有支持SGX的处理器上具有相同的语义。</p><p><strong>保存TCS的EPC页面的内容不能直接访问，甚至不能由拥有TCS的enclave的代码访问</strong>。此限制类似于对访问持有SECS实例的EPC页面的限制。但是，<strong>TCS中的体系结构字段可以通过enclave调试指令读取</strong>。TCS中的体系结构字段列出了逻辑处理器在执行非enclave代码和enclave代码之间转换时执行的上下文切换。例如，OENTRY字段指定当TCS用于开始执行enclave代码时加载在 指令指针(RIP) 中的值，因此enclave作者可以严格控制enclave的主程序可用的入口点。此外，OFSBASGX和OFSBASGX字段指定了加载在FS和GS段寄存器中的基地址，这通常指向 线程本地存储(TLS)。</p><h3 id="5-2-5-状态保存区域-SSA">5.2.5 状态保存区域 (SSA)</h3><p>当处理器在enclave中执行代码时遇到硬件异常，比如中断时，它会执行特权级别切换并调用系统软件提供的硬件异常处理程序。然而，在执行异常处理程序之前，处理器需要一个安全的区域来存储enclave代码的执行上下文，这样执行上下文中的信息就不会泄露给不受信任的系统软件。</p><p>在SGX设计中，<strong>在处理硬件异常时用于存储enclave线程的执行上下文的区域</strong>称为 <em>State Save Area</em> (SSA)，如下图所示（enclave虚拟地址空间的一种可能的布局。每个enclave有一个SECS，每个支持的并发线程有一个TCS。每个TCS指向一个SSA序列，并为RIP以及FS和GS的基址指定初始值）。<strong>每个TCS引用一个连续的SSA序列</strong>。SSA数组偏移量(OSSA)字段指定了第一个SSA在enclave的虚拟地址空间中的位置。SSA数量(NSSA)字段表示可用的SSAs的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128145659924.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128145659924.png" srcset="data:image/png;base64,666" alt="image-20201128145659924"></p><p>每个SSA从EPC页面的开头开始，并<strong>使用在enclave的SECS的SSAFRAMESIZE字段中指定的EPC页面数量</strong>。通过减少需要处理的特殊情况的数量，这些对齐和大小限制很可能简化了SGX的实现。</p><p>Enclave线程的执行上下文由通用寄存器(GPRs)和XSAVE指令的结果组成。因此，执行上下文的大小取决于XSAVE使用的 请求特性位图(RFBM)。enclave中的所有代码都使用相同的RFBM，它是在XFRM  enclave属性(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)中声明的。为每个SSA保留的EPC页面数量(在SSAFRAMESIZE中指定)必须足够大，以适合XSAVE输出的XFRM指定的特性位图。</p><p><strong>SSA存储在常规EPC页面中，其EPCM页面类型为 <code>PT_REG</code></strong>。因此，<strong>enclave软件可以访问SSA内容</strong>。SSA布局是体系结构的，并且完全记录在SDM中。这为主机应用程序在发生硬件异常后调用enclave异常处理程序并对SSA中的信息进行操作提供了可能性。</p><h2 id="5-3-SGX-Enclave的生命周期">5.3 SGX Enclave的生命周期</h2><p>Enclave的生命周期与资源管理密切相关，特别是EPC页面的分配。因此，在不同生命周期状态之间转换的指令只能由系统软件执行。系统软件将公开以下描述的SGX指令，作为enclave加载和销毁的服务。</p><p>下面的小节描述了enclave生命周期中的主要步骤，如下图所示:</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128152622170.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128152622170.png" srcset="data:image/png;base64,666" alt="image-20201128152622170"  /><h3 id="5-3-1-创建">5.3.1 创建</h3><p>当系统软件发出 <code>ECREATE</code> 指令时，一个enclave就诞生了，该指令<strong>将一个空闲的EPC页面转换为用于新enclave的SECS</strong>(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)。</p><p><strong><code>ECREATE</code> 使用系统软件拥有的非EPC页面中的信息初始化新创建的SECS</strong>。这个页面指定SDM中定义的所有SECS字段的值，比如BASEADDR和SIZE，使用的是一种体系结构布局，未来的实现保证会保留这种布局。</p><p>虽然最初的SGX实现使用的实际SECS布局很可能与架构布局非常接近，但是未来的实现可以自由地改变这个布局，只要它们保持使用架构布局初始化SECS的能力。软件不能访问包含SECS的EPC页面，因此它不能依赖于SECS的内部布局。这是在虚拟机控制结构(VMCS，§2.8.3)中使用的更强的封装版本。</p><p><strong><code>ECREATE</code> 验证用于初始化SECS的信息，如果信息无效，则会导致页面错误(#PF，§2.8.2)或一般保护错误(#GP，§2.8.2)</strong>。例如，如果SIZE字段不是2的幂，<code>ECREATE</code>结果是#GP。这种验证，加上软件无法访问SECS这一事实，简化了其他SGX指令的实现，这可以假设SECS内部的信息是有效的。</p><p>最后，<strong><code>ECREATE</code>将enclave的INIT属性(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)初始化为false值。在INIT属性被设置为true之前，enclave的代码不能执行</strong>，在初始化阶段会将INIT设置为true，这将在<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>中描述。</p><h3 id="5-3-2-加载">5.3.2 加载</h3><p><code>ECREATE</code> 将新创建的SECS标记为未初始化。当enclave的SECS处于这种状态时，<strong>系统软件可以使用<code>EADD</code>指令将初始代码和数据加载到enclave中。EADD用于创建TCS页面(<a href="#5.2.4-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(TCS)">§5.2.4</a>)和常规页面。</strong></p><p><strong><code>EADD</code> 从<em>页面信息</em>(PAGEINFO)结构中读取其输入数据</strong>，如下图所示。该结构的内容仅用于与SGX实现通信，因此它完全是体系结构的，并在SDM中记录。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128164130332.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128164130332.png" srcset="data:image/png;base64,666" alt="image-20201128164130332"></p><p>目前，PAGEINFO结构包含的将要分配的EPC页面的虚拟地址(LINADDR)、非EPC页面的虚拟地址（其内容将被复制到新分配的EPC页面(SRCPGE)）、一个虚拟地址，解析为SECS的enclave的页面(SECS)以及与新分配的EPC页面相关联的EPCM条目的某些字段的值(SECINFO)。</p><p>PAGEINFO结构中的SECINFO字段实际上是一个虚拟内存地址，并指向一个<em>安全信息</em>(SECINFO)结构，其中一些结构如上图所示。<strong>SECINFO结构包含新分配的EPC页面的访问权限(R、W、X)及其EPCM页面类型(<code>PT_REG</code>或<code>PT_TCS</code>)</strong>。与PAGEINFO一样，SECINFO结构仅用于与SGX实现通信数据，因此它的内容也完全是体系结构的。但是，该结构的大部分64字节内容被保留以备将来使用。</p><p>PAGEINFO和SECINFO结构都是由调用<code>EADD</code>指令的系统软件准备的，因此必须<strong>包含在非EPC页面中</strong>。两个结构必须按照其大小对齐——<strong>PAGEINFO是32字节长，因此每个PAGEINFO实例必须是32字节对齐的，而SECINFO是64字节对齐的，因此每个SECINFO实例必须是64字节对齐的</strong>。对齐要求可能通过减少必须处理的特殊情况的数量来简化SGX实现。</p><p><strong><code>EADD</code>在修改新分配的EPC页面或其EPCM条目之前验证其输入</strong>。最重要的是，<strong>尝试将一个页面<code>EADD</code>到SECS处于初始化状态（INIT属性为true）的enclave将导致一个#GP</strong>。此外，<strong>尝试<code>EADD</code>已经分配的EPC页面(其EPCM条目中的VALID字段为1)将导致一个#PF</strong>。EADD还确保页面的虚拟地址位于enclave的ELRANGE内，并且<strong>SECINFO中的所有保留字段都被设置为零</strong>。</p><ul><li><strong><code>EADD</code> 指令将EPCM条目中的VALID字段置为1？</strong></li></ul><p>在加载enclave时，系统软件还将使用EEXTEND指令，该指令将<strong>更新在软件认证过程中使用的enclave度量值</strong>。软件认证在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中进行了讨论。</p><h3 id="5-3-3-初始化">5.3.3 初始化</h3><p>在将初始代码和数据页面加载到enclave后，<strong>系统软件必须使用<em>Launch enclave</em>(LE)来获取EINIT令牌结构</strong>，这是通过一个未文档化的过程实现的，将在<a href="#5.9.1-Enclave%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">§5.9.1</a>中详细描述。然后<strong>将令牌提供给<code>EINIT</code>指令，该指令将enclave的SECS标记为<em>initialized</em></strong>。</p><p>LE是由Intel提供的特权enclave，是使用由Intel以外的第三方编写的enclave的先决条件。LE是SGX的Enclave，因此必须使用本节中描述的进程来创建、加载和初始化它。然而，LE是用一个特殊的Intel密钥加密签名的(§3.1.3)，这个密钥被硬编码到SGX的实现中，这导致**<code>EINIT</code>在初始化LE时没有检查有效的EINIT令牌结构**。</p><p><strong>当<code>EINIT</code>成功完成时，它将enclave的INIT属性设置为true</strong>。这就为ring 3(§2.3)应用软件使用<a href="#5.4-SGX%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§5.4</a>中描述的SGX指令执行enclave的代码开辟了道路。另一方面，一旦INIT设置为true，就不能再在该enclave上调用<code>EADD</code>，因此<strong>在执行<code>EINIT</code>指令之前，系统软件必须加载构成enclave初始状态的所有页面</strong>。</p><h3 id="5-3-4-销毁">5.3.4 销毁</h3><p>Enclave完成了它要执行的计算之后，<strong>系统软件执行<code>EREMOVE</code>指令来释放enclave使用的EPC页面</strong>。</p><p><strong><code>EREMOVE</code>将EPC页面的EPCM条目的VALID字段设置为0，从而将该页面标记为可用</strong>。在释放页面之前，<code>EREMOVE</code>确保在拥有要删除的页面的enclave内部没有执行代码的逻辑处理器。</p><p>当保存SECS的EPC页面被释放时，enclave将被完全销毁。<strong>如果SECS页面被任何其他EPCM条目的ENCLAVESECS字段引用，<code>EREMOVE</code>将拒绝释放该页面</strong>，因此，<strong>只有在所有enclave页面都被释放之后，才能释放enclave的SECS页面</strong>。</p><h2 id="5-4-SGX线程的生命周期">5.4 SGX线程的生命周期</h2><p>在enclave被初始化(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)和被销毁(<a href="#5.3.4-%E9%94%80%E6%AF%81">§5.3.4</a>)这段时间内，任何将enclave的EPC页面映射到其虚拟地址空间的应用程序进程都可以执行enclave的代码。</p><p>当在enclave中执行代码时，逻辑处理器被称为处于enclave模式，它执行的代码可以<strong>访问属于当前执行的enclave的常规(<code>PT_REG</code>，<a href="#5.1.2-Enclave%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%98%A0%E5%B0%84%E8%A1%A8-(EPCM)">§5.1.2</a>)EPC页面</strong>。<strong>当逻辑进程处于enclave模式之外时，它会退回处理器保留内存范围(PRM, <a href="#5.1-SGX%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87">§5.1</a>)内的任何内存访问，包括EPC</strong>。</p><p><strong>每个执行enclave代码的逻辑处理器都使用一个线程控制结构</strong>(TCS，<a href="#5.2.4-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(TCS)">§5.2.4</a>)。当一个TCS被一个逻辑处理器使用时，它被认为是忙碌的，并且它不能被任何其他逻辑处理器使用。下图演示了主进程用于执行enclave代码的指令，以及它们与目标TCS的交互，这是具有两个状态保存区(SSAs)的SGX线程控制结构(TCS)的生命周期的各个阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128174512721.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128174512721.png" srcset="data:image/png;base64,666" alt="image-20201128174512721"></p><p>假设没有发生硬件异常，enclave的主进程使用<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>中描述的<code>EENTER</code>指令来执行enclave代码。当enclave代码完成它的任务时，它使用EEXIT指令(参见<a href="#5.4.2-%E5%90%8C%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.2</a>)将执行控制权返回给调用enclave的主进程。</p><p>如果在逻辑处理器处于enclave模式时发生硬件异常，则在调用系统软件的异常处理程序之前，使用<em>异步enclave退出</em>(AEX)将处理器从enclave模式中取出(<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)。在系统软件的处理程序被调用后，enclave的主进程可以使用<a href="#5.4.4-%E4%BB%8E%E5%BC%82%E6%AD%A5%E9%80%80%E5%87%BA%E6%81%A2%E5%A4%8D">§5.4.4</a>中描述的<code>ERESUME</code>指令重新输入enclave并恢复它退出之前正在执行的计算。</p><h3 id="5-4-1-同步Enclave进入">5.4.1 同步Enclave进入</h3><p>在较高的级别上，<code>EENTER</code>执行受控跳转到enclave代码，同时执行SGX的安全保证所需要的处理器配置。遍历所有配置步骤是一项冗长乏味的工作，但这是理解SGX使用的所有数据结构如何协同工作的必要先决条件。由于这个原因，<code>EENTER</code>和它的兄弟指令描述的比其他的SGX指令更详细。</p><p>下图所示的<code>EENTER</code>只能由运行在Ring 3(§2.3)的非特权应用程序软件执行，<strong>如果由系统软件执行，则会导致未定义指令(#UD)故障</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128175647644.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128175647644.png" srcset="data:image/png;base64,666" alt="image-20201128175647644"></p><p><code>EENTER</code>将逻辑处理器切换到enclave模式，但<strong>不执行特权级别切换</strong>。因此，<strong>enclave代码总是在Ring3执行</strong>，具有与调用它的应用程序代码相同的特权。这使得基础设施所有者可以允许用户提供的软件创建和使用enclave，同时保证OS内核和管理员仍然可以保护基础设施免受bug或恶意软件的攻击。</p><p><strong><code>EENTER</code>将TCS的虚拟地址作为它的输入，并要求TCS可用，并且TCS中至少有一个状态保存区域(SSA，<a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)可用</strong>。后者是通过确保TCS中的<em>当前SSA索引</em>(CSSA)字段小于SSAs  (NSSA)的数量来实现的。在执行enclave代码时发生硬件异常时，将使用CSSA所指示的SSA(应该称为当前SSA)。</p><p><strong><code>EENTER</code>将逻辑处理器转换为enclave模式，并将指令指针(RIP)设置为它接收到的TCS中的<em>入口点偏移</em>(OENTRY)字段所指示的值</strong>。<code>EENTER</code>被不受信任的调用者用来在一个受保护的环境中执行代码，因此它与用于调用系统软件的<code>SYSCALL</code>(§2.8)具有相同的安全考虑。将RIP设置为OENTRY所指示的值，可以向enclave作者保证enclave代码只会在定义良好的节点上调用，并防止恶意主机应用程序绕过enclave作者可能执行的任何安全检查。</p><p><strong><code>EENTER</code>还将XCR0(§2.6)设置为enclave属性的值XFRM</strong>(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)，XCR0是一个寄存器，用于控制正在使用的扩展架构特性。确保XCR0是根据enclave作者的意图设置的，从而防止恶意操作系统通过启用enclave尚未准备处理的体系结构特性来绕过enclave的安全性。</p><p>此外，<code>EENTER</code>使用TCS中指定的值加载段寄存器(§2.7)FS和GS的基底。段的选择器和类型是硬编码为安全值的Ring3数据段。SGX设计的这个方面使得实现每个线程的<em>线程本地存储</em>(TLS)变得很容易。对于64位的enclave，这是一种方便的特性，而不是一种安全措施，因为enclave代码可以使用WRFSBASE和WRGSBASE指令安全地将新的基底加载到FS和GS中。</p><p><strong><code>EENTER</code>将备份它修改的寄存器的旧值，以便在enclave完成其计算时恢复这些值</strong>。就像<code>SYSCALL</code>一样，<code>EENTER</code>将以下指令的地址保存在RCX寄存器中。</p><p>有趣的是，SDM声明XCR0、FS和GS寄存器的旧值保存在专用于SGX实现的新寄存器中。但是，鉴于它们只用于enclave退出，我们希望寄存器保存在DRAM中，在TCS的保留区域中。</p><p>与<code>SYSCALL</code>一样，<strong><code>EENTER</code>不修改堆栈指针寄存器(RSP)</strong>。为了避免任何安全漏洞，<strong>enclave代码应该将RSP设置为指向完全包含在EPC页面中的堆栈区域</strong>。通过设置每个线程的TLS区域以包含指向线程堆栈的指针，并将RSP设置为通过读取FS或GS段所指向的TLS区域获得的值，多线程enclave可以很容易地实现每个线程的堆栈区域。</p><p>最后，当<code>EENTER</code>进入enclave模式时，它会暂停一些处理器的调试特性，比如硬件断点和精确的基于事件的采样(PEBS)。从概念上讲，附加到主进程的调试器将enclave的执行看作一条单处理器指令。</p><h3 id="5-4-2-同步Enclave退出">5.4.2 同步Enclave退出</h3><p><strong><code>EEXIT</code>只能在逻辑处理器处于enclave模式时执行，如果在任何其他情况下执行，则会导致一个(#UD)</strong>。简而言之，该指令<strong>将处理器返回到Ring3外部enclave模式，并恢复由<code>EENTER</code>保存的寄存器</strong>。</p><p>与<code>SYSRET</code>不同，<strong><code>EEXIT</code>在退出enclave模式后将RIP设置为从RBX读取的值</strong>。这与<code>EENTER</code>不一致，<strong><code>EENTER</code>将RIP值保存到RCX</strong>。除非这种不一致性源于SDM中的错误，否则enclave代码必须确保注意到这种差异。</p><p>SDM明确声明**<code>EEXIT</code>不会修改大多数寄存器**，因此enclave作者必须确保在将控制权返回给主进程之前清除存储在处理器寄存器中的任何秘密。此外，如果enclave软件没有将堆栈指针RSP和堆栈帧基指针RBP恢复到它们在<code>EENTER</code>被调用时拥有的值，那么它很可能会在调用者中造成错误。</p><p>Enclave代码可能会在其调用者中引发错误，这似乎很不幸。无论好坏，这完全符合应用程序调用动态加载模块的情况。更具体地说，模块的代码还负责保存与堆栈相关的寄存器，有bug的模块可能会跳转到主进程的应用程序代码中的任何位置。</p><p>本节描述64位enclave的<code>EENTER</code>行为。32位enclave的<code>EENTER</code>实现要复杂得多，因为在32位Intel架构中仍然存在成熟的分段模型引入了额外的特殊情况。</p><h3 id="5-4-3-异步Enclave退出">5.4.3 异步Enclave退出</h3><p>如果在逻辑处理器执行enclave代码时发生了硬件异常，比如错误(§2.8.2)或中断(§2.12)，处理器<strong>在调用系统软件的异常处理程序之前执行<em>异步enclave退出</em></strong>(AEX)，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128192836878.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128192836878.png" srcset="data:image/png;base64,666" alt="image-20201128192836878"></p><p>AEX保存enclave代码的执行上下文(§2.6)，恢复<code>EENTER</code>保存的状态，并设置处理器寄存器，以便系统软件的硬件异常处理程序返回到enclave的主进程中的异步退出处理程序。<strong>退出处理程序将使用<code>ERESUME</code>指令恢复被硬件异常中断的enclave计算</strong>。</p><p>除了<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>中描述的行为外，<code>EENTER</code>还向当前SSA写入一些信息，这只在AEX发生时使用。<code>EENTER</code>将堆栈指针寄存器RSP和堆栈帧基指针寄存器RBP存储到当前SSA中的U_RSP和U_RBP字段中。最后，<strong><code>EENTER</code>将值存储在当前SSA的<em>异步退出处理程序指针</em>(AEP)字段中的RCX中</strong>。</p><p>当在enclave模式下发生硬件异常时，SGX实现执行一系列步骤，将逻辑处理器从enclave模式中取出，并在系统软件中调用硬件异常处理程序。从概念上讲，SGX首先执行AEX以使逻辑处理器脱离enclave模式，然后使用§2.8.2中描述的标准英特尔架构的行为来处理硬件异常。实际的Intel处理器可能会将AEX实现与异常处理实现交错使用。然而，为了简单起见，该工作将AEX描述为一个单独的过程，在采取任何异常处理步骤之前执行。</p><p>在英特尔架构中，如果发生硬件异常，应用程序代码的执行上下文可以被系统软件的异常处理程序读取和修改(§2.8.2)。当应用程序软件信任系统软件时，这是可以接受的。然而，在SGX的威胁模式下，系统软件不被Enclave信任。因此，<strong>AEX步骤通过将其所有寄存器重置为预定义值来清除执行状态中可能存在的任何秘密</strong>。</p><p>在重置enclave的执行状态之前，将它备份到当前SSA中。具体来说，AEX备份SSA中的GPRSGX区域中的通用寄存器(GPRs，§2.6)，然后使用enclave SECS中的XFRM字段中指定的<em>请求特性位图</em>(RFBM)执行<code>XSAVE</code>(§2.6)。由于每个SSA都完全存储在分配给enclave的EPC页面中，因此<strong>系统软件不能读取或篡改备份的执行状态</strong>。<strong>当SSA接收到enclave的执行状态时，通过递增当前TCS中的CSSA字段，将其标记为used</strong>。</p><p>在清除执行上下文后，<strong>AEX进程将RSP和RBP设置为<code>EENTER</code>在当前SSA中保存的值，将RIP设置为当前SSA的AEP字段中的值</strong>。这样，当系统软件的硬件异常处理程序完成时，处理器将在enclave的主进程中执行异步退出处理程序代码。SGX的设计使得在包含<code>EENTER</code>指令的例程中将异步处理程序代码设置为异常处理程序变得很容易，因为RSP和RBP寄存器拥有的值与执行<code>EENTER</code>时相同。</p><p>AEX在enclave模式之外获取逻辑处理器所采取的许多操作都与<code>EEXIT</code>匹配。段寄存器FS和GS恢复到<code>EENTER</code>保存的值，所有被<code>EENTER</code>抑制的调试工具恢复到它们以前的状态。</p><h3 id="5-4-4-从异步退出恢复">5.4.4 从异步退出恢复</h3><p>当在enclave模式下发生硬件异常时，处理器在调用系统软件设置的异常处理程序之前执行AEX。AEX设置执行上下文的方式是，<strong>当系统软件完成异常处理时，它返回到enclave的主进程中的异步退出处理程序。异步异常处理程序通常执行<code>ERESUME</code>指令</strong>，这将导致逻辑处理器返回到enclave模式并继续被硬件异常中断的计算。</p><p><code>ERESUME</code>与<code>EENTER</code>共享其大部分功能。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128201539849.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128201539849.png" srcset="data:image/png;base64,666" alt="image-20201128201539849"></p><p><code>EENTER</code>和<code>ERESUME</code>接收相同的输入，即<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>中描述的TCS指针和<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>中描述的AEP指针。最常见的应用程序设计将每个<code>EENTER</code>实例与使用完全相同的参数调用<code>ERESUME</code>的异步退出处理程序配对。</p><p><code>ERESUME</code>和<code>EENTER</code>之间的主要区别在于前者使用一个由AEX“填写”的SSA(<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)，而后者使用一个空的SSA。因此，<strong>如果提供的TCS中的CSSA字段为0，则<code>ERESUME</code>会导致#GP故障，而如果CSSA大于或等于NSSA，则<code>EENTER</code>会失败</strong>。</p><p>当成功时，<code>ERESUME</code>递减TCS的CSSA字段，并恢复TCS中CSSA字段所指向的SSA备份的执行上下文。具体来说，<strong><code>ERESUME</code>实现从SSA中的GPRSGX字段中恢复GPRs(§2.6)，并执行<code>XRSTOR</code>(§2.6)来加载与enclave所使用的扩展体系结构特性相关联的执行状态</strong>。</p><p><code>ERESUME</code>与<code>EENTER</code>共享以下行为。这两个指令<strong>都写入当前SSA中的U_RSP、U_RBP和AEP字段</strong>。这两个指令<strong>遵循相同的过程来备份XCR0、FS和GS段寄存器</strong>，并<strong>基于当前TCS及其enclave的SECS将它们设置为相同的值</strong>。最后，这两个指令都<strong>禁用了逻辑处理器的调试特性的同一子集</strong>。</p><p><code>ERESUME</code>正确处理的一个有趣的情况是，它在执行<code>XRSTOR</code>之前将XCR0设置为enclave属性XFRM  。<strong>如果SSA中的<em>请求特性位图</em>(RFBM)不是XFRM的子集，那么<code>ERESUME</code>就会失败</strong>。这很重要，因为尽管AEX总是使用XFRM值作为RFBM，但在另一个线程上执行的enclave代码可以在调用<code>ERESUME</code>之前自由地修改SSA内容。</p><p><code>ERESUME</code>实现中正确的操作顺序可以防止恶意应用程序使用enclave修改与未在XFRM中声明的扩展体系结构特性相关联的寄存器。这将破坏系统软件提供线程级执行上下文隔离的能力。</p><h2 id="5-5-EPC页面交换">5.5 EPC页面交换</h2><p>现代操作系统内核利用地址转换(§2.5)来实现页面交换，也称为分页(§2.5)。简而言之，通过将很少使用的内存页交换到称为磁盘等较慢的存储介质，分页允许OS内核过量提交计算机的DRAM。</p><p>分页是有效利用计算机资源的关键因素。例如，用户并发运行多个程序的桌面系统可以退出分配给不活动应用程序的内存页，而不会显著降低用户体验。</p><p>不幸的是，不能允许OS通过像在PRM范围之外的DRAM内存页面交换一样来交换enclave的EPC页面。在SGX的威胁模型中，enclave不相信系统软件，因此SGX的设计提供了一种EPC页面交换方法，可以防御试图进行§3.7中所述的任何主动地址转换攻击的恶意操作系统。</p><p>SGX所提供的安全性的代价是，支持交换EPC页面的操作系统内核必须使用经过修改的页面交换实现，该实现与SGX机制交互。Enclave作者基本上可以忽略EPC交换，类似于今天的应用程序开发人员可以忽略OS内核的分页实现。</p><p>如下图所示，SGX支持将EPC页面交换到PRM范围之外的DRAM页面。系统软件使用现有的页交换技术实现将这些页的内容从DRAM中交换到磁盘上。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202326077.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202326077.png" srcset="data:image/png;base64,666" alt="image-20201128202326077"></p><p>SGX的交换特性围绕着<code>EWB</code>指令，在<a href="#5.5.4-EPC%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2">§5.5.4</a>中有详细描述。实际上，<strong><code>EWB</code>将EPC页交换到EPC之外的DRAM页，并通过将该页EPCM条目中的VALID字段置零将EPC页标记为可用</strong>。</p><p><strong>SGX设计依赖于对称密钥加密来保证被交换的EPC页面的机密性和完整性，并依赖于nonces(§3.1.4)来保证带回EPC的页面的新鲜度</strong>。这些nonces存储在<a href="#5.5.2-%E7%89%88%E6%9C%AC%E6%95%B0%E7%BB%84" title="VA">§5.5.2</a>中介绍的版本数组(VA)中，它们是专门用于nonce存储的EPC页面。</p><p>在EPC页面被交换并释放给其他enclaves使用之前，SGX实现必须确保没有TLB拥有与被交换的页面相关联的地址转换，以避免§3.7.4中描述的基于TLB的地址转换攻击。</p><p>正如<a href="#5.1.1-Enclave%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98-(EPC)">§5.1.1</a>中所解释的，SGX让系统软件负责管理EPC。自然地，本节中描述的用于实现EPC分页的SGX指令只对运行在Ring 0(§2.3)上的系统软件可用。</p><p>在今天的软件栈(§2.3)中，只有操作系统内核实现了页面交换，以支持DRAM的过度使用。管理程序仅用于在操作系统之间划分计算机的物理资源。因此，在编写本节时，我们期望OS内核也将承担EPC页面交换的责任。为了简单起见，我们经常使用术语“操作系统内核”而不是“系统软件”。读者应该知道，SGX设计并不排除系统管理程序实现自己的EPC页面交换的系统。因此，“OS内核”实际上应该理解为“执行EPC分页的系统软件”。</p><h3 id="5-5-1-页面交换和TLB">5.5.1 页面交换和TLB</h3><p>SGX没有向内存执行单元添加任何安全检查(§2.9.4，§2.10)。相反，SGX的访问控制检查是在地址转换(§2.5)完成之后进行的，就在转换结果写入TLBs之前(§2.11.5)。在整个SDM中，这个方面通常被忽略，但是在解释SGX的EPC页面清除机制时，它就变得显而易见了。</p><p>关于SGX的内存访问保护检查的完整讨论值得单独一节来讨论，请参见§6.2。只需使用SGX的安全模型中的两个需求就可以解释EPC页面清除机制。首先，当一个逻辑处理器通过<code>EEXIT</code>(<a href="#5.4.2-%E5%90%8C%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.2</a>)或AEX(<a href="#5.4.3%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)退出一个enclave时，它的TLB被刷新。其次，当从enclave释放EPC页面时，必须使得执行该enclave代码的所有逻辑处理器退出enclave。这足以保证删除任何针对已释放的EPC的TLB条目。</p><p>系统软件可以通过发送处理器间中断(IPI，§2.12)，使逻辑处理器退出enclave，这将在接收时触发AEX。</p><p>SGX不相信系统软件。因此，<strong>在将EPC页面的EPCM条目标记为free之前，SGX必须确保OS内核已经清除了所有可能包含该页面转换的TLB</strong>。此外，为每个页面清除执行IPIs和TLB刷新会给分页实现增加很大的开销，因此SGX设计允许使用一个IPI/TLB刷新序列来清除一批页面。</p><p><strong>TLB刷新验证逻辑依赖于一个名为BLOCKED的1位EPCM条目字段</strong>。如下图所示，VALID和BLOCKED字段产生三种可能的EPC页面状态。当两个位都为零时，页面是空闲的；当VALID为1，BLOCKED为0时使用；当两个位都为1时，页面被阻塞。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202429126.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202429126.png" srcset="data:image/png;base64,666" alt="image-20201128202429126"></p><p><strong>被阻塞的页面被认为不能被enclave访问</strong>。如果一个地址转换导致一个被阻塞的EPC页面，SGX实现会导致一个页面错误(#PF，§2.8.2)。这保证了一旦一个页面被阻塞，CPU将不会创建任何新的指向它的TLB条目。</p><p>此外，<strong>每条SGX指令都确保它所操作的EPC页面不会被阻塞</strong>。例如，<code>EENTER</code>确保它提供的TCS没有被阻塞，它的enclave的SECS没有被阻塞，以及当前SSA中的每个页面没有被阻塞。</p><p>为了交换一批EPC页面，OS内核必须首先针对这些页面发出<code>EBLOCK</code>指令。SGX还希望OS从页表中删除EPC页的映射，但并不信任OS。</p><p><strong>在所有所需的页面都被阻塞之后，操作系统内核必须执行一条<code>ETRACK</code>指令，这条指令指示SGX实现跟踪哪些逻辑处理器的TLBs已被刷新</strong>。<code>ETRACK</code>要求enclave的SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)的虚拟地址。如果OS希望交换属于多个enclave的一批EPC页面，它必须为每个enclave发出一个<code>ETRACK</code>。</p><p>按照<code>ETRACK</code>指令，操作系统内核必须在所有执行enclave代码的逻辑处理器上的enclave退出。SGX设计期望操作系统将使用IPIs在逻辑处理器中导致AEXs，而逻辑处理器的TLBs必须被刷新。</p><p>当OS对每个要交换的EPC页面执行<code>EWB</code>指令时，EPC页面交换过程就完成了。这条指令将在<a href="#5.5.4-EPC%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2">§5.5.4</a>中详细描述，它将<strong>写入EPC页面的加密版本并将其交换到DRAM中，然后通过清除其EPCM条目中的VALID和BLOCKED位来释放该页面</strong>。在执行其任务之前，<code>EWB</code>确保它所目标的EPC页面已经被阻塞，并检查<code>ETRACK</code>设置的状态，以确保所有相关的TLB都已被刷新。</p><p>可以<strong>通过<code>ELDU</code>和<code>ELDB</code>指令将被交换的页面加载回EPC</strong>。这两个指令启动时都有一个空闲的EPC页面和一个DRAM页面(其中包含EPC页面的已交换内容)，然后将DRAM页面的内容解密到EPC页面，并恢复相应的EPCM条目。<strong><code>ELDU</code>和<code>ELDB</code>之间的唯一区别是后者在页面的EPCM条目中设置阻塞位，而前者将其清除</strong>。</p><p><code>ELDU</code>和<code>ELDB</code>类似于<code>ECREATE</code>和<code>EADD</code>，因为它们填充了一个空闲的EPC页面。由于他们操作的页面是空闲的，因此SGX安全模型断言没有TLB条目可能针对它。因此，这些指令不需要类似于<code>EBLOCK</code>或<code>ETRACK</code>的机制。</p><h3 id="5-5-2-版本数组-VA">5.5.2 版本数组 (VA)</h3><p>当<code>EWB</code>交换EPC的内容时，它会<strong>创建一个8字节的nonce</strong>(§3.1.4)，英特尔的文档将其称为页面版本。<strong>SGX的新鲜度保证是建立在安全存储nonces的假设之上的，所以<code>EWB</code>将它创建的nonce存储在一个<em>版本数组</em>(VA)中</strong>。</p><p>版本数组是EPC页面，专门用于存储由<code>EWB</code>生成的nonces。每个VA被划分成槽，每个槽都足够存储一个nonce。假设EPC页面的大小是4KB，每个nonce占用8字节，那么每个VA就有512个槽。</p><p><strong>页是使用<code>EPA</code>指令分配的，该指令接受空闲EPC页的虚拟地址，并将其转换为具有空槽的版本数组</strong>。每一页在其EPCM条目中以PT_VA类型标识。<strong>与SECS页面一样，VA页面的EPCM条目中的ENCLAVEADDRESS字段设置为零</strong>，任何软件(包括enclave)都不能直接访问它们。</p><p>与到目前为止讨论的其他页面类型不同，<strong>VA页面不与任何enclave关联</strong>。这意味着可以通过<code>EREMOVE</code>释放它们，而不受任何限制。但是，将一个槽正在使用的VA页面释放时会丢弃这些槽中的nonces，这将导致丢失将相应的被交换的页面加载回EPC的能力。因此，一个正确的操作系统实现不太可能在一个非空闲槽的VA调用<code>EREMOVE</code>。</p><p>根据SDM中<code>EPA</code>和<code>EWB</code>的伪代码，<strong>SGX使用零值来表示VA中的空槽</strong>，这意味着所有生成的nonces必须是非零的。这还意味着<code>EPA</code>通过将底层EPC页面归零来初始化VA。然而，由于软件不能访问VA的内容，无论是使用一个特殊值，或值本身都不是体系结构的。</p><h3 id="5-5-3-Enclave-IDs">5.5.3 Enclave IDs</h3><p><code>EWB</code>和<code>ELDU</code> / <code>ELDB</code>指令使用一个<strong><em>enclave ID</em> (EID)来标识拥有被交换页面的enclave</strong>。EID与EPCM条目中的ENCLAVESECS(<a href="#5.1.2-Enclave%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%98%A0%E5%B0%84%E8%A1%A8-(EPCM)">§5.1.2</a>)字段具有相同的用途，后者也用于标识拥有EPC页面的enclave。本节通过比较两个值及其用法，说明使用两个值表示相同概念的必要性。</p><p>SDM声明EPCM条目中的ENCLAVESECS字段用于标识拥有相关EPC页面的enclave的SECS，但没有描述其格式。理论上，ENCLAVESECS字段可以在SGX实现之间更改，因为SGX指令从不向软件暴露其值。</p><p>然而，我们稍后将讨论，ENCLAVESECS最可信的表示是其字段中的enclave物理地址。因此，如果从EPC中交换出enclave的SECS并在另一个位置加载回该enclave，则与给定enclave关联的ENCLAVESECS值将发生更改。由此可见，<strong>ENCLAVESECS值仅适用于标识某个enclave，而其SECS仍在EPC中</strong>。</p><p>根据SDM,  <strong>EID字段是存储在enclave的SECS中的64位字段</strong>。SDM中的<code>ECREATE</code>伪代码显示，在分配SECS时，通过原子递增全局计数器生成enclave的ID。假设计数器不会发生滚动，此过程将确保在电源循环期间创建的每个enclave都具有唯一的EID。</p><p>尽管SDM没有明确保证这一点，但<strong>enclave SECS中的EID字段似乎不会被任何指令修改</strong>。这使得EID的值适合在整个enclave的生命周期内标识它，甚至在从EPC中将其SECS页面驱逐出去时也是如此。</p><h3 id="5-5-4-EPC页面交换">5.5.4 EPC页面交换</h3><p>系统软件使用<code>EWB</code>指令交换EPC页面，<code>EWB</code>指令在稍后通过<code>ELDU</code>指令生成恢复交换页面所需的所有数据，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202614082.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202614082.png" srcset="data:image/png;base64,666" alt="image-20201128202614082"></p><p><strong><code>EWB</code>的输出包括被交换的EPC页面内容的加密版本、与该页面对应的EPCM条目中的字段子集、<a href="#5.5.2-%E7%89%88%E6%9C%AC%E6%95%B0%E7%BB%84-(VA)">§5.5.2</a>中讨论的nonce和消息身份验证代码(MAC，§3.1.3)标记</strong>。除了nonce之外，<code>EWB</code>将其输出写入PRM区域之外的DRAM中，因此系统软件可以选择进一步将其交换出磁盘。</p><p>EPC页面内容被加密，以保护enclave数据的机密性，同时页面存储在PRM范围之外的不受信任的DRAM中。在不使用加密的情况下，系统软件可以通过将EPC页面从EPC中交换出来从而了解该页面的内容。</p><p><strong>页面元数据存储在页面信息(PAGEINFO)结构中</strong>，如下图所示。这个结构类似于<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>中描述的PAGEINFO结构，<strong>除了SECINFO字段被一个PCMD字段所取代</strong>，它包含一个页面加密元数据(PCMD)结构的虚拟地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202629432.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202629432.png" srcset="data:image/png;base64,666" alt="image-20201128202629432"></p><p>PAGEINFO结构中的LINADDR字段用于存储EPCM条目中的地址字段，该字段指示用于访问页面的虚拟地址。<strong>PCMD结构嵌入了<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>中描述的安全信息(SECINFO)，用于在EPCM条目中存储页面类型(PT)和访问权限标志(R, W, X)</strong>。PCMD结构还存储了enclave的ID (EID，<a href="#5.5.3-Enclave-IDs">§5.5.3</a>)。这些字段稍后由<code>ELDU</code>或<code>ELDB</code>用于填充重新加载的EPC页面的EPCM条目。</p><p>上面描述的元数据是未加密存储的，因此操作系统可以选择按原样使用内部信息进行自己的记帐。这对安全性没有负面影响，因为<strong>元数据不是机密的</strong>。实际上，除了enclave ID之外，所有元数据字段都是在调用<code>ECREATE</code>时由系统软件指定的。enclave ID仅用于标识EPC页面所属的enclave，而且系统软件也已经拥有该信息。</p><p>除了上面描述的元数据之外，PCMD结构还存储由<code>EWB</code>生成的MAC标签。<strong>MAC标记涵盖EPC页面内容的真实性、元数据和nonce</strong>。MAC标记由<code>ELDU</code>和<code>ELDB</code>检查，只有在MAC验证确认了页面数据、元数据和nonce的真实性时，它们才会将一个被交换的页面加载回EPC。这个安全检查可以防止在§3.7.3中描述的页面交换攻击。</p><p>与<code>EREMOVE</code>类似，<strong>如果没有其他EPCM条目的ENCLAVESECS字段引用该SECS，则<code>EWB</code>只会交换包含enclave SECS的EPC页面</strong>。同时，作为一种优化，SGX实现在交换SECS时不执行与<code>ETRACK</code>相关的检查。这是安全的，因为只有在EPC没有属于SECS的页面时，才会交换SECS，这意味着EPC中没有属于enclave的任何TCS，因此没有处理器可以执行enclave代码。</p><p>与任何其他EPC页面一样，可以清除持有版本数组的页面。VA页面永远不能被软件访问，所以他们不能有任何TLB条目指向他们。因此，<code>EWB</code>在不执行任何<code>ETRACK</code>相关检查的情况下交换VA页面。</p><p><code>EWB</code>的数据流(如下图所示)有一个方面可能会让操作系统开发人员感到困惑。该指令从寄存器(RBX)中读取将要被交换出的EPC页面的虚拟地址，并将其写入提供给它的PAGEINFO结构的LINADDR字段。可以通过在LINADDR字段中提供EPC页面的地址来删除单独的输入(RBX)。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201129122411533.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201129122411533.png" srcset="data:image/png;base64,666" alt="image-20201129122411533"></p><h3 id="5-5-5-将交换的页面加载回EPC">5.5.5 将交换的页面加载回EPC</h3><p>在交换出属于enclave的EPC页面之后，<strong>任何从enclave代码访问该页面的尝试都将导致页面错误(#PF，§2.8.2)</strong>。#PF将导致逻辑处理器通过AEX退出enclave模式(<a href="#5.4.3-%E5%BC%82%E6%AD%A5Enclave%E9%80%80%E5%87%BA">§5.4.3</a>)，然后调用OS内核的页面错误处理程序。</p><p>页面错误从AEX流程接受特殊处理。当离开enclave时，AEX逻辑专门检查触发AEX的硬件异常是否为#PF。如果是这样，AEX实现将清除CR2寄存器中最不重要的12位，该寄存器存储虚拟地址，其转换导致了页面错误。</p><p>通常，操作系统内核的页面处理程序需要能够从CR2中提取虚拟页码(VPN，§2.5.1)，这样它就知道需要将哪些内存页加载回DRAM。操作系统内核还可以使用12个最不重要的地址位，这不是VPN的一部分，从而更好地预测应用程序软件的内存访问模式。然而，与组成VPN的位不同，最下面的12位对于故障处理程序执行其工作不是绝对必要的。因此，SGX的AEX实现清除这12位，以限制页面错误处理程序得到的信息量。</p><p><strong>当OS页面错误处理程序检查CR2寄存器中的地址并确定错误地址在EPC中时，通常希望使用<code>ELDU</code>或<code>ELDB</code>指令将被交换的页面加载回EPC中</strong>。如果<code>EWB</code>的输出已经从DRAM中被交换到较慢的存储介质中，操作系统内核将不得不在调用<code>ELDU</code>  / <code>ELDB</code>之前将输出读回DRAM中。</p><p><code>ELDU</code>和<code>ELDB</code>验证由<code>EWB</code>产生的MAC标签，如<a href="#5.5.4-EPC%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2">§5.5.4</a>所述。这可以防止操作系统内核执行§3.7.3中描述的基于页面交换的主动地址转换攻击。</p><h3 id="5-5-6-交换树">5.5.6 交换树</h3><p>SGX允许从EPC中交换VA页面，就像enclave页面一样。当从EPC中交换一个VA页面时，处理器将无法访问由VA槽存储的所有nonces。因此，在操作系统将VA页面加载回EPC之前，<code>ELDB</code>无法恢复与这些nonces关联的被交换的页面。</p><p>换句话说，<strong>一个被交换的页面依赖于存储其nonce的VA页面，并且在VA页面也被重新加载之前不能被加载回EPC</strong>。由此关系创建的依赖图是一个交换树的森林。如下图所示，一个交换树将EPC页面作为叶子，将VA页面作为内部节点。页面的父页面是保存其nonce的VA页面。由于<code>EWB</code>总是在一个页面中输出一个nonce，所以每个交换树的根节点在EPC中总是一个页面。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202740316.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202740316.png" srcset="data:image/png;base64,666" alt="image-20201128202740316"></p><p>一个简单的归纳表明，<strong>当OS希望将一个交换的enclave页面加载回EPC时，它需要在从交换树的根到与该enclave页面对应的叶的路径上加载所有VA页面</strong>。因此，在EPC中满足页面错误所需的页面加载数量取决于包含该页面的交换树的形状。</p><p>SGX让OS完全掌控交换树的形状。这对安全性没有负面影响，因为树的形状只影响交换方案的性能，而不影响其正确性。</p><h2 id="5-6-SGX-Enclave度量">5.6 SGX Enclave度量</h2><p>SGX实现了一个软件认证方案，该方案遵循了§3.3中概述的一般原则。对于本节而言，最相关的原则是远程方根据其度量对enclave进行身份验证，该度量用于识别正在enclave内部执行的软件。远程方将可信硬件报告的enclave度量与预期的度量进行比较，只有在两个值匹配时才进行。</p><p><a href="#5.3-SGX-Enclave%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§5.3</a>解释了SGX enclave是使用<code>ECREATE</code>(<a href="#5.3.1-%E5%88%9B%E5%BB%BA">§5.3.1</a>)、<code>EADD</code>(<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>)和<code>EEXTEND</code>指令构建的。在通过<code>EINIT</code>(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)初始化enclave之后，上面提到的指令就不能再使用了。SGX度量的方案遵循§3.3.2中概述的原则，SGX enclave的度量是通过计算安全散列(§3.1.3)输入<code>ECREATE</code>,  <code>EADD</code>和<code>EEXTEND</code>。<code>EINIT</code>结束了表示enclave度量值的散列。</p><p>除了enclave的内容之外，enclave作者还需要指定应该使用的指令序列，以便创建一个enclave，该enclave的度量将与软件认证过程中远程方使用的期望值相匹配。.so和.dll动态加载库文件格式是SGX打算使用的enclave传递方法，它们已经包含了加载算法的非正式规范。我们期望非正式的加载规范作为规范的起点，这些规范规定了应该用于从.so和.dll文件创建enclave的SGX指令的确切序列。</p><p>如§3.3.2所述，<strong>enclave的度量是使用安全的哈希算法计算的，因此系统软件只能按照enclave作者指定的指令顺序构建与预期度量匹配的enclave</strong>。</p><p><strong>SGX设计使用256位SHA-2安全哈希函数来计算其度量值</strong>。SHA-2是一个块哈希函数(§3.1.3)，它对64字节的块进行操作，使用32字节的内部状态，并产生32字节的输出。<strong>每个enclave的度量都存储在enclave SECS的MRENCLAVE字段中</strong>。32字节字段存储256位SHA-2安全哈希函数的内部状态和最终输出。</p><h3 id="5-6-1-ECREATE度量">5.6.1 ECREATE度量</h3><p>在<a href="#5.3.1-%E5%88%9B%E5%BB%BA">§5.3.1</a>中概述的<code>ECREATE</code>指令，首先使用256位SHA-2初始化算法在新创建的SECS中初始化MRENCLAVE字段，然后使用下表中描述的64字节块扩展哈希。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202858886.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202858886.png" srcset="data:image/png;base64,666" alt="image-20201128202858886" style="zoom:80%;" /><p>enclave的度量不包括BASEADDR字段。此处省略是有意的，因为它<strong>允许系统软件在满足ELRANGE限制的主进程内的任何虚拟地址加载enclave，而不会改变enclave度量值</strong>。此特性可以与生成位置无关的enclave代码的编译器结合使用，以获得可重定位的enclave。</p><p>enclave的度量包括SSAFRAMESIZE字段，它<strong>保证AEX创建、<code>EENTER</code>(<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>)和<code>ERESUME</code>(<a href="#5.4.4-%E4%BB%8E%E5%BC%82%E6%AD%A5%E9%80%80%E5%87%BA%E6%81%A2%E5%A4%8D">§5.4.4</a>)使用的SSAs(<a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)具有enclave作者所期望的大小</strong>。如果将此字段排除在enclave的度量之外，会允许恶意的enclave加载程序通过指定比enclave作者预期的更大的SSAFRAMESIZE来试图攻击enclave的安全检查，这可能导致AEX编写的SSA内容覆盖enclave的代码或数据。</p><h3 id="5-6-2-度量Enclave属性">5.6.2 度量Enclave属性</h3><p><strong>enclave的度量不包括在SECS中的ATTRIBUTES字段中指定的enclave属性</strong>(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)。相反，它直接包含在认证签名所涵盖的信息中，这将在<a href="#5.8.1-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81">§5.8.1</a>中讨论。</p><p><strong>SGX软件认证需要涵盖enclave属性</strong>。例如，如果XFRM(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a> <a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)不被覆盖，一个恶意的enclave装载机可以通过设置XFRM值试图颠覆一个enclave的安全检查，让体系结构扩展指令使用的enclave的语义变化，但仍然是产生符合SSAFRAMESIZE的XSAVE输出。</p><p>应用到ATTRIBUTES  SECS字段的特殊处理从安全角度来看似乎是有问题的，因为它给软件认证验证器增加了额外的复杂性，从而转化为可利用的漏洞的更多机会。这个决定也增加了SGX软件认证设计的复杂性，在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中有描述。</p><p>尽管存在上述问题，SGX设计决定走这条路的最可能的原因是希望能够使用单一度量来表示一个能够利用一些架构扩展的enclave，但也可以在没有它们的情况下执行其任务。</p><p>例如，考虑使用OpenCV这样的库执行图像处理的enclave，它具有针对SSE和VX优化的例程，但还包括针对不具备这些特性的处理器的通用回退。enclave的作者可能希望允许enclave加载器将位1(SSE)和位2(VX)设置为真或假。如果ATTRIBUTES(以及XFRM)是enclave度量的一部分，则enclave作者必须指定enclave有4个有效度量。通常，允许n个架构扩展独立使用将导致2<sup>n</sup>个无效度量。</p><h3 id="5-6-3-度量EADD">5.6.3 度量EADD</h3><p><a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>中描述的<code>EADD</code>指令用下表中所示的64字节块扩展了MRENCLAVE中的SHA-2哈希。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202953982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128202953982.png" srcset="data:image/png;base64,666" alt="image-20201128202953982" style="zoom:80%;" /><p><strong>度量中包含的地址是<code>EADD</code>页面预期映射到enclave的虚拟地址空间中的地址</strong>。这可以确保系统软件根据enclave作者的规范设置enclave的虚拟内存布局。如果恶意的enclave加载程序试图错误地设置enclave的布局，可能是为了挂载一个活动的地址转换攻击(§3.7.2)，所加载的enclave的度量结果将与enclave作者期望的度量结果不同。</p><p>新创建的页面的虚拟地址相对于enclave的ELRANGE的起点进行度量。换句话说，度量中包含的值是LINADDR -  BASEADDR。这使得<strong>enclave的度量对BASEADDR的变化保持不变</strong>，这对于可重定位的enclave是理想的。度量相对地址仍然保留了关于ELRANGE内内存布局的所有信息，因此没有负面的安全影响。</p><p><strong><code>EADD</code>同时也度量提供给<code>EADD</code>的SECINFO(<a href="#5.3.2-%E5%8A%A0%E8%BD%BD">§5.3.2</a>)结构的前48字节</strong>，其中包含用于初始化页面的EPCM条目的页面类型(PT)和访问权限(R,  W, X)字段值。同样，在度量中包含这些值可以保证加载enclave的系统软件构建的内存布局与enclave作者的规范相匹配。</p><p>上面提到的EPCM字段值在SECINFO结构中只占不到一个字节，其余的字节被保留，并被初始化为零。这为SGX未来的功能留下了大量的扩展空间。</p><p>上表中最值得注意的省路是用于初始化新创建的EPC页面的数据。因此，<code>EADD</code>提供的度量数据保证了enclave的内存布局将具有在所需虚拟地址上分配的有指定访问权限的页面。但是，度量不包括在这些页面中加载的代码或数据。</p><p>例如，<code>EADD</code>的度量数据保证enclave的内存布局由三个可执行页面和五个可写数据页面组成，但它不能保证任何代码页面包含enclave作者提供的代码。</p><h3 id="5-6-4-度量EEXTEND">5.6.4 度量EEXTEND</h3><p><code>EEXTEND</code>指令的存在仅仅是为了度量加载在enclave的EPC页面中的数据。该指令读入一个虚拟地址，并使用下表中的5个64字节块扩展enclave的度量散列，这有效地保证了enclave内存中256字节数据块的内容。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203446836.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203446836.png" srcset="data:image/png;base64,666" alt="image-20201128203446836" style="zoom:80%;" /><p>在检查<code>EEXTEND</code>的细节之前，我们注意到，SGX的安全保证只有在对enclave的关键页面的内容进行测量时才有效。例如，<code>EENTER</code>(<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>)只有在测量了所有线程控制结构(TCS，<a href="#5.2.4-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(TCS)">§5.2.4</a>)页面的内容后，才保证在enclave的代码中执行受控跳转。否则，恶意的enclave加载程序可以在构建enclave时更改TCS中的OENTRY字段(§5.2.4，<a href="#5.4.1-%E5%90%8C%E6%AD%A5Enclave%E8%BF%9B%E5%85%A5">§5.4.1</a>)，然后恶意的操作系统可以使用TCS在enclave代码中执行任意跳转。同样的道理，所有enclave的代码都应该用<code>EEXTEND</code>来度量。任何无法测量的代码片段都可以被恶意的enclave加载程序替换。</p><p>考虑到这些缺陷，令人惊讶的是SGX设计选择将由<code>EADD</code>完成的虚拟地址空间布局度量与由<code>EEXTEND</code>完成的内存内容度量分离。</p><p>乍一看，这种解耦似乎只有一个好处，即能够在构建enclave时将未测量的用户输入加载到该enclave中。但是，这种好处只会转化为很小的性能改进，因为可以将enclave设计为在初始化后从不受信任的DRAM复制用户输入。与此同时，由于没有通过<code>EEXTEND</code>调用度量所有重要数据，这种分离打开了依赖于一个没有提供有意义的安全保证的enclave的可能性。</p><p>然而，<code>EADD</code>  / <code>EEXTEND</code>分离背后的真正原因是由SDM中的<code>EINIT</code>伪代码所暗示的，它表明该指令在执行计算密集型RSA签名检查时打开了一个中断窗口(§2.12)。如果在检查期间发生中断，<code>EINIT</code>会失败并出现错误代码，然后中断。对于处理器指令来说，这种非常不寻常的方法表明，SGX实现受到了其指令被允许添加到中断处理进程中的延迟时间的限制。</p><p>考虑到上面的问题，可以合理地推断引入了<code>EEXTEND</code>，因为使用256位SHA-2度量整个页面非常耗时，而且在<code>EADD</code>中这样做会导致指令超出SGX的延迟预算。需要达到某个延迟目标，这是对似乎任意的256字节块大小的合理解释。</p><p>如果使用构建当前动态加载模块(似乎是SGX设计的目标工作流)的相同工具编写enclave，那么<code>EADD</code> /  <code>EEXTEND</code>分离将不会导致安全问题。在此工作流中，构建enclave的工具可以轻松识别需要度量的enclave数据。</p><p>从安全性的角度来看，让<code>EEXTEND</code>提供给散列函数的消息块除了包含数据内容外，还包含256字节块的地址是正确的，也是有意义的。如果地址不包括在内，恶意的enclave加载器就会装载§3.7.2中描述的内存映射攻击。</p><p>更具体地说，恶意加载程序将在用于泄漏的虚拟地址处<code>EADD</code> <code>errorOut</code>页面内容，在用于泄漏的虚拟地址处<code>EADD disclose</code>页面内容，然后以错误的顺序<code>EEXTEND</code>页面。如果<code>EEXTEND</code>不包含被测量的数据块的地址，那么上面的步骤将产生与正确构造的enclave相同的测量结果。</p><p><code>EEXTEND</code>值得分析的最后一个方面是它对enclave迁移的支持。与<code>EADD</code>类似，<code>EEXTEND</code>测量的虚拟地址是相对于enclave的BASEADDR的。此外，唯一的SGX结构的内容将被<code>EEXTEND</code>测量是TCS。SGX的设计已经仔细地为所有代表enclave地址的TCS字段使用了相对地址，这是OENTRY,  OFSBASGX和OGSBASGX。</p><h3 id="5-6-5-度量EINIT">5.6.5 度量EINIT</h3><p><code>EINIT</code>指令(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)结束了enclave的构建过程。在enclave上成功调用<code>EINIT</code>之后，enclave的内容是“密封的”，这意味着系统软件不能使用<code>EADD</code>指令将代码和数据加载到enclave中，也不能使用<code>EEXTEND</code>指令更新enclave的度量。</p><p><code>EINIT</code>在enclave的SECS的MRENCLAVE字段上使用SHA-2算法(§3.1.3)。在<code>EINIT</code>之后，字段不再存储SHA-2算法的中间状态，而是存储安全哈希函数的最终输出。该值在<code>EINIT</code>完成后保持不变，并包含在SGX软件认证过程生成的认证签名中。</p><h2 id="5-7-SGX-Enclave版本支持">5.7 SGX Enclave版本支持</h2><p>由可信平台模块(§4.4)引入的软件认证模型(§3.3)依赖于度量，它本质上是一个内容散列，用于识别容器内的软件。使用内容哈希进行标识的缺点是，存放同一软件的不同版本的容器的标识之间没有关系。</p><p>在实践中，基于安全容器的系统在初始软件认证过程中不访问远程方来处理软件更新是非常理想的。这需要有能力在拥有旧版本软件的容器和拥有更新版本的容器之间迁移秘密。这一需求转化为对能够识别同一软件的两个版本之间关系的独立身份系统的需求。</p><p>SGX支持在表示同一软件的不同版本的enclave之间迁移秘密，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203650801.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203650801.png" srcset="data:image/png;base64,666" alt="image-20201128203650801"></p><p>秘密迁移特性依赖于一个一级证书层次结构(§3.2.1)，其中每个enclave作者都是一个证书颁发机构，每个enclave从作者那里收到一个证书。这些证书必须格式化为签名结构(SIGSTRUCT)，这在<a href="#5.7.1-Enclave%E8%AF%81%E4%B9%A6">§5.7.1</a>中有描述。这些证书中的信息是<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>中介绍的enclave身份方案的基础，它可以识别同一软件的不同版本之间的关系。</p><p><code>EINIT</code>指令(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)检查目标enclave的证书，并使用其中的信息填充SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)字段，这些字段描述了enclave基于证书的标识。这个过程在<a href="#5.7.4-%E5%BB%BA%E7%AB%8BEnclave%E8%BA%AB%E4%BB%BD">§5.7.4</a>中进行了总结。</p><p>最后，实际的秘密迁移过程是基于<code>EGETKEY</code>指令实现的密钥派生服务，在<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>中进行了描述。发送enclave使用<code>EGETKEY</code>指令根据其身份获得一个对称密钥(§3.1.1)，用该密钥加密其秘密，并将加密的秘密交给不受信任的系统软件。接收enclave将发送enclave的身份传递给<code>EGETKEY</code>，获得与上面相同的对称密钥，并使用该密钥解密从系统软件接收到的秘密。</p><p>从<code>EGETKEY</code>获得的对称密钥可以与加密原语一起使用，这些原语可以在不受信任的系统软件迁移到另一个enclave时保护enclave秘密的机密性(§3.1.2)和完整性(§3.1.3)。但是，仅凭对称密钥无法提供新鲜度保证(§3.1)，因此秘密迁移容易受到重放攻击。当被迁移的秘密是不可变的，例如当秘密是通过软件认证获得的加密密钥时，这是可以接受的。</p><h3 id="5-7-1-Enclave证书">5.7.1 Enclave证书</h3><p>SGX的设计要求每个enclave都有其作者颁发的证书。这一要求是由<code>EINIT</code>强制执行的(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)，它拒绝在没有有效证书的enclave上操作。</p><p>SGX实现使用格式化为签名结构(SIGSTRUCT)的证书，这些证书将由enclave构建工具链生成，如下图所示。</p><p><img src="D:%5CSource%5Cnotes%5Ctranslation-sgx-programming-model%5Cimage-20201128203825740.png" class="lazyload" data-srcset="D:%5CSource%5Cnotes%5Ctranslation-sgx-programming-model%5Cimage-20201128203825740.png" srcset="data:image/png;base64,666" alt="image-20201128203825740"></p><p>SIGSTRUCT证书由元数据字段和保证元数据真实性的（其中最有趣的字段在下表中显示）。字段的语义将在下面的部分中揭示。</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203806483.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203806483.png" srcset="data:image/png;base64,666" alt="image-20201128203806483" style="zoom:80%;" /><p>RSA签名组成格式如下表所示：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203943298.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128203943298.png" srcset="data:image/png;base64,666" alt="image-20201128203943298" style="zoom:80%;" /><p>enclave证书必须由RSA签名(§3.1.3)签名，该签名遵循RFC 3447中描述的方法，使用256位SHA-2]作为哈希函数来减少输入大小，以及PKCS #1 v1.5中描述的填充方法。</p><h3 id="5-7-2-基于证书的Enclave身份">5.7.2 基于证书的Enclave身份</h3><p>enclave的身份由其证书中的三个字段决定(<a href="#5.7.1-Enclave%E8%AF%81%E4%B9%A6">§5.7.1</a>)：用于签署证书的RSA密钥的模数(模数)、enclave的产品ID(ISVPRODID)和安全版本号(ISVSVN)。</p><p>用于颁发证书的公共RSA密钥标识enclave的作者。用于颁发enclave证书的所有RSA密钥必须将公开指数设置为3，因此它们仅通过模量进行区分。SGX不使用密钥的整个模量，而是模量的256位SHA-2哈希。这称为签名者度量(MRSIGNER)，与标识enclave内容的SHA-2散列的enclave度量(MRENCLAVE)名称量级相同。</p><p>SGX实现依赖于一个硬编码的MRSIGNER值来识别由Intel颁发的证书。拥有英特尔颁发的证书的enclave可以获得额外的特权，这在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中有讨论。</p><p>enclave作者可以使用相同的RSA密钥为表示不同软件模块的enclave颁发证书。每个模块由一个唯一的产品ID(ISVPRODID)值标识。相反，假定证书具有相同ISVPRODID并由相同RSA密钥(因此具有相同的MRENCLAVE)颁发的所有enclave代表同一软件模块的不同版本。通常假定证书由不同密钥签名的enclave包含不同的软件模块。</p><p>表示模块的不同版本的enclave可以具有不同的安全版本号(SVN)。SGX的设计不允许秘密从具有较高SVN的enclave迁移到具有较低SVN的enclave。此限制旨在帮助分发安全补丁，如下所示。</p><p>如果在enclave中发现安全漏洞，作者可以发布具有更高SVN的固定版本。随着用户升级，SGX将帮助机密从enclave的脆弱版本转移到固定版本。一旦用户的秘密迁移完成，SGX中的SVN限制将基于构建易受攻击的enclave版本并使用它读取迁移后的秘密来转移任何攻击。</p><p>增加功能的软件升级不应该伴随着SVN的增加，因为SGX允许秘密在具有匹配SVN值的enclave之间自由迁移。如上所述，只有在发现安全漏洞时，软件模块的SVN才应该增加。SIGSTRUCT只给ISVSVN字段分配2个字节，转换成65,536个可能的SVN值。如果一个大型团队(错误地)设置了一个连续构建系统，为它生成的每个软件构建分配一个新的SVN，并且每个代码更改触发一个构建，那么这个空间就会耗尽。</p><h3 id="5-7-3-CPU安全版本号">5.7.3 CPU安全版本号</h3><p>SGX实现本身有一个安全版本号(CPUSVN)，除了enclave的身份信息之外，它还用于<code>EGETKEY</code>实现的密钥派生过程中。CPUSVN是一个128位的值，根据SDM，它反映了处理器的微码更新版本。</p><p>SDM没有描述CPUSVN的结构，但是它指出使用整型比较来比较CPUSVN的值是没有意义的，并且只有一些CPUSVN值是有效的。此外，CPUSVNs承认的排序关系与enclave SVNs之间的排序关系具有相同的语义。特别地，一个SGX实现将考虑所有具有较低SVN的SGX实现由于安全漏洞而受到损害，并且不会信任它们。</p><p>SGX的一项专利披露，CPUSVN是小整数的串联，这些小整数表示构成SGX实现的各种组件的svn。这种结构与SDM中所做的所有声明一致。</p><h3 id="5-7-4-建立Enclave身份">5.7.4 建立Enclave身份</h3><p>当EINIT(<a href="#5.3.3-%E5%88%9D%E5%A7%8B%E5%8C%96">§5.3.3</a>)指令准备执行代码的enclave时，它还会设置SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)字段，这些字段组成enclave的基于证书的标识，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204429025.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204429025.png" srcset="data:image/png;base64,666" alt="image-20201128204429025"></p><p><code>EINIT</code>需要颁发给enclave的SIGSTRUCT证书的虚拟地址，并使用证书中的信息初始化enclave的SECS中的基于证书的标识信息。在使用证书中的信息之前，<code>EINIT</code>首先验证其RSA签名。SIGSTRUCT字段Q1和Q2，以及RSA指数3，简化了验证算法，这在§6.5中讨论。</p><p>如果发现SIGSTRUCT证书被正确签名，<code>EINIT</code>将按照下面几段中讨论的步骤确保将证书颁发给正在初始化的enclave。检查完成后，<code>EINIT</code>计算MRSIGNER,  SIGSTRUCT中模数字段的256位SHA-2哈希，并将其写入enclave的SECS中。<code>EINIT</code>还将ISVPRODID和ISVSVN字段从SIGSTRUCT复制到enclave的SECS中。正如在<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>中所解释的，这些字段构成了enclave的基于证书的标识。</p><p>在验证了SIGSTRUCT中的RSA签名之后，<code>EINIT</code>将签名的填充复制到enclave的SECS中的填充字段中。PKCS #1 v1.5填充方案不包含随机性，因此填充对于所有enclave应该具有相同的值。</p><p><code>EINIT</code>执行一些检查，以确保正在进行初始化的enclave确实是由提供的SIGSTRUCT证书授权的。最明显的检查包括确保SIGSTRUCT中的MRENCLAVE值等于enclave的度量，后者存储在enclave的SECS中的MRENCLAVE字段中。</p><p>但是，MRENCLAVE没有涵盖enclave的属性，这些属性存储在SECS的ATTRIBUTES字段中。正如在<a href="#5.6.2-%E5%BA%A6%E9%87%8FEnclave%E5%B1%9E%E6%80%A7">§5.6.2</a>中所讨论的，从MRENCLAVE中省略一个ATTRIBUTES有助于编写具有优化实现的enclave，这些实现可以在存在时使用架构扩展，也可以在没有扩展的情况下在CPU上工作的回退实现。当使用XFRM(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a> <a href="#5.2.5-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%8C%BA%E5%9F%9F-(SSA)">§5.2.5</a>)属性中的各种值构建时，这样的enclave可以正确执行。与此同时，允许系统软件在ATTRIBUTES字段中使用任意值，将危及SGX的安全保证。</p><p>当enclave使用软件认证(§3.3)访问机密时，用于构建该机密的附加值包含在SGX认证签名(<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>)中。这使认证过程中的远程方有机会拒绝使用不需要的ATTRIBUTES值构建的enclave。但是，当使用基于证书的身份验证的迁移过程获得机密时，没有远程方可以检查enclave的属性。</p><p>SGX设计通过让enclave作者在为enclave颁发的SIGSTRUCT证书的ATTRIBUTES和ATTRIBUTEMASK字段中为enclave传递一组可接受的属性值来解决这个问题。如果在SECS中的ATTRIBUTES字段和SIGSTRUCT中的ATTRIBUTESMASK字段之间的位不等于SIGSTRUCT中的ATTRIBUTES字段，<code>EINIT</code>将拒绝使用SIGSTRUCT初始化enclave。此检查可防止具有不需要的属性的enclave在迁移过程中获取或泄漏机密。</p><p>任何enclave作者都可以使用SIGSTRUCT来请求enclave的ATTRIBUTES字段中的任何位为零。但是，对于由Intel签署的enclave，某些位只能设置为1。<code>EINIT</code>有一个限制ATTRIBUTES比特的掩码，在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中讨论过。<code>EINIT</code>实现包含一个硬编码的MRSIGNER值，该值用于标识英特尔的特权enclave，并且只允许使用与受限制掩码中的任何位匹配的ATTRIBUTES值构建特权enclave。这个检查对于SGX软件认证过程的安全性是至关重要的，这在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中描述。</p><p>最后，<code>EINIT</code>还检查SIGSTRUCT中的VENDOR字段。专用于SIGSTRUCT的一节中对VENDOR字段的SDM描述表明，该字段本质上用于区分由Intel签名的特殊enclave(使用VENDOR值0x8086)和其他所有人的enclave(使用VENDOR值0)。然而，<code>EINIT</code>伪代码似乎暗示了SGX实现只检查VENDOR是否为0或0x8086。</p><h3 id="5-7-5-Enclave密钥分发">5.7.5 Enclave密钥分发</h3><p>SGX的秘密迁移机制基于<code>EGETKEY</code>指令提供给enclave的对称密钥分发服务，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204651510.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204651510.png" srcset="data:image/png;base64,666" alt="image-20201128204651510"></p><p><code>EGETKEY</code>生成的密钥是基于当前enclave的SECS中的身份信息和存储在支持SGX的处理器内的安全硬件中的两个秘密分发的。其中一个秘密是对基本没有文档记录的一系列转换的输入，这些转换为密钥分发过程背后的加密原语生成对称密钥。另一个秘密，在SDM中称为CR_SEAL_FUSES，是在关键推导材料中使用的信息片段之一。</p><p>SDM没有指定密钥分发算法，但SGX专利披露密钥是使用FIPS SP 800-108中描述的方法，使用AES-CMAC]作为伪随机函数(PRF)。同样的专利声明，用于密钥分发的秘密存储在CPU的e-fuse中，这一点在ISCA 2015 SGX教程中得到证实。</p><p>这一附加信息意味着，使用相同密钥分发材料的所有<code>EGETKEY</code>调用将产生相同的密钥，即使是跨CPU能量周期。此外，如果不访问存储在CPU e-fuse中的密钥，对手是不可能从特定密钥派生材料中获得密钥的。SGX的关键层次结构在<a href="#5.8.2%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81">§5.8.2</a>中有进一步的描述。</p><p>下面的段落讨论密钥分发材料中使用的数据片段，这些数据片段由下表中所示的密钥请求(KEYREQUEST)结构选择：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204721723.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204721723.png" srcset="data:image/png;base64,666" alt="image-20201128204721723" style="zoom:80%;" /><p>KEYREQUEST中的KEYNAME字段总是参与密钥生成，它指示要生成的键的类型。虽然SGX设计定义了一些密钥类型，但秘密迁移特性总是使用密封密钥。其他关键类型由SGX软件认证过程使用，将在<a href="#5.8-SGX%E8%BD%AF%E4%BB%B6%E8%AE%A4%E8%AF%81">§5.8</a>中概述。</p><p>KEYREQUEST中的KEYPOLICY字段有两个标志，用于指示是否将使用enclave的SECS中的MRENCLAVE和MRSIGNER字段进行密钥分发。虽然字段允许4个值，但只有两个值是有意义的，如下所述。</p><p>在KEYPOLICY中设置MRENCLAVE标志将分发的密钥与反映其内容的当前enclave度量绑定。其他enclave将无法获得相同的密钥。当分发的密钥用于加密enclave秘密时，这是非常有用的，因此它们可以由系统软件存储在非易失性内存中，从而在电源周期中存活。</p><p>如果设置了KEYPOLICY中的MRSIGNER标志，则分发的密钥将绑定到发布enclave证书的公共RSA密钥。因此，由同一作者发布的其他enclave可能能够获得相同的密钥，但要遵守下面的限制。这是唯一允许秘密迁移的KEYPOLICY值。</p><p>在KEYPOLICY中不设置标志没有什么意义。在这种情况下，分发的密钥没有有用的安全属性，因为它可以由与调用<code>EGETKEY</code>的enclave完全无关的其他enclave获得。相反，设置两个标志是多余的，因为仅设置MRENCLAVE就会导致分发的密钥绑定到当前enclave，这是最严格的策略。</p><p>KEYREQUEST结构指定了密钥分发过程中使用的enclave SVN (ISVSVN，<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>)和SGX实现SVN  (CPUSVN，<a href="#5.7.3-CPU%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC%E5%8F%B7">§5.7.3</a>)。但是，如果期望的enclave SVN大于当前enclave的SVN，或者期望的SGX实现的SVN大于当前实现的SVN,  <code>EGETKEY</code>将拒绝派生请求并生成一个错误代码。</p><p>SVN限制可以防止秘密从具有较高SVN的集合转移到具有较低SVN的集合，或者从具有较高SVN的SGX实现转移到具有较低SVN的实现。<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>认为SVN限制可以减少enclave和SGX实施中安全漏洞的影响。</p><p><code>EGETKEY</code>总是使用来自当前enclave的SECS的ISVPRODID值进行密钥分发。因此，秘密永远不能在其SIGSTRUCT证书为其分配不同产品ID的enclaves之间流动。</p><p>类似地，密钥分发材料总是包含128位所有者轮数(OWNEREPOCH)SGX配置寄存器的值。这个寄存器是由计算机的固件设置为一个秘密生成一次，并存储在非易失性内存。在计算机更改所有权之前，旧的所有者可以从非易失性内存中清除OWNEREPOCH，从而使新所有者无法解密任何可能留在计算机上的enclave机密。</p><p>由于密钥分发过程的加密特性，外部观察者无法关联使用不同的OWNEREPOCH值分发的密钥。这使得软件开发人员不可能使用本节中描述的<code>EGETKEY</code>分发的密钥来跟踪处理器更改所有者。</p><p><code>EGETKEY</code>分发材料还在KEYID字段中包含由enclave提供的256bit值。这使得enclave可以从<code>EGETKEY</code>生成密钥集合，而不是单个密钥。SDM规定KEYID应该用随机数填充，目的是帮助防止密钥损耗。</p><p>最后，密钥分发材料包括enclave的SECS中的ATTRIBUTES(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)字段的位和和KEYREQUEST结构中的ATTRIBUTESMASK字段。该掩码的作用是从密钥分发材料中删除一些ATTRIBUTES比特，从而使在具有不同属性的enclave之间迁移秘密成为可能。<a href="#5.6.2-%E5%BA%A6%E9%87%8FEnclave%E5%B1%9E%E6%80%A7">§5.6.2</a>和<a href="#5.7.4-%E5%BB%BA%E7%AB%8BEnclave%E8%BA%AB%E4%BB%BD">§5.7.4</a>解释此功能的需要及其安全含义。</p><p>在将掩码属性值添加到密钥生成材料之前，<code>EGETKEY</code>强制掩码位对应<code>INIT</code>和调试属性(<a href="#5.2.2-SGX-Enclave%E5%B1%9E%E6%80%A7">§5.2.2</a>)。从实用的角度来看，这意味着秘密永远不会支持调试和生产的enclave之间迁移。</p><p>如果没有此限制，enclave作者使用相同的RSA密钥向调试和生产enclave颁发证书将是不安全的。调试enclave没有从SGX获得完整性保证，因此攻击者有可能修改调试enclave内的代码，使其泄漏它所能访问的任何秘密。</p><h2 id="5-8-SGX软件认证">5.8 SGX软件认证</h2><p>SGX实施的软件认证方案遵循了§3.3中概述的原则。启用SGX的处理器计算加载在每个enclave中的代码和数据的度量，这类似于TPM计算的度量(§4.4)。enclave内部的软件可以启动一个进程，从而产生SGX认证签名，其中包括enclave的度量和enclave消息。</p><p>SGX认证签名中使用的密码原语过于复杂，无法在硬件上实现，因此签名过程是由英特尔发行的一个有特权的引用Enclave来执行的，它可以访问SGX认证密钥。这个enclave在<a href="#5.8.2-%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81">§5.8.2</a>中进行了讨论。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204833328.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204833328.png" srcset="data:image/png;base64,666" alt="image-20201128204833328"></p><p>图79: 建立一个SGX enclave并进行软件认证过程涉及到SGX指令<code>EINIT</code>和<code>EREPORT</code>，以及两个由英特尔编写的特殊enclave，SGX启动enclave和SGX引用enclave。</p><p>将签名功能推入引用Enclave，就需要在正在进行软件认证的Enclave和引用Enclave之间建立安全通信路径。SGX设计通过本地认证机制解决了这个问题，enclave可以使用该机制向同一启用SGX的CPU托管的任何其他enclave证明其身份。<a href="#5.8.1-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81">§5.8.1</a>中描述的这个方案是通过<code>EREPORT</code>指令实现的。</p><p>引用enclave使用的SGX认证密钥在启用SGX的处理器离开工厂时不存在。认证密钥是稍后提供的，使用的过程包括一个由Intel发布的配置Enclave和两种特殊的<code>EGETKEY</code>(<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>)密钥类型。这一过程的公开细节概述在<a href="#5.8.2-%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81">§5.8.2</a>中。</p><p>SGX启动enclave和<code>EINITTOKEN</code>结构将在<a href="#5.9-SGX%E5%90%AF%E5%8A%A8%E6%8E%A7%E5%88%B6">§5.9</a>中讨论。</p><h3 id="5-8-1-本地认证">5.8.1 本地认证</h3><p>enclave通过如图80所示的<code>EREPORT</code>指令向另一个目标enclave证明其身份。SGX指令生成一个认证报告(报告)，该报告以加密方式将enclave提供的消息与enclave的基于度量(<a href="#5.6-SGX-Enclave%E5%BA%A6%E9%87%8F">§5.6</a>)和基于证书(<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>)的身份绑定。加密绑定由MAC标签(§3.1.3)完成，MAC标签使用对称密钥计算，该密钥仅在目标enclave和SGX实现之间共享。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204914002.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204914002.png" srcset="data:image/png;base64,666" alt="image-20201128204914002"></p><p>​图80：EREPORT数据流</p><p><code>EREPORT</code>指令从enclave的SECS(<a href="#5.1.3-SGX-Enclave%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-(SECS)">§5.1.3</a>)中读取当前enclave的标识信息，并使用它填充报告结构。具体来说，<code>EREPORT</code>会复制SECS字段，这些字段表示enclave的度量(MRENCLAVE)、基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)和属性(ATTRIBUTES)。认证报告还包括SGX实现的SVN(CPUSVN)和enclave提供的64字节(512位)消息。</p><p>接收认证报告的目标enclave可以确信报告的真实性，如图81所示。这份报告的真实性证明是它的MAC标签。验证MAC所需的密钥只能由目标enclave获得，通过要求<code>EGETKEY</code>(<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>)分发一个报告密钥。SDM声明MAC标记是使用基于块加密的MAC (CMAC)计算的，但是没有指定底层密码。SGX文件之一声明CMAC是基于128位AES。</p><p><code>EGETKEY</code>返回的报告密钥来自于嵌入在处理器中的一个秘密(<a href="#5.7.5-Enclave%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91">§5.7.5</a>)，密钥材料包括目标enclave的度量。可以确保目标enclave报告中的MAC标签是由SGX产生的，原因如下。底层密钥分发的加密特性推导和MAC算法确保只有SGX所实现可以产生MAC标签，因为它是唯一的实体，可以访问处理器的秘密，这是不可能对攻击者获得报告密钥不知道处理器的秘密。SGX的设计保证了<code>EGETKEY</code>生成的密钥依赖于调用enclave的度量，因此只有目标enclave才能获得报告中用于生成MAC标签的密钥。</p><p>当KEYNAME设置为与报告密钥相关联的值时，<code>EREPORT</code>使用与EGETKEY相同的密钥分发过程。因此，<code>EREPORT</code>需要<em>报告目标信息</em>(TARGETINFO)结构的虚拟地址，该结构包含基于度量的标识和目标enclave的属性。</p><p>在分发一个报告密钥时，<code>EGETKEY</code>的行为与它在密封密钥情况下的行为略有不同，如图81所示。密钥生成材料从不包括与enclave的基于证书的身份(MRSIGNER、ISVPRODID、ISVSVN)对应的字段，并且KEYREQUEST结构中的KEYPOLICY字段将被忽略。因此，该报告只能由目标enclave加以核实。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204934312.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128204934312.png" srcset="data:image/png;base64,666" alt="image-20201128204934312"></p><p>图81: 由<code>EREPORT</code>创建的报告结构的真实性可以而且应该由报告的目标enclave验证。目标代码使用<code>EGETKEY</code>获取嵌入在报告结构中的MAC标记使用的密钥，然后验证标记。</p><p>此外，SGX实现用于密钥生成的SVN  (CPUSVN)值是由当前的CPUSVN决定的，而不是从密钥请求结构中读取。因此，SGX实现升级，增加CPUSVN使所有未完成的报告无效。鉴于CPUSVN的增加与安全修复有关，<a href="#5.7.2-%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84Enclave%E8%BA%AB%E4%BB%BD">§5.7.2</a>中的论证表明，这一限制可能会减少SGX实现中漏洞的影响。</p><p>最后，<code>EREPORT</code>将密钥生成材料中的KEYID字段设置为SGX配置寄存器(CR_REPORT_KEYID)的内容，该寄存器在初始化SGX时以随机值初始化。KEYID值也保存在认证报告中，但是它不包含在MAC标签中。</p><!--### 5.8.2 远程认证远程认证过程包括引用Enclave和基础密钥，在Intel的一份出版物中对其进行了高层介绍。本节的内容基于SDM、一篇SGX论文和ISCA 2015 SGX tutorial。SGX的软件认证方案，如图82所示，依赖于密钥生成设施和供应服务，两者都由英特尔运营。![image-20201128205219513](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128205219513.png)图82:SGX的软件认证基于存储在处理器芯片内的e-fuse中的两个秘密，以及从英特尔供应服务接收的密钥。在制造过程中，一个启用了SGX的处理器与英特尔的密钥生成设备进行通信，并有两个秘密被烧到e-fuse中。e-fuse是一种一次性可编程存储介质，可以经济地包含在高性能芯片上。我们将把存储在e-fuse中的秘密称为供应秘密和密封秘密。供应秘密是输出`EGETKEY`使用的SGX主衍生密钥的过程的主要输入，图78、79、80和81中引用了这个过程。密封秘密不会通过SDM中记录的任何架构机制暴露给软件。只有当秘密包含在`EGETKEY`实现的密钥推导过程所使用的材料中时，该秘密才能被访问([§5.7.5](#5.7.5-Enclave密钥分发))。SDM中的伪代码使用CR_SEAL_FUSES起存其名来引用密封机密。名称“Seal Secret”和“Provisioning Secret”与英特尔的官方文件有所不同，后者使用“Seal Key”和“Provisioning  Key”来指代存储在e-fuse中的秘密和`EGETKEY`分发的密钥，这令人困惑。SDM简要地描述了`EGETKEY`生成的密钥，但是没有官方文档明确地描述e-fuse中的秘密。下面的描述是对所有公共信息来源的唯一解释，它与SDM关于关键来源的所有声明一致。![image-20201128205236786](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128205236786.png)![image-20201128205249675](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128205249675.png)## 5.9 SGX启动控制### 5.9.1 Enclave属性访问控制![image-20201128210858231](https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/translation-sgx-programming-model/image-20201128210858231.png)### 5.9.2 许可证### 5.9.3 系统软件可以执行启动策略### 5.9.4 Enclave不能损坏主机计算机### 5.9.5 与杀毒软件交互-->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
          <category> SGX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSDN博客保存为PDF</title>
      <link href="2020/11/26/csdn-pdf/"/>
      <url>2020/11/26/csdn-pdf/</url>
      
        <content type="html"><![CDATA[<p>F12打开开发者工具，在Console输入以下js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> articleBox = $(<span class="string">&quot;div.article_content&quot;</span>);</span><br><span class="line">articleBox.removeAttr(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;#btn-readmore&quot;</span>).parent().remove();</span><br><span class="line">$(<span class="string">&quot;#side&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;#comment_title, #comment_list, #comment_bar, #comment_form, .announce, #ad_cen, #ad_bot&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.nav_top_2011, #header, #navigator&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.csdn-side-toolbar,.template-box,.reward-user-box,.blog-footer-bottom&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.p4course_target, .comment-box, .recommend-box, #csdn-toolbar, #tool-box,#dmp_ad_58, .more-toolbox, .article-info-box, .btn-readmore, .pub-footer-new&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;aside&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;.tool-box&quot;</span>).remove();</span><br><span class="line">$(<span class="string">&quot;main&quot;</span>).css(<span class="string">&#x27;display&#x27;</span>,<span class="string">&#x27;content&#x27;</span>); </span><br><span class="line">$(<span class="string">&quot;main&quot;</span>).css(<span class="string">&#x27;float&#x27;</span>,<span class="string">&#x27;left&#x27;</span>); </span><br><span class="line">$(<span class="string">&quot;#mainBox&quot;</span>).width(<span class="string">&quot;100%&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].style.zoom=<span class="number">0.8</span>;</span><br><span class="line"><span class="built_in">window</span>.print();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">doPrint</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> articleBox = $(<span class="string">&quot;div.article_content&quot;</span>);</span><br><span class="line">articleBox.removeAttr(<span class="string">&quot;style&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> head_str = <span class="string">&quot;&quot;</span>;       </span><br><span class="line"><span class="keyword">var</span> foot_str = <span class="string">&quot;&quot;</span>;   </span><br><span class="line"><span class="keyword">var</span> older = <span class="built_in">document</span>.body.innerHTML;       </span><br><span class="line"><span class="keyword">var</span> title= <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;article-title-box&#x27;</span>)[<span class="number">0</span>].innerHTML; </span><br><span class="line"><span class="keyword">var</span> main_body = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;article_content&#x27;</span>)[<span class="number">0</span>].innerHTML;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = head_str + title + main_body + foot_str;</span><br><span class="line">$(<span class="string">&quot;#mainBox&quot;</span>).width(<span class="string">&quot;100%&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].style.zoom=<span class="number">0.8</span>;     </span><br><span class="line"><span class="built_in">window</span>.print();</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = older;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Useful Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学 Notes</title>
      <link href="2020/11/25/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/"/>
      <url>2020/11/25/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="古典替换密码">古典替换密码</h2><h3 id="恺撒密码">恺撒密码</h3><p>每个字母用其后的第三个字母替换，即</p><blockquote><p>Plain:   ABCDEFGHIJKLMNOPQRSTUVWXYZ</p><p>Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC</p></blockquote><ul><li>恺撒密码的一般形式，可以将字母移动的位数由3变为1-25中的任何一个</li></ul><h3 id="混合单表替换密码">混合单表替换密码</h3><ul><li>每个字母可以用其它任何一个字母替换（不能重复）</li><li>密钥长度为26个字母，因为每个字母需要一个映射</li></ul><h3 id="简单的单表替换密码">简单的单表替换密码</h3><ul><li>设置一个没有重复字母的“密钥字”，其它字母按顺序写在密钥字最后字母后面</li></ul><blockquote><p>给定密钥字 JULISCAER</p><p>Plain:   ABCDEFGHIJKLMNOPQRSTUVWXYZ</p><p>Cipher: JULISCAERTVWXYZBDFGHKMNOPQ</p></blockquote><h3 id="多字母替换密码">多字母替换密码</h3><p>使用多个单字母替换表，因此一个字母可以被多个字母替换：用一个密钥选择每个字母使用哪个字母表，密钥的第i个字母表示使用第i个字母表，依次使用每个字母表，当密钥的字母使用完后，再从头开始</p><h2 id="古典置换密码">古典置换密码</h2><ul><li>方法：通过重新编排消息字母隐藏信息</li><li>特点：没有改变原来消息的字母集</li><li>关键思想：<strong>按一定规则写出明文，按另一规则读出密文</strong></li><li>密钥：用于读密文的方法和写明文的方法</li></ul><h2 id="分组密码">分组密码</h2><p>在分组密码中，消息被分成许多块，每块都要被加密</p><h3 id="替换运算-S-boxes">替换运算 S-boxes</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210011605.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210011605.png" srcset="data:image/png;base64,666" alt="image-20201125210011605" style="zoom:56%;" /><ul><li><p>一个二进制字用其它二进制字替换，这种替换函数就构成密钥，可以看作是一个大的查表运算</p></li><li><p>混淆：使作用于明文的密钥和密文之间的关系复杂化</p></li></ul><h3 id="置换运算-P-boxes">置换运算 P-boxes</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205943924.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205943924.png" srcset="data:image/png;base64,666" alt="image-20201125205943924" style="zoom:67%;" /><ul><li>二进制字次序被打乱，重新排序的方法构成密钥</li><li>扩散：将明文及密钥的影响尽可能迅速地散布到较多个输出的密文中</li></ul><h4 id="雪崩效应">雪崩效应</h4><ul><li>输入改变1bit, 导致近一半的比特发生变化</li><li>保证小的输入变化导致大的输出变化</li></ul><h4 id="完备性效应">完备性效应</h4><ul><li>每个输出比特是所有输入比特的复杂函数的输出</li><li>保证每个输出比特依赖于所有的输入比特</li></ul><h3 id="Feistel密码">Feistel密码</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125203244552.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125203244552.png" srcset="data:image/png;base64,666" alt="image-20201125203244552" style="zoom: 50%;" /><blockquote><ul><li>把输入块分成左右两部分</li><li>轮函数g是一个S-P网络</li><li>由第i个密钥控制（子密钥）</li></ul><p>L(i) = R(i-1)</p><p>R(i) = L(i-1) xor g(K(i), R(i-1))</p></blockquote><ul><li>求逆很容易</li><li>实际中，一些这样的连续变换形成完整密码变换</li></ul><h4 id="Feistel密码设计">Feistel密码设计</h4><ul><li>分组大小：增加分组长度会提高安全性, 但降低了密码运算速度</li><li>密钥大小：增加密钥长度可以提高安全性(使得穷搜索困难)，但降低了密码速度</li><li>轮数：增加轮数可以提高安全性，但降低速度</li><li>子密钥生成：子密钥生成越复杂就越安全，但降低速度</li></ul><h3 id="Lucifer">Lucifer</h3><ul><li>分组长度是128-bit，密钥长度是128-bit</li><li>每轮使用的子密钥是密钥的左半部分</li><li>密钥每次要向左旋转56-bits，所以密钥的每部分都参加运算</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210039067.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125210039067.png" srcset="data:image/png;base64,666" alt="image-20201125210039067" style="zoom: 67%;" /><p>轮函数的具体结构：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205433305.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201125205433305.png" srcset="data:image/png;base64,666" alt="image-20201125205433305" style="zoom:67%;" /><h2 id="现代分组加密算法">现代分组加密算法</h2><h3 id="简化的DES-S-DES">简化的DES (S-DES)</h3><p>加密算法涉及五个函数：</p><ul><li>初始置换 IP</li><li>复合函数 f<sub>k1</sub> ，由密钥K确定，具有转换和替换的运算</li><li>转换函数 SW</li><li>复合函数 f<sub>k2</sub></li><li>初始置换IP的逆置换 IP<sup>-1</sup></li></ul><h4 id="加解密流程">加解密流程</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126105757628.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126105757628.png" srcset="data:image/png;base64,666" alt="image-20201126105757628" style="zoom:55%;" /><ul><li><p>密文 = IP<sup>-1</sup>(f<sub>k2</sub>(SW(f<sub>k1</sub>(IP(明文)))))</p></li><li><p>明文 = IP<sup>-1</sup>(f<sub>k1</sub>(SW(f<sub>k2</sub>(IP(密文)))))</p></li><li><p>密钥生成：</p><ul><li><p>P10(k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub>, k<sub>4</sub>, k<sub>5</sub>, k<sub>6</sub>, k<sub>7</sub>, k<sub>8</sub>, k<sub>9</sub>, k<sub>10</sub>) = (k<sub>3</sub>, k<sub>5</sub>, k<sub>2</sub>, k<sub>7</sub>, k<sub>4</sub>, k<sub>10</sub>, k<sub>1</sub>, k<sub>9</sub>, k<sub>8</sub>, k<sub>6</sub>)</p></li><li><p>P8(k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub>, k<sub>4</sub>, k<sub>5</sub>, k<sub>6</sub>, k<sub>7</sub>, k<sub>8</sub>, k<sub>9</sub>, k<sub>10</sub>) = (k<sub>6</sub>, k<sub>3</sub>, k<sub>7</sub>, k<sub>4</sub>, k<sub>8</sub>, k<sub>5</sub>, k<sub>10</sub>, k<sub>9</sub>)</p></li><li><p>LS-1为循环左移1位，LS-2为循环左移2位</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126120725293.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126120725293.png" srcset="data:image/png;base64,666" alt="image-20201126120725293" style="zoom:50%;" /></li></ul></li><li><p>IP函数：</p><blockquote><p>IP=   1 2 3 4 5 6 7 8</p><p>​        2 6 3 1 4 8 5 7</p><p>IP<sup>-1</sup>=   1 2 3 4 5 6 7 8</p><p>​          4 1 3 5 7 2 8 6</p></blockquote></li><li><p>函数f<sub>k</sub>：f<sub>k</sub>(L, R) = (L xor F(R, SK), R) , 其中SK为子密钥</p><ul><li><p>F是一个4-bit到4-bit的映射：</p><ul><li><p>首先对R做扩张/置换(E/P)运算</p><blockquote><p>E/P运算：(1, 2, 3, 4)  =&gt;  (4, 1, 2, 3, 2, 3, 4, 1)</p></blockquote></li><li><p>将子密钥SK（对应具体算法中的K<sub>1</sub>和K<sub>2</sub>）与E/P运算的结果异或得到8-bit数</p><blockquote><p>P0,0    P0,1    P0,2    P0,3</p><p>P1,0    P1,1    P1,2    P1,3</p></blockquote></li><li><p>第一行进入S盒S0，第二行进入S盒S1，分别产生2-bit输出</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123020454.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123020454.png" srcset="data:image/png;base64,666" alt="image-20201126123020454" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123032631.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123032631.png" srcset="data:image/png;base64,666" alt="image-20201126123032631" style="zoom:50%;" /><blockquote><p>第1和第4输入比特决定行，第2和第3输入比特决定列，以确定选取S-盒元素的位置</p><p>如 (P0,0 P0,3)=(0 0),并且(P0,1 P0,2)=(1 0)，则选取S盒矩阵的第0行第2列的元素作为2-bit输出</p></blockquote></li></ul></li></ul></li><li><p>加密具体过程</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123926304.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126123926304.png" srcset="data:image/png;base64,666" alt="image-20201126123926304" style="zoom:55%;" /><h3 id="数据加密标准DES">数据加密标准DES</h3><h4 id="DES加密流程">DES加密流程</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126130554342.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126130554342.png" srcset="data:image/png;base64,666" alt="image-20201126130554342" style="zoom:60%;" /><blockquote><ol><li>对明文X，通过一个固定的初始置换IP得到X<sub>0</sub>：<br>X<sub>0</sub> = IP(X) = L<sub>0</sub>R<sub>0</sub> , 分为左右两部分。</li><li>函数F的16次迭代：L<sub>i</sub>R<sub>i</sub> (1&lt;=i&lt;=16）<br>L<sub>i</sub> = R<sub>i-1</sub> ,    R<sub>i</sub> = L<sub>i-1</sub> xor F(R<sub>i-1</sub>, K<sub>i</sub>)<br>其中K<sub>i</sub>是长为48位的子密钥。</li><li>对比特串R<sub>16</sub>L<sub>16</sub>使用逆置换IP<sup>-1</sup>得到密文Y：<br>Y = IP<sup>-1</sup>(R<sub>16</sub>L<sub>16</sub>)</li></ol></blockquote><p><a href="#DES%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E8%A1%A8">加密相关的表见附录</a></p><h4 id="DES一轮加密">DES一轮加密</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140254793.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140254793.png" srcset="data:image/png;base64,666" alt="image-20201126140254793" style="zoom:50%;" /><h5 id="轮函数F">轮函数F</h5><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140406545.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140406545.png" srcset="data:image/png;base64,666" alt="image-20201126140406545" style="zoom:40%;" /><p>F(R<sub>i-1</sub>, K<sub>i</sub>) ，输入为32-bit的R<sub>i-1</sub>和48-bit的子密钥K<sub>i</sub></p><blockquote><ol><li>对R<sub>i-1</sub>使用扩展函数E，扩展为48-bit</li><li>计算 E(R<sub>i-1</sub>) xor K<sub>i</sub> ，结果写成8个6-bit串 B=b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>b<sub>6</sub></li><li>使用8个4*16的S盒，其中的元素取0~15的整数，每个S盒输出为4-bit串：<ul><li>b<sub>1</sub>b<sub>6</sub>确定S盒的行数，b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>确定S盒的列数</li></ul></li><li>最后，P为固定置换，输出为32-bit串</li></ol></blockquote><h4 id="密钥K计算子密钥">密钥K计算子密钥</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126142937157.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126142937157.png" srcset="data:image/png;base64,666" alt="image-20201126142937157" style="zoom:55%;" /><p>密钥K是长度为64的位串：56位参加子密钥编排，8位是奇偶校验位，在密钥编排的计算中，不参加运算。</p><blockquote><ol><li><p>给定64位的密钥K，放弃奇偶校验位(8, 16, …, 64)，先进行PC-1固定置换，结果为前28-bit的C<sub>0</sub>和后28-bit的D<sub>0</sub></p></li><li><p>对1 &lt;= i &lt;= 16，计算</p><p>C<sub>i</sub> = LS<sub>i</sub>(C<sub>i-1</sub>)</p><p>D<sub>i</sub> = LS<sub>i</sub>(D<sub>i-1</sub>)</p><p>其中LS<sub>i</sub>表示循环左移1或2位，当i=1,2,9,16时移1位，其他情况移2位</p></li><li><p>计算 K<sub>i</sub> = PC-2(C<sub>i</sub>D<sub>i</sub>)</p></li></ol></blockquote><h4 id="DES的S盒">DES的S盒</h4><p>DES的核心是S盒</p><ul><li>S盒不是它输入变量的线性函数</li><li>改变S盒的一个输入位至少要引起两位的输出改变</li><li>对任何一个S盒，如果固定一个输入比特，其它输入变化时，输出数字中0和1的总数近于相等</li></ul><h4 id="双重DES">双重DES</h4><blockquote><p>加密：C = E<sub>K2</sub>[E<sub>K1</sub>[P]]</p><p>解密：P = D<sub>K1</sub>[D<sub>K2</sub>[P]]</p></blockquote><h4 id="三重DES">三重DES</h4><blockquote><p>两个密钥加密：C = E<sub>K1</sub>[D<sub>K2</sub>[E<sub>K1</sub>[P]]]</p></blockquote><h3 id="IDEA">IDEA</h3><ul><li>分组长度为64位，子分组长度为16位</li><li>密钥长度为128位</li><li>进行8轮循环</li><li>同一算法既可以加密也可以解密</li></ul><h4 id="IDEA加密总体方案">IDEA加密总体方案</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126144958945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126144958945.png" srcset="data:image/png;base64,666" alt="image-20201126144958945" style="zoom:50%;" /><h4 id="IDEA加密具体过程">IDEA加密具体过程</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145235594.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145235594.png" srcset="data:image/png;base64,666" alt="image-20201126145235594" style="zoom:60%;" /><ul><li><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145539436.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126145539436.png" srcset="data:image/png;base64,666" alt="image-20201126145539436" style="zoom:80%;" />是整数模2<sup>16</sup>+1乘 (IDEA的S盒)</li><li><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126145717202.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126145717202.png" srcset="data:image/png;base64,666" alt="image-20201126145717202">是整数模2<sup>16</sup>加</li></ul><h4 id="IDEA的密钥生成">IDEA的密钥生成</h4><p>52个16-bit的加密子密钥从128-bit的密钥中生成：</p><blockquote><ol><li>前8个子密钥直接从密钥中取出；</li><li>对密钥进行25-bit循环左移，接下来的密钥从中取出；</li><li>重复进行直到52个子密钥全部生成。</li></ol></blockquote><p>解密密钥从加密子密钥中导出：</p><blockquote><ul><li>解密循环 i 的前4个子密钥从加密循环 10-i 的前4个子密钥中导出：<ul><li>解密密钥的第1、4个子密钥对应于1、4加密子密钥的<strong>乘法逆元</strong>；</li><li>解密密钥的第2、3个子密钥对应于2、3加密子密钥的<strong>加法逆元</strong></li></ul></li><li>对前8个循环来说，循环 i 的最后两个子密钥等于加密循环 9-i 的最后两个子密钥</li></ul></blockquote><h3 id="AES-Rijndael">AES-Rijndael</h3><ul><li>可变块长、可变密钥长度<ul><li>分组长度指定为128位</li><li>密钥长度为128，192或256位，相应的迭代轮数为10、12和14</li></ul></li></ul><h4 id="AES框架">AES框架</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126151721262.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126151721262.png" srcset="data:image/png;base64,666" alt="image-20201126151721262" style="zoom:60%;" /><h4 id="AES轮函数">AES轮函数</h4><p>每一轮迭代的结构都一样，只是最后一轮省略了列混合变换：</p><h5 id="字节替换-Byte-Sub">字节替换(Byte Sub)</h5><p>对数据的每一字节应用一个非线性变换；</p><p><a href="#%E5%AD%97%E8%8A%82%E6%9B%BF%E6%8D%A2%E8%A1%A8">替换表</a>是一个16×16的矩阵。表中纵向的x取自状态矩阵中的高4比特，横向的y取自低4比特。</p><h5 id="行移位-Shift-Row">行移位(Shift Row)</h5><p>对每一行的字节循环重新排序，可以表示为:  B<sub>i,j</sub> = A<sub>i,(i+j)mod4</sub></p><h5 id="列混合-Mix-Column">列混合(Mix Column)</h5><p>对矩阵的列应用一个线性变换:</p><ul><li>将状态的每一列视为GF(2<sup>8</sup>)上的多项式S(x)，然后乘以固定多项式a(x)，并模除x<sup>4</sup>+1。其中a(x) = {03}x<sup>3</sup>+{01}x<sup>2</sup>+{01}x+{02}</li><li>a(x)存在关于x<sup>4</sup>+1的逆元，变换的矩阵为：</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163656799.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163656799.png" srcset="data:image/png;base64,666" alt="image-20201126163656799" style="zoom:50%;" /><ul><li>列混合变换的结果为：</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163743098.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126163743098.png" srcset="data:image/png;base64,666" alt="image-20201126163743098" style="zoom:50%;" /><h5 id="轮密钥加-Add-Round-Key">轮密钥加(Add Round Key)</h5><ul><li><p>把轮密钥混合到中间数据，对状态和每轮的子密钥进行简单的异或操作</p></li><li><p>每轮子密钥是通过密钥调度算法从主密钥中产生，子密钥长度等于分组长度</p></li><li><p>轮密钥加运算需要用到4个导出的32比特子密钥</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164006477.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164006477.png" srcset="data:image/png;base64,666" alt="image-20201126164006477" style="zoom:66%;" /><h4 id="AES子密钥生成">AES子密钥生成</h4><p>Rijindael算法每一轮需要用到N<sub>b</sub>比特的子密钥，共有N<sub>r</sub>轮，另外，第一次轮密钥加的时候也需要用一轮子密钥，于是总共需要N<sub>b</sub>*(N<sub>r</sub>+1)比特的子密钥，对于AES-128来说就是用1408比特的子密钥</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164423818.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164423818.png" srcset="data:image/png;base64,666" alt="image-20201126164423818" style="zoom:67%;" /><h4 id="AES解密过程">AES解密过程</h4><p>逆字节替换、逆行移位、逆列混合、轮密钥加(其逆变换就是本身)</p><h3 id="分组密码工作模式">分组密码工作模式</h3><h4 id="ECB-电码本模式">ECB 电码本模式</h4><ul><li>消息分成相互独立的加密模块</li><li>每块独立使用DES算法</li><li>适合少量的数据加密</li><li>如果最后一个分组长度不够，需要填充</li><li>对于同一个明文分组，如果出现多次，其密文是相同的，因为每次的加密密钥都相同 (<strong>缺陷</strong>)</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164736650.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126164736650.png" srcset="data:image/png;base64,666" alt="image-20201126164736650" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165303436.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165303436.png" srcset="data:image/png;base64,666" alt="image-20201126165303436" style="zoom:67%;" /><h4 id="CBC-密码分组链接模式">CBC 密码分组链接模式</h4><ul><li>使重复的明文分组产生不同的密文分组：每次加密使用相同加密密钥，但是输入是当前明文分组盒前一个密文分组的异或</li><li>适合加密长度大于64比特的消息</li><li>如果最后一个分组长度不够，需要填充</li><li>可以用来进行用户鉴别</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165145190.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165145190.png" srcset="data:image/png;base64,666" alt="image-20201126165145190" style="zoom:67%;" /><ul><li>解密时，每一个密文分组被解密后，再与前一个密文分组异或，便能得到明文分组</li><li>产生第一个密文分组时，需要一个初始向量IV与第一个明文分组异或，IV对于收发方都是已知的，且应该像密钥一样被保护</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165215403.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126165215403.png" srcset="data:image/png;base64,666" alt="image-20201126165215403" style="zoom:67%;" /><h4 id="CFB-密码反馈模式">CFB 密码反馈模式</h4><ul><li>消息作为比特流，不需要对消息填充</li><li>适合数据以比特或字节为单位出现</li><li>错误传播</li><li>可以用于认证</li></ul><p>加密过程：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170039554.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170039554.png" srcset="data:image/png;base64,666" alt="image-20201126170039554" style="zoom:67%;" /><p>解密过程：</p><ul><li>将收到的密文单元和加密函数的输出进行异或</li><li>仍然使用加密算法而不是解密算法</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170254044.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170254044.png" srcset="data:image/png;base64,666" alt="image-20201126170254044" style="zoom:67%;" /><h4 id="OFB-输出反馈模式">OFB 输出反馈模式</h4><ul><li>结构类似CFB，不同之处在于OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器</li><li>消息作为比特流，不需要对消息填充</li><li>比特错误不会被传播</li></ul><p>加密过程：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170529982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170529982.png" srcset="data:image/png;base64,666" alt="image-20201126170529982" style="zoom:67%;" /><p>解密过程：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170543567.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170543567.png" srcset="data:image/png;base64,666" alt="image-20201126170543567" style="zoom:67%;" /><h4 id="CTR-计算器模式">CTR 计算器模式</h4><ul><li>可并行加密</li><li>预处理</li><li>吞吐量仅受可使用并行数量的限制</li><li>加密数据块随机访问</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170708908.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126170708908.png" srcset="data:image/png;base64,666" alt="image-20201126170708908" style="zoom:67%;" /><h3 id="对称密码算法分析">对称密码算法分析</h3><h2 id="流密码">流密码</h2><h3 id="流密码简单结构">流密码简单结构</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083144531.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083144531.png" srcset="data:image/png;base64,666" alt="image-20201127083144531" style="zoom:67%;" /><ul><li>密钥源是一个容易记住的密钥</li><li>密钥流生成器生成一个周期较长、可用于加解密运算的伪随机序列</li></ul><h3 id="同步流密码与自同步流密码">同步流密码与自同步流密码</h3><h4 id="同步流密码">同步流密码</h4><ul><li>密钥流的产生与明文消息流相互独立</li><li>无错误传播：在传输期间一个密文字符被改变只影响该符号的恢复，不会对后继的符号产生影响</li></ul><h4 id="自同步流密码">自同步流密码</h4><p>密钥流的产生与之前已经产生的若干密文有关</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083600988.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083600988.png" srcset="data:image/png;base64,666" alt="image-20201127083600988" style="zoom:67%;" /><h3 id="线性反馈移位寄存器-LFSR">线性反馈移位寄存器 LFSR</h3><ul><li>用于生成密钥流：<ul><li>LFSR的结构非常适合硬件实现</li><li>LFSR的结构便于使用代数方法进行理论分析</li><li>产生的序列的周期可以很大</li><li>产生的序列具有良好的统计特性</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083933077.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127083933077.png" srcset="data:image/png;base64,666" alt="image-20201127083933077" style="zoom:67%;" /><ul><li><p>反馈函数为：<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084035769.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084035769.png" srcset="data:image/png;base64,666" alt="image-20201127084035769" style="zoom:60%;" />， 其中加法运算为模2加，乘法为普通乘法</p></li><li><p>第t+1时刻第i级寄存器的内容为：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084404733.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127084404733.png" srcset="data:image/png;base64,666" alt="image-20201127084404733" style="zoom:60%;" /></li><li><p>LFSR的联接多项式为：</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127090215010.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127090215010.png" srcset="data:image/png;base64,666" alt="image-20201127090215010" style="zoom:67%;" /></li></ul><h4 id="LFSR的周期与m序列">LFSR的周期与m序列</h4><ul><li>一个n级LFSR序列的周期最大只能是2<sup>n</sup>-1</li><li>若n级LFSR产生的非零序列的周期为2<sup>n</sup>-1，则称其为m序列</li><li>一个n级LFSR为最长移位寄存器的充要条件是它的联接多项式为F<sub>2</sub>上的n次本原多项式</li><li>2<sup>n</sup>-1为素数时，F<sub>2</sub>上的每一个n次不可约多项式均为n次本原多项式</li></ul><h3 id="伪随机序列">伪随机序列</h3><h4 id="Golomb随机性假设">Golomb随机性假设</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092052608.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092052608.png" srcset="data:image/png;base64,666" alt="image-20201127092052608" style="zoom:70%;" /><p>注：游程指一段连续的相同数字</p><h4 id="m序列的伪随机性">m序列的伪随机性</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127091508439.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127091508439.png" srcset="data:image/png;base64,666" alt="image-20201127091508439" style="zoom:70%;" /><h3 id="线性复杂度">线性复杂度</h3><p>线性复杂度：能够输出该序列的最小线性移位寄存器的级数，即次数最小的联接多项式</p><ul><li>如果序列的线性复杂度为l(&gt;=1)，则只要知道序列中任意相继的2l位，就可确定整个序列</li></ul><h3 id="安全的密钥流">安全的密钥流</h3><ul><li>周期充分长，一般不少于1016</li><li>随机统计特性好，即基本满足Golomb的随机性假设</li><li>大的线性复杂度，为序列长度的一半</li></ul><h3 id="基于LFSR的伪随机序列生成器">基于LFSR的伪随机序列生成器</h3><p>在LFSR的基础上加入非线性化的手段，产生适合于流密码应用的密钥序列(伪随机序列)</p><h4 id="滤波生成器">滤波生成器</h4><p>由一个n级线性移位寄存器和一个m(&lt;n)元非线性滤波函数组成，滤波函数的输出为密钥流序列</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092445491.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092445491.png" srcset="data:image/png;base64,666" alt="image-20201127092445491" style="zoom: 67%;" /><ul><li>g是一个m元布尔函数</li></ul><h4 id="组合生成器">组合生成器</h4><p>若干个线性移位寄存器LFSR<sub>i</sub>(i=1, …, n)和一个非线性组合函数组成，组合函数的输出构成密钥流序列</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092657734.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127092657734.png" srcset="data:image/png;base64,666" alt="image-20201127092657734" style="zoom:67%;" /><ul><li>其中LFSR<sub>i</sub>为n个级数分别为r<sub>1</sub>, r<sub>2</sub>, …, r<sub>n</sub>的线性移位寄存器</li><li>f是n元布尔函数</li></ul><h4 id="钟控制生成器">钟控制生成器</h4><p>用一个或多个移位寄存器来控制另一个或多个移位寄存器的时钟</p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093002106.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093002106.png" srcset="data:image/png;base64,666" alt="image-20201127093002106" style="zoom:67%;" /><ul><li>当LFSR<sub>1</sub>输出1时，移位时钟脉冲通过与门使LFSR<sub>2</sub>进行一次移位，从而生成下一位</li><li>当LFSR<sub>1</sub>输出0时，移位时钟脉冲无法通过与门影响LFSR<sub>2</sub>，因此LFSR<sub>2</sub>重复输出前一位</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093608989.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201127093608989.png" srcset="data:image/png;base64,666" alt="image-20201127093608989" style="zoom:77%;" /><ul><li>当LFSR<sub>1</sub>的输出是1时，LFSR<sub>2</sub>被时钟驱动</li><li>当LFSR<sub>1</sub>的输出是0时，LFSR<sub>3</sub>被时钟驱动</li><li>LFSR<sub>1</sub>的输出与LFSR<sub>2</sub>的输出做异或运算即为这个<strong>交错式停走生成器</strong>的输出</li></ul><h2 id="附录">附录</h2><h3 id="DES算法相关表">DES算法相关表</h3><h4 id="初始置换IP-对明文输入进行次序打乱">初始置换IP (对明文输入进行次序打乱)</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133239171.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133239171.png" srcset="data:image/png;base64,666" alt="image-20201126133239171" style="zoom: 40%;" /><h4 id="初始置换的逆置换IP-1">初始置换的逆置换IP<sup>-1</sup></h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133334739.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126133334739.png" srcset="data:image/png;base64,666" alt="image-20201126133334739" style="zoom:40%;" /><h4 id="扩展置换E-32-bit到48-bit">扩展置换E (32-bit到48-bit)</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135403930.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135403930.png" srcset="data:image/png;base64,666" alt="image-20201126135403930" style="zoom: 40%;" /><h4 id="置换函数P">置换函数P</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135548535.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135548535.png" srcset="data:image/png;base64,666" alt="image-20201126135548535" style="zoom:40%;" /><h4 id="PC1">PC1</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135745175.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135745175.png" srcset="data:image/png;base64,666" alt="image-20201126135745175" style="zoom:44%;" /><h4 id="PC2">PC2</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135956793.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126135956793.png" srcset="data:image/png;base64,666" alt="image-20201126135956793" style="zoom:44%;" /><h4 id="S-box-例子">S-box 例子</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140106789.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/现代密码学-notes/image-20201126140106789.png" srcset="data:image/png;base64,666" alt="image-20201126140106789" style="zoom:40%;" /><h3 id="AES算法相关表">AES算法相关表</h3><h4 id="字节替换表">字节替换表</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126152318235.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-notes/image-20201126152318235.png" srcset="data:image/png;base64,666" alt="image-20201126152318235"></p>]]></content>
      
      
      <categories>
          
          <category> Course Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-SGX Support for Dynamic Memory Management Inside an Enclave</title>
      <link href="2020/11/25/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/"/>
      <url>2020/11/25/paper-sgx-support-for-dynamic-memory-management-inside-an-enclave/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction">1. Introduction</h2><h3 id="SGX1-shortcomings">SGX1 shortcomings</h3><ul><li><p>enclave建立时必须分配其所需的所有内存，并且难以根据工作量自适应分配enclave，需要根据最坏情况的工作量来分配内存</p></li><li><p>enclave页的访问控制由EPCM来管理，当页被加入enclave时其权限就得写入EPCM中，并且不能再改变，这就意味着必须允许页上将来可能执行的任何操作，不能做到权限最小化</p></li><li><p>library OS，异常处理和代码延迟加载</p></li></ul><h2 id="2-SGX2-Considerations-Requirements">2. SGX2 Considerations &amp; Requirements</h2><h3 id="动态内存管理需要满足的条件">动态内存管理需要满足的条件</h3><ul><li>enclave需要自己掌控其内存和权限</li><li>enclave代码在enclave不知情的情况下被改变时，将不会被执行</li><li>系统的资源管理器能够正常管理和分配资源</li><li>需要同时有EPCM权限和系统权限才能更改内存权限</li></ul><h3 id="安全考量">安全考量</h3><ul><li>enclave软件需要改变页的权限来进行访问控制</li><li>权限更改时要保证旧的权限从TLB中移除</li><li>如果enclave要将页还回系统，并且想要在以后使用相同的内存地址，则enclave需要知道页是什么时候被还回的</li></ul><h3 id="软件考量">软件考量</h3><ul><li>enclave内部的内存管理机构需要能够重新分配内存资源</li></ul><h2 id="3-SGX2-Overview-and-Usage">3. SGX2 Overview and Usage</h2><h3 id="SGX2新增的指令">SGX2新增的指令</h3><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160452272.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160452272.png" srcset="data:image/png;base64,666" alt="image-20201125160452272" style="zoom: 80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160710352.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/sgx-support-for-dynamic-memory-management-inside-an-enclave-notes/image-20201125160710352.png" srcset="data:image/png;base64,666" alt="image-20201125160710352"></p><h3 id="Enclave内存分配">Enclave内存分配</h3><blockquote><p>To implement dynamic memory allocation and commitment, the enclave runtime system and the operating system have to agree on a protocol that coordinates the operating system usage of EAUG and the enclave runtime system usage of EACCEPT.</p></blockquote><p><strong>Committed：</strong> Virtual Size减去为程序保留的内存（未分配）。怎么理解为程序保留的但未分配的内存？就是告诉系统我要一块内存，但暂时还用不上，不过分配的地址得给我，系统就给程序一个不用的地址，但不分配内存，等程序真的要使用时（读写），就从页面或物理内存中分配出来映射到那个地址上。</p><p><strong>提交的内存：</strong> 系统从物理内存或者换页内存分配给进程的那一部分。这部分内存在虚拟内存的线性地址中是连续的，不过在物理内存或者换页内存中，不一定是连续的。提交但未使用的内存一般都在换页内存里面，只有去使用的时候，才会换到物理内存里面，这点要注意。</p><h3 id="Enclave内存释放">Enclave内存释放</h3><blockquote><p>SGX2 provides a more robust reclamation of committed memory. OS and enclave runtime system need to coordinate the execution of EMODT, ETRACK, and EREMOVE by the OS and execution of EACCEPT by the enclave runtime.</p></blockquote><h3 id="改变页的权限">改变页的权限</h3><p>分为扩大权限和缩减权限。</p><ul><li><p>扩大权限：</p><blockquote><ol><li>The internal manager executes EMODPE to extend the page permissions in the EPCM.</li><li>The internal manager requests the system manager to extend page permissions in the page tables.</li></ol></blockquote></li><li><p>缩减权限：</p><blockquote><ol><li><p>The internal manager requests that the system manager to restrict permissions on a page.</p></li><li><p>The system manager executes EMODPR and updates page table permissions. After permissions have been updated, the system manager executes ETRACK on the SECS of the calling enclave and sends <strong>IPI</strong>s (处理器间中断：允许一个CPU向系统其他的CPU发送中断信号) to all processors that may be executing inside the enclave to flush TLB mappings.</p></li><li><p>After all IPIs have been acknowledged, control is returned to the internal manager. The internal manager verifies that page permissions have been restricted and TLB mappings flushed by executing EACCEPT.</p></li></ol></blockquote></li><li><p>权限的更改(同时包含扩大和缩减权限)：先缩减后扩大 —— 避免产生不安全的中间临时情况</p></li></ul><h3 id="线程控制机构TCS分配">线程控制机构TCS分配</h3><blockquote><p>The software protocol is very similar to page restriction except that instead of executing EMODPR the OS executes EMODT.</p></blockquote><h3 id="动态加载模块">动态加载模块</h3><blockquote><p>To support dynamic loading of modules, SGX2 provides EACCEPTCOPY which allows the internal manager to atomically initialize the contents and permission of a page.</p></blockquote><h3 id="Library-OS支持">Library OS支持</h3><ul><li>提供异常处理<ul><li>由enclave产生的异常</li><li>异常的类型</li><li>错误情况的具体信息</li></ul></li><li>SGX2还另外提供enclave运行时产生的enclave内部的异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGX程序基础</title>
      <link href="2020/11/24/sgx-programming/"/>
      <url>2020/11/24/sgx-programming/</url>
      
        <content type="html"><![CDATA[<h2 id="项目目录结构">项目目录结构</h2><p>以<code>SampleEnclave</code>为例，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── App</span><br><span class="line">│   ├── App.cpp</span><br><span class="line">│   ├── App.h</span><br><span class="line">│   ├── Edger8rSyntax</span><br><span class="line">│   │   ├── Arrays.cpp</span><br><span class="line">│   │   ├── Functions.cpp</span><br><span class="line">│   │   ├── Pointers.cpp</span><br><span class="line">│   │   └── Types.cpp</span><br><span class="line">│   └── TrustedLibrary</span><br><span class="line">│       ├── Libc.cpp</span><br><span class="line">│       ├── Libcxx.cpp</span><br><span class="line">│       └── Thread.cpp</span><br><span class="line">├── Enclave</span><br><span class="line">│   ├── Edger8rSyntax</span><br><span class="line">│   │   ├── Arrays.cpp</span><br><span class="line">│   │   ├── Arrays.edl</span><br><span class="line">│   │   ├── Functions.cpp</span><br><span class="line">│   │   ├── Functions.edl</span><br><span class="line">│   │   ├── Pointers.cpp</span><br><span class="line">│   │   ├── Pointers.edl</span><br><span class="line">│   │   ├── Types.cpp</span><br><span class="line">│   │   └── Types.edl</span><br><span class="line">│   ├── Enclave.config.xml</span><br><span class="line">│   ├── Enclave.cpp</span><br><span class="line">│   ├── Enclave.edl</span><br><span class="line">│   ├── Enclave.h</span><br><span class="line">│   ├── Enclave.lds</span><br><span class="line">│   ├── Enclave_private_test.pem</span><br><span class="line">│   └── TrustedLibrary</span><br><span class="line">│       ├── Libc.cpp</span><br><span class="line">│       ├── Libc.edl</span><br><span class="line">│       ├── Libcxx.cpp</span><br><span class="line">│       ├── Libcxx.edl</span><br><span class="line">│       ├── Thread.cpp</span><br><span class="line">│       └── Thread.edl</span><br><span class="line">├── Include</span><br><span class="line">│   └── user_types.h</span><br><span class="line">├── Makefile</span><br><span class="line">└── README.txt</span><br></pre></td></tr></table></figure><ul><li>App目录：存放应用程序中的不可信代码部分<ul><li>App.cpp文件：应用程序中的不可信部分代码，其中包括了创建Enclave及销毁Enclave的代码，也定义了一些相关的返回码供使用者查看Enclave程序的执行状态。其中的main函数是整个项目的入口函数。</li><li>App.h文件：应用程序中的不可信部分代码的头文件，定义了一些宏常量和函数声明。</li><li>Edger8rSyntax文件夹：提供了一些工具。</li><li>TrustedLibrary文件夹：提供了一些函数库。</li></ul></li><li>Enclave目录：存放应用程序中的可信代码部分和可信与不可信代码接口文件<ul><li>Enclave.config.xml文件：Enclave的配置文件，定义了Enclave的元数据信息。</li><li>Enclave.cpp文件：应用程序中的可信部分代码，包括了可信函数的实现。</li><li>Enclave.h文件：应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明。</li><li>Enclave.edl文件：Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口，trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。</li><li>Enclave.lds文件：定义了一些Enclave可执行文件信息。</li><li>Enclave_private_test.pem文件：SGX生成的私钥。</li><li>Edger8rSyntax文件夹：提供了一些工具。</li><li>TrustedLibrary文件夹：提供了一些函数库。</li></ul></li><li>Include目录：存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义<ul><li>user_types.h文件：定义了用户自定义的类型</li></ul></li><li>Makefile文件：项目的编译文件，定义了项目的编译信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu将安装的应用固定到桌面</title>
      <link href="2020/11/23/ubuntu-show-application/"/>
      <url>2020/11/23/ubuntu-show-application/</url>
      
        <content type="html"><![CDATA[<p>升级了一下ubuntu，从18.04升到了20.04，发现自动安装了国际版的firefox，之前安装的国内版firefox目录还在<code>/opt</code>下，但是桌面显示的firefox是国际版的，且启动栏也没有国内版的firefox应用。</p><h2 id="Step1">Step1</h2><p>卸载国际版firefox</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections | grep firefox</span><br><span class="line">sudo apt-get purge firefox ... <span class="comment"># 所有上一步列出的应用</span></span><br></pre></td></tr></table></figure><h2 id="Step2">Step2</h2><p>在<code>/usr/share/applications/</code>目录新建<code>firefox.desktop</code>，并添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name&#x3D;Firefox</span><br><span class="line">Exec&#x3D;&#x2F;opt&#x2F;firefox&#x2F;firefox</span><br><span class="line">Icon&#x3D;&#x2F;opt&#x2F;firefox&#x2F;browser&#x2F;chrome&#x2F;icons&#x2F;default&#x2F;default128.png</span><br><span class="line">Terminal&#x3D;False</span><br><span class="line">Type&#x3D;Application</span><br></pre></td></tr></table></figure><h2 id="Step3">Step3</h2><p>更改firefox.desktop文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 firefox.desktop</span><br></pre></td></tr></table></figure><h2 id="Step4">Step4</h2><p>在启动栏可以看见新建的应用图标，并且可以添加到侧边栏</p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGX Developer Guide - Reading Notes</title>
      <link href="2020/11/16/SGX-Developer-Guide-Notes/"/>
      <url>2020/11/16/SGX-Developer-Guide-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="专业名词">专业名词</h2><ul><li><p>ECall：“Enclave Call”一个调用enclave内部接口函数的操作</p></li><li><p>OCall：“Out call”从enclave内部向外部的应用发起调用的操作</p></li><li><p>Trusted：任何在enclave内部 <code>trusted</code> 环境下执行的代码或者数据结构</p></li><li><p>Trusted Thread Context：线程的上下文存放在enclave中，主要包括以下几个部分组成：</p><ul><li>Thread Control Structure（TCS）线程控制结构</li><li>Thread Data/Thread Local Storage 在enclave中的线程相关的数据</li><li>State Save Area(SSA) 线程异常处理机制</li><li>Stack 线程栈</li></ul></li><li><p>Untrusted：指代任何运行在应用的 <code>untrusted</code> 环境下（等价于enclave外部）的代码或者数据结构。</p></li></ul><h2 id="Enclave-编程模型">Enclave 编程模型</h2><h3 id="Enclave开发原则">Enclave开发原则</h3><ul><li>enclave是一个庞大而单一的软件实体，目标在于将对于一个应用而言的可信计算基降低至可信运行时系统，ISV代码和第三方可信库。在上述组件中的任一个bug将会导致enclave的安全问题。</li><li>非可信域控制了enclave 接口函数什么时候被调用的顺序。</li><li>当调用进入enclave中，是由不可信域来在enclave中选择可信线程上下文去执行。</li><li>并不保证传递进去enclave（ecall）中的参数和从enclave向外部发送的参数（ocall）是正确的，因为这是由不可信域提供的。</li><li>enclave向外部发送的调用 <code>OCall</code>，不能保证不可信函数一定正确地被执行。</li><li>任何人都可以加载一个enclave。更为严重的是，攻击者可能使用攻击性应用程序去加载一个enclave，利用该enclave存在的安全漏洞，窃取相关数据。</li></ul><h3 id="Enclave文件格式">Enclave文件格式</h3><ul><li>一个 enclave library 文件包括可信代码和数据部分，当enclave被创建时，这些将会被导入到受保护的 enclave 内存（即EPC）中</li><li>在一个enclave文件中，还存在着Intel SGX特定的数据结构，enclave元数据：<ul><li>元数据没有导入EPC中，而是被不可信的加载器加载，并决定enclave如何导入到EPC中</li><li>元数据中定义了可信线程上下文的数量，包括可信堆和可信栈的大小，在enclave初始化的时候，可信堆和可信栈被可信运行时系统初始化</li><li>元数据同时包括enclave的签名，这对于enclave的认证和初始化时非常重要的</li></ul></li></ul><p>**注：**不管enclave中定义了多少个可信线程，在设计的过程中不能假设不可信应用将会以特定的顺序去调用 Enclave 中的接口函数。一旦enclave被初始化，一个攻击者可以调用 Enclave 接口函数，以任何可能的顺序去发起调用并且提供相应的输入参数。</p><h3 id="Enclave可信计算基">Enclave可信计算基</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201118224903930.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201118224903930.png" srcset="data:image/png;base64,666" alt="image-20201118224903930"></p><h3 id="Enclave-Interface-函数-ECalls">Enclave Interface 函数 (ECalls)</h3><ul><li>enclave无法控制哪个ECall被执行，或者ECall将会以怎样的顺序被调用</li><li>ISV接口函数仅仅只能在enclave初始化后被调用，这意味着：<ul><li>任何必要的地址基地址重置被正确地执行。</li><li>可信全局数据，例如栈等被正确地初始化。</li><li>可信线程的上下文，可信线程被正确地初始化。</li><li>不直接说明的可信初始化函数执行完成。（例如ISV全局构造函数）</li></ul></li></ul><h3 id="Enclave的输入">Enclave的输入</h3><ul><li>Enclave输入和输出可以被不可信的代码观察和修改</li><li>为了防止针对输入函数的攻击，软件开发者应该采用加密的方式和完整性检测来保证enclave执行的可信性</li></ul><p><strong>当一个encalve函数被调用时</strong>：</p><ul><li>函数的参数和其他任何通过引用传递的序列化数据参数进入到可信环境中，并且对于攻击者无法访问的。</li><li>在参数上进行读写操作，返回值和其他序列化的引用，根据enclave开发者的参数与特殊定义，将不会影响ISV代码和数据的保密和完整性。<ul><li>参数和返回值，序列化数据被可信运行时分配和管理，不对任何ISV代码和数据进行覆盖。</li><li>参数，返回值和序列化引用的大小被ISV所指定。</li></ul></li></ul><h2 id="通过引用传递的输入参数">通过引用传递的输入参数</h2><p>当ISV接口函数被调用时，输入参数将被停留在enclave中。然而，当一个输入参数通过引用的形式传递，只有引用（或指针）将会放置到enclave中。引用所指向的值停留在外部，并且会不断地变化。例如，一个攻击者可能在enclave检查函数参数后改变所引用的值。</p><h3 id="外部Enclave调用-OCalls">外部Enclave调用 (OCalls)</h3><p>Enclave无法直接访问OS提供的服务。作为替代的是，encalve必须发起一个OCall将其传递到不可信应用中。</p><p>当一个enclave内的ISV函数发起OCall时：</p><ul><li>OCall仅仅暴露其参数和返回值到不可信域中。</li><li>当一个OCall发生时，返回值和任何序列化数据的引用将传递进入可信执行环境中，对攻击者不可以访问。另外enclave需要检查指针。</li><li>当一个OCall发生时，可信线程上下文与OCall之前的相同，除了在栈上的数据和易变寄存器上的值。</li></ul><h2 id="Enclave签名">Enclave签名</h2><p>在软件中通过enclave建立信任的过程中主要有着以下三种行为：</p><ul><li>Measurement（度量）：作为enclave在可信环境中初始化时用来验证文件准确性的身份。</li><li>Attestation（认证）：向其它实体证明当前的环境被正确的初始化。</li><li>Sealing（数据的密封）：通过某种方式保证可信环境上的数据可以正确地持久化和重新加载。</li></ul><p>Enclave签名包含允许Intel SGX硬件检测enclave的完整性是否被篡改的信息，同时可以识别enclave持有人的身份。encalve 签名包含这几个如下的重要字段，对于外部实体的认证非常重要。</p><ul><li>Enclave Measurement - 一个简单的256位哈希值用来标注代码和放入到enclave中的初始化数据，包括他们放入到EPC中期待的顺序和位置，以及这些页面的安全属性。当enclave代码/数据加载到EPC中，CPU开始计算enclave measurement并且将这个值存储在MRENCLAVE 寄存器中。接着CPU比较MRENCLAVE寄存器中的内容和存放在SIGSTRUCT中的enclave measurement值。当且仅当它们相等的时候，CPU允许enclave被初始化。</li><li>Enclave所有者的公钥 - 当一个enclave被正确地初始化，CPU将enclave所有者的公钥的hash存放在MRSIGNER寄存器中。MRSIGNER中的内容将会用作enclave所有者的身份证明。被同一个key认证的enclave在MRSIGNER寄存器中的值相同。</li><li>Enclave的安全版本号（ISVSVN）- enclave所有者对于enclave的每个版本号分配一个安全版本号。安全版本号反映了enclave的安全属性级别，并且需要单调递增，随着安全属性的不断上升。在一个enclave被正确初始化后，CPU记录SVN，并且在远程认证的过程中被使用。一个有着相同安全属性的enclave的不同版本应该分配相同的安全版本号。例如，一个没有解决安全相关bug的新版本enclave需要与旧版本的enclave持有相同的安全版本号。</li><li>Enclave的产品ID（ISVPRODID）- enclave所有者针对每一个enclave分配一个产品ID。产品ID允许enclave所有者使用相同的enclave所有者身份去分割enclave。当一个enclave被正确的初始化后，CPU记录Product ID，在远程认证的过程中可以被使用。</li></ul><h2 id="Enclave认证">Enclave认证</h2><h3 id="本地认证">本地认证</h3><p>一个enclave可以请求硬件生成一个证书，即report，其中通过密码学证据证明着enclave存在这个平台上。这个report可以给其他的enclave，让其进行验证report是同一平台上生成。内部enclave之间认证机制使用的是对称密钥，只有验证report结构的enclave和创建enclave report的硬件可以访问到，并且嵌入到硬件平台中。</p><p>一个enclave report包含着以下的信息：</p><ul><li>enclave中的code和初始化数据的measurement。</li><li>enclave初始化的时候记录ISV证书公钥的哈希值。</li><li>用户后来添加的数据。</li><li>其他安全相关的状态信息。</li><li>上述所有数据的一个签名，可以被生成report的同一平台去进行验证。</li></ul><h4 id="本地认证过程">本地认证过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122114320790.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122114320790.png" srcset="data:image/png;base64,666" alt="image-20201122114320790"></p><ol><li><p>在上图中，应用A持有enclave A，应用B持有enclave B。在不可信应用A和B为两个enclave建立通信后，enclave B向enclave A发送了MRENCLAVE的值。（应用A和B可以是同一应用）</p><p>有两种方法对于应用而言可以提取enclave的MRENCLAVE measurement:</p><ul><li>应用B从enclave B的enclave证书中提取MRENCLAVE的值。</li><li>enclave B提供了一个接口来导出该值，通过创建一个report。</li></ul></li><li><p>Encalve A请求硬件生成一份report送至enclave B，并且其中包含着从enclave B获取到的数据。enclave A通过不可信应用将数据发送给enclave B。</p></li><li><p>当enclave B收到了来自enclave A的报告，enclave B要求硬件去验证report来确认enclave A和B在同一平台上运行。enclave B从enclave A中提取相应的MRENCLAVE，然后请求硬件生成自己的report，接着发送给enclave A。</p></li><li><p>enclave A验证enclave B的report，并且验证enclave B和自己运行在同一平台上。</p></li></ol><h3 id="远程-跨平台-认证">远程 (跨平台) 认证</h3><p>一个持有enclave的应用可以要求enclave去生成一份report，接着将这份report传到平台服务去生成一种类型的证书，反映着enclave和平台的状态。这种类型的证书被称为quote。这个quote可以传递到平台外的实体，并且使用Intel Enhanced Privacy ID（Intel EPID）签名技术去进行验证。作为结果，CPU的密钥并没有直接从平台内部暴露出去。</p><p>一个quote包含这以下的数据：</p><ul><li>enclave中代码和初始化数据的measurement。</li><li>enclave初始化的时候记录ISV证书公钥的哈希值。</li><li>enclave的产品ID和安全版本号。</li><li>enclave的属性，例如，encalve是否运行在debug mode。</li><li>enclave中添加的用户数据。提供了一种方式由enclave向外部实体提供数据。</li><li>上述所有数据的一个签名，借助于Intel EPID组签名技术。 包含在quote中的enclave 数据（MRENCLAVE, MRSIGNER, ISVPRODID, ISVSVN, ATTRIBUTES等等）在远程认证过程的末尾提供给远程服务使用上。服务提供者将根据这些数据去进行判断是否可信。</li></ul><h4 id="EPID">EPID</h4><p>Intel EPID是一种组签名技术，允许平台去匿名签名对象并且可以保护签名者的隐私（如果使用机器的CPUID签名，会导致隐私的泄露）。通过Intel EPID签名技术，组里面的每一个签名者都有他们各自的私钥，但是验证者使用相同的公钥去验证个人的签名。因此，用户无法识别出两个交易是否来自于同一个机构，因为用户无法检测中是组里面哪个成员做了签名。在Intel SGX中，这个组是所有支持Intel SGX平台的集合。</p><h4 id="QE">QE</h4><p>Intel中内嵌了一种特殊的enclave，成为Quoting Enclave（QE），QE验证report正确地按照其MRENCLAVE mesurement值进行创建，然后将它用一个硬件特定的非对称密钥（Intel EPID key）进行签名，输出的内容就是quote。当enclave 系统正在运行的过程中，只有QE有权限访问Intel EPID key。因此quote可以看作直接来自于硬件本身，但是CPU key永远不会暴露到平台外部。</p><h4 id="远程认证过程">远程认证过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122120414342.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/SGX-Developer-Guide-Notes/image-20201122120414342.png" srcset="data:image/png;base64,666" alt="image-20201122120414342"></p><ol><li>当应用需要在平台外部的服务，它首先和外部服务提供系统建立连接。服务提供者发起挑战(包含一个nonce)来证明应用确实运行在enclave中</li><li>应用从应用的enclave请求一份report，并将来自外部服务提供商的nonce传递进enclave中</li><li>enclave生成一份report结构，并将其连同一个清单返回给应用，清单包含report中用户数据部分的值以及nonce和用于挑战应答交互的密钥</li><li>report发送给QE去做签名<ul><li>QE验证report</li><li>QE转换report的body转换为quote，并对其使用EPID进行签名</li></ul></li><li>QE返回quote structure</li><li>应用返回quote结构体和其他相关的信息到外部服务者</li><li>外部服务者使用EPID验证公钥去验证quote的签名信息。</li><li>外部服务者对比来自enclave的信息，并与其它可信配置的信息进行比较。判断enclave是否满足条件。其中包括检测enclave是否运行在debug模式，及其的measurement，产品ID和enclave所有人等等。</li></ol><h3 id="区分不同的Enclave运行实例">区分不同的Enclave运行实例</h3><p>Intel SGX不直接提供一种机制（例如，通过自动生成的REPORT字段）来区分同一个enclave的两个不同的实例。</p><p>如果想要尝试的话，可以使用RDRAND函数生成随机数，并作为作为用户数据，嵌入到REPORT中。</p><h2 id="Enclave密封">Enclave密封</h2><p>为了保护和持久化数据，提供了一种由enclave软件从特定的enclave中提取key的机制。这个Key只能在特定的平台上被某个enclave生成。enclave 软件使用那个key去在平台上加密数据或者从平台上解密已经存在的数据。我们把这种加密和解密的操作成为密封和解封。</p><h3 id="软件密封技术">软件密封技术</h3><h4 id="密封到当前的enclave（依照于enclave度量）">密封到当前的enclave（依照于enclave度量）</h4><p>密封到当前enclave 使用enclave measurement的当前版本（MRENCLAVE），当enclave创建的时候，将这个值绑定到密封操作所需要使用的key上。这个绑定操作由硬件执行通过EGETKEY指令。</p><p>只有有着相同的MRENCLAVE度量的enclave才能够将密封的数据进行解密。如果enclave的DLL，Dynamic Library，或者Shared Object文件被篡改，那么enclave的measurement将会发生改变。作为影响，密封的key同样会发生变化，数据将不会被还原。</p><h4 id="密封到enclave当前的所有者">密封到enclave当前的所有者</h4><p>将数据密封到enclave的当前的所有者需要使用enclave所有者的身份，这个值由CPU在enclave初始化的过程中存储在MRSIGNER寄存器中，并且这个值被绑定到密封数据函数所需要使用到的key中。这个绑定是由硬件通过EGETKEY指令完成。被密封数据函数使用的key同时也被绑定到enclave的产品ID上。产品ID在enclave初始化时存储在CPU中。</p><p>当MRSIGNER度量寄存器的值和产品ID相同时，enclave才能解密。 这种机制的好处是：</p><ul><li>它允许enclave的所有者对enclave进行升级，但是不需要进行复杂的升级过程来解密之前密封在之前版本的enclave（MRENCLAVE 度量值不同）中的数据，并且重新使用密封到新的版本</li><li>它允许来自相同的所有者的enclave实现共享数据</li></ul><p>Enclave所有者生产出enclave后，可以为之指定安全版本号。这个安全版本号同样在enclave初始化的时候存储在CPU中。一个enclave在从CPU中获取密封key的请求中必须提供一个相应的安全版本号。一个enclave不能指定一个比它当前安全版本号靠后的enclave，但是encalve可以指定一个在当前安全版本号之前的安全版本号。这个选项使enclave获得了解封之前版本的enclave中的数据，对于enclave软件更新，是有着巨大的好处的。</p><h3 id="密封和解封过程">密封和解封过程</h3><p>在enclave中<strong>密封</strong>数据的主要过程如下：</p><ol><li><p>为加密数据和密封数据结构在enclave中分配内存。其中密封数据结构主要包括要加密的数据和额外认证数据(AAD, 额外的参与MAC计算但不进行加密的数据或文本)。额外认证数据中的信息可能包括应用enclave，版本号，数据等</p></li><li><p>调用加密数据的API来执行加密操作，一个加密操作算法如下：</p><ul><li>验证输入参数是有效的。例如，如果作为参数进行传递的是一个指向加密数据结构的指针，它指向的缓存必须存在于enclave中。</li><li>初始化并向其中填充一个将要被EGETKEY指令来执行密钥请求的数据结构。过程如下：<ul><li>获取EREPORT去获得安全ISV和TCB安全版本号，将在key获取中使用</li><li>Key 名称：识别获取key的名字，在这种情况下即为Seal key</li><li>Key Policy：识别即将使用的软件密封策略。使用MRSIGNER来表示密封到enclave的所有者上，使用MRENCLAVE来表示密封到当前的enclave（enclave measurement）中。保留位必须被清除</li><li>Key ID：调用RDRAND来获取一个随机数</li><li>属性字段：表明密封密钥应该与什么属性进行绑定</li></ul></li><li>使用上一步构造出的密钥请求结构调用EGETKEY获取Seal key</li><li>使用加密算法来使用密封密钥来执行密封操作。推荐使用AES-GCM加解密函数，例如Rijndael128GCM</li><li>从内存删除seal key以防泄露</li></ul></li><li><p>将密封数据结构（包括密钥请求结构）从enclave中保存到外部内存中。密钥请求结构将用来在今后的enclave初始化后去获取密封密钥。</p></li></ol><p>在enclave中对加密数据进行<strong>解密</strong>主要包括以下过程：</p><ol><li><p>为待解密的数据分配内存。</p></li><li><p>调用解密api去执行解密操作。一个解密操作算法如下：</p><ul><li>验证输入参数的合法性。</li><li>从密封数据结构中提取密钥请求结构</li><li>借助密钥请求结构去通过EGETKEY指令获取密封密钥</li><li>调用解密算法使用密封密钥解密</li><li>从内存中删除密封密钥以防止泄露</li><li>验证解密算法生成的hash与加密过程中生成的hash一致</li></ul></li></ol><h3 id="区分不同的Enclave实例">区分不同的Enclave实例</h3><p>即使同一个enclave的两个不同的实例可以在它们认证时区分，但是当两个enclave都使用EGETKEY指令时，目前Intel SGX不提供一种机制来阻止一个enclave实例去访问另一个enclave的密封数据，两个实例将会返回相同的密钥值。</p><p>如果要区分enclave实例的SEAL key，推荐：</p><blockquote><p>Intel recommends that enclave writers use the KEYID field of the KEYREQUEST structure passed into the EGETKEY instruction to pass an enclave instance specific nonce. This will provide a different key even when the same enclave is in a different virtual machine.</p></blockquote><h2 id="处理器特征">处理器特征</h2><p>在enclave中可以执行大部分Ring3软件能执行的指令</p><h2 id="程序性能">程序性能</h2><h3 id="Enclave创建">Enclave创建</h3><p>enclave的大小很大程度上影响了创建enclave的时间，主要是由于在enclave的度量（measurement）过程中，需要进行一系列操作以保证所有的代码加载到enclave中是可信的。</p><p>在enclave的创建过程中，一系列的EADD和EEXTEND指令将被运行，主要用于加载和度量enclave的页面。</p><ul><li>EADD每次加载4k字节的数据。</li><li>EEXTEND每次度量256字节的数据。这意味着对于EADD添加的4KB的数据，需要发起16次的EEXTEND调用。</li></ul><p>相关的性能优化建议：</p><ul><li>减小enclave的大小。仔细检查在enclave中每段代码和数据元素，如有必要，将其移除。（使用工具：Intel VTune Amplifier）。例如，将即将静态链接的.o 文件先转换为诶.a文件。</li><li>Intel SGX 允许enclave通过 Enclave Dynamic Memory Management（EDMM）的方式去进行扩展。当你的OS支持EDMM，那么可以先创建一个比较小的enclave，然后扩展它。</li><li>通过在application中添加加载条的方式来获取用户的注意力，借此隐藏应用的加载时间。</li><li>避免频繁的enclave创建和重新加载，进而最小化重复的加载性能损耗。</li></ul><h3 id="Enclave切换">Enclave切换</h3><p>在enclave之间的频繁转变需要在上下文之间切换非常多次。当一个EENTER指令触发进入enclave时，为了保证enclave可以正常运行，属于不可信运行时的注册状态（register state）和其它信息被存储，enclave中的线程状态和其它属于可信状态的信息被加载，这部分工作主要是由SDK生成的代码执行。一个相反的过程发生在从enclave中退出（被EEXIT指令触发）：可信线程状态信息被保存，不可信的注册状态和其它信息被还原，在这个过程中同样执行着安全检查，这部分工作也主要由SDK生成的代码自动执行。这些行为构成了在应用和enclave之间控制权切换所带来的固定负载。</p><p>然而，这个转变中有一些可变变量影响着损耗，即传递参数的大小。参数在从不可信应用部分到可信enclave传递的过程中被序列化，并且返回值被反序列化。在可信enclave中，来自不可信应用的参数被反序列化，并且将返回值序列化。如果应用传递大量的参数，将会有显著的性能损耗。</p><p>如果在enclave和应用之间的控制权的转变很大程度地冲击着性能，考虑通过通过以下的方式降低影响：</p><ul><li>减小传递参数的总大小。（使用工具：Intel VTunte Amplifier）</li><li>当确实有大量数据需要进行传递的时候，考虑使用指针的方式。<strong>需要说明的是，使用指针会带来一部分安全风险，为此你必须自己去实现指针检查器，如果使用这种方式的话。</strong></li></ul><h3 id="过多缓存未命中">过多缓存未命中</h3><p>encalve所存储的内存内容在处理器cache之外的部分都是加密受保护的。这种类型的保护在从内存中获取cache lines带来了相应的负载。这种负载和Intel SGX实现方式有直接关系。</p><p>Intel SGX架构中在缓存未命中的情况下，相对于其他传统的负载，新增了两种类型的负载：</p><ul><li>对于不在处理器cache中的每一条cache line所执行的完成check/anti-replay 检查，以及在系统内存中更新相应的数据结构（如果必要的话）。这种类型的负载依赖于内存访问模式。</li><li>在cache和内存中加载和移除数据所带来的加解密。</li></ul><p>如果你的系统受到大量的缓存未命中而相关的性能损耗的冲击，可以考虑下面的步骤：</p><ul><li>减小enclave中的数据的大小。观察数据，以保证只有必要的数据才能装载进入enclave中。更少的数据意味着更少的加减密和更少的数据结构检查，在Intel SGX内存控制/保护机制下。可以使用Intel VTune Amplifier来观察应用中的cache行为。</li><li>可以查看下面的文档去创建一个更加“缓存友好”的应用：<a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf">PDF地址</a></li></ul><h3 id="过多的页写入">过多的页写入</h3><p>需要考虑Intel SGX应用频繁大量的页面切换对性能的影响，并且如何最小化这方面的后果：</p><p>Intel SGX使用安全存储 EPC 来存储enclave中的内容。Enclave页面大小为4KB。当enclave比EPC总可用的内存要大的话，enclave分页机制可能会被某些特权软件来使用。当OS尝试交换enclave页面时，CPU使用EWB指令执行以下的步骤：</p><ul><li>读取要替换出去的Intel SGX页面（移出）</li><li>加密页面中的内容</li><li>将加密的页面写到未收到保护的系统内存中</li></ul><p>由于这个过程有着固定的负载，因此越多的页面被替换出去，越多的性能损耗发生。为了阻止应用频繁经历这种页面的交换，尽可能确保enclave的大小小于EPC。尽可能只将秘密数据和在这之上的操作放入enclave中，从而最小化页面交换的可能性。可以使用Intel VTune Amplifier工具来观察应用中页面替换的行为，来保证做出正确的决定</p><h3 id="多线程下的性能">多线程下的性能</h3><p>如果应用是多线程的，从数据同步，锁，线程模型和内存分配算法上去寻找改善性能的方法。</p><ul><li>Intel SGX SDK 的一些关于同步和锁的原语已经被优化。</li><li>对于较重的多线程应用，推荐选择更好的内存分配算法。Intel SGX SDK针对linux提供了TCMalloc内存分配算法，相对于默认的dlmalloc内存分配算法，有着更好的性能表现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SGX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sgx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust - Learn</title>
      <link href="2020/11/13/Rust-notes/"/>
      <url>2020/11/13/Rust-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Ch0-安装Rust">Ch0 安装Rust</h2><ul><li><p>使用rustup安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></li><li><p>安装时出现的问题（<s>未完全</s>解决）：默认<code>.cargo</code>环境变量设置为了<code>/home/&lt;username&gt;/~/.cargo</code>，导致在用户家目录下又新建了<code>~</code>目录，在安装完rust后，将<code>.cargo</code>目录移动到<code>~/</code>家目录下，并修改所有可能会更改环境变量的文件，包括<code>~/.profile</code>、<code>/etc/profile</code>、<code>/etc/bash.bashrc</code>、<code>~/.cargo/env</code>，将其中的<code>/home/&lt;username&gt;/~/.cargo</code>改为<code>~/.cargo</code>。但是每当打开终端时，环境变量PATH还是会自动添加<code>/home/&lt;username&gt;/~/.cargo/bin</code></p><ul><li><p><s>暂时的</s>解决方案：在<code>~/.bashrc</code>文件中添加语句，覆盖错误的环境变量(重启后就成功了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/.cargo/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Ch1-Cargo">Ch1 Cargo</h2><h3 id="1-1-使用Cargo创建项目">1.1 使用Cargo创建项目</h3><ul><li><p>创建hello_world目录，并在其中新建二进制项目hello_world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world</span><br></pre></td></tr></table></figure></li><li><p>创建库项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world --lib</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-1-Cargo-toml">1.1.1 Cargo.toml</h4><p>Cargo.toml是项目的配置文件，通过cargo new自动生成</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><ul><li>[package]片段：配置一个包，包含项目名称、版本、作者和Rust版本</li><li>[dependencies]片段：罗列项目依赖</li></ul><h4 id="1-1-2-源代码目录src">1.1.2 源代码目录src</h4><p>包含main.rs以及其他源文件</p><h3 id="1-2-构建并运行Cargo项目">1.2 构建并运行Cargo项目</h3><p><strong>编译项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><p><strong>编译并运行项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br></pre></td></tr></table></figure><p><strong>快速检查代码确保其可以编译，但不生成可执行文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br></pre></td></tr></table></figure><p>以上命令会生成以下文件：</p><h4 id="1-2-1-可执行文件">1.2.1 可执行文件</h4><p>存放目录为<code>./target/debug/hello_world</code></p><h4 id="1-2-2-Cargo-lock">1.2.2 Cargo.lock</h4><p>Cargo.lock记录项目依赖的实际版本，确保项目构建是可重现的，这个文件不需要人为修改</p><h3 id="1-3-发布-release-构建">1.3 发布(release)构建</h3><p>当项目最终准备好发布时，可以优化编译项目是的Rust代码运行更快</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br></pre></td></tr></table></figure><p>此时生成的可执行文件在<code>./target/release/</code>目录下</p><h2 id="Ch2-引入-guess-number">Ch2 引入 - guess_number</h2><h3 id="2-1-创建变量">2.1 创建变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure><ul><li><code>let</code> 创建变量，变量默认不可变</li><li><code>mut</code> 使得变量可变</li><li><code>::</code> 表明new是<code>String</code>类型的一个关联函数</li></ul><h3 id="2-2-从标准输入读取">2.2 从标准输入读取</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>io::stdin</code>函数返回一个终端标准输入句柄</li><li><code>read_line</code>将标准输入存入字符串</li><li><code>&amp;</code>表示这个参数是一个引用</li><li><code>read_line</code>函数返回一个<code>Result</code>类型（枚举），成员有<code>Ok</code>和<code>Err</code></li><li><code>Result</code>实例有<code>expect</code>方法：<ul><li>若<code>Result</code>值为<code>Ok</code>，<code>expect</code>获取<code>Ok</code>中的值并原样返回</li><li>若<code>Result</code>值为<code>Err</code>，<code>expect</code>导致程序崩溃，并显式当做参数传给<code>expect</code>的信息</li></ul></li></ul><h3 id="2-3-crate">2.3 crate</h3><p>crate是一个Rust代码包</p><ul><li>我们构建的项目是一个<strong>二进制crate</strong></li><li>rand crate是一个<strong>库crate</strong></li></ul><h4 id="2-3-1-导入外部crate">2.3.1 导入外部crate</h4><p>以rand crate为例</p><ul><li><p>在使用rand编写代码之前需要修改<code>Cargo.toml</code>文件</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.5.5&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>再进行<code>cargo build</code>，此时会从Crates.io拷贝数据并下载对应的库文件，需要更换国内镜像源进行加速，编辑<code>.cargo/config</code>文件，加入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;</span><br><span class="line">replace-with &#x3D; &#39;ustc&#39;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-更新crate">2.3.2 更新crate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo update</span><br></pre></td></tr></table></figure><h4 id="2-3-3-获取所有本地依赖提供的文档">2.3.3 获取所有本地依赖提供的文档</h4><p>查看应该 <code>use</code>哪个<code>trait</code>以及该从<code>crate</code>中调用哪个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo doc --open</span><br></pre></td></tr></table></figure><h2 id="Ch3-常见编程概念">Ch3 常见编程概念</h2><h3 id="3-1-变量和可变性">3.1 变量和可变性</h3><ul><li><p>使用<code>let</code>声明的变量默认是不可改变的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">5</span>;   <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure></li><li><p>在变量名之前加<code>mut</code>来使其可变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">5</span>;   <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-1-变量和常量的区别">3.1.1 变量和常量的区别</h4><ul><li><p>常量使用关键字<code>const</code>声明，并且必须<strong>注明值的类型</strong></p></li><li><p>不能对常量使用<code>mut</code></p></li><li><p>常量只能被设置为常量表达式，而不能是函数调用的结果</p></li></ul><h4 id="3-1-2-隐藏">3.1.2 隐藏</h4><ul><li><p>定义一个与之前变量同名的新变量，而新变量会<strong>隐藏</strong>之前的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>当再次使用<code>let</code>时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字</p></li></ul><h3 id="3-2-数据类型">3.2 数据类型</h3><p>Rust 是 <strong>静态类型</strong>语言，在编译时就必须知道所有变量的类型</p><h4 id="3-2-1-标量类型">3.2.1 标量类型</h4><ul><li><strong>标量</strong>类型代表一个单独的值</li></ul><h5 id="整型">整型</h5><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal</td><td><code>98_222</code></td></tr><tr><td>Hex</td><td><code>0xff</code></td></tr><tr><td>Octal</td><td><code>0o77</code></td></tr><tr><td>Binary</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr></tbody></table><h5 id="浮点型">浮点型</h5><ul><li><p>Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位</p></li><li><p>默认类型是 <code>f64</code></p></li></ul><h5 id="布尔型">布尔型</h5><ul><li><code>bool</code>，两个可能的值<code>true</code>和<code>false</code></li></ul><h5 id="字符类型">字符类型</h5><ul><li><code>char</code> 类型的大小为四个字节，并代表了一个 Unicode 标量值</li></ul><h4 id="3-2-2-复合类型">3.2.2 复合类型</h4><h5 id="元组类型">元组类型</h5><ul><li><p>元组长度固定：一旦声明，其长度不会增大或缩小</p></li><li><p>元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;   <span class="comment">// 解构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five_hundred = tup.<span class="number">0</span>;   <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure><h5 id="数组类型">数组类型</h5><ul><li>数组中的每个元素的类型必须相同</li><li>Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">0</span>; <span class="number">10</span>];   <span class="comment">// 初始化一个长度为10的全零数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];   <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure><h3 id="3-3-函数">3.3 函数</h3><ul><li><p><code>fn</code> 关键字声明新函数</p></li><li><p>在函数签名中，<strong>必须</strong>声明每个参数的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-1-具有返回值的函数">3.3.1 具有返回值的函数</h4><ul><li><p>以表达式结尾</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-注释">3.4 注释</h3><ul><li>// 单行注释</li></ul><h3 id="3-5-控制流">3.5 控制流</h3><h4 id="3-5-1-if表达式">3.5.1 if表达式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rust 不会尝试自动地将非布尔值转换为布尔值，所以<code>if</code>后跟的表达式必须是<code>bool</code></li></ul><h5 id="在let语句中使用if">在let语句中使用if</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>代码块的值是其最后一个表达式的值</li><li><code>if</code>和<code>else</code>中返回的类型要相同</li></ul><h4 id="3-5-2-循环">3.5.2 循环</h4><h5 id="loop">loop</h5><ul><li><p>无限循环，直到按下ctrl+c，或有break</p></li><li><p>内循环可以 <code>continue</code> 或者 <code>break</code> 外循环，此时需要在外循环添加生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unreachable_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="symbol">&#x27;outer</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Entered the outer loop&quot;</span>);</span><br><span class="line">        <span class="symbol">&#x27;inner</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Entered the inner loop&quot;</span>);</span><br><span class="line">            <span class="comment">// This would break only the inner loop</span></span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">            <span class="comment">// This breaks the outer loop</span></span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;outer</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>loop</code> 可以返回值，返回 <code>break</code> 后的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="while">while</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    number = number - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for遍历集合">for遍历集合</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// iter引用集合a，在循环结束后仍然可以使用a</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// into_iter移动集合a的所有权，在循环结束后不能使用a</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.into_iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// iter_mut引用可变集合b，可以在循环中改变b中的元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.iter_mut() &#123;</span><br><span class="line">    *element += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch4-所有权">Ch4 所有权</h2><h3 id="4-1-什么是所有权">4.1 什么是所有权</h3><ul><li>Rust管理内存的方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查</li></ul><h4 id="4-1-1-所有权规则：">4.1.1 所有权规则：</h4><blockquote><ol><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol></blockquote><h4 id="4-1-2-变量作用域">4.1.2 变量作用域</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3-String类型">4.1.3 String类型</h4><ul><li>字符串的字面值是不可变的，而<code>String</code>类型的字符串是可变的</li><li><code>String</code>类型的字符串被分配到<strong>堆</strong>上，所以能够存储在编译时未知大小的文本</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于字符串字面值来创建String</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-1-4-内存与分配">4.1.4 内存与分配</h4><p>对于<code>String</code>类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向操作系统请求内存</li><li>需要一个当我们处理完<code>String</code>时将内存返回给操作系统的方法</li></ul><p>Rust处理第二点的策略：内存在拥有它的变量离开作用域后就被自动释放</p><h4 id="4-1-5-存储在堆上的变量">4.1.5 存储在堆上的变量</h4><h5 id="1-移动">1. 移动</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234252508.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234252508.png" srcset="data:image/png;base64,666" alt="image-20201110234252508"></p><p><code>String</code> 由三部分组成，如上图所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。</p><p>当 <code>s2</code> 和 <code>s1</code> 离开作用域，他们都会尝试释放相同的内存。这是一个叫做<strong>二次释放</strong>的错误，两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>在Rust中，经过以上语句，会认为s1不再有效，即<code>s1</code> 被<strong>移动</strong>到了 <code>s2</code> 中，因此当<code>s1</code>离开作用域时不会释放内存。</p><h5 id="克隆">克隆</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br></pre></td></tr></table></figure><p><code>s2</code>深度复制了<code>s1</code>堆上的内容，而不仅仅是栈上的指针。</p><ul><li>以上只针对存储在堆上的类型，而对于类似整型等存储在栈上的类型，可以直接拷贝，变量值不会被移动</li></ul><h4 id="4-1-6-所有权与函数">4.1.6 所有权与函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中, </span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-引用与借用">4.2 引用与借用</h3><p>当<code>String</code>类型的变量传入函数中时，如何以引用的方式传入而不是将所有权交给函数？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;  <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">   <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234314662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201110234314662.png" srcset="data:image/png;base64,666" alt="image-20201110234314662"></p><ul><li><p><code>&amp;s1</code>语法让我们创建一个<strong>指向</strong>值<code>s1</code>的引用，但是并不拥有它</p></li><li><p>我们将获取引用作为函数参数称为<strong>借用</strong></p></li><li><p>引用<strong>默认</strong>不允许被修改</p></li></ul><h4 id="4-2-1-可变引用">4.2.1 可变引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用，如以下代码是非法的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s被引用了两次，非法</span></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure><ul><li><p>这样的限制可以避免<strong>数据竞争</strong>，即</p><ul><li>两个或更多指针同时访问同一数据</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制</li></ul></li><li><p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能<strong>同时</strong>拥有</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可变引用和不可变引用不能同时存在，如以下代码非法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><ul><li><p>由于一个引用的作用域从声明的地方开始一直持续到最后一次使用为止，所以以下代码合法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-2-2-悬垂引用">4.2.2 悬垂引用</h4><ul><li><p>所谓<strong>悬垂指针</strong>是其指向的内存可能已经被分配给其它持有者</p></li><li><p>在Rust中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域，如以下函数非法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。危险！</span></span><br></pre></td></tr></table></figure><ul><li>而应该直接返回<code>String</code>，将所有权移动出去</li></ul></li></ul><h3 id="4-3-Slice类型">4.3 Slice类型</h3><ul><li><code>slice</code>是一个没有所有权的数据类型</li><li><code>slice</code>允许你引用集合中一段连续的元素序列，而不用引用整个集合</li></ul><h4 id="4-3-1-字符串slice">4.3.1 字符串slice</h4><p>字符串 slice是<code>String</code>中一部分值的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> all_s = &amp;s[..];</span><br></pre></td></tr></table></figure><ul><li>字符串字面值就是slice，如<code>let s = &quot;Hello world&quot;</code>中，<code>s</code>的类型是<code>&amp;str</code>，是一个指向二进制程序特定位置的slice</li></ul><h4 id="4-3-2-其他类型的slice">4.3.2 其他类型的slice</h4><p>如数组slice:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="Ch5-结构体">Ch5 结构体</h2><h3 id="5-1-结构体的定义和实例化">5.1 结构体的定义和实例化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并修改字段</span></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>想要修改实例中的字段，必须将整个结构体声明为可变</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>..</code>语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值</li></ul><h4 id="5-1-1-元组结构体">5.1.1 元组结构体</h4><ul><li>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5-1-2-结构体数据的所有权">5.1.2 结构体数据的所有权</h4><ul><li>结构体可以直接存放自身拥有所有权的类型，如<code>String</code>等</li><li>结构体在存储<code>引用</code>、<code>slice</code>等没有自身所有权的类型时，需要用上生命周期</li></ul><h3 id="5-2-结构体引用和打印">5.2 结构体引用和打印</h3><h4 id="5-2-1-函数调用结构体">5.2.1 函数调用结构体</h4><p>函数引用结构体时，不需要获得其所有权，所以采用引用的方式调用:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        area(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-结构体打印">5.2.2 结构体打印</h4><p>需要使用派生trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    <span class="comment">// 或 println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-方法语法">5.3 方法语法</h3><p>使用关键字<code>impl</code>给结构体定义方法，可以避免另外定义函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 将self以不可变引用的方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.area()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-关联函数">5.3.1 关联函数</h4><p>在<code>impl</code>块中定义不以<code>self</code>作为参数的函数，通常用作返回一个结构体实例的构造函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 返回一个正方形的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>let sq = Rectangle::square(3);</code>调用关联函数</li></ul><h2 id="Ch6-枚举和模式匹配">Ch6 枚举和模式匹配</h2><h3 id="6-1-定义枚举">6.1 定义枚举</h3><ul><li>以IP地址类型为例，通过<code>enum</code>定义一个枚举类型：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建<code>IpAddrKind</code>实例：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4(<span class="number">127.0</span>.<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>枚举类型也可以像结构体一样使用<code>impl</code>为其定义方法</li></ul><h4 id="6-1-1-Option枚举">6.1.1 Option枚举</h4><ul><li><p><code>Option</code>是标准库定义的另一个枚举，且被包含在<code>preclude</code>中</p></li><li><p>Rust没有空值，但拥有<code>Option</code>枚举来编码存在或不存在</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Some</code>可以包含任意类型的数据</p></li><li><p>使用<code>None</code>需要指定类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Option&lt;T&gt;</code>类型的值不能和<code>T</code>类型的值直接运算，必须提前进行转换，因此空值在使用前必须被检查</p></li></ul><h3 id="6-2-match控制流运算符">6.2 match控制流运算符</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">   Penny,</span><br><span class="line">   Nickel,</span><br><span class="line">   Dime,</span><br><span class="line">   Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个<code>match</code>表达式的返回值</li></ul><h4 id="6-2-1-匹配Option-T">6.2.1 匹配Option&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> six = plus_one(five);</span><br><span class="line"><span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure><ul><li>用于空值处理</li><li>匹配是有穷的，必须覆盖变量的所有情况</li></ul><h4 id="6-2-2-通配符">6.2.2 _通配符</h4><ul><li><p>可以在match的所有分支的最后使用<code>_</code>来匹配剩余的所有情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-if-let-简单控制流">6.3 if let 简单控制流</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以用于替代只有两分支的<code>match</code>语句</li></ul><h2 id="Ch7-使用包、Crate和模块管理项目">Ch7 使用包、Crate和模块管理项目</h2><h3 id="7-1-包和crate">7.1 包和crate</h3><ul><li>crate是一个二进制项或者库</li><li>包 (package) 是提供一系列功能的一个或者多个 crate，一个包会包含有一个<code>Cargo.toml</code>文件，阐述如何去构建这些 crate<ul><li>一个包中至多<strong>只能</strong>包含一个库 crate</li><li>一个包中可以包含任意多个二进制 crate</li><li>一个包中至少包含一个 crate，无论是库的还是二进制的</li></ul></li><li>使用<code>cargo new</code>创建项目时，<code>src/main.rs</code>就是一个与包同名的二进制 crate 的 crate根</li><li>通过将文件放在 <code>src/bin</code> 目录下，一个包可以拥有多个二进制 crate：每个 <code>src/bin</code> 下的文件都会被编译成一个独立的二进制 crate</li></ul><h3 id="7-2-模块">7.2 模块</h3><p>模块定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">server_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模块树：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><h3 id="7-3-引用模块树中项的路径">7.3 引用模块树中项的路径</h3><p>路径的两种形式，都是通过<code>::</code>连接：</p><ul><li>**绝对路径 ** 从 crate 根开始，以 crate 名或者字面值 <code>crate</code> 开头。</li><li><strong>相对路径</strong> 从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li></ul><h4 id="7-3-1-使用pub关键字暴露路径">7.3.1 使用pub关键字暴露路径</h4><ul><li>Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，父模块不能使用子模块的私有项，但子模块可以使用父模块中的项，同级的两个模块可以互相引用</li><li>当父模块需要使用子模块的项的，需要在子模块中将其声明为<code>pub</code></li></ul><h4 id="7-3-2-使用super起始的相对路径">7.3.2 使用super起始的相对路径</h4><ul><li><code>super</code>相当于文件系统中的<code>..</code>，即当前模块的父模块</li></ul><h4 id="7-3-3-创建公有的结构体和枚举">7.3.3 创建公有的结构体和枚举</h4><ul><li>如果在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造实例 <code>Breakfast</code>，否则无法在 <code>eat_at_restaurant</code> 中创建实例</li></ul><h3 id="7-4-use关键字">7.4 use关键字</h3><ul><li>使用use关键字可以简化模块中项的调用：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;  <span class="comment">// 绝对路径</span></span><br><span class="line"><span class="comment">// 或 use front_of_house::hosting;  相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用 <code>as</code> 关键字提供新名称</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用 <code>use</code> 关键字将名称导入作用域时，在新作用域中可用的名称是私有的，可以使用 <code>pub use</code> 重导出，使得名称可以引入任何代码的作用域中</p></li></ul><h4 id="7-4-1-使用嵌套路径精简代码">7.4.1 使用嵌套路径精简代码</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 可以精简为：</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="comment">// 可以精简为：</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-2-glob运算符">7.4.2 glob运算符</h4><p>如果希望将一个路径下<strong>所有</strong>公有项引入作用域，可以指定路径后跟 <code>*</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure><h3 id="7-5-将模块分割进不同文件">7.5 将模块分割进不同文件</h3><p>先使用如下语句引入模块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br></pre></td></tr></table></figure><h2 id="Ch8-常见集合">Ch8 常见集合</h2><h3 id="8-1-vector">8.1 vector</h3><ul><li>在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值</li><li>vector 只能储存相同类型的值</li></ul><h4 id="8-1-1-新建vector">8.1.1 新建vector</h4><ul><li><p>新建空vector时需要指明类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>vec!</code> 宏来定义含有初值的vector</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-2-vector添加元素">8.1.2 vector添加元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>当vector离开作用域时，会连同其元素全部销毁</li></ul><h4 id="8-1-3-读取vector元素">8.1.3 读取vector元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li><p>使用索引访问，若越界，则会报错崩溃(适用于访问边界严格的vector)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>get</code> 方法返回一个 <code>Option&lt;&amp;T&gt;</code>，若越界，则会返回None(适用于vector索引可能由用户输入而越界)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当获取了vector的一个元素的不可变引用后，不能在其末尾添加元素，如下代码<code>非法</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.push(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-4-遍历vector中的元素">8.1.4 遍历vector中的元素</h4><ul><li><p>遍历不可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-1-5-结合枚举来存储多种类型">8.1.5 结合枚举来存储多种类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="8-2-字符串">8.2 字符串</h3><h4 id="8-2-1-新建字符串">8.2.1 新建字符串</h4><ul><li><p>新建空字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure></li><li><p>往空字符串中装载数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;initial contents&quot;</span>.to_string();</span><br></pre></td></tr></table></figure></li><li><p>新建有初始值的字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;initial contents&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-2-更新字符串">8.2.2 更新字符串</h4><ul><li><p>使用 <code>push_str</code> 方法来附加字符串 slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>push</code> 附加一个字符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.push(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>+</code> 运算符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>format!</code> 宏</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-3-索引字符串">8.2.3 索引字符串</h4><p>Rust的 <code>String</code> 字符串不支持索引单个值，但能够创建字符串slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><h4 id="8-2-4-遍历字符串">8.2.4 遍历字符串</h4><ul><li><p>遍历每个元素（每个元素可能不止一个字节）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历每个原始字节</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-哈希map">8.3 哈希map</h3><p><code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射</p><h4 id="8-3-1-新建一个哈希map">8.3.1 新建一个哈希map</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个空的Hashmap</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li>哈希 map 将它们的数据储存在堆上</li><li>所有的键必须是相同类型，值也必须都是相同类型</li></ul><p>也可以通过vector的 <code>collect</code> 方法创建</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure><h4 id="8-3-2-哈希map和所有权">8.3.2 哈希map和所有权</h4><ul><li>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map</li><li>对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者</li></ul><h4 id="8-3-3-访问哈希map中的值">8.3.3 访问哈希map中的值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure><ul><li><code>get</code> 方法返回的 <code>score</code> 是 <code>Option&lt;T&gt;</code> 类型</li></ul><h4 id="8-3-4-遍历哈希map">8.3.4 遍历哈希map</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-5-更新哈希map">8.3.5 更新哈希map</h4><ul><li><p>使用相同的键插入不同的值，会覆盖旧值</p></li><li><p>使用 <code>entry</code> 方法，只有在键没有对应的值存在的时候插入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure></li><li><p>根据旧值更新一个值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计单词出现的次数</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure><ul><li><code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）</li></ul></li></ul><h2 id="Ch9-错误处理">Ch9 错误处理</h2><h3 id="9-1-panic-与不可恢复的错误">9.1 panic!与不可恢复的错误</h3><p>遇到错误时，Rust 有 <code>panic!</code>宏，当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出</p><h4 id="9-1-1-backtrace">9.1.1 backtrace</h4><ul><li><p>backtrace 是一个执行到目前位置所有被调用的函数的列表</p></li><li><p>使用backtrace来找到自己写的代码中错误出在哪一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-Result与可恢复的错误">9.2 Result与可恢复的错误</h3><p><code>Result</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型</li><li><code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型</li></ul><h4 id="9-2-1-匹配不同的错误">9.2.1 匹配不同的错误</h4><ul><li>使用 <code>match</code> 代码比较冗长，且较难理解</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, </span><br><span class="line">                other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-unwrap">9.2.2 unwrap</h4><ul><li>如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值</li><li>如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-3-expect">9.2.3 expect</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).expect(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用方法类似 <code>unwrap</code> ，但是可以自己指定显示的错误信息</li></ul><h4 id="9-2-4-传播错误">9.2.4 传播错误</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 若文件打开失败，函数会返回相应的错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="comment">// 若文件内容写入字符串失败，函数会返回相应的错误</span></span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="comment">// 若函数执行完成没有出错，则返回Ok</span></span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust提供了<code>fs::read_to_string</code> 的函数来简化从文件读取到一个字符串中的操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-panic-的使用场景">9.3 panic!的使用场景</h3><p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code> —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况：</p><ul><li>有害状态并不包含 <strong>预期</strong> 会偶尔发生的错误</li><li>之后的代码的运行依赖于处于这种有害状态</li><li>当没有可行的手段来将有害状态信息编码进所使用的类型中的情况</li></ul><h2 id="Ch10-泛型、trait和生命周期">Ch10 泛型、trait和生命周期</h2><h3 id="10-1-泛型">10.1 泛型</h3><p>使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型</p><h4 id="10-1-1-在函数定义中使用泛型">10.1.1 在函数定义中使用泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，所以需要在函数名称之后写上 <code>&lt;T&gt;</code></li></ul><h4 id="10-1-2-结构体定义中的泛型">10.1.2 结构体定义中的泛型</h4><ul><li>字段 <code>x</code> 和 <code>y</code> 必须是相同的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段 <code>x</code> 和 <code>y</code> 可以是不同的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> both_integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> both_float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> integer_and_float = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-3-枚举定义中的泛型">10.1.3 枚举定义中的泛型</h4><p><code>Option&lt;T&gt;</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result&lt;T, E&gt;</code> 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-4-方法定义中的泛型">10.1.4 方法定义中的泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用</li><li>必须在 <code>impl</code> 后面声明 <code>T</code>，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型</li></ul><h4 id="10-1-5-泛型代码的性能">10.1.5 泛型代码的性能</h4><ul><li>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失</li><li>Rust 通过在编译时进行泛型代码的<strong>单态化</strong>来保证效率，即在编译时填充泛型所使用的具体类型，从而将通用代码转换为特定代码</li></ul><h3 id="10-2-trait：定义共享的行为">10.2 trait：定义共享的行为</h3><p><em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能</p><h4 id="10-2-1-定义并使用trait">10.2.1 定义并使用trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实现这个 trait 的类型所需要的行为的方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在impl关键字之后，提供需要实现trait的名称，接着是for和需要实现trait的类型的名称</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait</li><li>不能为外部类型实现外部 trait：例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中，它们并不位于 <code>aggregator</code> crate 本地作用域中</li></ul><h4 id="10-2-2-默认实现">10.2.2 默认实现</h4><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait提供默认实现</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-trait作为参数">10.2.3 trait作为参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>item</code> 参数，指定了 <code>impl</code> 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code></p><ul><li><p>使用trait bound重写上面的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>trait bound适合函数传入多个相同类型的参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item1和item2的类型可以不同，只要它们都实现了Summary</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: <span class="keyword">impl</span> Summary, item2: <span class="keyword">impl</span> Summary) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// item1和item2的类型必须相同</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定多个trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display)</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: T)</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>where</code> 简化trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-2-4-返回trait类型">10.2.4 返回trait类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型</li><li>只适用于返回单一类型的情况，如果有分支结构，每个分支返回不同类型，则编译不能通过</li></ul><h3 id="10-3-生命周期与引用有效性">10.3 生命周期与引用有效性</h3><h4 id="10-3-1-生命周期防止悬垂引用">10.3.1 生命周期防止悬垂引用</h4><ul><li>Rust 编译器有一个<strong>借用检查器</strong>，它比较作用域来确保所有的借用都是有效的</li><li>避免了引用比数据的生命周期短的情况</li></ul><h4 id="10-3-2-函数的泛型生命周期">10.3.2 函数的泛型生命周期</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code></li></ul><h5 id="生命周期注解语法">生命周期注解语法</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><ul><li>当有两个或以上的引用参数的生命周期注解都定义为 <code>&amp;'a i32</code> ，则这些参数的生命周期必须与这泛型生命周期一样长</li></ul><h5 id="函数签名中的生命周期注解">函数签名中的生命周期注解</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写上面的longest函数，指定了签名中所有的引用必须有相同的生命周期&#x27;a</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-3-结构体定义生命周期注解">10.3.3 结构体定义生命周期注解</h4><p>有生命周期注解的结构体可以存放引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-4-生命周期省略">10.3.4 生命周期省略</h4><p>编译器采用三条规则来判断引用何时不需要明确的注解，这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块</p><ul><li>每一个是引用的参数都有它自己的生命周期参数</li><li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数</li><li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数</li></ul><h4 id="10-3-5-方法定义中的生命周期注解">10.3.5 方法定义中的生命周期注解</h4><p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return_part</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-6-静态生命周期">10.3.6 静态生命周期</h4><ul><li><p><code>'static</code> 其生命周期<strong>能够</strong>存活于整个程序期间</p></li><li><p>所有的字符串字面值都拥有 <code>'static</code> 生命周期</p></li></ul><h2 id="Ch11-编写自动化测试">Ch11 编写自动化测试</h2><h3 id="11-1-如何编写测试">11.1 如何编写测试</h3><p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p><ol><li>设置任何所需的数据或状态</li><li>运行需要测试的代码</li><li>断言其结果是我们所期望的</li></ol><h4 id="11-1-1-测试函数剖析">11.1.1 测试函数剖析</h4><ul><li>为了将一个函数变成测试函数，需要在 <code>fn</code> 行之前加上 <code>#[test]</code></li><li>使用 <code>cargo test</code> 命令运行测试</li><li>使用 Cargo 新建一个<strong>库项目</strong>时，它会自动为我们生成一个测试模块和一个测试函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">exploration</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-2-使用assert-宏来检查结果">11.1.2 使用assert!宏来检查结果</h4><ul><li>如果值是 <code>true</code>，<code>assert!</code> 什么也不做，同时测试会通过</li><li>如果值为 <code>false</code>，<code>assert!</code> 调用 <code>panic!</code> 宏，这会导致测试失败</li></ul><h4 id="11-1-3-使用assert-eq-和assert-ne-宏来测试相等">11.1.3 使用assert_eq!和assert_ne!宏来测试相等</h4><ul><li><code>assert_eq!</code> 判断是否相等，<code>assert_ne!</code> 判断是否不等</li><li>断言失败时他们会打印出这两个值具体是什么，以便于观察测试<strong>为什么</strong>失败</li></ul><h4 id="11-1-4-自定义失败信息">11.1.4 自定义失败信息</h4><p>为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 <code>greeting</code> 函数的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greeting_contains_name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = greeting(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.contains(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">        <span class="string">&quot;Greeting did not contain name, value was `&#123;&#125;`&quot;</span>, result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-5-使用-should-panic-检查-panic">11.1.5 使用 should_panic 检查 panic</h4><ul><li><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前</li><li>这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败</li></ul><h4 id="11-1-6-将-Result-T-E-用于测试">11.1.6 将 Result&lt;T, E&gt; 用于测试</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-运行测试">11.2 运行测试</h3><h4 id="11-2-1-并行或连续的运行测试">11.2.1 并行或连续的运行测试</h4><ul><li><p>当运行多个测试时， Rust 默认使用线程来并行运行</p></li><li><p>应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境</p></li><li><p>如果有依赖，可以限制线程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --test-threads=1</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-2-显示函数输出">11.2.2 显示函数输出</h4><ul><li><p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容</p></li><li><p>如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 <code>--nocapture</code> 参数来禁用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --nocapture</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-3-通过指定名字来运行部分测试">11.2.3 通过指定名字来运行部分测试</h4><ul><li><p>运行单个测试，向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> one_hundred</span><br></pre></td></tr></table></figure></li><li><p>过滤运行多个测试，指定部分测试的名称，任何名称匹配这个名称的测试会被运行，以下命令运行了所有名字中带有 <code>add</code> 的测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> add</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-4-忽略某些测试">11.2.4 忽略某些测试</h4><p>使用 <code>ignore</code> 属性来标记耗时的测试并排除他们</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 需要运行一个小时的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code></p><h3 id="11-3-测试的组织结构">11.3 测试的组织结构</h3><h4 id="11-3-1-单元测试">11.3.1 单元测试</h4><ul><li>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。</li><li>单元测试与他们要测试的代码共同存放在位于 <em>src</em> 目录下相同的文件中。</li><li>规范是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块。</li></ul><h5 id="测试模块">测试模块</h5><p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码</p><h4 id="11-3-2-集成测试">11.3.2 集成测试</h4><ul><li><p>集成测试的目的是测试库的多个部分能否一起正常工作</p></li><li><p>二进制项目，即只有 <em>src/main.rs</em> 而没有 <em>src/lib.rs</em> 不能进行集成测试</p></li><li><p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级，可以随意在这个目录中创建任意多的测试文件</p></li><li><p>需要在文件顶部添加 <code>use</code></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch12-I-O项目：命令行程序">Ch12 I/O项目：命令行程序</h2><h3 id="12-1-接受命令行参数">12.1 接受命令行参数</h3><ul><li>使用标准库提供的函数：<code>std::env::args</code> ，返回一个传递给程序的命令行参数的<strong>迭代器</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-读取文件">12.2 读取文件</h3><ul><li>使用标准库  <code>std::fs</code> 来处理文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>, contents);</span><br></pre></td></tr></table></figure><h3 id="12-3-重构改进模块性和错误处理">12.3 重构改进模块性和错误处理</h3><p>在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程:</p><ul><li>将程序拆分成 <em><a href="http://main.rs">main.rs</a></em> 和 <em><a href="http://lib.rs">lib.rs</a></em> 并将程序的逻辑放入 <em><a href="http://lib.rs">lib.rs</a></em> 中。</li><li>当命令行解析逻辑比较小时，可以保留在 <em><a href="http://main.rs">main.rs</a></em> 中。</li><li>当命令行解析开始变得复杂时，也同样将其从 <em><a href="http://main.rs">main.rs</a></em> 提取到 <em><a href="http://lib.rs">lib.rs</a></em> 中。</li></ul><p>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>设置任何其他的配置</li><li>调用 <em><a href="http://lib.rs">lib.rs</a></em> 中的 <code>run</code> 函数</li><li>如果 <code>run</code> 返回错误，则处理这个错误</li></ul><h3 id="12-4-采用测试驱动开发完善库的功能">12.4 采用测试驱动开发完善库的功能</h3><p>测试驱动开发（Test Driven Development, TDD）模式，是一个软件开发技术，它遵循如下步骤：</p><ol><li>编写一个会失败的测试，并运行它以确保其因为你期望的原因失败。</li><li>编写或修改刚好足够的代码来使得新的测试通过。</li><li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li><li>从步骤 1 开始重复！</li></ol><h3 id="12-6-将错误信息输出到标准错误">12.6 将错误信息输出到标准错误</h3><ul><li><p>使用 <code>eprintln!</code> 将错误信息写入标准错误而不是标准输出</p></li><li><p>使用输出重定向：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run to poem.txt &gt; output.txt</span><br></pre></td></tr></table></figure><ul><li>若出错，会输出到标准错误，即显示在命令行，而不写入 <em>output.txt</em></li><li>若正常执行，会输出到标准输出，即重定向到 <em>output.txt</em></li></ul></li></ul><h2 id="Ch13-迭代器和闭包">Ch13 迭代器和闭包</h2><h3 id="13-1-闭包">13.1 闭包</h3><ul><li><p>可以保存进变量或作为参数传递给其他函数的匿名函数</p></li><li><p>使用闭包的原因是我们需要在一个位置定义代码，储存代码，并在之后的位置实际调用它</p></li></ul><h4 id="13-1-1-定义闭包">13.1.1 定义闭包</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">expensive_closure(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>闭包的定义以一对竖线（<code>|</code>）开始，在竖线中指定闭包的参数</li><li>如果有多于一个参数，可以使用逗号分隔，比如 <code>|param1, param2|</code></li></ul><h4 id="13-1-2-闭包类型推断和注解">13.1.2 闭包类型推断和注解</h4><ul><li>闭包不用于暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用</li><li>闭包定义会为每个参数和返回值推断一个具体类型</li><li>如果尝试调用闭包两次，第一次使用 <code>String</code> 类型作为参数而第二次使用 <code>u32</code>，则会得到一个错误</li></ul><h4 id="13-1-3-使用带有泛型和Fn-trait的闭包">13.1.3 使用带有泛型和Fn trait的闭包</h4><p>可以创建一个存放闭包和调用闭包结果的结构体，该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="comment">// 闭包有一个 u32 的参数并返回一个 u32</span></span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="comment">/*检查self.value是否已经有了一个 Some 的结果值；</span></span><br><span class="line"><span class="comment">            如果有，它返回 Some 中的值并不会再次执行闭包*/</span></span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="comment">/* 如果 self.value 是 None，</span></span><br><span class="line"><span class="comment">            则会调用 self.calculation 中储存的闭包，</span></span><br><span class="line"><span class="comment">            将结果保存到 self.value 以便将来使用，</span></span><br><span class="line"><span class="comment">            并同时返回结果值*/</span></span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> v = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="literal">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行闭包之前，<code>value</code> 将是 <code>None</code>。如果使用 <code>Cacher</code> 的代码请求闭包的结果，这时会执行闭包并将结果储存在 <code>value</code> 字段的 <code>Some</code> 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 <code>Some</code> 成员中的结果。</p><ul><li><code>Cacher</code> 实现的限制：<ul><li>第一次初始化 <code>value</code> 的值之后，就无法再改动；可以通过使 <code>Cacher</code> 存储一个哈希map而不是一个单独的值解决</li><li>它的应用被限制为只接受获取一个 <code>u32</code> 值并返回一个 <code>u32</code> 值的闭包</li></ul></li></ul><h4 id="13-1-4-闭包会捕获其环境">13.1.4 闭包会捕获其环境</h4><ul><li><p>闭包周围的作用域被称为其<strong>环境</strong></p></li><li><p>闭包可以捕获其环境并访问其被定义的作用域的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/* x 并不是 equal_to_x 的一个参数，</span></span><br><span class="line"><span class="comment">但equal_to_x 闭包也被允许使用变量 x，</span></span><br><span class="line"><span class="comment">因为它与 equal_to_x 定义于相同的作用域*/</span></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>闭包有三种方式捕获其环境</p><ul><li><code>FnOnce</code> 消费从周围作用域捕获的变量。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次</li><li><code>FnMut</code> 获取可变的借用值，所以可以改变其环境</li><li><code>Fn</code> 从其环境获取不可变的借用值</li></ul></li></ul><h3 id="13-2-迭代器">13.2 迭代器</h3><ul><li><p><strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑</p></li><li><p>迭代器是惰性的，即在调用方法使用迭代器之前它都不会有效果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 创建一个迭代器，但是没有任何效果</span></span><br><span class="line"><span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="comment">/* 使用迭代器遍历，迭代器中的元素才开始迭代</span></span><br><span class="line"><span class="comment">用 for 循环时无需使 v1_iter 可变，</span></span><br><span class="line"><span class="comment">因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变*/</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-1-Iterator-trait-和-next方法">13.2.1 Iterator trait 和 next方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator 是定义于标准库的 trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="comment">// Item类型将是迭代器next方法返回元素的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"><span class="comment">// next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代器上直接调用 <code>next</code> 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_demonstration</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 需要将迭代器定义为可变，因为next方法会改变迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-2-2-消费适配器">13.2.2 消费适配器</h4><ul><li><p>调用 <code>next</code> 方法的方法，如 <code>sum</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="comment">// 调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权</span></span><br><span class="line">    <span class="keyword">let</span> total: <span class="built_in">i32</span> = v1_iter.sum();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-3-迭代器适配器">13.2.3 迭代器适配器</h4><ul><li><p>将当前迭代器变为不同类型的迭代器，如 <code>map</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 调用 map 方法创建一个新迭代器，接着调用collect方法消费新迭代器并创建一个vector</span></span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-4-创建自定义迭代器">13.2.4 创建自定义迭代器</h4><p>可以实现 <code>Iterator</code> trait 来创建任何我们希望的迭代器</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Counter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的Counter迭代器的多种方法</span></span><br><span class="line"><span class="comment">// 获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在省略了第一个值之后产生的值配对，将每一对值相乘，只保留那些可以被三整除的结果，然后将所有保留的结果相加</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">using_other_iterator_trait_methods</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum: <span class="built_in">u32</span> = Counter::new().zip(Counter::new().skip(<span class="number">1</span>))</span><br><span class="line">                                 .map(|(a, b)| a * b)</span><br><span class="line">                                 .filter(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                 .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ch14-进一步认识Cargo和Crates-io">Ch14 <a href="http://xn--CargoCrates-km8q749dp96e4c7etpa368c.io">进一步认识Cargo和Crates.io</a></h2><h3 id="14-1-采用发布配置自定义构建">14.1 采用发布配置自定义构建</h3><p>Cargo 有两个主要的配置：</p><ul><li>运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置</li><li>运行 <code>cargo build --release</code> 的 <code>release</code> 配置</li></ul><p><code>dev</code> 配置被定义为开发时的好的默认配置，<code>release</code> 配置则有着良好的发布构建的默认配置</p><p>可以在 <em>Cargo.toml</em> 文件中定义 <code>[profile.*]</code> 部分来覆盖默认配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><code>opt-level</code> 设置控制 Rust 会对代码进行何种程度的优化，值从0到3，越高的优化级别需要更多的时间编译</li></ul><h3 id="14-2-将-crate-发布到-Crates-io">14.2 将 crate 发布到 <a href="http://Crates.io">Crates.io</a></h3><h3 id="14-3-Cargo工作空间">14.3 Cargo工作空间</h3><h3 id="14-4-从-Crates-io-安装二进制文件">14.4 从 <a href="http://Crates.io">Crates.io</a> 安装二进制文件</h3><p>使用命令 <code>cargo install</code> 可以从crates.io下载二进制crate，安装到 <em>~/.cargo/bin</em></p><h2 id="Ch15-智能指针">Ch15 智能指针</h2><h3 id="15-1-Box-T">15.1 Box&lt;T&gt;</h3><p>box 允许将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针</p><p>使用场景：</p><ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li></ul><h4 id="15-1-1-Box创建递归类型">15.1.1 Box创建递归类型</h4><ul><li>Rust 需要在编译时知道类型占用多少空间，而<strong>递归类型</strong>无法在编译的时候知道大小</li><li>box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了</li></ul><h5 id="以cons-list为例">以cons list为例</h5><ul><li><p>cons list 的每一项都包含两个元素：当前项的值和下一项。</p></li><li><p>其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。</p></li><li><p>cons list 通过递归调用 <code>cons</code> 函数产生。</p></li><li><p>代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust编译器无法计算一个 <code>List</code> 需要的大小，因为编译器尝试计算出储存一个 <code>List</code> 枚举需要多少内存，并开始检查 <code>Cons</code> 成员，那么 <code>Cons</code> 需要的空间等于 <code>i32</code> 的大小加上 <code>List</code> 的大小。为了计算 <code>List</code> 需要多少内存，它检查其成员，从 <code>Cons</code> 成员开始。<code>Cons</code>成员储存了一个 <code>i32</code> 值和一个<code>List</code>值，这样的计算将无限进行下去。</p><h5 id="使用Box-T-给递归类型一个已知的大小">使用Box&lt;T&gt;给递归类型一个已知的大小</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>,</span><br><span class="line">            <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>,</span><br><span class="line">                <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何 <code>List</code> 值最多需要一个 <code>i32</code> 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 <code>List</code> 值需要的大小了。</p><h3 id="15-2-Deref-trait">15.2 Deref trait</h3><p>实现 <code>Deref</code> trait 允许我们重载<strong>解引用运算符</strong> <code>*</code></p><h4 id="15-2-1-像引用一样使用-Box-T">15.2.1 像引用一样使用 Box&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-自定义智能指针">15.2.2 自定义智能指针</h4><p>定义 <code>MyBox&lt;T&gt;</code> 类型:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-3-在自定义智能指针实现-Deref-trait">15.2.3 在自定义智能指针实现 Deref trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义trait的关联类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        <span class="comment">// deref返回了我希望通过*运算符访问的值的引用</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br></pre></td></tr></table></figure><p><code>*y</code> 在Rust底层运行了 <code>*(y.deref())</code></p><h4 id="15-2-4-函数和方法的隐式解引用强制多态">15.2.4 函数和方法的隐式解引用强制多态</h4><p><strong>解引用强制多态</strong>是 Rust 在函数或方法传参上的一种便利。将实现了 <code>Deref</code> 的类型的引用转换为原始类型通过 <code>Deref</code> 所能够转换的类型的引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">// 解引用强制多态将 &amp;MyBox&lt;String&gt; 自动转换为 &amp;str</span></span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-Drop-trait">15.3 Drop trait</h3><ul><li><p>允许我们在值要离开作用域时执行一些代码，可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源</p></li><li><p>通过 <code>Drop</code> trait 中的 <code>drop</code> 方法，可以在变量离开作用域时自动丢弃该值</p></li></ul><h4 id="15-3-1-通过-std-mem-drop-提早丢弃值">15.3.1 通过 std::mem::drop 提早丢弃值</h4><ul><li>Rust不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法</li><li>当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>，其位于preclude，可以直接通过 <code>drop(variable);</code> 调用</li></ul><h3 id="15-4-Rc-T-引用计数智能指针">15.4 Rc&lt;T&gt; 引用计数智能指针</h3><ul><li><p>有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。</p></li><li><p>Rust 使用<strong>引用计数</strong> <code>Rc&lt;T&gt;</code> 的类型来启用多所有权，记录了一个值引用的数量来知晓这个值是否仍在被使用。</p></li><li><p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。</p></li><li><p><code>Rc&lt;T&gt;</code> 只能用于单线程场景</p></li></ul><h4 id="15-4-1-使用-Rc-T-共享数据">15.4.1 使用 Rc&lt;T&gt; 共享数据</h4><p>使用 <code>Box&lt;T&gt;</code> 定义的 cons list 的两个列表 <code>b</code> 和 <code>c</code>, 共享第三个列表 <code>a</code> 的所有权</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201112210915469.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Rust-notes/image-20201112210915469.png" srcset="data:image/png;base64,666" alt="image-20201112210915469"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Rc::clone</code> 只会增加引用计数，而不会深拷贝</li><li>在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 <code>Rc::strong_count</code> 函数获得</li></ul><h3 id="15-5-RefCell-T-和内部可变性模式">15.5 RefCell&lt;T&gt; 和内部可变性模式</h3><p><strong>内部可变性</strong>是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的</p><h3 id="15-6-引用循环与内存泄漏">15.6 引用循环与内存泄漏</h3><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存，但是创建引用循环从而造成内存泄漏的可能性是存在的</p><h2 id="Ch16-并发">Ch16 并发</h2><h3 id="16-1-使用线程同时运行代码">16.1 使用线程同时运行代码</h3><p>线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p><ul><li>竞争状态，多个线程以不一致的顺序访问数据或资源</li><li>死锁，两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li><li>只会发生在特定情况且难以稳定重现和修复的 bug</li></ul><h4 id="16-1-1-使用-spawn-创建新线程">16.1.1 使用 spawn 创建新线程</h4><p>为了创建一个新线程，需要调用 <code>thread::spawn</code> 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            <span class="comment">// thread::sleep调用强制线程停止执行一小段时间，允许其他不同的线程运行</span></span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 4 from the main thread!</span></span><br><span class="line"><span class="comment">hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>当主线程结束时，新线程也会结束，而不管其是否执行完毕</li></ul><h4 id="16-1-2-使用-join-等待所有线程结束">16.1.2 使用 join 等待所有线程结束</h4><ul><li><code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code></li><li><code>JoinHandle</code> 是一个拥有所有权的值，当对其调用 <code>join</code> 方法时，它会等待其线程结束</li><li>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 从thread::spawn保存一个JoinHandle来确保该线程能够运行结束</span></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-1-3-线程与-move-闭包">16.1.3 线程与 move 闭包</h4><p>在参数列表前使用 <code>move</code> 关键字强制闭包获取其使用的环境值的所有权，可用于创建新线程时将值的所有权从一个线程移动到另一个线程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-2-线程间消息传递">16.2 线程间消息传递</h3><p>Rust 中一个实现消息传递并发的主要工具是<strong>通道</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>mpsc::channel</code> 函数创建一个新的通道，可以有多个<strong>发送端</strong>，但只能有一个<strong>接收端</strong>， <code>mpsc::channel</code> 函数返回一个元组：(发送端，接收端)，或 <code>(tx, rx)</code></p></li><li><p>通道的发送端有一个 <code>send</code> 方法用来获取需要放入通道的值，返回一个 <code>Result&lt;T, E&gt;</code> 类型</p><ul><li><code>send</code> 函数获取其参数的所有权并移动这个值归接收者所有，所以线程在发送 <code>val</code> 之后就不能再使用它了</li></ul></li><li><p>通道的接收端有两个有用的方法：<code>recv</code> 和 <code>try_recv</code></p><ul><li><code>recv</code> 会阻塞主线程执行直到从通道中接收一个值，一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它；当通道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了</li><li><code>try_recv</code> 不会阻塞，立刻返回一个 <code>Result&lt;T, E&gt;</code>：<code>Ok</code> 值包含可用的信息，而 <code>Err</code> 值代表此时没有任何消息</li></ul></li><li><p>可以将 <code>rx</code> 作为迭代器来接收发送端发送的多个数据，并通过 <code>for</code> 循环打印</p></li><li><p>可以通过 <code>clone</code> 方法来创建多个发送端:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br></pre></td></tr></table></figure></li></ul><h3 id="16-3-共享状态并发">16.3 共享状态并发</h3><h4 id="16-3-1-互斥器">16.3.1 互斥器</h4><ul><li>通过<strong>锁</strong>来保证任意时刻只有一个线程能访问某些数据</li><li>使用方式：<ul><li>在使用数据之前尝试获取锁。</li><li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li></ul></li><li>使用 <code>Mutex&lt;T&gt;</code> 实现<ul><li>通过关联函数 <code>new</code> 来创建 <code>Mutex&lt;T&gt;</code></li><li>使用 <code>lock</code> 方法获取锁，该方法会阻塞当前线程，直到拥有锁为止</li><li><code>lock</code> 调用返回一个叫做 <code>MutexGuard</code> 的智能指针，当其离开作用域时，会自动释放锁</li></ul></li></ul><h4 id="16-3-2-在线程间共享-Mutex-T">16.3.2 在线程间共享 Mutex&lt;T&gt;</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<strong>原子引用计数</strong> <code>Arc&lt;T&gt;</code> 来实现 <code>Mutex&lt;T&gt;</code> 在多线程之间共享所有权</li></ul><h2 id="Ch17-Rust面向对象">Ch17 Rust面向对象</h2><h3 id="17-1-面向对象语言的特征">17.1 面向对象语言的特征</h3><ul><li>对象包含数据和行为：结构体和枚举包含数据，<code>impl</code> 块提供对应方法</li><li>封装隐藏了实现细节：不添加 <code>pub</code> 就是私有的</li><li>通过继承重用代码：使用 <code>trait</code> 对象</li></ul><h3 id="17-2-为使用不同类型的值而设计的-trait-对象">17.2 为使用不同类型的值而设计的 trait 对象</h3><h3 id="17-3-面向对象设计模式的实现">17.3 面向对象设计模式的实现</h3><h2 id="Ch18-模式">Ch18 模式</h2><h3 id="18-1-用到模式的位置">18.1 用到模式的位置</h3><h4 id="18-1-1-match分支">18.1.1 match分支</h4><p>在形式上 <code>match</code> 表达式由 <code>match</code> 关键字、用于匹配的值和一个或多个分支构成，这些分支包含一个模式和在值匹配分支的模式时运行的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-1-2-if-let-表达式">18.1.2 if let 表达式</h4><ul><li>等同于只关心一个情况的 <code>match</code> 语句简写</li><li><code>if let</code> 表达式的缺点在于其穷尽性没有为编译器所检查，而 <code>match</code> 表达式则检查了</li></ul><h4 id="18-1-3-while-let-条件循环">18.1.3 while let 条件循环</h4><p>允许只要模式匹配就一直进行 <code>while</code> 循环</p><h4 id="18-1-4-for循环">18.1.4 for循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.iter().enumerate() &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>(index, value)</code> 来匹配 <code>enumerate</code></p><h4 id="18-1-5-let语句">18.1.5 let语句</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PATTERN = EXPRESSION;</span><br></pre></td></tr></table></figure><h4 id="18-1-6-函数参数">18.1.6 函数参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x</code> 部分就是一个模式</p><h3 id="18-2-可反驳和不可反驳">18.2 可反驳和不可反驳</h3><ul><li><p>能匹配任何传递的可能值的模式被称为是<strong>不可反驳的</strong>，如 <code>let x = 5;</code> 中的 <code>x</code></p></li><li><p>对某些可能的值进行匹配会失败的模式被称为是<strong>可反驳的</strong>，如 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code></p></li><li><p>函数参数、 <code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式</p></li><li><p>匹配分支必须使用可反驳模式，如 <code>if let</code></p></li></ul><h3 id="18-3-模式语法">18.3 模式语法</h3><h4 id="18-3-1-匹配字面值">18.3.1 匹配字面值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-2-匹配命名变量">18.3.2 匹配命名变量</h4><p>命名变量是匹配任何值的不可反驳模式，当其用于 <code>match</code> 表达式时，情况会不一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">会打印：</span></span><br><span class="line"><span class="comment">Matched, y = 5</span></span><br><span class="line"><span class="comment">at the end: x = Some(5), y = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>match</code> 表达式的新作用域中， <code>y</code> 是一个新变量，而不是开头声明为值 10 的那个 <code>y</code> ，新的 <code>y</code> 绑定会匹配任何 <code>Some</code> 中的值，在这里是 <code>x</code> 中的值</li></ul><h4 id="18-3-3-多个模式">18.3.3 多个模式</h4><p>使用 <code>|</code> 语法匹配多个模式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-4-通过-…-匹配值的范围">18.3.4 通过 …= 匹配值的范围</h4><ul><li><p>使用 <code>1..=5</code> 替代 <code>1 | 2 | 3 | 4 | 5</code></p></li><li><p>对 <code>char</code> 类型也适用：<code>'a'..='j'</code></p></li></ul><h4 id="18-3-5-忽略模式中的值">18.3.5 忽略模式中的值</h4><ul><li><p>使用 <code>_</code> 忽略整个值</p></li><li><p>通过 <code>_x</code> 来忽略未使用的变量</p></li><li><p>使用 <code>..</code> 忽略剩余的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., last) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="18-3-6-匹配守卫">18.3.6 匹配守卫</h4><p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-7-绑定">18.3.7 @绑定</h4><ul><li><p><code>@</code> 允许我们在创建一个存放值的变量的同时测试其值是否匹配模式</p></li><li><p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="built_in">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    <span class="comment">// 将id值保存在id_variable中</span></span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无法保存id值</span></span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch19-高级特征">Ch19 高级特征</h2><h3 id="19-1-不安全的Rust">19.1 不安全的Rust</h3><h3 id="19-2-高级trait">19.2 高级trait</h3><h3 id="19-3-高级类型">19.3 高级类型</h3><h3 id="19-4-高级函数与闭包">19.4 高级函数与闭包</h3><h3 id="19-5-宏">19.5 宏</h3>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pointers on C - Learn</title>
      <link href="2020/11/11/C%E5%92%8C%E6%8C%87%E9%92%88notes/"/>
      <url>2020/11/11/C%E5%92%8C%E6%8C%87%E9%92%88notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Ch2-基本概念">Ch2 基本概念</h2><h3 id="2-1-环境">2.1 环境</h3><h4 id="2-1-1-翻译环境">2.1.1 翻译环境</h4><ul><li><p>翻译过程：各源文件通过<code>编译过程</code>分别转为<strong>目标代码</strong> -&gt; 各目标代码文件由<strong>链接器</strong>捆绑为单一完整的可执行程序</p></li><li><p>编译过程：预处理器处理 -&gt; 源代码经过<strong>解析</strong>判断语句的意思，从而生成目标代码 -&gt; 优化器对目标代码进一步处理</p></li></ul><h4 id="2-1-4-执行环境">2.1.4 执行环境</h4><ul><li><p>程序执行过程：程序载入内存 -&gt; 启动程序调用main函数 -&gt; 程序的终止</p></li><li><p>程序运行过程中使用一个运行时的<strong>堆栈</strong>，用于存储函数的局部变量和返回地址；同时，程序也可以使用<strong>静态内存</strong>，其中的值在程序整个执行过程都会保留</p></li></ul><h3 id="2-2-词法规则">2.2 词法规则</h3><h4 id="2-2-1-字符">2.2.1 字符</h4><ul><li><p>\ddd：三个八进制数字表示的字符</p></li><li><p>\xddd：三个十六进制数字表示的字符</p></li></ul><h4 id="2-2-2-注释">2.2.2 注释</h4><ul><li><p>//：单行注释</p></li><li><p>/*     */：多行注释</p></li></ul><h3 id="TIPS">TIPS:</h3><ul><li>有的程序从标准输入读取数据，读到EOF停止，在终端输入时Ctrl+D即为输入EOF</li></ul><h2 id="Ch3-数据">Ch3 数据</h2><h3 id="3-1-基本数据类型">3.1 基本数据类型</h3><h4 id="3-1-1-整型">3.1.1 整型</h4><p>变量的最小范围</p><table><thead><tr><th>类型</th><th>最小范围</th></tr></thead><tbody><tr><td>char</td><td>0 ~ 2<sup>7</sup>-1</td></tr><tr><td>signed char</td><td>-(2<sup>7</sup>-1) ~ 2<sup>7</sup>-1</td></tr><tr><td>unsigned char</td><td>0 ~ 2<sup>8</sup>-1</td></tr><tr><td>short int</td><td>-(2<sup>15</sup>-1) ~ 2<sup>15</sup>-1</td></tr><tr><td>unsigned short int</td><td>0 ~ 2<sup>16</sup>-1</td></tr><tr><td>int</td><td>-(2<sup>15</sup>-1) ~ 2<sup>15</sup>-1</td></tr><tr><td>unsigned int</td><td>0 ~ 2<sup>16</sup>-1</td></tr><tr><td>long int</td><td>-(2<sup>31</sup>-1) ~ 2<sup>31</sup>-1</td></tr><tr><td>unsigned long int</td><td>0 ~ 2<sup>32</sup>-1</td></tr></tbody></table><ul><li><p>short int至少16位，long int至少32位</p></li><li><p>头文件limits.h说明各种不同的整型的特点</p></li></ul><p><strong>一、整型常量</strong></p><ul><li><p>声明为const，初始化之后不能被改变</p></li><li><p>十进制整型常量可能是int、long、unsigned long。缺省情况下为最短类型但能完整容纳这个值</p></li><li><p>八进制整数以0开头</p></li><li><p>十六进制整数以0x开头</p></li><li><p>字符常量：类型为int，是单引号包围的单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;M&#x27;</span><span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>宽字符常量：多字节字符常量的前面有个L</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&#x27;X&#x27;L&#x27;e^&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二、枚举类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Jar_Type</span> &#123;</span>CUP, PINT, QUART, HALF_GALLON, GALLON&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Jar_Type</span> <span class="title">milk_jug</span>, <span class="title">gas_can</span>, <span class="title">medicine_bottle</span>;</span></span><br></pre></td></tr></table></figure><ul><li>以整型方式存储，符号名实际值都是整型值。如CUP=0，PINT=1，以此类推</li><li>可以显式定值，若未指定值，则比前一个符号名大1</li></ul><h4 id="3-1-2-浮点类型">3.1.2 浮点类型</h4><ul><li>包括float、double、long double类型</li><li>所有浮点类型至少能容纳从10<sup>-37</sup>到10<sup>37</sup>之间的任何值</li><li>头文件float.h说明各种不同的浮点型的特点</li><li>浮点数默认为double类型；后面跟L/l表示long double；后面跟F/f表示float</li></ul><h4 id="3-1-3-指针">3.1.3 指针</h4><p><strong>一、指针常量</strong></p><ul><li>一般都通过操作符来获得一个变量的地址，而不是通过表示为字面值的指针常量，如0xff2044ec</li></ul><p><strong>二、字符串常量</strong></p><ul><li>字符串：以NUL字节结尾的零个或多个字符，存储在字符数组中</li><li>字符串常量：直接值是一个“指向字符的指针”，而不是这些字符本身</li></ul><h3 id="3-2-基本声明">3.2 基本声明</h3><h4 id="3-2-2-声明简单数组">3.2.2 声明简单数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><ul><li>编译器不检查数组的下标是否在合法范围内，所以当下标是通过用户输入计算而来的，必须检测是否越界<ul><li>如果越界，不会报错，只会返回null</li></ul></li></ul><h4 id="3-2-3-声明指针">3.2.3 声明指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">// 把message声明为一个指向字符的指针，并用字符串常量中的第1个字符的地址对其初始化</span></span><br><span class="line"><span class="comment">// 等价于以下语句</span></span><br><span class="line"><span class="keyword">char</span> *message;</span><br><span class="line">message = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-typedef">3.3 typedef</h3><p>为各种数据类型定义新名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将变量ptr_to_char声明为一个指向字符的指针类型的新名字</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *ptr_to_char;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明a是一个指向字符的指针</span></span><br><span class="line">ptr_to_char a;</span><br></pre></td></tr></table></figure><h3 id="3-4-常量">3.4 常量</h3><p>const</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明整数常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *pci;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向整型的常量指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> cpi;</span><br></pre></td></tr></table></figure><p>#define</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 20</span></span><br></pre></td></tr></table></figure><h3 id="3-5-作用域">3.5 作用域</h3><h4 id="3-5-1-代码块作用域">3.5.1 代码块作用域</h4><ul><li><p>代码块：位于一对花括号之间的所有语句</p></li><li><p>嵌套代码块中，内层可以访问外层变量，而外层无法访问内层变量，但是当内外层有名字相同的变量时，内层无法访问外层的那个同名变量</p></li><li><p>非嵌套的代码块中，作用域没有重叠，所以编译器可以把它们存储在同一个内存地址</p></li></ul><h4 id="3-5-2-文件作用域">3.5.2 文件作用域</h4><ul><li>任何在所有代码块之外声明的标识符都具有文件作用域，在声明处到源文件末尾都可以访问</li></ul><h4 id="3-5-3-原型作用域">3.5.3 原型作用域</h4><ul><li>只适用于在函数原型中声明的参数名</li></ul><h4 id="3-5-4-函数作用域">3.5.4 函数作用域</h4><ul><li>只适用于语句标签，语句标签用于goto语句</li></ul><h3 id="3-6-链接属性">3.6 链接属性</h3><p><strong>一、none 没有链接属性</strong></p><ul><li>声明的同名标识符被当作独立不同的实体</li></ul><p><strong>二、internal属性</strong></p><ul><li>单个文件中声明的同名标识符表示同一个实体</li></ul><p><strong>三、external属性</strong></p><ul><li>多个文件中声明的同名标识符表示同一个实体</li><li>只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。</li><li>默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体。</li></ul><p><strong>四、关键字extern和static</strong></p><ul><li>如果某个标识符在正常情况下具有external链接属性(只能是具有文件作用域的标识符)，在其前面加上static关键字可以将其链接属性变为internal</li><li>链接属性只能修改一次，也就是说一旦将标识符的链接属性变为internal，就无法变回external了</li></ul><h3 id="3-7-存储类型">3.7 存储类型</h3><ul><li>存储变量的内存类型，有普通内存、运行时堆栈、硬件寄存器</li><li>在任何代码块之外声明的变量存储在<strong>静态内存</strong>中，为静态变量，在程序运行之前创建</li><li>在代码块内部声明的变量的缺省存储类型是自动的，即存储于<strong>堆栈</strong>中，进入代码块创建，离开代码块销毁<ul><li>在代码块内部声明的变量加上static关键字，变为静态变量，但作用域不变。如在函数中声明static变量a，则a在程序开始执行时就被初始化，并且每次函数被调用时，a不会重新初始化</li></ul></li><li>关键字register声明自动变量，存储在<strong>硬件寄存器</strong>中，为寄存器变量</li></ul><p><strong>初始化</strong></p><ul><li>如果不显式指定初值，静态变量将初始化为0，而自动变量初始值不确定</li></ul><h3 id="3-8-static关键字">3.8 static关键字</h3><ul><li>用于函数定义或在代码块外声明变量时，将标识符的链接属性从external改为internal，但变量的存储类型和作用域不受影响</li><li>在代码块内部声明变量时将标识符的存储类型从自动变量改为静态变量，但变量的链接属性和作用域不受影响</li></ul><h3 id="3-9-总结">3.9 总结</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201028211529931.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201028211529931.png" srcset="data:image/png;base64,666" alt="image-20201028211529931"></p><h2 id="Ch4-语句">Ch4 语句</h2><h3 id="4-1-空语句">4.1 空语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><p>只包含一个分号，不执行任何任务</p><h3 id="4-2-表达式语句">4.2 表达式语句</h3><ul><li><p>C不存在赋值语句，赋值通过表达式语句(在表达式之后加上一个分号)实现，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>以下语句也是合法的，但结果被立即丢弃：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码块">4.3 代码块</h3><p>位于一对花括号之内的可选的声明和语句列表</p><h3 id="4-4-if语句">4.4 if语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C语言不存在布尔变量，而使用整型的0和1代替，所以expression的结果不是0就是1</li></ul><h3 id="4-5-while语句">4.5 while语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>break终止所在while代码块的所有循环；continue终止所在while代码块的当前循环</li></ul><h3 id="4-6-for语句">4.6 for语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化部分; 条件部分; 调整部分)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-do语句">4.7 do语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure><ul><li>循环体至少执行一次</li></ul><h3 id="4-8-switch语句">4.8 switch语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression<span class="number">-1</span>:</span><br><span class="line">        statement<span class="number">-1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression<span class="number">-2</span>:</span><br><span class="line">        statement<span class="number">-2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch的条件expression必须为整型值</li><li>每个case标签必须具有唯一的值</li><li>每个switch语句都应该添加一条并且只能添加一条default语句，可以在case语句列表的任何位置</li></ul><h3 id="4-9-goto语句">4.9 goto语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 语句标签;</span><br></pre></td></tr></table></figure><ul><li>语句标签是在标识符后添加一个冒号，并跟上一些表达式语句</li><li>要尽可能避免使用goto语句</li></ul><h2 id="Ch5-操作符和表达式">Ch5 操作符和表达式</h2><h3 id="5-1-操作符">5.1 操作符</h3><h4 id="5-1-1-算术操作符">5.1.1 算术操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure><h4 id="5-1-2-移位操作符">5.1.2 移位操作符</h4><ul><li><p>左移：&lt;&lt;</p></li><li><p>右移：&gt;&gt;</p></li><li><p>无符号数的所有移位操作都是逻辑移位，有符号数是逻辑移位还是算术移位取决于编译器</p></li></ul><h4 id="5-1-3-位操作符">5.1.3 位操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; | ~</span><br><span class="line"><span class="comment">// 与或非</span></span><br></pre></td></tr></table></figure><ul><li><p>将value指定位置1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = value | <span class="number">1</span> &lt;&lt; bit_number;</span><br></pre></td></tr></table></figure></li><li><p>将value指定位置0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = value &amp; ~ (<span class="number">1</span> &lt;&lt; bit_number);</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-5-单目操作符">5.1.5 单目操作符</h4><ul><li><p>!：逻辑取反，产生整型结果0或1</p></li><li><p>~：操作数每一位取反</p></li><li><p>-：取负</p></li><li><p>&amp;：取操作数的地址</p></li><li><p>*：间接访问，访问指针所指向的值</p></li><li><p>sizeof：判断操作数的类型长度，以字节为单位，操作数可以是变量，也可以是加上括号的类型</p><ul><li>sizeof (a = b + 1)并没有向a赋值</li></ul></li><li><p>强制类型转换，如获得整型变量a对应的浮点数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">float</span>) a</span><br></pre></td></tr></table></figure></li><li><p>c+：增值操作符，<ins>a在变量被使用之前增加它的值，a</ins>在变量被使用之后增加它的值</p></li></ul><h4 id="5-1-6-关系操作符">5.1.6 关系操作符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &gt;=    &lt;  &lt;=    ==  !=</span><br></pre></td></tr></table></figure><ul><li>产生的结果是整型的0或1</li></ul><h4 id="5-1-7-逻辑操作符">5.1.7 逻辑操作符</h4><ul><li>&amp;&amp;：对于expression1 &amp;&amp; expression2，若expression1为假，则不再对expression2求值</li><li>||：对于expression1 || expression2，若expression1为真，则不再对expression2求值</li></ul><h4 id="5-1-8-条件操作符">5.1.8 条件操作符</h4><p>expression1 ? expression2 : expression3</p><h3 id="5-2-布尔值">5.2 布尔值</h3><ul><li>C没有显式的布尔类型，用整数代替，0是假，任何非零值都是真</li></ul><h3 id="5-4-表达式求值">5.4 表达式求值</h3><ul><li><p>函数进行表达式求值时应该尽量避免以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f() + g() + h()</span><br></pre></td></tr></table></figure><p>而使用以下形式，因为如果函数的返回值和执行顺序相关，则会产生不确定性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = f();</span><br><span class="line">temp += g();</span><br><span class="line">temp += h();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch6-指针">Ch6 指针</h2><h3 id="6-1-内存和地址">6.1 内存和地址</h3><ul><li>内存中的每个位置由一个独一无二的地址标识</li><li>内存中的每个位置都包含一个值</li><li>编译器帮助实现通过变量访问内存位置，但是硬件仍然通过地址访问内存位置</li></ul><h3 id="6-2-值和类型">6.2 值和类型</h3><p>不能简单地通过检查一个值的位来判断它的类型，因为不同的数据类型和指令会将其解释为不同的类型</p><h3 id="6-5-未初始化和非法的指针">6.5 未初始化和非法的指针</h3><p>在对指针进行间接访问之前，一定要进行初始化，下面是一个<strong>错误例子</strong>，因为指针a指向的位置不能确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">*a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="6-6-NULL指针">6.6 NULL指针</h3><ul><li><p>NULL指针不指向任何东西</p></li><li><p>要使一个指针变量为NULL，可以给它赋一个零值；测试一个指针变量是否为NULL，可以将它与零值比较</p></li></ul><h3 id="6-7-指针、间接访问和左值">6.7 指针、间接访问和左值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *d = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法，对指针d指向的值(a)进行修改</span></span><br><span class="line">*d = <span class="number">10</span> - *d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法，整型数的计算结果赋给指针</span></span><br><span class="line">d = <span class="number">10</span> - *d;</span><br></pre></td></tr></table></figure><h3 id="6-10-指针的指针">6.10 指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>相当的表达式</th></tr></thead><tbody><tr><td>a</td><td>12</td></tr><tr><td>b</td><td>&amp;a</td></tr><tr><td>*b</td><td>a, 12</td></tr><tr><td>c</td><td>&amp;b</td></tr><tr><td>*c</td><td>b, &amp;a</td></tr><tr><td>**c</td><td>*b, a, 12</td></tr></tbody></table><h3 id="6-11-指针表达式">6.11 指针表达式</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112510530.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112510530.png" srcset="data:image/png;base64,666" alt="image-20201030112510530"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112528313.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112528313.png" srcset="data:image/png;base64,666" alt="image-20201030112528313"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112553253.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112553253.png" srcset="data:image/png;base64,666" alt="image-20201030112553253"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112611434.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112611434.png" srcset="data:image/png;base64,666" alt="image-20201030112611434"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112624338.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112624338.png" srcset="data:image/png;base64,666" alt="image-20201030112624338"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112817215.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112817215.png" srcset="data:image/png;base64,666" alt="image-20201030112817215"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112834050.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112834050.png" srcset="data:image/png;base64,666" alt="image-20201030112834050"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112852658.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112852658.png" srcset="data:image/png;base64,666" alt="image-20201030112852658"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112905585.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112905585.png" srcset="data:image/png;base64,666" alt="image-20201030112905585"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112918911.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112918911.png" srcset="data:image/png;base64,666" alt="image-20201030112918911"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112931420.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112931420.png" srcset="data:image/png;base64,666" alt="image-20201030112931420"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112944852.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112944852.png" srcset="data:image/png;base64,666" alt="image-20201030112944852"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112958540.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030112958540.png" srcset="data:image/png;base64,666" alt="image-20201030112958540"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030113010189.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030113010189.png" srcset="data:image/png;base64,666" alt="image-20201030113010189"></p><h3 id="6-13-指针运算">6.13 指针运算</h3><h4 id="6-13-1-算术运算">6.13.1 算术运算</h4><ul><li>当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据对应变量的类型的长度进行调整。例如若float类型指针变量p占4个字节，则p+1不会指向p的第二字节，而是会指向p所占的4个字节之后的那个字节</li><li>两个指针只有当都指向同一个数组中的元素时，才允许进行相减，并且减法的结果是两个元素在数组中的距离，而不是内存地址的差值，即在减法运算的同时会除掉变量类型的长度</li></ul><h4 id="6-13-2-关系运算">6.13.2 关系运算</h4><p>对于指向同一个数组中的元素的指针，可以用关系操作符(<code>&gt; &lt; &gt;= &lt;=</code>)来判断哪个指针指向数组中更前或更后的元素</p><h2 id="Ch7-函数">Ch7 函数</h2><h3 id="7-2-函数声明">7.2 函数声明</h3><h4 id="7-2-1-原型">7.2.1 原型</h4><ul><li><p>原型总结了函数定义的起始部分的声明，向编译器提供有关函数应该如何调用的完整信息</p></li><li><p>函数原型的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func_use.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// func.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>声明一个没有参数的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2-2-函数的缺省认定">7.2.2 函数的缺省认定</h4><p>当程序调用一个无法见到原型的函数时，编译器会认为该函数返回一个整型</p><h3 id="7-3-函数的参数">7.3 函数的参数</h3><ul><li>所有参数都是<strong>传值调用</strong>，函数不会修改实际传递的参数</li><li>当传递的参数是指针时，可以通过指针的间接访问修改指针所指的值，称为<strong>传址调用</strong></li></ul><h3 id="7-4-ADT和黑盒">7.4 ADT和黑盒</h3><p>使用static关键字限制对非接口函数和数据的访问</p><h3 id="7-5-递归">7.5 递归</h3><ul><li>通过运行时堆栈支持递归函数的实现</li></ul><p>通过一个简单的递归作为实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个整型值(无符号)，把它转换为字符并打印，前导零被删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_to_ascii</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quotient;</span><br><span class="line">    </span><br><span class="line">    quotient = value / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (quotient != <span class="number">0</span>) &#123;</span><br><span class="line">        binary_to_ascii(quotient);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(value % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-1-追踪递归函数">7.5.1 追踪递归函数</h4><p>程序运行时堆栈的变化：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144906982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144906982.png" srcset="data:image/png;base64,666" alt="image-20201030144906982"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144921304.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144921304.png" srcset="data:image/png;base64,666" alt="image-20201030144921304"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144933258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144933258.png" srcset="data:image/png;base64,666" alt="image-20201030144933258"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144943300.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144943300.png" srcset="data:image/png;base64,666" alt="image-20201030144943300"></p><p>​…</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144956035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030144956035.png" srcset="data:image/png;base64,666" alt="image-20201030144956035"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145042009.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145042009.png" srcset="data:image/png;base64,666" alt="image-20201030145042009"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145053160.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145053160.png" srcset="data:image/png;base64,666" alt="image-20201030145053160"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145101621.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145101621.png" srcset="data:image/png;base64,666" alt="image-20201030145101621"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145110915.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030145110915.png" srcset="data:image/png;base64,666" alt="image-20201030145110915"></p><h4 id="7-5-2-递归与迭代">7.5.2 递归与迭代</h4><ul><li>如果一个递归函数内部所执行的最后一条语句就是调用自身时，被称为尾部递归，这样的递归很容易被改写为循环迭代的形式，而迭代的效率通常较高</li></ul><h3 id="7-6-可变参数列表">7.6 可变参数列表</h3><h4 id="7-6-1-stdarg宏">7.6.1 stdarg宏</h4><p>定义于stdarg.h头文件</p><ul><li>类型va_list：用于声明变量来访问参数列表的未确定部分<ul><li>此时声明函数的方式为<code>float average(int n, ...)</code></li></ul></li><li>宏va_start：初始化va_list声明的变量，第1个参数是va_list变量名，第2个参数是省略号前的最后一个有名字的参数</li><li>宏va_arg：用于访问参数，第1个参数是va_list变量名，第2个参数是参数列表中下一个参数的类型，返回这个参数的值，并指向下一个可变参数</li><li>宏va_end：访问完最后一个可变参数后调用，参数为va_list变量名</li></ul><h4 id="7-6-2-可变参数的限制">7.6.2 可变参数的限制</h4><ul><li>这些宏无法判断实际存在的参数的数量</li><li>这些宏无法判断每个参数的类型</li></ul><h2 id="Ch8-数组">Ch8 数组</h2><h3 id="8-1-一维数组">8.1 一维数组</h3><h4 id="8-1-1-数组名">8.1.1 数组名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><p>b[3]的类型是整型</p></li><li><p>b是一个指向b[0]的常量指针，因而不能修改数组名的值，即不能修改数组存储的内存地址</p></li><li><p>数组的赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个表达式作用相同，将c指向a[0]</span></span><br><span class="line">c = &amp;a[<span class="number">0</span>];</span><br><span class="line">c = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>// 以下表达式非法，不能将数组复制给数组，数组间的复制只能通过循环逐个元素复制<br>b = a;</p><p>// 以下表达式非法，a是常量，不能被修改<br>a = c;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 8.1.2 下标引用</span><br><span class="line"></span><br><span class="line">通过以下例子说明：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">int array[10];</span><br><span class="line">int *ap &#x3D; array + 2;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>对等表达式</th></tr></thead><tbody><tr><td>ap</td><td>array+2, &amp;array[2]</td></tr><tr><td>*ap</td><td>array[2], *(array+2)</td></tr><tr><td>ap[0]</td><td>array[2]</td></tr><tr><td>ap+6</td><td>array+8, &amp;array[8]</td></tr><tr><td>*ap+6</td><td>array[2]+6</td></tr><tr><td>*(ap+6)</td><td>array[8]</td></tr><tr><td>ap[-1]</td><td>array[1]</td></tr><tr><td>ap[9]</td><td>非法</td></tr></tbody></table><h4 id="8-1-3-指针与下标">8.1.3 指针与下标</h4><p>指针有时比下标更加高效</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172144100.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172144100.png" srcset="data:image/png;base64,666" alt="image-20201030172144100"></p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172236189.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030172236189.png" srcset="data:image/png;base64,666" alt="image-20201030172236189"></p><ul><li>在数组中一次一步移动时，与固定数字相乘的运算在编译的时候完成，所以在运行时所需的指令就少</li><li>但这在实际中不常用，因为可能编译器对循环会有优化</li></ul><h4 id="8-1-5-数组和指针">8.1.5 数组和指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];   <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> *b;     <span class="comment">// 指针</span></span><br></pre></td></tr></table></figure><ul><li><p>a和b都具有指针值，都可以进行间接访问和下标引用操作</p></li><li><p>区别：</p><ul><li>声明数组时，编译器会为数组保留内存空间，然后再创建数组名</li><li>声明指针变量时，编译器只为指针本身保留内存空间，而不为整型值分配内存空间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030175554658.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030175554658.png" srcset="data:image/png;base64,666" alt="image-20201030175554658"></p></li><li><p>在上述声明后：</p><ul><li>*a是合法的，*b是非法的，因为*b将访问内存中某个不确定的位置</li><li>b<ins>是合法的，a</ins>是非法的，因为a是常量指针</li></ul></li></ul><h4 id="8-1-7-声明数组参数">8.1.7 声明数组参数</h4><p>下面的函数原型是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-1-8-初始化">8.1.8 初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>静态初始化：静态变量存储在静态内存，只初始化一次</li><li>自动初始化：自动变量在缺省情况下是未初始化的，若给定初值，则每次进入代码块都会重新初始化</li></ul><h4 id="8-1-9-不完整的初始化">8.1.9 不完整的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>vector[4]被初始化为0</p><h4 id="8-1-10-自动计算数组长度">8.1.10 自动计算数组长度</h4><p>如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有初始值的长度</p><h4 id="8-1-11-字符数组的初始化">8.1.11 字符数组的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字符串数组</span></span><br><span class="line"><span class="keyword">char</span> message1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个字符串常量</span></span><br><span class="line"><span class="keyword">char</span> *message2 = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030233429373.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030233429373.png" srcset="data:image/png;base64,666" alt="image-20201030233429373"></p><h3 id="8-2-多维数组">8.2 多维数组</h3><h4 id="8-2-1-存储顺序">8.2.1 存储顺序</h4><p>定义一个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><p>其在内存中的存储形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030235423211.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201030235423211.png" srcset="data:image/png;base64,666" alt="image-20201030235423211"></p><p>这18个元素的下标值依次是(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (1,0) … (2,4) (2,5)</p><h4 id="8-2-2-数组名">8.2.2 数组名</h4><p>如在<code>int matrix[3][10]</code>中，matrix是指向一个包含10个整型元素的数组的指针</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000129705.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000129705.png" srcset="data:image/png;base64,666" alt="image-20201031000129705"></p><p>那么matrix+1则指向：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000214011.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000214011.png" srcset="data:image/png;base64,666" alt="image-20201031000214011"></p><p>而*(matrix + 1) + 5就等价于matrix[1] + 5，是一个指向整型的指针：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000530029.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031000530029.png" srcset="data:image/png;base64,666" alt="image-20201031000530029"></p><h4 id="8-2-4-指向数组的指针">8.2.4 指向数组的指针</h4><p>声明一个指向整型数组的指针，并令其指向matrix数组的第一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = matrix;</span><br></pre></td></tr></table></figure><h4 id="8-2-5-作为函数参数的多维数组">8.2.5 作为函数参数的多维数组</h4><p>可以使用以下两张形式的任何一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*mat)[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> mat[][<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-2-6-初始化">8.2.6 初始化</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031171919198.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031171919198.png" srcset="data:image/png;base64,666" alt="image-20201031171919198"></p><h4 id="8-2-7-数组长度自动计算">8.2.7 数组长度自动计算</h4><p>在多维数组中，只有第1维才能根据初始化列表缺省地提供，剩余的几个维必须显式写出</p><h3 id="8-3-指针数组">8.3 指针数组</h3><p>定义方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *keyword[] = &#123;</span><br><span class="line">    <span class="string">&quot;do&quot;</span>,</span><br><span class="line">    <span class="string">&quot;for&quot;</span>,</span><br><span class="line">    <span class="string">&quot;if&quot;</span>,</span><br><span class="line">    <span class="string">&quot;return&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义的好处在于如果要遍历这个表，只需要<code>for (kwp=keyword; *kwp!=NULL; kwp++)</code></p><h2 id="Ch9-字符串、字符和字节">Ch9 字符串、字符和字节</h2><h3 id="9-1-字符串基础">9.1 字符串基础</h3><ul><li>字符串的长度不包含最后的NUL字节</li><li>头文件string.h包含了使用字符串函数所需的原型和声明</li></ul><h3 id="9-2-字符串长度">9.2 字符串长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回类型为size_t，是一个无符号整数类型</p></li><li><p>不要在表达式中同时包含有符号数和无符号数，因此应该把strlen的返回值<strong>强制转换为int</strong></p></li></ul><h3 id="9-3-不受限制的字符串函数">9.3 不受限制的字符串函数</h3><h4 id="9-3-1-复制字符串">9.3.1 复制字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>dst必须是一个字符数组或是一个指向动态分配内存的数组的指针</li><li>复制字符串前必须保证目标字符数组的空间足以容纳需要复制的字符串，不然会覆盖数组之后内存的内容</li></ul><h4 id="9-3-2-连接字符串">9.3.2 连接字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将src字符串的拷贝添加到dst字符串之后</li></ul><h4 id="9-3-4-字符串比较">9.3.4 字符串比较</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若s1小于s2，返回一个小于0的值；若s1大于s2，返回一个大于0的值；若s1和s2相等，返回0</li></ul><h3 id="9-4-长度受限的字符串函数">9.4 长度受限的字符串函数</h3><ul><li><p>字符串复制，将src的前len个字符(不够补NUL)复制给dst，但当src的长度大于len时，只能复制len个字符给dst，因此结果的dst最后是没有NUL的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串连接，将src的前len个字符(不够补NUL)连接到dst后面，会自动添加一个NUL在dst的最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串比较，比较两个字符串的前len位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-5-字符串查找基础">9.5 字符串查找基础</h3><h4 id="9-5-1-查找一个字符">9.5.1 查找一个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在字符串str中查找字符ch第一次出现的位置，返回一个指向该位置的指针，若没有找到返回NULL指针</li><li>strchr从左开始找，strrchr从右开始找</li></ul><h4 id="9-5-2-查找任何几个字符">9.5.2 查找任何几个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回一个指向str中第一个匹配group中任何一个字符的位置指针</li></ul><h4 id="9-5-3-查找一个子串">9.5.3 查找一个子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针</li></ul><h3 id="9-6-高级字符串查找">9.6 高级字符串查找</h3><h4 id="9-6-1-查找一个字符串前缀">9.6.1 查找一个字符串前缀</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strspn</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strcspn</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *group)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>strspn返回str起始部分匹配group中任意字符的字符数，而strcspn找的是非group中的字符</p></li><li><p>例如得到指向字符串中第一个非空白字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prt = buffer + <span class="built_in">strspn</span>(buffer, <span class="string">&quot;\n\t\r\f\v&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-6-2-查找标记">9.6.2 查找标记</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> <span class="keyword">const</span> *sep)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>从字符串中隔离各个单独的称为标记的部分</p></li><li><p>sep定义了用作分隔符的字符集合</p></li><li><p>若strtok的第一个参数不是NULL，函数将找到字符串的第一个标记，同时保存它在字符串中的位置；若strtok的第一个参数是NULL，函数将在同一个字符串中从保存的位置开始查找下一个标记；若找不到下一个标记，则返回NULL</p></li><li><p>例子：查找被空白分隔的单词</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (token=strtok(line, whitespace); token!=<span class="literal">NULL</span>; token=strtok(<span class="literal">NULL</span>, whitespace)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-7-错误信息">9.7 错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> error_number)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数为错误代码，返回一个指向用于描述错误的字符串的指针</li></ul><h3 id="9-8-字符操作">9.8 字符操作</h3><p>头文件ctype.h</p><h4 id="9-8-1-字符分类">9.8.1 字符分类</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031215526209.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201031215526209.png" srcset="data:image/png;base64,666" alt="image-20201031215526209"  /><h4 id="9-8-2-字符大小写转换">9.8.2 字符大小写转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-9-内存操作">9.9 内存操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> <span class="keyword">const</span> *src, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a, <span class="keyword">void</span> <span class="keyword">const</span> *b, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>与strn带头的函数不同，这些函数遇到NUL字节时不会停止操作</li></ul><h2 id="Ch10-结构和联合">Ch10 结构和联合</h2><h3 id="10-1-结构基础知识">10.1 结构基础知识</h3><p>当一个结构变量在表达式中使用时，并不被替换成一个指针，而是一个标量类型</p><h4 id="10-1-1-结构声明">10.1.1 结构声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125; x, y[<span class="number">20</span>], *z;</span><br></pre></td></tr></table></figure><ul><li>声明了结构体x，包含20个结构体的数组y，指向结构体的指针z</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">x</span>, <span class="title">y</span>[20], *<span class="title">z</span>;</span></span><br></pre></td></tr></table></figure><p>推荐使用以下声明方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125; Simple;</span><br><span class="line"></span><br><span class="line">Simple x, y[<span class="number">20</span>], *z;</span><br></pre></td></tr></table></figure><h4 id="10-1-2-结构成员">10.1.2 结构成员</h4><ul><li><p>直接访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple simp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问成员a</span></span><br><span class="line">simp.a</span><br></pre></td></tr></table></figure></li><li><p>间接访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple *simp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问成员a</span></span><br><span class="line">simp-&gt;a</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-1-5-结构的自引用">10.1.5 结构的自引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; SELF_REF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125; SELF_REF;</span><br></pre></td></tr></table></figure><h4 id="10-1-6-不完整的声明">10.1.6 不完整的声明</h4><p>用于多个相互依赖的结构体之间的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-2-结构、指针和成员">10.2 结构、指针和成员</h3><p>后面几节都以以下结构体为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b[<span class="number">2</span>];</span><br><span class="line">&#125; Ex2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ex</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">    Ex2 c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EX</span> *<span class="title">d</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184819038.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184819038.png" srcset="data:image/png;base64,666" alt="image-20201101184819038" style="zoom:80%;" /><p>若声明一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex x = &#123;<span class="number">10</span>, <span class="string">&quot;Hi&quot;</span>, &#123;<span class="number">5</span>, &#123;<span class="number">-1</span>, <span class="number">25</span>&#125;&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">Ex *px = &amp;x;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184841055.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101184841055.png" srcset="data:image/png;base64,666" alt="image-20201101184841055"></p><h4 id="10-2-1-访问指针">10.2.1 访问指针</h4><ul><li>px的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185055208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185055208.png" srcset="data:image/png;base64,666" alt="image-20201101185055208"></p><ul><li>px的左值：<ul><li>px+1是一个非法的左值</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185116789.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185116789.png" srcset="data:image/png;base64,666" alt="image-20201101185116789"></p><h4 id="10-2-2-访问结构">10.2.2 访问结构</h4><ul><li>*px的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185329988.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185329988.png" srcset="data:image/png;base64,666" alt="image-20201101185329988"></p><ul><li>*px的左值（接受一个新值）：<ul><li>*px+1是非法的，因为没办法将结构体和整型相加</li><li>*(px+1)也是非法的</li></ul></li></ul><h4 id="image-2020110118534746710-2-3-访问结构成员"><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185347467.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185347467.png" srcset="data:image/png;base64,666" alt="image-20201101185347467">10.2.3 访问结构成员</h4><ul><li>px-&gt;a的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185553782.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185553782.png" srcset="data:image/png;base64,666" alt="image-20201101185553782"></p><ul><li><p>如果进行以下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = &amp;px-&gt;a;</span><br></pre></td></tr></table></figure><p>则pi为：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185756719.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101185756719.png" srcset="data:image/png;base64,666" alt="image-20201101185756719"></p><p>​**注：**<em>px的结果是整个结构，而</em>pi的结果是一个整型数</p><ul><li>px-&gt;b的右值为指针常量，所以没有合法左值：<ul><li>对数组元素的访问采用px-&gt;b[1]</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190015612.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190015612.png" srcset="data:image/png;base64,666" alt="image-20201101190015612"></p><h4 id="10-2-4-访问嵌套的结构">10.2.4 访问嵌套的结构</h4><ul><li>px-&gt;c的左值是整个结构，右值如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190226613.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190226613.png" srcset="data:image/png;base64,666" alt="image-20201101190226613"></p><ul><li>px-&gt;c.a的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190313143.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190313143.png" srcset="data:image/png;base64,666" alt="image-20201101190313143"></p><ul><li>*px-&gt;c.b的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190339608.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190339608.png" srcset="data:image/png;base64,666" alt="image-20201101190339608"></p><h4 id="10-2-5-访问指针成员">10.2.5 访问指针成员</h4><p>对px-&gt;d进行初始化，使其指向一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex y;</span><br><span class="line">px-&gt;d = &amp;y;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190547718.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190547718.png" srcset="data:image/png;base64,666" alt="image-20201101190547718"></p><ul><li>px-&gt;d-&gt;c.b[1]的右值：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190624854.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101190624854.png" srcset="data:image/png;base64,666" alt="image-20201101190624854"></p><h3 id="10-3-结构的存储分配">10.3 结构的存储分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上述结构体，若整型长度为4字节，而且它的起始存储位置必须能被4整除，于是a存储为1字节，但是后面必须空出3字节才能存放b，其存储形式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101191932308.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201101191932308.png" srcset="data:image/png;base64,666" alt="image-20201101191932308"></p><p>一个结构体占了12个字节的存储空间，有效利用空间却只有6字节</p><p>如果声明改为如下形式，则只需要8个字节就能存储这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>sizeof可以得出一个结构体的整体长度，包括跳过的字节</li><li>使用offset(type, member)能获得结构体中某成员的实际位置，如offset(struct ALIGN, b)</li></ul><h3 id="10-4-作为函数参数的结构">10.4 作为函数参数的结构</h3><ul><li><p>最好使用指针来传递参数，并声明为寄存器变量来提高效率</p><ul><li><p>若结构体成员不能改变，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">register</span> ALIGN <span class="keyword">const</span> *test)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>若需要根据程序运行结果修改结构体中的值，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">register</span> ALIGN *test)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>调用方式都为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(&amp;align);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="10-5-位段">10.5 位段</h3><ul><li>注重可移植性的程序应该避免使用位段</li></ul><h3 id="10-6-联合">10.6 联合</h3><ul><li><p>联合的所有成员引用的是内存中的相同位置</p></li><li><p>如果联合的各个成员具有不同的长度，联合的长度就是最长成员的长度</p></li><li><p>应用场景比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VARIABLE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>INT, FLOAT, STRING&#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">float</span> f;</span><br><span class="line">        <span class="keyword">char</span> *s;</span><br><span class="line">    &#125; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于整型，type设为INT，存储于value.i中；对于浮点数，type设为FLOAT，存储于value.f中；</p></li><li><p>联合的初始化，初始值必须是联合第一个成员的类型，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">4</span>];</span><br><span class="line">&#125; x = &#123;<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ch11-动态内存分配">Ch11 动态内存分配</h2><h3 id="11-1-为什么使用动态分配内存">11.1 为什么使用动态分配内存</h3><p>声明数组时，数组的长度往往在运行时才能知道，但是编译时需要指定数组的长度，因为需要提前开辟内存空间。</p><h3 id="11-2-malloc和free">11.2 malloc和free</h3><ul><li>在头文件stdlib.h中声明</li></ul><h4 id="11-2-1-malloc">11.2.1 malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>malloc从内存池中提取一块合适的内存，并返回一个指向这块内存起始位置的指针(如果内存池中的内存可以满足需求的话，否则返回NULL)</li><li>参数是需要分配的内存字节数</li><li>malloc分配的是一块连续的内存</li><li>分配的内存不会被初始化</li></ul><h4 id="11-2-2-free">11.2.2 free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *pointer)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数是NULL时不会产生任何效果</li><li>参数是先前从malloc、calloc或realloc返回的值时，将分配的内存归还给内存池</li></ul><h3 id="11-3-calloc和realloc">11.3 calloc和realloc</h3><h4 id="11-3-1-calloc">11.3.1 calloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num_elements, <span class="keyword">size_t</span> element_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数包括所需元素的数量和每个元素的字节数</li><li>将分配的内存初始化为0</li></ul><h4 id="11-3-2-realloc">11.3.2 realloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>用于修改一个原先已经分配的内存块的大小</li><li>扩大内存块时，在原先的内存块之后添加；缩小内存块时，从原先内存块的尾部删除</li></ul><h3 id="11-4-使用动态分配的内存">11.4 使用动态分配的内存</h3><ul><li><p>获得足够存储25个整型的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = <span class="built_in">malloc</span>(<span class="number">25</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-5-常见的动态内存错误">11.5 常见的动态内存错误</h3><ul><li><p>对NULL指针进行解引用操作</p></li><li><p>对分配的内存进行操作时越界</p></li><li><p>释放并非动态分配的内存</p></li><li><p>试图释放一块动态分配的内存的一部分</p></li><li><p>一块动态内存被释放之后被继续使用</p></li><li><p>内存泄漏：在使用完毕动态内存后没有进行释放</p></li></ul><h2 id="Ch12-使用结构和指针">Ch12 使用结构和指针</h2><h3 id="12-2-单链表">12.2 单链表</h3><p>声明一个节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>链表结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105130430994.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105130430994.png" srcset="data:image/png;base64,666" alt="image-20201105130430994"></p><h4 id="12-2-1-插入一个有序单链表">12.2.1 插入一个有序单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的参数是一个指向链表第一个节点的指针，以及一个需要插入的新值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sll_node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sll_insert</span><span class="params">(<span class="keyword">register</span> Node **linkp, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> Node *current;</span><br><span class="line">    <span class="keyword">register</span> Node *<span class="keyword">new</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找正确的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> ((current=*linkp) != <span class="literal">NULL</span> &amp;&amp; current-&gt;value &lt; new_value) &#123;</span><br><span class="line">        linkp = &amp;current-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    <span class="keyword">new</span> = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;link = current;</span><br><span class="line">    *linkp = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-双链表">12.3 双链表</h3><p>声明一个双链表节点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">fwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">bwd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>双链表结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105133824925.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Pointers-on-c-Notes/image-20201105133824925.png" srcset="data:image/png;base64,666" alt="image-20201105133824925"></p><h2 id="Ch14-预处理器">Ch14 预处理器</h2><h3 id="14-1-预定义符号">14.1 预定义符号</h3><table><thead><tr><th>符号</th><th>样例</th><th>含义</th></tr></thead><tbody><tr><td>_<em>FILE</em>_</td><td>“name.c”</td><td>进行编译的文件名</td></tr><tr><td>_<em>LINE</em>_</td><td>25</td><td>文件当前行的行号</td></tr><tr><td>_<em>DATE</em>_</td><td>“Jan 31 1997”</td><td>文件被编译的日期</td></tr><tr><td>_<em>TIME</em>_</td><td>“18:04:30”</td><td>文件被编译的时间</td></tr><tr><td>_<em>STDC</em>_</td><td>1</td><td>如果编译器遵循ANSI C，值为1</td></tr></tbody></table><h3 id="14-2-define">14.2 #define</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> name stuff</span></span><br></pre></td></tr></table></figure><p>替换文本不仅限于数值字面值常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_forever for(;;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE break;case</span></span><br></pre></td></tr></table></figure><h4 id="14-2-1-宏">14.2.1 宏</h4><p>#define允许把参数替换到文本中，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) (x)*(x)</span></span><br><span class="line"></span><br><span class="line">SQUARE(<span class="number">5</span>)   <span class="comment">// 输出25</span></span><br></pre></td></tr></table></figure><h4 id="14-2-3-宏与函数">14.2.3 宏与函数</h4><p>可以使用宏来实现简单的函数，如比较大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><h4 id="14-2-6-undef">14.2.6 #undef</h4><p>移除一个宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> name</span></span><br></pre></td></tr></table></figure><h3 id="14-3-条件编译">14.3 条件编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 常量表达式</span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>如果常量表达式非零，则statements正常编译，否则不编译</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习 - SQ1复形</title>
      <link href="2020/11/04/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/"/>
      <url>2020/11/04/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview">Overview</h2><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104190715236.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104190715236.png" srcset="data:image/png;base64,666" alt="image-20201104190715236"></p><h2 id="CS-Algs-by-Depth">CS Algs by Depth</h2><h3 id="Depth-1">Depth 1</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104191942490.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104191942490.png" srcset="data:image/png;base64,666" alt="image-20201104191942490"></td><td>/</td><td>/</td></tr></tbody></table><h3 id="Depth-2">Depth 2</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192059289.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192059289.png" srcset="data:image/png;base64,666" alt="image-20201104192059289"></td><td>/-3-3/</td><td>/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192131237.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192131237.png" srcset="data:image/png;base64,666" alt="image-20201104192131237"></td><td>/3/</td><td>/-3/</td></tr></tbody></table><h3 id="Depth-3">Depth 3</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192837328.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104192837328.png" srcset="data:image/png;base64,666" alt="image-20201104192837328"></td><td>/3/1/</td><td>/-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104193911825.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104193911825.png" srcset="data:image/png;base64,666" alt="image-20201104193911825"></td><td>/-3/-2/</td><td>/2/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194301885.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194301885.png" srcset="data:image/png;base64,666" alt="image-20201104194301885"></td><td>/3/3/</td><td>/-3/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194351763.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194351763.png" srcset="data:image/png;base64,666" alt="image-20201104194351763"></td><td>/3/12/</td><td>/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194631403.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194631403.png" srcset="data:image/png;base64,666" alt="image-20201104194631403"></td><td>/33/-1-2/</td><td>/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194831210.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194831210.png" srcset="data:image/png;base64,666" alt="image-20201104194831210"></td><td>/33/-1/</td><td>/1/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194906760.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104194906760.png" srcset="data:image/png;base64,666" alt="image-20201104194906760"></td><td>/-3-3/2/</td><td>/-2/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195100188.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195100188.png" srcset="data:image/png;base64,666" alt="image-20201104195100188"></td><td>/3/1-4/</td><td>/-14/-3/</td></tr></tbody></table><h3 id="Depth-4">Depth 4</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195239653.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195239653.png" srcset="data:image/png;base64,666" alt="image-20201104195239653"></td><td>/33/-1-2/-2-4/</td><td>/24/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195402306.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195402306.png" srcset="data:image/png;base64,666" alt="image-20201104195402306"></td><td>/-3-3/01/-2-2/</td><td>-2/22/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195546376.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104195546376.png" srcset="data:image/png;base64,666" alt="image-20201104195546376"></td><td>/3/1-4/42/</td><td>/24/1/-4/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104200419264.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104200419264.png" srcset="data:image/png;base64,666" alt="image-20201104200419264"></td><td>/3/1-4/-2-4/</td><td><strong><code>/-4-2/1/-4/3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104203853713.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104203853713.png" srcset="data:image/png;base64,666" alt="image-20201104203853713"></td><td>/33/-1-2/0-4/</td><td>/04/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204102761.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204102761.png" srcset="data:image/png;base64,666" alt="image-20201104204102761"></td><td>/33/12/02/</td><td>/0-2/21/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204218035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204218035.png" srcset="data:image/png;base64,666" alt="image-20201104204218035"></td><td>/33/-1-2/0-2/</td><td>/02/12/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204256742.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204256742.png" srcset="data:image/png;base64,666" alt="image-20201104204256742"></td><td>/-3-3/01/-2/</td><td>/2/0-1/33/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204502256.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204502256.png" srcset="data:image/png;base64,666" alt="image-20201104204502256"></td><td>/3/1-4/4/</td><td>y2 /0-4/-41/3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204733435.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104204733435.png" srcset="data:image/png;base64,666" alt="image-20201104204733435"></td><td>1-1/0-3/5-2/04/</td><td><strong><code>y2 /-4/1/-4/3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205118213.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205118213.png" srcset="data:image/png;base64,666" alt="image-20201104205118213"></td><td>/03/12/-32/</td><td>/-34/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205234862.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205234862.png" srcset="data:image/png;base64,666" alt="image-20201104205234862"></td><td>1-1/0-3/-1-2/3-2/</td><td>/-32/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205624947.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205624947.png" srcset="data:image/png;base64,666" alt="image-20201104205624947"></td><td>/3/1-4/02/</td><td><strong><code>/0-2/-14/-3/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205728979.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205728979.png" srcset="data:image/png;base64,666" alt="image-20201104205728979"></td><td>/0-3/0-1/02/</td><td>/0-2/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205859708.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205859708.png" srcset="data:image/png;base64,666" alt="image-20201104205859708"></td><td>/0-3/0-1/12/</td><td>/-1-2/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205950415.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104205950415.png" srcset="data:image/png;base64,666" alt="image-20201104205950415"></td><td>1-1/3/21/-2/</td><td><strong><code>/2/12/03/</code></strong></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210319195.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210319195.png" srcset="data:image/png;base64,666" alt="image-20201104210319195"></td><td>/3/12/4/</td><td>/-4/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210408388.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210408388.png" srcset="data:image/png;base64,666" alt="image-20201104210408388"></td><td>1-1/0-3/-1-2/0-4/</td><td>/04/12/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210512395.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210512395.png" srcset="data:image/png;base64,666" alt="image-20201104210512395"></td><td>1-1/3/21/-2-3/</td><td>/23/-2-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210603505.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210603505.png" srcset="data:image/png;base64,666" alt="image-20201104210603505"></td><td>/3/12/23/</td><td>/-2-3/-1-2/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210645921.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210645921.png" srcset="data:image/png;base64,666" alt="image-20201104210645921"></td><td>/33/-1/4/</td><td>/-4/1/-3-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210758160.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210758160.png" srcset="data:image/png;base64,666" alt="image-20201104210758160"></td><td>1-1/3/21/0-3/</td><td>/03/-2-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210924727.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104210924727.png" srcset="data:image/png;base64,666" alt="image-20201104210924727"></td><td>/0-3/0-1/1/</td><td>/-1/01/03/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104211056172.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104211056172.png" srcset="data:image/png;base64,666" alt="image-20201104211056172"></td><td>/0-3/0-1/04/</td><td>/0-4/01/03/</td></tr></tbody></table><h3 id="Depth-5">Depth 5</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th><th>Note</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104214123694.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104214123694.png" srcset="data:image/png;base64,666" alt="image-20201104214123694"></td><td>/03/12/-3/02/</td><td><strong><code>/0-2/3/-1-2/0-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104215905927.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104215905927.png" srcset="data:image/png;base64,666" alt="image-20201104215905927"></td><td>/0-3/0-1/1/02/</td><td><strong><code>/0-2/-1/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104220413801.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104220413801.png" srcset="data:image/png;base64,666" alt="image-20201104220413801"></td><td>1-1/03/01/-1/0-2/</td><td><strong><code>/02/02/1/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221315982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221315982.png" srcset="data:image/png;base64,666" alt="image-20201104221315982"></td><td>/3/12/2-3/34/</td><td>/32/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213314692.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213314692.png" srcset="data:image/png;base64,666" alt="image-20201104213314692"></td><td>1-1/0-3/-1-2/3-4/-3/</td><td>/3/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213425561.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104213425561.png" srcset="data:image/png;base64,666" alt="image-20201104213425561"></td><td>1-1/0-3/-1-2/3-2/3/</td><td>/-3/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221827619.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104221827619.png" srcset="data:image/png;base64,666" alt="image-20201104221827619"></td><td>1-1/0-3/-1-2/0-4/-3/</td><td><strong><code>/3/04/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104222735067.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104222735067.png" srcset="data:image/png;base64,666" alt="image-20201104222735067"></td><td>/03/12/04/3/</td><td><strong><code>/-3/62/-12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233553524.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233553524.png" srcset="data:image/png;base64,666" alt="image-20201104233553524"></td><td>/33/1/-2/2/</td><td>/-2/2/-1/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104223119427.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104223119427.png" srcset="data:image/png;base64,666" alt="image-20201104223119427"></td><td>/33/-1-2/-2/1-2/</td><td><strong><code>/-12/2/12/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104224012377.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104224012377.png" srcset="data:image/png;base64,666" alt="image-20201104224012377"></td><td>/33/-1-2/02/2-1/</td><td><strong><code>/-21/0-2/12/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234024560.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234024560.png" srcset="data:image/png;base64,666" alt="image-20201104234024560"></td><td>1-1/3/21/2-3/2-1/</td><td>/-21/-23/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234520095.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104234520095.png" srcset="data:image/png;base64,666" alt="image-20201104234520095"></td><td>1-1/3/21/4-3/-21/</td><td>/2-1/-43/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230509180.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230509180.png" srcset="data:image/png;base64,666" alt="image-20201104230509180" style="zoom:130%;" /></td><td>/0-3/0-1/1/32/</td><td><strong><code>/-3-2/-1/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230553088.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/复习-SQ1复形/image-20201104230553088.png" srcset="data:image/png;base64,666" alt="image-20201104230553088" style="zoom:130%;" /></td><td>1-1/0-3/-1/0-2/-3-2/</td><td><strong><code>/32/02/1/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104225944910.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104225944910.png" srcset="data:image/png;base64,666" alt="image-20201104225944910"></td><td>/33/-1-2/-2-4/-3/</td><td>/3/24/12/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104230030964.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104230030964.png" srcset="data:image/png;base64,666" alt="image-20201104230030964"></td><td>1-1/0-3/-1-2/0-4/-32/</td><td><strong><code>/3-2/04/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231503453.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231503453.png" srcset="data:image/png;base64,666" alt="image-20201104231503453"></td><td>1-1/-3/-1-2/4/-2/</td><td><strong><code>/2/-4/12/3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235201130.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235201130.png" srcset="data:image/png;base64,666" alt="image-20201104235201130"></td><td>/33/-1-2/0-4/02/</td><td>/0-2/04/12/-3-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231611888.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104231611888.png" srcset="data:image/png;base64,666" alt="image-20201104231611888"></td><td>1-1/3/21/2/0-1/</td><td><strong><code>/01/-2/-2-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232130549.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232130549.png" srcset="data:image/png;base64,666" alt="image-20201104232130549"></td><td>1-1/0-3/-1-2/02/0-1/</td><td><strong><code>/01/0-2/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232211689.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232211689.png" srcset="data:image/png;base64,666" alt="image-20201104232211689"></td><td>/3/12/-2/01/</td><td><strong><code>/0-1/2/-1-2/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232318699.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232318699.png" srcset="data:image/png;base64,666" alt="image-20201104232318699"></td><td>/03/12/02/3-2/</td><td><strong><code>/-32/0-2/-1-2/0-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232554844.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232554844.png" srcset="data:image/png;base64,666" alt="image-20201104232554844"></td><td>/3/1/-2/2/</td><td>/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232626895.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104232626895.png" srcset="data:image/png;base64,666" alt="image-20201104232626895"></td><td>/3/1/-2-1/01/</td><td><strong><code>/0-1/21/-1/-3/</code></strong></td><td>三小角换风筝尾</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233425542.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104233425542.png" srcset="data:image/png;base64,666" alt="image-20201104233425542"></td><td>/3/1/-2/0-1/</td><td><strong><code>/01/2/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235428645.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235428645.png" srcset="data:image/png;base64,666" alt="image-20201104235428645"></td><td>1-1/0-3/-1-2/3-4/32/</td><td>/-3-2/-34/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235508229.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235508229.png" srcset="data:image/png;base64,666" alt="image-20201104235508229"></td><td>/3/12/-23/21/</td><td>/-2-1/2-3/-1-2/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235554034.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235554034.png" srcset="data:image/png;base64,666" alt="image-20201104235554034"></td><td>1-1/0-3/-1-2/3-2/-3/</td><td>/3/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235637927.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235637927.png" srcset="data:image/png;base64,666" alt="image-20201104235637927"></td><td>/03/12/-32/3/</td><td>/-3/3-2/-1-2/0-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235721071.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235721071.png" srcset="data:image/png;base64,666" alt="image-20201104235721071"></td><td>1-1/0-3/-1-2/3-2/0-2/</td><td>/02/-32/12/03/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235832145.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201104235832145.png" srcset="data:image/png;base64,666" alt="image-20201104235832145"></td><td>/3/1-4/02/-1/</td><td>/1/0-2/-14/-3/</td><td>构造飞镖</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093024208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093024208.png" srcset="data:image/png;base64,666" alt="image-20201105093024208"></td><td>/3/1-4/02/0-2/</td><td><strong><code>/02/0-2/-14/-3/</code></strong></td><td>构造飞镖</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105000229881.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105000229881.png" srcset="data:image/png;base64,666" alt="image-20201105000229881"></td><td>1-1/3/21/2-3/0-1/</td><td>/01/-23/-2-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105092327756.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105092327756.png" srcset="data:image/png;base64,666" alt="image-20201105092327756"></td><td>/33/-1-2/2/0-1/</td><td><strong><code>/01/-2/12/-3-3/</code></strong></td><td>三小角并一小角</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093823821.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105093823821.png" srcset="data:image/png;base64,666" alt="image-20201105093823821"></td><td>/-3-3/01/-2-2/1-2/</td><td>\</td><td>合并六星</td></tr></tbody></table><h3 id="Depth-6">Depth 6</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th><th>Note</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094450515.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094450515.png" srcset="data:image/png;base64,666" alt="image-20201105094450515"></td><td>/0-3/-2-1/-32/-1-2/-4/</td><td><strong><code>/4/12/3-2/21/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094654340.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094654340.png" srcset="data:image/png;base64,666" alt="image-20201105094654340"></td><td>1-1/-3/-1-2/2-3/-2-1/0-4/</td><td>/04/21/-23/12/3/</td><td>待优化</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094819794.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094819794.png" srcset="data:image/png;base64,666" alt="image-20201105094819794"></td><td>1-1/0-3/-1-2/3-4/-1-2/-2/</td><td><strong><code>/2/12/ -34/12/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095130553.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095130553.png" srcset="data:image/png;base64,666" alt="image-20201105095130553"></td><td>1-1/3/21/4-3/21/02/</td><td><strong><code>/0-2/-2-1/-43/-2-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095323990.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095323990.png" srcset="data:image/png;base64,666" alt="image-20201105095323990"></td><td>/0-3/0-1/12/2/-1/</td><td><strong><code>/1/-2/-1-2/01/03/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095631429.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095631429.png" srcset="data:image/png;base64,666" alt="image-20201105095631429"></td><td>/3/1/-2-1/0-2/01/</td><td><strong><code>/0-1/02/21/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095654217.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095654217.png" srcset="data:image/png;base64,666" alt="image-20201105095654217"></td><td>/3/1/-2/2/03/</td><td>/0-3/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095830977.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105095830977.png" srcset="data:image/png;base64,666" alt="image-20201105095830977"></td><td>/33/1/-2-2/21/-2-2/</td><td>\</td><td>两步变六星</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100045458.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100045458.png" srcset="data:image/png;base64,666" alt="image-20201105100045458"></td><td>/3/1/-2/0-1/2/</td><td>/-2/01/2/-1/-3/</td><td>两步后23动1</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100234945.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100234945.png" srcset="data:image/png;base64,666" alt="image-20201105100234945"></td><td>/3/1/-2-1/01/-2/</td><td>/2/0-1/21/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100350400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100350400.png" srcset="data:image/png;base64,666" alt="image-20201105100350400"></td><td>/33/1/-2/2/-2-3/</td><td><strong><code>/23/-2/2/-1/-3-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100619220.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105100619220.png" srcset="data:image/png;base64,666" alt="image-20201105100619220"></td><td>/3/12/-2/01/2/</td><td><strong><code>/-2/0-1/2/-1-2/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101051905.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101051905.png" srcset="data:image/png;base64,666" alt="image-20201105101051905"></td><td>/3/12/-2/2-3/-2/</td><td><strong><code>/21/2-1/21/-1/-3/</code></strong></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101400605.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101400605.png" srcset="data:image/png;base64,666" alt="image-20201105101400605"></td><td>/3/1/-2/2/-23/</td><td>/2-3/-2/2/-1/-3/</td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101539136.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101539136.png" srcset="data:image/png;base64,666" alt="image-20201105101539136"></td><td>/33/-1-2/-2/1/2/</td><td></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101705861.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101705861.png" srcset="data:image/png;base64,666" alt="image-20201105101705861"></td><td>/33/12/2/-1/-2/</td><td></td><td></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101757442.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105101757442.png" srcset="data:image/png;base64,666" alt="image-20201105101757442"></td><td>1-1/3/2-5/2/0-1/-4/</td><td><strong><code>/4/01/-2/-25/-3/</code></strong></td><td>构造shield-paw</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105102105612.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105102105612.png" srcset="data:image/png;base64,666" alt="image-20201105102105612"></td><td>/3/1/-2/2/-2/</td><td>/2/-2/2/-1/-3/</td><td>构造shield-kite</td></tr></tbody></table><h3 id="Depth-7">Depth 7</h3><table><thead><tr><th>Shape</th><th>Scramble</th><th>Solve</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094216164.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094216164.png" srcset="data:image/png;base64,666" alt="image-20201105094216164"></td><td>/3/1/-2/2/-2/1/</td><td>/-1/2/-2/2/-1/-3/</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094250825.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/cube/%E5%A4%8D%E4%B9%A0-SQ1%E5%A4%8D%E5%BD%A2/image-20201105094250825.png" srcset="data:image/png;base64,666" alt="image-20201105094250825"></td><td>/0-3/0-1/02/0-2/02/0-1/</td><td>/01/0-2/02/0-2/01/03/</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Cube </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sq1 </tag>
            
            <tag> cube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Volantis个人博客部署</title>
      <link href="2020/11/03/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
      <url>2020/11/03/Hexo-Volantis%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="配置部署Hexo">配置部署Hexo</h2><h3 id="配置流程">配置流程</h3><ul><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">参考链接</a></p><ul><li>安装<a href="https://www.cnblogs.com/lgx5/p/10732016.html">npm</a></li><li>安装<a href="https://blog.csdn.net/sinat_20177327/article/details/76062030">git</a></li><li>其中配置npm源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取npm源</span></span><br><span class="line">npm get registry</span><br><span class="line"><span class="comment"># 修改为淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 重置</span></span><br><span class="line"><span class="comment"># npm config set registry https://registry.npmjs.org/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常用命令">常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传至github</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地运行</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="Markdown公式显示问题">Markdown公式显示问题</h3><p>使用<a href="https://www.jianshu.com/p/588ab3d22eb8">hexo-renderer-markdown-it</a>插件</p><h2 id="处理Markdown图片问题">处理Markdown图片问题</h2><p>在最开始的尝试中遇到以下问题：</p><ul><li>直接将图片保存到github，在hexo编译生成的html网页中通过相对路径访问<strong>速度太慢</strong></li><li>将博客部署到gitee上，由于服务器在国内，图片加载速度确实比github快很多，但是问题在于部署在gitee上的博客会有各种奇怪<strong>显示问题</strong>，所以也放弃</li></ul><p>最终的解决办法：</p><ul><li>先在github新建一个仓库Source，专门用来存放博客文章用到的图片</li><li>使用jsdelivr提供的cdn加速<ul><li>在本地编写好markdown后，将图片文件夹复制到Source目录下并push到github仓库</li><li>在markdown文档中通过<code>ctrl+f</code>将所有图片的路径前缀改为<code>https://cdn.jsdelivr.net/gh/&lt;github用户名&gt;/Source@latest/&lt;文件夹名&gt;</code></li></ul></li></ul><h2 id="Volantis主题配置">Volantis主题配置</h2><h3 id="主题安装">主题安装</h3><ol><li><p>修改<code>./_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">volantis</span></span><br></pre></td></tr></table></figure></li><li><p>下载主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-volantis</span><br></pre></td></tr></table></figure></li><li><p>volantis主题会安装在<code>./node_modules/hexo-theme-volantis</code>中</p></li></ol><h3 id="主题个性化">主题个性化</h3><h4 id="搜索工具安装">搜索工具安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-json-content</span><br></pre></td></tr></table></figure><h4 id="字数统计工具安装">字数统计工具安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="主题配置文件">主题配置文件</h4><h5 id="顶部导航栏">顶部导航栏</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># choose [img] or [icon + title]</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/taiga.svg</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">主页</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-stack-overflow</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">Search...</span>   <span class="comment"># Search bar placeholder</span></span><br></pre></td></tr></table></figure><h5 id="封面">封面</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">layout_scheme:</span> <span class="string">dock</span> <span class="comment"># blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点)</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/interstellar.jpg</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&#x27;Schenk - Blog&#x27;</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;SJTUer | Cuber&#x27;</span></span><br><span class="line">  <span class="attr">features:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br></pre></td></tr></table></figure><h5 id="全局CSS">全局CSS</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="attr">navbar:</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">44px</span> </span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="comment"># auto, max</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">blur</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">floatable</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">    <span class="attr">highlight:</span></span><br><span class="line">      <span class="attr">language:</span> <span class="literal">true</span> <span class="comment"># show language of codeblock</span></span><br><span class="line">      <span class="attr">copy_btn:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">grayscale:</span> <span class="literal">false</span> <span class="comment"># Enable grayscale effect</span></span><br><span class="line">    <span class="attr">text_align:</span> <span class="comment"># left, right, justify, center</span></span><br><span class="line">      <span class="attr">h1:</span> <span class="string">center</span></span><br><span class="line">      <span class="attr">h2:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h3:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h4:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">p:</span> <span class="string">justify</span></span><br><span class="line">  <span class="attr">gap:</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="string">30px</span> <span class="comment"># Spacing above H2 (only px unit)</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="string">18px</span> <span class="comment"># Spacing above H3 (only px unit)</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="string">8px</span> <span class="comment"># Spacing above H4 (only px unit)</span></span><br><span class="line">    <span class="attr">p:</span> <span class="string">1em</span> <span class="comment"># Paragraph spacing between paragraphs</span></span><br><span class="line">    <span class="attr">line_height:</span> <span class="number">1.6</span> <span class="comment"># normal, 1.5, 1.75, 2 ...</span></span><br><span class="line">  <span class="attr">fontsize:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">16px</span></span><br><span class="line">    <span class="attr">h1:</span> <span class="number">1.</span><span class="string">5rem</span> <span class="comment"># 不推荐用在文章中</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="number">1.</span><span class="string">5rem</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="number">1.</span><span class="string">25rem</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="number">1.</span><span class="string">125rem</span></span><br><span class="line">    <span class="attr">h5:</span> <span class="string">1rem</span></span><br><span class="line">    <span class="attr">h6:</span> <span class="string">1rem</span></span><br><span class="line">    <span class="attr">list:</span> <span class="string">.9375rem</span></span><br><span class="line">    <span class="attr">meta:</span> <span class="string">.875rem</span></span><br><span class="line">    <span class="attr">code:</span> <span class="string">.875rem</span></span><br><span class="line">    <span class="attr">footnote:</span> <span class="string">.78125rem</span></span><br><span class="line">  <span class="attr">fontfamily:</span></span><br><span class="line">    <span class="attr">logofont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Microsoft Yahei&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">bodyfont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Microsoft Yahei&quot;,&quot;Hiragino Sans GB&quot;,Helvetica,&quot;Helvetica Neue&quot;,&quot;微软雅黑&quot;,Tahoma,Arial,sans-serif&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Microsoft Yahei&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/Microsoft-YaHei.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">codefont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/fonts/UbuntuMono-Regular.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure><h5 id="页脚">页脚</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_footer:</span></span><br><span class="line">  <span class="comment"># layout of footer: [aplayer, social, license, info, copyright]</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">copyright</span>]</span><br><span class="line">  <span class="comment"># site copyright</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">&#x27;[Copyright © 2020 Schenk](https://github.com/Schenk75/Schenk75.github.io)&#x27;</span></span><br><span class="line">  <span class="comment"># You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;)</span></span><br><span class="line">  <span class="attr">br:</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="文章布局">文章布局</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">article:</span></span><br><span class="line">  <span class="comment"># 文章列表页面的文章卡片布局方案</span></span><br><span class="line">  <span class="attr">preview:</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">landscape</span> <span class="comment"># landscape</span></span><br><span class="line">    <span class="comment"># pin icon for post</span></span><br><span class="line">    <span class="attr">pin_icon:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg</span></span><br><span class="line">    <span class="comment"># auto generate title if not exist</span></span><br><span class="line">    <span class="attr">auto_title:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># auto generate excerpt if not exist</span></span><br><span class="line">    <span class="attr">auto_excerpt:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># show split line or not</span></span><br><span class="line">    <span class="attr">line_style:</span> <span class="string">solid</span> <span class="comment"># hidden, solid, dashed, dotted</span></span><br><span class="line">    <span class="comment"># show author</span></span><br><span class="line">    <span class="attr">author:</span> <span class="literal">false</span> <span class="comment"># true, false</span></span><br><span class="line">    <span class="comment"># show readmore button</span></span><br><span class="line">    <span class="attr">readmore:</span> <span class="string">always</span> <span class="comment"># auto, always</span></span><br><span class="line">  <span class="comment"># 文章详情页面的文章卡片本体布局方案</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="comment"># 文章顶部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">top_meta:</span> [<span class="string">author</span>, <span class="string">category</span>, <span class="string">date</span>, <span class="string">wordcount</span>, <span class="string">counter</span>]</span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="comment"># 文章页脚组件</span></span><br><span class="line">    <span class="attr">footer_widget:</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 参考资料、相关资料等 (for layout: post/docs)</span></span><br><span class="line">      <span class="attr">references:</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">参考资料</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-quote-left</span></span><br><span class="line">        <span class="comment"># 在 front-matter 中:</span></span><br><span class="line">        <span class="comment">#   references:</span></span><br><span class="line">        <span class="comment">#     - title: 某篇文章</span></span><br><span class="line">        <span class="comment">#       url: https://</span></span><br><span class="line">        <span class="comment"># 即可显示此组件。</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 相关文章，需要安装插件 (for layout: post)</span></span><br><span class="line">      <span class="comment"># npm i hexo-related-popular-posts</span></span><br><span class="line">      <span class="attr">related_posts:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">相关文章</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bookmark</span></span><br><span class="line">        <span class="attr">max_count:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># 设为空则不使用文章头图</span></span><br><span class="line">        <span class="attr">placeholder_img:</span> <span class="string">data:image/png;base64,666</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 打赏组件 (for layout: post)</span></span><br><span class="line">      <span class="attr">donate:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">height:</span> <span class="string">128px</span></span><br><span class="line">        <span class="attr">images:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png</span></span><br><span class="line">    <span class="comment"># 文章底部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">bottom_meta:</span> [<span class="string">updated</span>, <span class="string">tags</span>]</span><br><span class="line">    <span class="comment"># meta library</span></span><br><span class="line">    <span class="attr">meta_library:</span></span><br><span class="line">      <span class="comment"># 默认文章作者（可在 front-matter 中覆盖）</span></span><br><span class="line">      <span class="attr">author:</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Schenk</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">      <span class="comment"># 文章创建日期</span></span><br><span class="line">      <span class="attr">date:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-calendar-alt</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;发布于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章更新日期</span></span><br><span class="line">      <span class="attr">updated:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-edit</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;更新于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章分类</span></span><br><span class="line">      <span class="attr">category:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="comment"># 文章浏览计数</span></span><br><span class="line">      <span class="attr">counter:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-eye</span></span><br><span class="line">        <span class="attr">unit:</span> <span class="string">&#x27;次浏览&#x27;</span></span><br><span class="line">      <span class="comment"># 文章字数和阅读时长</span></span><br><span class="line">      <span class="attr">wordcount:</span></span><br><span class="line">        <span class="attr">icon_wordcount:</span> <span class="string">fas</span> <span class="string">fa-keyboard</span></span><br><span class="line">        <span class="attr">icon_duration:</span> <span class="string">fas</span> <span class="string">fa-hourglass-half</span></span><br><span class="line">      <span class="comment"># 文章标签</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-hashtag</span></span><br></pre></td></tr></table></figure><h5 id="侧边栏">侧边栏</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 主页、分类、归档等独立页面</span></span><br><span class="line">  <span class="attr">for_page:</span> [<span class="string">blogger</span>, <span class="string">category</span>, <span class="string">tagcloud</span>, <span class="string">webinfo</span>]</span><br><span class="line">  <span class="comment"># layout: docs/post 这类文章页面</span></span><br><span class="line">  <span class="attr">for_post:</span> [<span class="string">toc</span>]</span><br><span class="line">  <span class="comment"># 侧边栏组件库</span></span><br><span class="line">  <span class="attr">widget_library:</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># blogger info widget</span></span><br><span class="line">    <span class="attr">blogger:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">blogger</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/avatar.jpg</span></span><br><span class="line">      <span class="attr">shape:</span> <span class="string">circle</span> <span class="comment"># circle, rectangle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/about/</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">Schenk</span></span><br><span class="line">      <span class="attr">subtitle:</span></span><br><span class="line">      <span class="attr">jinrishici:</span> <span class="literal">false</span> <span class="comment"># Poetry Today. You can set a string, and it will be displayed when loading fails.</span></span><br><span class="line">      <span class="attr">social:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/github-icon.svg</span></span><br><span class="line">          <span class="attr">size:</span> <span class="string">30px</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://github.com/Schenk75</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@latest/logos/struts.svg</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/logos/WCAlogo.svg</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://cubingchina.com/results/person/2018SHEN04</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># toc widget (valid only in articles)</span></span><br><span class="line">    <span class="attr">toc:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">本文目录</span></span><br><span class="line">      <span class="attr">list_number:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">min_depth:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">max_depth:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># category widget</span></span><br><span class="line">    <span class="attr">category:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">category</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># tagcloud widget</span></span><br><span class="line">    <span class="attr">tagcloud:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">tagcloud</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">热门标签</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">      <span class="attr">min_font:</span> <span class="number">14</span></span><br><span class="line">      <span class="attr">max_font:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">start_color:</span> <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      <span class="attr">end_color:</span> <span class="string">&#x27;#555&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># qrcode widget</span></span><br><span class="line">    <span class="attr">donate:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">qrcode</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">64px</span>  <span class="comment"># Automatic height if not set</span></span><br><span class="line">      <span class="attr">images:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/common/donate.png</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># webinfo widget</span></span><br><span class="line">    <span class="attr">webinfo:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">webinfo</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>]</span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-award</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">站点信息</span></span><br><span class="line">      <span class="attr">type:</span></span><br><span class="line">        <span class="attr">article:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;文章数目：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;篇&#x27;</span></span><br><span class="line">        <span class="attr">runtime:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">data:</span> <span class="string">&#x27;2020/11/01&#x27;</span>    <span class="comment"># 填写建站日期</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;已运行时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;天&#x27;</span></span><br><span class="line">        <span class="attr">wordcount:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;本站总字数：&#x27;</span>   <span class="comment"># 需要启用 wordcount</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;字&#x27;</span></span><br><span class="line">        <span class="attr">visitcounter:</span></span><br><span class="line">          <span class="attr">service:</span> <span class="string">busuanzi</span>  <span class="comment"># busuanzi, leancloud</span></span><br><span class="line">          <span class="attr">siteuv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站访客数：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;人&#x27;</span></span><br><span class="line">          <span class="attr">sitepv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站总访问量：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;次&#x27;</span></span><br><span class="line">        <span class="attr">lastupd:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">friendlyShow:</span> <span class="literal">true</span>    <span class="comment"># 更友好的时间显示</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;最后活动时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;日&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="统计工具">统计工具</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">analytics:</span></span><br><span class="line">  <span class="attr">busuanzi:</span> <span class="string">https://cdn.jsdelivr.net/gh/Schenk75/Source@master/tools/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure><h5 id="关闭评论">关闭评论</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&lt;i</span> <span class="string">class=&#x27;fas</span> <span class="string">fa-comments&#x27;&gt;&lt;/i&gt;</span> <span class="string">评论</span></span><br><span class="line">  <span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="comment"># valine, minivaline, disqus, gitalk, vssue, livere, isso, hashover</span></span><br></pre></td></tr></table></figure><h5 id="插件">插件</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="comment">######## Plugins to optimize the experience:</span></span><br><span class="line">  <span class="comment"># Codeblock Copy Button</span></span><br><span class="line">  <span class="attr">clipboard:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">######## Plugins for SEO:</span></span><br><span class="line">  <span class="comment"># npm i hexo-wordcount</span></span><br><span class="line">  <span class="attr">wordcount:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="页面布局模板">页面布局模板</h4><p><a href="https://volantis.js.org/page-settings/layout/">参考链接</a></p><h4 id="front-matter设置">front-matter设置</h4><p><a href="https://volantis.js.org/page-settings/front-matter/">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internet安全协议与分析Notes</title>
      <link href="2020/11/02/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/"/>
      <url>2020/11/02/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes/</url>
      
        <content type="html"><![CDATA[<h2 id="IPSec">IPSec</h2><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101110459619.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101110459619.png" srcset="data:image/png;base64,666" alt="image-20201101110459619"></p><h3 id="通信保护协议">通信保护协议</h3><h4 id="AH">AH</h4><ul><li>通信提供数据源认证、<strong>抗抵赖性</strong>、数据完整性和反重播保证，但不提供机密性保护</li></ul><p><strong>AH传输模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111305325.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111305325.png" srcset="data:image/png;base64,666" alt="image-20201101111305325" style="zoom:80%;" /><ul><li>源IP地址、目的IP地址是不能修改的，否则会被检测出来，因此AH在传输模式下和NAT冲突</li></ul><p><strong>AH隧道模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111704982.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101111704982.png" srcset="data:image/png;base64,666" alt="image-20201101111704982" style="zoom:80%;" /><ul><li>AH验证的范围也是整个IP包，因此AH和NAT的冲突在隧道模式下也存在</li></ul><h4 id="ESP">ESP</h4><ul><li>为IP提供<strong>机密性</strong>、数据源认证、抗重播以及数据完整性等安全服务，但不提供抗抵赖性</li><li>对IP头部不进行认证，因此不会和NAT冲突</li></ul><p><strong>ESP传输模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112035985.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112035985.png" srcset="data:image/png;base64,666" alt="image-20201101112035985"  /><p><strong>ESP隧道模式</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112141274.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101112141274.png" srcset="data:image/png;base64,666" alt="image-20201101112141274" style="zoom:80%;" /><h3 id="密钥交换管理协议IKE">密钥交换管理协议IKE</h3><ul><li>安全机制<ul><li>前向安全性：一个密钥被破解不影响其他密钥的安全性</li><li>数据验证</li><li>DH交换和密钥分发</li></ul></li></ul><h4 id="阶段1">阶段1</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113424882.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113424882.png" srcset="data:image/png;base64,666" alt="image-20201101113424882" style="zoom:80%;" /><p><strong>主模式协商</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113221833.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113221833.png" srcset="data:image/png;base64,666" alt="image-20201101113221833" style="zoom:80%;" /><p><strong>野蛮模式协商</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113300883.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113300883.png" srcset="data:image/png;base64,666" alt="image-20201101113300883" style="zoom:80%;" /> <p><strong>两种模式对比</strong></p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113329111.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113329111.png" srcset="data:image/png;base64,666" alt="image-20201101113329111" style="zoom:80%;" /><h4 id="阶段2">阶段2</h4><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113446458.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101113446458.png" srcset="data:image/png;base64,666" alt="image-20201101113446458" style="zoom:80%;" /><h2 id="SSL">SSL</h2><ul><li>安全机制<ul><li>数据机密性：对称加密</li><li>身份验证机制：基于证书的数字签名</li><li>消息完整性：MAC算法</li></ul></li><li>SSL连接和会话<ul><li>连接是点对点的、暂时的</li><li>会话是客户端和服务器之间持久的关联</li></ul></li></ul><h3 id="SSL分层结构">SSL分层结构</h3><ul><li>上层协议<ul><li>SSL握手协议：协商加密套件，交换密钥，身份认证</li><li>SSL password变化协议：修改新的加密套件和密钥</li><li>SSL警告协议：当其他过程中出现错误或发送异常时，向对方报告告警信息</li></ul></li><li>下层协议<ul><li>SSL记录协议：对上层数据分块、压缩、加密、传输</li></ul></li></ul><h4 id="SSL握手协议">SSL握手协议</h4><p><strong>阶段1：建立安全能力</strong></p><ul><li>协商加密套件</li></ul><p><strong>阶段2：服务器鉴别与密钥交换</strong></p><p><strong>阶段3：客户端鉴别与密钥交换</strong></p><ul><li>服务器和客户端分别发送自己的证书并交换密钥信息以便进行身份认证</li></ul><p><strong>阶段4：完成</strong></p><ul><li>检验双方是否获得同样的安全参数</li></ul><h4 id="SSL记录协议">SSL记录协议</h4><p>为每个SSL连接提供：</p><ul><li>机密性</li><li>完整性</li></ul><h3 id="SSL协议安全性分析">SSL协议安全性分析</h3><ul><li>鉴别机制：公开密钥机制和数字证书</li><li>加密机制：混合密码体制</li><li>完整性机制：定义了共享的、可以用来形成报文鉴别码MAC的密钥</li><li>抗重放攻击：序列号，用随机数标记握手</li></ul><h3 id="SSL脆弱性分析">SSL脆弱性分析</h3><ul><li>客户端假冒</li><li>无法提供基于UDP的应用的安全保护</li><li>不能对抗通信流量分析：SSL只对数据进行保护，数据包的IP头和TCP头暴露在外</li><li>SSL进程存储空间中的主密钥泄露</li></ul><h2 id="SET">SET</h2><h3 id="双重数字签名">双重数字签名</h3><ul><li>订单信息OI：客户给商家</li><li>支付信息PI：客户给银行</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125501014.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125501014.png" srcset="data:image/png;base64,666" alt="image-20201101125501014" style="zoom:80%;" /><h3 id="SET电子支付流程">SET电子支付流程</h3><ol><li><p>支付初始化：持卡人选择商品，下订单，选择银行卡</p><ul><li>初始请求：持卡人发送请求指定交易环境</li><li>初始应答：商家回复交易环境信息，以及证书等，并附上签名</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125955162.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101125955162.png" srcset="data:image/png;base64,666" alt="image-20201101125955162" style="zoom:80%;" /></li><li><p>购物请求：</p><ul><li>持卡人检查商家初始应答发送的签名信息，确保数据完整性</li><li>持卡人发送PReq</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130235811.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130235811.png" srcset="data:image/png;base64,666" alt="image-20201101130235811" style="zoom:80%;" /></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130805188.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101130805188.png" srcset="data:image/png;base64,666" alt="image-20201101130805188" style="zoom:150%;" /><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131210287.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131210287.png" srcset="data:image/png;base64,666" alt="image-20201101131210287"></p><ol start="3"><li><p>商家验证持卡人的身份和授权</p><ul><li>商家将相关信息发送给支付网关</li></ul><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131339258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101131339258.png" srcset="data:image/png;base64,666" alt="image-20201101131339258" style="zoom:150%;" /></li><li><p>支付网关认证</p><ul><li>网关将信息发送给银行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101132850316.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101132850316.png" srcset="data:image/png;base64,666" alt="image-20201101132850316"></p></li><li><p>收单银行处理</p><ul><li><p>确保PI和AuthReq的一致性</p></li><li><p>校验持卡人和商家对于订购行为的一致性</p></li><li><p>发送AuthRes给商家</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133223907.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133223907.png" srcset="data:image/png;base64,666" alt="image-20201101133223907"></p></li><li><p>支付完成</p><ul><li>通过捕获令牌(Capture Token)完成支付</li></ul></li><li><p>下单回复</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133759144.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101133759144.png" srcset="data:image/png;base64,666" alt="image-20201101133759144"></p></li></ol><h3 id="SET核心技术">SET核心技术</h3><ul><li>公开密钥加密</li><li>数字签名</li><li>数字信封：公钥算法加密对称密钥</li><li>电子安全证书</li></ul><h2 id="PGP">PGP</h2><ul><li>提供可用于电子邮件和文件存储应用的<strong>保密</strong>与<strong>鉴别</strong>服务</li></ul><h3 id="PGP数字签名与认证">PGP数字签名与认证</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101134921229.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101134921229.png" srcset="data:image/png;base64,666" alt="image-20201101134921229"></p><h3 id="PGP保密性">PGP保密性</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135128996.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135128996.png" srcset="data:image/png;base64,666" alt="image-20201101135128996"></p><ul><li>邮件的存储转发特性不适合用DH算法交换密钥</li><li>使用公钥算法对每个消息生成<strong>一次性</strong>会话密钥</li></ul><h3 id="PGP保密和认证结合">PGP保密和认证结合</h3><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135448177.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101135448177.png" srcset="data:image/png;base64,666" alt="image-20201101135448177"></p><h3 id="PGP压缩">PGP压缩</h3><ul><li>使用ZIP算法</li><li>先签名后压缩<ul><li>只需要存储原始报文和签名</li><li>易于更换压缩算法</li></ul></li></ul><h3 id="PGP密钥环">PGP密钥环</h3><ul><li>每个结点都有存储密钥的结构<ul><li>私钥环：存储该结点拥有的公/私钥对</li><li>公钥环：存储该结点拥有的其他所有用户的公钥</li></ul></li></ul><h3 id="PGP信任网">PGP信任网</h3><ul><li>PGP中没有认证机构，而是由用户互相对对方的公钥进行数字签名</li><li>确认是否信任<ul><li>通过自己的数字签名</li><li>通过自己完全信任的人的数字签名</li><li>通过自己有限信任的多个人的数字签名</li></ul></li></ul><h2 id="Kerberos">Kerberos</h2><ul><li>采用传统加密算法(非公钥算法)</li></ul><h3 id="基本概念">基本概念</h3><ul><li>Principle：安全个体，有名字和口令</li><li>KDC：网络服务，提供ticket和临时会话密钥</li><li>Ticket：客户用来向服务器证明身份的票据<ul><li>其大多数信息被服务器的密钥加密</li></ul></li><li>Authenticator：包含最近产生的信息的记录，需要用到会话密钥</li><li>Credentials：一个Ticket加上秘密的会话密钥</li><li>AS：Authentication Server<ul><li>通过long-term key认证用户</li><li>授予用户ticket granting ticket和short-term key</li><li>认证服务</li></ul></li><li>TGS：Ticket Granting Server<ul><li>通过ticket granting ticket和short-term key认证用户</li><li>发放service granting ticket给用户以访问其他服务器</li><li>授权和访问控制服务</li></ul></li></ul><h3 id="Kerberos工作流程">Kerberos工作流程</h3><h4 id="1-认证服务交换：获得票据许可票据-ticket-granting-ticket">1. 认证服务交换：获得票据许可票据(ticket granting ticket)</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101144837036.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101144837036.png" srcset="data:image/png;base64,666" alt="image-20201101144837036"></p><h4 id="2-票据许可服务交换：获得服务许可票据-service-granting-ticket">2. 票据许可服务交换：获得服务许可票据(service granting ticket)</h4><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145139960.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145139960.png" srcset="data:image/png;base64,666" alt="image-20201101145139960"></p><h4 id="3-客户-服务器认证交换：获得服务image-20201101145321623">3. 客户/服务器认证交换：获得服务<img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145321623.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145321623.png" srcset="data:image/png;base64,666" alt="image-20201101145321623"></h4><h3 id="Kerberos跨域认证">Kerberos跨域认证</h3><ol><li>获得本地TGS访问权</li><li>请求一张远程TGS的票据许可票据</li><li>向远程TGS请求其域内的服务</li></ol><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145413287.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AENotes//image-20201101145413287.png" srcset="data:image/png;base64,666" alt="image-20201101145413287" style="zoom: 50%;" /><h3 id="Kerberos优缺点">Kerberos优缺点</h3><h4 id="优点">优点</h4><ul><li>密码不在网上传输，不易被窃听，难以猜测</li><li>单点登录机制，只用输入一次口令</li><li>票据被盗之后难以使用，因为需要配合认证头来使用</li></ul><h4 id="缺点">缺点</h4><ul><li>缺乏撤销机制</li><li>密钥管理复杂</li><li>跨域认证复杂</li><li>需要始终同步</li><li>需要始终在线的AS和TGS</li></ul><h2 id="BAN">BAN</h2><h3 id="所用符号">所用符号</h3><ul><li><p>A, B, S：泛指参与协议的主体</p></li><li><p>P, Q, R：主体变量</p></li><li><p>X, Y: 公式变量</p></li><li><p>K: 密钥变量</p></li><li><p>K<sub>ab</sub>, K<sub>bs</sub>, K<sub>as</sub>: 主体之间的共享密钥</p></li><li><p>K<sub>a</sub>, K<sub>b</sub>, K<sub>s</sub>: 主体的公钥</p></li><li><p>K<sub>a</sub><sup>-1</sup>, K<sub>b</sub><sup>-1</sup>, K<sub>s</sub><sup>-1</sup>: 主体的私钥</p></li><li><p>N<sub>a</sub>, N<sub>b</sub>, N<sub>s</sub>：主体各自生成的用于确认新鲜性的随机数Nonce</p></li><li><p>{X}<sub>k</sub>：用密钥k加密X的结果</p></li><li><p>&lt;X&gt;Y：X和Y的组合</p></li><li><p>P-&gt;Q:(X)：P发送消息X给Q</p></li><li><p>bel(P,Q)：主体P相信X</p></li><li><p>sees(P,X)：P接收到X</p></li><li><p>said(P,X)：P发送X</p></li><li><p>cont(P,X)：P拥有对X正确与否的判决权</p></li><li><p>fresh(X)：X是新鲜的</p></li><li><p>skey(P,K,Q)：K是P,Q的共享密钥</p></li><li><p>goodkey(P,K,Q)：K是P,Q共享的良好密钥</p></li><li><p>pubkey(P,K)：K是P的公钥</p></li><li><p>secret(P,X,Q)：X是P和Q的共享秘密</p></li></ul><h3 id="推理规则">推理规则</h3><h4 id="消息意义规则">消息意义规则</h4><p>从加密消息所使用密钥以及消息中包含的秘密来推断消息发送者的身份</p><ul><li>例如对于共享密钥：bel(P,goodkey(P,K,Q)) and sees(P,{X}<sub>k</sub>) =&gt; bel(P,said(Q,X))</li></ul><h4 id="随机数验证规则">随机数验证规则</h4><p>如果P相信X是新鲜的，并且P相信Q曾经发送过X，那么P相信Q相信X</p><ul><li>bel(P,fresh(X)) and bel(P,said(Q,X)) =&gt; bel(P,bel(Q,X))</li></ul><h4 id="仲裁规则">仲裁规则</h4><p>如果P相信Q对X是有仲裁权的，并且P相信Q相信X，那么P相信X</p><ul><li>bel(P,cont(Q,X)) and bel(P,bel(Q,X)) =&gt; bel(P,X)</li></ul><h4 id="信仰规则">信仰规则</h4><ul><li><p>bel(P,X) and bel(P,Y) =&gt; bel(P,(X,Y))</p></li><li><p>bel(P,(X,Y)) =&gt; bel(P,X) or bel(P,Y)</p></li><li><p>bel(P,bel(Q,(X,Y))) =&gt; bel(P,bel(Q,X)) or bel(P,bel(Q,Y))</p></li></ul><h4 id="接收规则">接收规则</h4><ul><li>如果P接收到一个消息，那么P也接收到这个消息的一部分<ul><li>sees(P,(X,Y)) =&gt; sees(P,X)</li><li>sees(P,&lt;X&gt;Y) =&gt; sees(P,X)</li></ul></li><li>如果P收到加密消息，那么以下三种情况P可以读出消息原文<ul><li>bel(P,goodkey(P,K,Q)) and sees(P,{X}<sub>K</sub>) =&gt; sees(P,X)</li><li>bel(P,pubkey(P,K)) and sees(P,{X}<sub>K</sub>) =&gt; sees(P,X)</li><li>bel(P,pubkey(Q,K)) and sees(P,{X}<sub>K</sub><sup>-1</sup>) =&gt; sees(P,X)</li></ul></li></ul><h4 id="新鲜规则">新鲜规则</h4><p>如果消息的一部分是新鲜的，则整个消息是新鲜的</p><ul><li>bel(P,fresh(X)) =&gt; bel(P,fresh(X,Y))</li></ul><h4 id="传递规则">传递规则</h4><p>如果P相信Q曾经发送过整个消息，那么P相信Q曾经发送过消息的部分</p><ul><li>bel(P,said(Q,(X,Y))) =&gt; bel(P,said(Q,X))</li></ul>]]></content>
      
      
      <categories>
          
          <category> Course Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/01/hello-world/"/>
      <url>2020/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git - Learn</title>
      <link href="2020/10/13/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/10/13/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制">版本控制</h2><h3 id="1-本地版本控制">1. 本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/1-1602592677643.webp" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/1-1602592677643.webp" srcset="data:image/png;base64,666" alt="img"></p><h3 id="2-集中版本控制">2. 集中版本控制</h3><p>所有的版本数据都存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203819662.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203819662.png" srcset="data:image/png;base64,666" alt="image-20201013203819662"></p><h3 id="3-分布式版本控制">3. 分布式版本控制</h3><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203824414.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/image-20201013203824414.png" srcset="data:image/png;base64,666" alt="image-20201013203824414"></p><h3 id="Git与SVN的主要区别">Git与SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h2 id="Git环境配置">Git环境配置</h2><h3 id="Git配置">Git配置</h3><p><strong>查看配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p><strong>查看不同级别的配置文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> Git\etc\gitconfig：Git安装目录下的gitconfig  </span></span><br><span class="line">　　</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> C:\Users\Administrator\.gitconfig    只适用于当前登录用户的配置 </span></span><br></pre></td></tr></table></figure><p><strong>设置用户名与邮箱（用户标识，必要）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;&lt;名称&gt;&quot;  # 名称</span><br><span class="line">git config --global user.email &lt;邮箱&gt;   # 邮箱</span><br></pre></td></tr></table></figure><h2 id="Git基本理论">Git基本理论</h2><h3 id="三个区域">三个区域</h3><p>Git本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/4.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/4.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/5.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/5.png" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h3 id="工作流程">工作流程</h3><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/6.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/6.png" srcset="data:image/png;base64,666" alt="img"></p><h2 id="Git项目搭建">Git项目搭建</h2><h3 id="创建工作目录与常用指令">创建工作目录与常用指令</h3><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/7.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Git-Notes/7.png" srcset="data:image/png;base64,666" alt="img"></p><h3 id="本地仓库搭建">本地仓库搭建</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p><strong>创建权限仓库</strong></p><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><p><strong>克隆远程仓库</strong></p><p>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Git文件操作">Git文件操作</h2><h3 id="文件的四种状态">文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h3 id="查看文件状态">查看文件状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看指定文件状态</span></span><br><span class="line">git status &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .                  添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br></pre></td></tr></table></figure><h3 id="忽略文件">忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     # 但lib.txt除外</span><br><span class="line">/temp        # 仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       # 忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h2 id="Git分支">Git分支</h2><p>git分支中常用指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker - Learn</title>
      <link href="2020/10/12/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/10/12/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="底层原理">底层原理</h2><p><strong>Docker是怎么工作的？</strong></p><p>Docker是一个C-S结构的系统，Docker的守护进程运行在服务主机上，通过Socket从客户端访问。</p><p>DockerServer接收到DockerClient的指令就会执行这个命令。</p><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120921063.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120921063.png" srcset="data:image/png;base64,666" alt="image-20201013120921063"></p><p><strong>Docker为什么比VM快？</strong></p><ol><li>Docker有着比虚拟机更少的抽象层</li><li>Docker利用的是宿主机的内核，VM需要有Guest OS。所以新建一个容器的时候，docker不需要像VM一样重新加载一个操作系统内核，避免引导</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120834703.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Schenk75/Source@master/notes/Docker-Notes/image-20201013120834703.png" srcset="data:image/png;base64,666" alt="image-20201013120834703"></p><h2 id="Docker常用命令">Docker常用命令</h2><h3 id="docker的默认工作路径">docker的默认工作路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker</span><br></pre></td></tr></table></figure><h3 id="帮助命令">帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version# 显示docker的版本信息</span><br><span class="line">docker info# 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker &lt;命令&gt; --help   # 查看帮助命令</span><br></pre></td></tr></table></figure><h3 id="镜像命令">镜像命令</h3><p><strong>docker images</strong> 查看所有本地的主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        9 months ago        13.3kB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释</span></span><br><span class="line">REPOSITORY镜像的仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的ID</span><br><span class="line">CREATED镜像的创建时间</span><br><span class="line">SIZE 镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令可选项</span></span><br><span class="line">-a, --all列出所有镜像</span><br><span class="line">-q, --quiet只显示镜像的id</span><br></pre></td></tr></table></figure><p><strong>docker search <image></strong> 搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search mysql</span><br><span class="line">NAME       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql      MySQL is a widely used, open-source relation…   10046     [OK]                </span><br><span class="line">mariadb    MariaDB is a community-developed fork of MyS…   3680      [OK]                </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项，通过收藏数过滤</span></span><br><span class="line">--filter=STAR=3000搜索出来的镜像是STARS大于3000的</span><br></pre></td></tr></table></figure><p><strong>docker pull <image>[:tag]</strong> 下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest# 如果不写tag，默认是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Pull complete # 分层下载，docker镜像的核心 联合文件系统</span><br><span class="line">f3cebc0b4691: Pull complete </span><br><span class="line">1862755a0b37: Pull complete </span><br><span class="line">489b44f3dbb4: Pull complete </span><br><span class="line">690874f836db: Pull complete </span><br><span class="line">baa8be383ffb: Pull complete </span><br><span class="line">55356608b4ac: Pull complete </span><br><span class="line">dd35ceccb6eb: Pull complete </span><br><span class="line">429b35712b19: Pull complete </span><br><span class="line">162d8291095c: Pull complete </span><br><span class="line">5e500ef7181b: Pull complete </span><br><span class="line">af7528e958b6: Pull complete </span><br><span class="line">Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest# 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载指定版本，共用的层会复用，不用重复下载</span></span><br><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Already exists </span><br><span class="line">f3cebc0b4691: Already exists </span><br><span class="line">1862755a0b37: Already exists </span><br><span class="line">489b44f3dbb4: Already exists </span><br><span class="line">690874f836db: Already exists </span><br><span class="line">baa8be383ffb: Already exists </span><br><span class="line">55356608b4ac: Already exists </span><br><span class="line">277d8f888368: Pull complete </span><br><span class="line">21f2da6feb67: Pull complete </span><br><span class="line">2c98f818bcb9: Pull complete </span><br><span class="line">031b0a770162: Pull complete </span><br><span class="line">Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>docker rmi</strong> 删除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;镜像id&gt; [&lt;镜像id&gt; &lt;镜像id&gt;]# 删除指定的镜像</span><br><span class="line">docker rmi -f $(docker images -aq)# 删除所有镜像</span><br></pre></td></tr></table></figure><h3 id="容器命令">容器命令</h3><p>**注：**有了镜像才可以创建容器，以centos镜像为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>docker run [可选参数] <image></strong>  新建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name=&quot;&lt;Name&gt;&quot;容器名字，自定义，用来区分容器</span><br><span class="line">-d 后台方式运行</span><br><span class="line">-it使用交互方式运行，进入容器查看内容</span><br><span class="line">-p指定容器的端口，配置端口转发</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 主机端口:容器端口（常用）</span><br><span class="line">-p 容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并进入容器</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器并关闭容器</span></span><br><span class="line">[root@bebbdced119e /]# exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器但不关闭容器</span></span><br><span class="line">Ctrl + p + q</span><br></pre></td></tr></table></figure><p><strong>docker ps [可选参数]</strong> 列出运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">-a列出所有运行过的容器</span><br><span class="line">-n=&lt;n&gt;列出最近创建的n个容器</span><br><span class="line">-q只显示容器编号</span><br></pre></td></tr></table></figure><p>**docker rm 删除容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器id&gt;删除指定容器，不能删除正在运行的容器，若要强制删除加参数-f</span><br><span class="line">docker rm -f $(docker ps -aq)  删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  删除所有的容器</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;容器id&gt;启动容器</span><br><span class="line">docker restart &lt;容器id&gt;重启容器</span><br><span class="line">docker stop &lt;容器id&gt;停止容器</span><br><span class="line">docker kill &lt;容器id&gt;强制停止容器</span><br></pre></td></tr></table></figure><h3 id="常用其他命令">常用其他命令</h3><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题：docker ps发现centos停止了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -ft &lt;容器id&gt;# 查看所有日志</span><br><span class="line">docker logs -ft --tail &lt;n&gt; &lt;容器id&gt;# 查看最新的n条日志</span><br></pre></td></tr></table></figure><p>**查看容器中的进程信息 **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器id&gt;</span><br></pre></td></tr></table></figure><p><strong>查看容器的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器id&gt;</span><br></pre></td></tr></table></figure><p><strong>进入正在后台运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法1</span></span><br><span class="line">docker exec -it &lt;容器id&gt; &lt;bashshell&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法2</span></span><br><span class="line">docker attach &lt;容器id&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><p><strong>从容器内拷贝文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;容器id&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux - Learn</title>
      <link href="2020/09/11/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/09/11/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="了解系统信息">了解系统信息</h2><h3 id="硬盘大小">硬盘大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">&#x2F;dev&#x2F;sda 操作系统中第一块硬盘的名称以及所在路径</span><br><span class="line">Linux操作系统一切皆文件 （文件名） sd (硬盘类型) a（第一块）</span><br></pre></td></tr></table></figure><h3 id="内存大小">内存大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure><h3 id="cpu大小">cpu大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><h3 id="收集系统信息">收集系统信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="Linux文件系统">Linux文件系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin    普通用户和管理员都可以执行的命令</span><br><span class="line">&#x2F;sbin   只有管理员才能执行的命令 eg.关机重启</span><br><span class="line">&#x2F;boot   引导 主引导目录 独立的分区 启动菜单 内核</span><br><span class="line">&#x2F;dev    device 设备文件存放目录</span><br><span class="line">&#x2F;etc    配置文件存放目录</span><br><span class="line">&#x2F;home   普通用户的家目录</span><br><span class="line">&#x2F;root   管理员的家</span><br><span class="line">&#x2F;media  光驱的挂载目录</span><br><span class="line">&#x2F;mnt    临时设备的挂载目录</span><br><span class="line">&#x2F;proc   里面的数据都在内存中，进程的所在目录</span><br><span class="line">&#x2F;tmp    临时文件存放目录</span><br><span class="line">&#x2F;usr    第三方软件的安装目录</span><br><span class="line">&#x2F;var    常变文件存放目录 eg.日志文件、邮件文件</span><br></pre></td></tr></table></figure><h3 id="挂载光驱">挂载光驱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弹出光驱：umount &#x2F;dev&#x2F;cdrom</span><br><span class="line">挂载光驱：mount &#x2F;dev&#x2F;cdrom &#x2F;media</span><br></pre></td></tr></table></figure><h2 id="Linux文件类型的显示颜色">Linux文件类型的显示颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">蓝色 目录</span><br><span class="line">黑色 普通文件</span><br><span class="line">浅蓝色 符号链接（快捷方式）</span><br><span class="line">黑底黄字 设备文件 硬盘 sda</span><br><span class="line">红色 压缩包</span><br><span class="line">绿色 带有执行权限的文件</span><br><span class="line">紫色 图片 模块文件</span><br></pre></td></tr></table></figure><h2 id="压缩和解压缩">压缩和解压缩</h2><h3 id="文件压缩和解压缩">文件压缩和解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip bigfile</span><br><span class="line">gunzip bigfile.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 bigfile</span><br><span class="line">bunzip2 bigfile.bz2</span><br></pre></td></tr></table></figure><h3 id="目录-文件夹-打包压缩">目录(文件夹)打包压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf &#x2F;tmp&#x2F;allfile.tar.gz &#x2F;tmp&#x2F;allfile</span><br><span class="line">tar -jcf &#x2F;tmp&#x2F;allfile.tar.bz2 &#x2F;tmp&#x2F;allfile</span><br></pre></td></tr></table></figure><h3 id="目录-文件夹-解压缩并解包">目录(文件夹)解压缩并解包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf &#x2F;tmp&#x2F;allfile.tar.gz -C &#x2F;tmp</span><br><span class="line">tar -jxf &#x2F;tmp&#x2F;allfile.tar.bz2 -C &#x2F;tmp</span><br><span class="line">-C 指定解包位置</span><br></pre></td></tr></table></figure><h2 id="vim">vim</h2><h3 id="模式切换">模式切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令模式 -&gt; 输入模式：i</span><br><span class="line">输入模式 -&gt; 命令模式：Esc</span><br><span class="line">命令模式 -&gt; 末行模式：:</span><br></pre></td></tr></table></figure><h3 id="末行模式命令">末行模式命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:wq   保存并退出</span><br><span class="line">:q!    不保存退出</span><br><span class="line">:set nu   显示行号</span><br><span class="line">:% s&#x2F;old&#x2F;new&#x2F;g   每一行中的old替换成new</span><br><span class="line">:50,56 d     删除50-56行的数据</span><br></pre></td></tr></table></figure><h3 id="命令模式命令">命令模式命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0       光标移动到当前行首</span><br><span class="line">$       光标移动到当前行末</span><br><span class="line">yy      复制当前行</span><br><span class="line">2yy     复制当前行以及后一行，其他数字以此类推</span><br><span class="line">p       粘贴到当前行下一行</span><br><span class="line">dd      删除当前行</span><br><span class="line">gg      回到第一行</span><br><span class="line">G       回到最后一行</span><br></pre></td></tr></table></figure><h2 id="Linux软件安装——封装后的软件包">Linux软件安装——封装后的软件包</h2><h3 id="后缀名">后缀名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm     red hat系统</span><br><span class="line">deb     debian系统</span><br><span class="line">源码包  不考虑系统版本</span><br></pre></td></tr></table></figure><h3 id="有关软件包安装的命令">有关软件包安装的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa             列出所有已经安装的rpm包</span><br><span class="line">查询特定的rpm包使用管道符：rpm -qa | grep &quot;tree&quot;</span><br><span class="line">rpm -qpi 软件名     确认该软件的作用</span><br><span class="line">rpm -qpl 软件名     确认该软件的安装路径(无法修改)</span><br><span class="line">rpm -ivh 软件名     安装软件</span><br><span class="line">rpm -e 软件名       软件卸载</span><br></pre></td></tr></table></figure><h2 id="Linux软件安装——yum">Linux软件安装——yum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install 软件名</span><br><span class="line">yum remove 软件名</span><br></pre></td></tr></table></figure><h2 id="用户和组">用户和组</h2><h3 id="三个重要文件">三个重要文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;passwd     保存操作系统中所有的用户信息</span><br><span class="line">root : x : 0 : 0 : root : &#x2F;root : &#x2F;bin&#x2F;bash</span><br><span class="line">每一条目共7个字段，用冒号隔开</span><br><span class="line">字段1：用户名</span><br><span class="line">字段2：密码占位符</span><br><span class="line">字段3：用户的UID</span><br><span class="line">    0 表示超级用户</span><br><span class="line">    500-60000 普通用户</span><br><span class="line">    1-499 程序用户</span><br><span class="line">字段4：基本组的GID，先有组才有用户</span><br><span class="line">字段5：用户信息记录字段</span><br><span class="line">字段6：用户的家目录</span><br><span class="line">字段7：用户登录系统后使用的命令解释器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadow     保存了用户密码信息</span><br><span class="line">root : $6$ME9wjPHAid5ds$PO&#x2F;GlBVEt1 : 18325 : 0 : 99999 : 7 :::</span><br><span class="line">字段1：用户名</span><br><span class="line">*字段2：用户的密码加盐并通过散列算法后的字符串（sha）</span><br><span class="line">字段3：距离1970&#x2F;1&#x2F;1密码最近一次修改的时间</span><br><span class="line">字段4：密码的最短有效期</span><br><span class="line">*字段5：密码的最长有效期（建议时间 90）</span><br><span class="line">字段6：密码过期前7天警告</span><br><span class="line">字段7：密码的不活跃期</span><br><span class="line">字段8：用户的失效时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group      记录了系统中所有组的信息</span><br></pre></td></tr></table></figure><h3 id="建立和调整用户属性">建立和调整用户属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1、建立一个名为class1的组ID为1000，class2的组ID为2000</span><br><span class="line">建立：</span><br><span class="line">groupadd class1</span><br><span class="line">groupadd -g 2000 class2</span><br><span class="line">修改gid：</span><br><span class="line">groupmod -g 1000 class1</span><br><span class="line">查看：</span><br><span class="line">vim &#x2F;etc&#x2F;group</span><br><span class="line"></span><br><span class="line">2、建立tom用户要求其基本组是class1,附加组为class2，tom用户的UID为600</span><br><span class="line">建立：</span><br><span class="line">useradd -g class1 -G class2 -u 600 tom</span><br><span class="line">修改：</span><br><span class="line">usermod</span><br><span class="line">查看：</span><br><span class="line">id tom</span><br><span class="line"></span><br><span class="line">3、建立一个程序用户UID为250,用户名为testuser，没有家目录（程序用户没有登录系统权限）</span><br><span class="line">useradd -u 250 -M -s &#x2F;sbin&#x2F;nologin testuser</span><br><span class="line">-M：没有家目录</span><br><span class="line">-s &#x2F;sbin&#x2F;nologin：不能登录</span><br><span class="line"></span><br><span class="line">4、为tom用户设定密码为123，并设定密码最长有效期为90天，将用户密码进行锁定使其无法登录</span><br><span class="line">passwd tom        设定密码</span><br><span class="line">chage -M 90 tom   设定密码最长有效期</span><br><span class="line">或者修改配置文件&#x2F;etc&#x2F;login.defs</span><br><span class="line">passwd -l tom     锁定</span><br><span class="line">passwd -u tom     解锁</span><br><span class="line">查看：</span><br><span class="line">passwd -S tom</span><br><span class="line">vim &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br><span class="line">5、删除tom用户和testuser用户，删除class1组和class2组</span><br><span class="line">userdel -r tom     （-r  连同用户的家目录一起删除）</span><br><span class="line">userdel -r testuser</span><br><span class="line">groupdel class1</span><br><span class="line">groupdel class1</span><br></pre></td></tr></table></figure><h2 id="文件目录权限">文件目录权限</h2><h3 id="列出文件信息">列出文件信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -a       列出所有文件，包括隐藏文件</span><br><span class="line">ls -l(ll)   列出文件详细信息</span><br><span class="line">文件：-rw-rw-r--.(权限) 1(链接数) centos(所属用户) centos(所属组)   12(文件大小，字节) Sep 12 10:07(最后修改时间) test.txt</span><br><span class="line">目录：drwxrwxr-x.(权限) 2(子目录数) centos(所属用户) centos(所属组)    6 Sep 12 10:06(最后修改时间) testdir</span><br><span class="line">ls -ld      列出某一目录的详细信息</span><br><span class="line">ls -h       用人能看懂的方式显示文件大小</span><br></pre></td></tr></table></figure><h3 id="权限详细">权限详细</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- rw- rw- r--.</span><br><span class="line">d rwx rwx r-x.</span><br><span class="line">共4个字段</span><br><span class="line">字段1：文件类型</span><br><span class="line">    -普通文件</span><br><span class="line">    d目录文件</span><br><span class="line">    l符号链接文件</span><br><span class="line">    b块设备</span><br><span class="line">字段2：文件所属者的权限</span><br><span class="line">            r               w           x</span><br><span class="line">    文件    读取            写入        可执行</span><br><span class="line">    目录    查看目录文件    增删文件    进入目录</span><br><span class="line">字段3：文件所属组的权限</span><br><span class="line">字段4：其他用户的权限</span><br></pre></td></tr></table></figure><h3 id="赋权限">赋权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：chmod 对象 算术运算符 权限 文件</span><br><span class="line">    对象：u-所属者 g-所属组 o-其他用户 a-所有用户</span><br><span class="line">    算术运算符：- + &#x3D;</span><br><span class="line">    权限：r w x</span><br><span class="line">方法2：chmod 777 文件</span><br></pre></td></tr></table></figure><h3 id="改变文件的所属者和所属组">改变文件的所属者和所属组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown 用户 文件</span><br><span class="line">chgrp 组 文件</span><br></pre></td></tr></table></figure><h3 id="粘滞位-sgid-suid权限">粘滞位 sgid suid权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">粘滞位针对目录赋权，目录中创建的文件只有建立者可以删除</span><br><span class="line">    chmod o+t 文件</span><br><span class="line">    chmod o-t 文件</span><br><span class="line">sgid 针对目录建立的权限，在该目录中建立的文件所属组继承父目录的所属组</span><br><span class="line">    chmod g+s 文件</span><br><span class="line">    chmod g-s 文件</span><br><span class="line">suid 对可执行文件建立。谁运行该文件，就具有该文件所属者的权限</span><br><span class="line">    chmod u+s 文件</span><br><span class="line">    chmod u-s 文件</span><br><span class="line">    eg. chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim</span><br></pre></td></tr></table></figure><h3 id="查找有异常权限的文件">查找有异常权限的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查找有suid权限的可执行文件</span><br><span class="line">find &#x2F;usr&#x2F;bin -perm 4755</span><br><span class="line">其中权限的第一个4表示suid权限，如果是2则表示sgid权限，如果是1则表示粘滞位</span><br><span class="line">权限的多一位也可以用于赋权限</span><br></pre></td></tr></table></figure><h3 id="不再允许添加新用户">不再允许添加新用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建用户时会更改的文件</span><br><span class="line">    &#x2F;etc&#x2F;group</span><br><span class="line">    &#x2F;etc&#x2F;passwd</span><br><span class="line">    &#x2F;etc&#x2F;shadow</span><br><span class="line">    home&#x2F;xxxx</span><br><span class="line">锁定文件从而不能添加新用户</span><br><span class="line">    chattr +i &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow</span><br><span class="line">查看文件是否被锁定</span><br><span class="line">    lsattr &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h3 id="umask">umask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般目录的最高权限是777</span><br><span class="line">一般文件的最高权限是666</span><br><span class="line">用户创建的文件通过umask来确定其权限</span><br><span class="line">root的umask是0022(第一位是特殊权限)</span><br><span class="line">普通用户并且uid&#x3D;sid的umask是0002</span><br><span class="line"></span><br><span class="line">umask的设置在&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc两个文件中</span><br></pre></td></tr></table></figure><h2 id="网络地址配置">网络地址配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 确认网卡信息：ip addr &#x2F; ifconfig</span><br><span class="line">2. 关闭NetworkManager服务：systemctl stop NetworkManager</span><br><span class="line">3. 网卡启用桥接模式，并配置网络地址：</span><br><span class="line">    ip addr add IP&#x2F;掩码长度 dev ens33</span><br><span class="line">4. 设置网关：</span><br><span class="line">    ip route add default via IP dev ens33</span><br><span class="line">5. 配置DNS：</span><br><span class="line">    vim &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">    nameserver 202.120.2.101</span><br><span class="line">6. 关闭防火墙：</span><br><span class="line">    systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h2 id="日志文件">日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">位置：&#x2F;var&#x2F;log</span><br><span class="line">日志记录的配置文件：&#x2F;etc&#x2F;rsyslog.conf</span><br><span class="line">    其中配置方式为 日志类型.日志级别 ，如authpriv.*表示记录所有级别的登录日志</span><br><span class="line">日志分类：</span><br><span class="line">    系统日志    &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">    登录日志    &#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line">    程序日志</span><br><span class="line">日志记录的日志级别：</span><br><span class="line">debug,  info,  notice, warning(warn), err(error), crit, alert, emerg(panic)</span><br><span class="line">最不严重  -&gt; 最严重</span><br><span class="line"></span><br><span class="line">配置日志备份服务器：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43252204&#x2F;article&#x2F;details&#x2F;105518163</span><br></pre></td></tr></table></figure><h2 id="WEB服务-apache">WEB服务-apache</h2><h3 id="开启并使用apache">开启并使用apache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 启动服务</span><br><span class="line">    service httpd start</span><br><span class="line">2. 验证服务是否开启</span><br><span class="line">    ss -antpl | grep 80</span><br><span class="line">3. 主页建立</span><br><span class="line">    vim &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><h3 id="httpd配置文件">httpd配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">默认会开启共享目录功能，这样会导致别人可以远程下载&#x2F;var&#x2F;www&#x2F;html中的内容，建议将其关闭：</span><br><span class="line">    Options Indexes FollowSymLinks改为Options FollowSymLinks</span><br><span class="line">限制访问，将Require all granted修改为以下语句：</span><br><span class="line">    &lt;RequireAll&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    Require not ip 192.168.1.10 192.168.2.0&#x2F;24</span><br><span class="line">        &#x2F;&#x2F;拒绝192.168.1.10和192.168.2.0网段客户机访问</span><br><span class="line">    &lt;&#x2F;RequireAll&gt;</span><br><span class="line">用户授权限制，只有通过指定的用户名密码才能访问网页：</span><br><span class="line">    设置用户名密码：htpasswd -c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser test   (-c表示新建文件)</span><br><span class="line">    设置该文件只有apache用户可读：</span><br><span class="line">        chown apache httpuser</span><br><span class="line">        chmod 400 httpuser</span><br><span class="line">    修改配置文件：</span><br><span class="line">        Authtype basic</span><br><span class="line">        Authname &quot;Input username and password&quot; &#x2F;&#x2F; 提示信息</span><br><span class="line">        Authuserfile &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpuser</span><br><span class="line">        Require valid-user</span><br></pre></td></tr></table></figure><h2 id="lamp平台搭建">lamp平台搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 安装apache</span><br><span class="line">2. 安装mysql</span><br><span class="line">    yum install mysql-server    &#x2F;&#x2F; 安装</span><br><span class="line">    service mysqld start        &#x2F;&#x2F; 启动</span><br><span class="line">    mysqladmin -u root -p password &quot;123.sck&quot;     &#x2F;&#x2F; 设置root密码</span><br><span class="line">    mysql -u root -p        &#x2F;&#x2F; 登录数据库</span><br><span class="line">3. 安装php</span><br><span class="line">    yum install php</span><br><span class="line">    yum install php-mysqlnd</span><br><span class="line">    yum install php-mbstring</span><br><span class="line">4. 配置php配置文件</span><br><span class="line">    vim &#x2F;etc&#x2F;php.ini</span><br><span class="line">    将short_open_tag从Off改为On</span><br><span class="line">5. 在&#x2F;var&#x2F;www&#x2F;html新建一个php文件</span><br></pre></td></tr></table></figure><h2 id="iptables防火墙">iptables防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四个表：</span><br><span class="line">    raw</span><br><span class="line">    mangle</span><br><span class="line">    nat     网络地址转换</span><br><span class="line">    filter  过滤</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
